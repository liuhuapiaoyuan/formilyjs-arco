(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react-is'), require('react')) :
    typeof define === 'function' && define.amd ? define('@formily/arco', ['exports', 'react-is', 'react'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.Formily = global.Formily || {}, global.Formily.Arco = {})));
})(this, (function (exports) { 'use strict';

    (function() {
        const env = {"NODE_ENV":"development"};
        try {
            if (process) {
                process.env = Object.assign({}, process.env);
                Object.assign(process.env, env);
                return;
            }
        } catch (e) {} // avoid ReferenceError: process is not defined
        globalThis.process = { env:env };
    })();

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign$2e = function() {
        __assign$2e = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$2e.apply(this, arguments);
    };

    function __rest$17(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __awaiter$7(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator$7(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __read$1x(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spreadArray$C(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }

    function _extends$1() {
      _extends$1 = Object.assign ? Object.assign.bind() : function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$1.apply(this, arguments);
    }

    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
      return target;
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }

    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    /* eslint-disable no-unused-vars */
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty$c = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;

    function toObject(val) {
    	if (val === null || val === undefined) {
    		throw new TypeError('Object.assign cannot be called with null or undefined');
    	}

    	return Object(val);
    }

    function shouldUseNative() {
    	try {
    		if (!Object.assign) {
    			return false;
    		}

    		// Detect buggy property enumeration order in older V8 versions.

    		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
    		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
    		test1[5] = 'de';
    		if (Object.getOwnPropertyNames(test1)[0] === '5') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test2 = {};
    		for (var i = 0; i < 10; i++) {
    			test2['_' + String.fromCharCode(i)] = i;
    		}
    		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
    			return test2[n];
    		});
    		if (order2.join('') !== '0123456789') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test3 = {};
    		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
    			test3[letter] = letter;
    		});
    		if (Object.keys(Object.assign({}, test3)).join('') !==
    				'abcdefghijklmnopqrst') {
    			return false;
    		}

    		return true;
    	} catch (err) {
    		// We don't expect any of the above to throw, but better to be safe.
    		return false;
    	}
    }

    var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
    	var from;
    	var to = toObject(target);
    	var symbols;

    	for (var s = 1; s < arguments.length; s++) {
    		from = Object(arguments[s]);

    		for (var key in from) {
    			if (hasOwnProperty$c.call(from, key)) {
    				to[key] = from[key];
    			}
    		}

    		if (getOwnPropertySymbols) {
    			symbols = getOwnPropertySymbols(from);
    			for (var i = 0; i < symbols.length; i++) {
    				if (propIsEnumerable.call(from, symbols[i])) {
    					to[symbols[i]] = from[symbols[i]];
    				}
    			}
    		}
    	}

    	return to;
    };

    var ReactPropTypesSecret$2 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

    var ReactPropTypesSecret_1 = ReactPropTypesSecret$2;

    var has$2 = Function.call.bind(Object.prototype.hasOwnProperty);

    var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;

    var has$1 = has$2;

    var printWarning$1 = function() {};

    if (process.env.NODE_ENV !== 'production') {
      var ReactPropTypesSecret = ReactPropTypesSecret$1;
      var loggedTypeFailures = {};
      var has = has$1;

      printWarning$1 = function(text) {
        var message = 'Warning: ' + text;
        if (typeof console !== 'undefined') {
          console.error(message);
        }
        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) { /**/ }
      };
    }

    /**
     * Assert that the values match with the type specs.
     * Error messages are memorized and will only be shown once.
     *
     * @param {object} typeSpecs Map of name to a ReactPropType
     * @param {object} values Runtime values that need to be type-checked
     * @param {string} location e.g. "prop", "context", "child context"
     * @param {string} componentName Name of the component for error messages.
     * @param {?Function} getStack Returns the component stack.
     * @private
     */
    function checkPropTypes$1(typeSpecs, values, location, componentName, getStack) {
      if (process.env.NODE_ENV !== 'production') {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            // Prop type validation may throw. In case they do, we don't want to
            // fail the render phase where it didn't fail before. So we log it.
            // After these have been cleaned up, we'll let them throw.
            try {
              // This is intentionally an invariant that gets caught. It's the same
              // behavior as without this statement except with a better message.
              if (typeof typeSpecs[typeSpecName] !== 'function') {
                var err = Error(
                  (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
                  'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +
                  'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
                );
                err.name = 'Invariant Violation';
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning$1(
                (componentName || 'React class') + ': type specification of ' +
                location + ' `' + typeSpecName + '` is invalid; the type checker ' +
                'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
                'You may have forgotten to pass an argument to the type checker ' +
                'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
                'shape all require an argument).'
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              // Only monitor this failure once because there tends to be a lot of the
              // same error.
              loggedTypeFailures[error.message] = true;

              var stack = getStack ? getStack() : '';

              printWarning$1(
                'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
              );
            }
          }
        }
      }
    }

    /**
     * Resets warning cache when testing.
     *
     * @private
     */
    checkPropTypes$1.resetWarningCache = function() {
      if (process.env.NODE_ENV !== 'production') {
        loggedTypeFailures = {};
      }
    };

    var checkPropTypes_1 = checkPropTypes$1;

    const _global_ReactIs = ReactIs;

    var checkPropTypes = checkPropTypes_1;

    var printWarning = function() {};

    if (process.env.NODE_ENV !== 'production') {
      printWarning = function(text) {
        var message = 'Warning: ' + text;
        if (typeof console !== 'undefined') {
          console.error(message);
        }
        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };
    }

    function emptyFunctionThatReturnsNull() {
      return null;
    }

    var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
      /* global Symbol */
      var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

      /**
       * Returns the iterator method function contained on the iterable object.
       *
       * Be sure to invoke the function with the iterable as context:
       *
       *     var iteratorFn = getIteratorFn(myIterable);
       *     if (iteratorFn) {
       *       var iterator = iteratorFn.call(myIterable);
       *       ...
       *     }
       *
       * @param {?object} maybeIterable
       * @return {?function}
       */
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === 'function') {
          return iteratorFn;
        }
      }

      /**
       * Collection of methods that allow declaration and validation of props that are
       * supplied to React components. Example usage:
       *
       *   var Props = require('ReactPropTypes');
       *   var MyArticle = React.createClass({
       *     propTypes: {
       *       // An optional string prop named "description".
       *       description: Props.string,
       *
       *       // A required enum prop named "category".
       *       category: Props.oneOf(['News','Photos']).isRequired,
       *
       *       // A prop named "dialog" that requires an instance of Dialog.
       *       dialog: Props.instanceOf(Dialog).isRequired
       *     },
       *     render: function() { ... }
       *   });
       *
       * A more formal specification of how these methods are used:
       *
       *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
       *   decl := ReactPropTypes.{type}(.isRequired)?
       *
       * Each and every declaration produces a function with the same signature. This
       * allows the creation of custom validation functions. For example:
       *
       *  var MyLink = React.createClass({
       *    propTypes: {
       *      // An optional string or URI prop named "href".
       *      href: function(props, propName, componentName) {
       *        var propValue = props[propName];
       *        if (propValue != null && typeof propValue !== 'string' &&
       *            !(propValue instanceof URI)) {
       *          return new Error(
       *            'Expected a string or an URI for ' + propName + ' in ' +
       *            componentName
       *          );
       *        }
       *      }
       *    },
       *    render: function() {...}
       *  });
       *
       * @internal
       */

      var ANONYMOUS = '<<anonymous>>';

      // Important!
      // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker('array'),
        bigint: createPrimitiveTypeChecker('bigint'),
        bool: createPrimitiveTypeChecker('boolean'),
        func: createPrimitiveTypeChecker('function'),
        number: createPrimitiveTypeChecker('number'),
        object: createPrimitiveTypeChecker('object'),
        string: createPrimitiveTypeChecker('string'),
        symbol: createPrimitiveTypeChecker('symbol'),

        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker,
      };

      /**
       * inlined Object.is polyfill to avoid requiring consumers ship their own
       * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
       */
      /*eslint-disable no-self-compare*/
      function is(x, y) {
        // SameValue algorithm
        if (x === y) {
          // Steps 1-5, 7-10
          // Steps 6.b-6.e: +0 != -0
          return x !== 0 || 1 / x === 1 / y;
        } else {
          // Step 6.a: NaN == NaN
          return x !== x && y !== y;
        }
      }
      /*eslint-enable no-self-compare*/

      /**
       * We use an Error-like object for backward compatibility as people may call
       * PropTypes directly and inspect their output. However, we don't use real
       * Errors anymore. We don't inspect their stack anyway, and creating them
       * is prohibitively expensive if they are created too often, such as what
       * happens in oneOfType() for any type before the one that matched.
       */
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === 'object' ? data: {};
        this.stack = '';
      }
      // Make `instanceof Error` still work for returned errors.
      PropTypeError.prototype = Error.prototype;

      function createChainableTypeChecker(validate) {
        if (process.env.NODE_ENV !== 'production') {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;

          if (secret !== ReactPropTypesSecret$1) {
            if (throwOnDirectAccess) {
              // New behavior only for users of `prop-types` package
              var err = new Error(
                'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
                'Use `PropTypes.checkPropTypes()` to call them. ' +
                'Read more at http://fb.me/use-check-prop-types'
              );
              err.name = 'Invariant Violation';
              throw err;
            } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
              // Old behavior for people using React.PropTypes
              var cacheKey = componentName + ':' + propName;
              if (
                !manualPropTypeCallCache[cacheKey] &&
                // Avoid spamming the console because they are often not actionable except for lib authors
                manualPropTypeWarningCount < 3
              ) {
                printWarning(
                  'You are manually calling a React.PropTypes validation ' +
                  'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +
                  'and will throw in the standalone `prop-types` package. ' +
                  'You may be seeing this warning due to a third-party PropTypes ' +
                  'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
              }
              return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }

        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);

        return chainedCheckType;
      }

      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            // `propValue` being instance of, say, date/regexp, pass the 'object'
            // check, but we can offer a more precise error message here rather than
            // 'of type `object`'.
            var preciseType = getPreciseType(propValue);

            return new PropTypeError(
              'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),
              {expectedType: expectedType}
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }

      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }

      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== 'function') {
            return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret$1);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }

      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }

      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!_global_ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }

      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }

      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (process.env.NODE_ENV !== 'production') {
            if (arguments.length > 1) {
              printWarning(
                'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
                'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
              );
            } else {
              printWarning('Invalid argument supplied to oneOf, expected an array.');
            }
          }
          return emptyFunctionThatReturnsNull;
        }

        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }

          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === 'symbol') {
              return String(value);
            }
            return value;
          });
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
        }
        return createChainableTypeChecker(validate);
      }

      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== 'function') {
            return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== 'object') {
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
          }
          for (var key in propValue) {
            if (has$1(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret$1);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }

      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
          return emptyFunctionThatReturnsNull;
        }

        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== 'function') {
            printWarning(
              'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
              'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
            );
            return emptyFunctionThatReturnsNull;
          }
        }

        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
            var checker = arrayOfTypeCheckers[i];
            var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret$1);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has$1(checkerResult.data, 'expectedType')) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
        }
        return createChainableTypeChecker(validate);
      }

      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }

      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +
          'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'
        );
      }

      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== 'object') {
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== 'function') {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret$1);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }

      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== 'object') {
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
          }
          // We need to check all keys in case some are required but missing from props.
          var allKeys = objectAssign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has$1(shapeTypes, key) && typeof checker !== 'function') {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
                '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
                '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret$1);
            if (error) {
              return error;
            }
          }
          return null;
        }

        return createChainableTypeChecker(validate);
      }

      function isNode(propValue) {
        switch (typeof propValue) {
          case 'number':
          case 'string':
          case 'undefined':
            return true;
          case 'boolean':
            return !propValue;
          case 'object':
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }

            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                // Iterator will provide entry [k,v] tuples rather than values.
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }

            return true;
          default:
            return false;
        }
      }

      function isSymbol(propType, propValue) {
        // Native Symbol.
        if (propType === 'symbol') {
          return true;
        }

        // falsy value can't be a Symbol
        if (!propValue) {
          return false;
        }

        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
        if (propValue['@@toStringTag'] === 'Symbol') {
          return true;
        }

        // Fallback for non-spec compliant Symbols which are polyfilled.
        if (typeof Symbol === 'function' && propValue instanceof Symbol) {
          return true;
        }

        return false;
      }

      // Equivalent of `typeof` but with special handling for array and regexp.
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return 'array';
        }
        if (propValue instanceof RegExp) {
          // Old webkits (at least until Android 4.0) return 'function' rather than
          // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
          // passes PropTypes.object.
          return 'object';
        }
        if (isSymbol(propType, propValue)) {
          return 'symbol';
        }
        return propType;
      }

      // This handles more types than `getPropType`. Only used for error messages.
      // See `createPrimitiveTypeChecker`.
      function getPreciseType(propValue) {
        if (typeof propValue === 'undefined' || propValue === null) {
          return '' + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === 'object') {
          if (propValue instanceof Date) {
            return 'date';
          } else if (propValue instanceof RegExp) {
            return 'regexp';
          }
        }
        return propType;
      }

      // Returns a string that is postfixed to a warning about an invalid type.
      // For example, "undefined" or "of type array"
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case 'array':
          case 'object':
            return 'an ' + type;
          case 'boolean':
          case 'date':
          case 'regexp':
            return 'a ' + type;
          default:
            return type;
        }
      }

      // Returns class name of the object, if any.
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }

      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;

      return ReactPropTypes;
    };

    function emptyFunction() {}
    function emptyFunctionWithReset() {}
    emptyFunctionWithReset.resetWarningCache = emptyFunction;

    var factoryWithThrowingShims = function() {
      function shim(props, propName, componentName, location, propFullName, secret) {
        if (secret === ReactPropTypesSecret$1) {
          // It is still safe when called from React.
          return;
        }
        var err = new Error(
          'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
          'Use PropTypes.checkPropTypes() to call them. ' +
          'Read more at http://fb.me/use-check-prop-types'
        );
        err.name = 'Invariant Violation';
        throw err;
      }  shim.isRequired = shim;
      function getShim() {
        return shim;
      }  // Important!
      // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
      var ReactPropTypes = {
        array: shim,
        bigint: shim,
        bool: shim,
        func: shim,
        number: shim,
        object: shim,
        string: shim,
        symbol: shim,

        any: shim,
        arrayOf: getShim,
        element: shim,
        elementType: shim,
        instanceOf: getShim,
        node: shim,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim,

        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
      };

      ReactPropTypes.PropTypes = ReactPropTypes;

      return ReactPropTypes;
    };

    var require$$1 = factoryWithTypeCheckers;

    var require$$2 = factoryWithThrowingShims;

    var propTypes$3 = createCommonjsModule(function (module) {
    if (process.env.NODE_ENV !== 'production') {
      var ReactIs = _global_ReactIs;

      // By explicitly using `prop-types` you are opting into new development behavior.
      // http://fb.me/prop-types-in-prod
      var throwOnDirectAccess = true;
      module.exports = require$$1(ReactIs.isElement, throwOnDirectAccess);
    } else {
      // By explicitly using `prop-types` you are opting into new production behavior.
      // http://fb.me/prop-types-in-prod
      module.exports = require$$2();
    }
    });

    var PropTypes = propTypes$3;

    /**
     * Checks if a given element has a CSS class.
     * 
     * @param element the element
     * @param className the CSS class name
     */
    function hasClass(element, className) {
      if (element.classList) return !!className && element.classList.contains(className);
      return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
    }

    /**
     * Adds a CSS class to a given element.
     * 
     * @param element the element
     * @param className the CSS class name
     */

    function addClass(element, className) {
      if (element.classList) element.classList.add(className);else if (!hasClass(element, className)) if (typeof element.className === 'string') element.className = element.className + " " + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + " " + className);
    }

    function replaceClassName(origClass, classToRemove) {
      return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
    }
    /**
     * Removes a CSS class from a given element.
     * 
     * @param element the element
     * @param className the CSS class name
     */


    function removeClass$1(element, className) {
      if (element.classList) {
        element.classList.remove(className);
      } else if (typeof element.className === 'string') {
        element.className = replaceClassName(element.className, className);
      } else {
        element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
      }
    }

    var config = {
      disabled: false
    };

    var timeoutsShape = process.env.NODE_ENV !== 'production' ? PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
      enter: PropTypes.number,
      exit: PropTypes.number,
      appear: PropTypes.number
    }).isRequired]) : null;
    var classNamesShape = process.env.NODE_ENV !== 'production' ? PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
      enter: PropTypes.string,
      exit: PropTypes.string,
      active: PropTypes.string
    }), PropTypes.shape({
      enter: PropTypes.string,
      enterDone: PropTypes.string,
      enterActive: PropTypes.string,
      exit: PropTypes.string,
      exitDone: PropTypes.string,
      exitActive: PropTypes.string
    })]) : null;

    var TransitionGroupContext = React.createContext(null);

    var forceReflow = function forceReflow(node) {
      return node.scrollTop;
    };

    var UNMOUNTED = 'unmounted';
    var EXITED = 'exited';
    var ENTERING = 'entering';
    var ENTERED = 'entered';
    var EXITING = 'exiting';
    /**
     * The Transition component lets you describe a transition from one component
     * state to another _over time_ with a simple declarative API. Most commonly
     * it's used to animate the mounting and unmounting of a component, but can also
     * be used to describe in-place transition states as well.
     *
     * ---
     *
     * **Note**: `Transition` is a platform-agnostic base component. If you're using
     * transitions in CSS, you'll probably want to use
     * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
     * instead. It inherits all the features of `Transition`, but contains
     * additional features necessary to play nice with CSS transitions (hence the
     * name of the component).
     *
     * ---
     *
     * By default the `Transition` component does not alter the behavior of the
     * component it renders, it only tracks "enter" and "exit" states for the
     * components. It's up to you to give meaning and effect to those states. For
     * example we can add styles to a component when it enters or exits:
     *
     * ```jsx
     * import { Transition } from 'react-transition-group';
     *
     * const duration = 300;
     *
     * const defaultStyle = {
     *   transition: `opacity ${duration}ms ease-in-out`,
     *   opacity: 0,
     * }
     *
     * const transitionStyles = {
     *   entering: { opacity: 1 },
     *   entered:  { opacity: 1 },
     *   exiting:  { opacity: 0 },
     *   exited:  { opacity: 0 },
     * };
     *
     * const Fade = ({ in: inProp }) => (
     *   <Transition in={inProp} timeout={duration}>
     *     {state => (
     *       <div style={{
     *         ...defaultStyle,
     *         ...transitionStyles[state]
     *       }}>
     *         I'm a fade Transition!
     *       </div>
     *     )}
     *   </Transition>
     * );
     * ```
     *
     * There are 4 main states a Transition can be in:
     *  - `'entering'`
     *  - `'entered'`
     *  - `'exiting'`
     *  - `'exited'`
     *
     * Transition state is toggled via the `in` prop. When `true` the component
     * begins the "Enter" stage. During this stage, the component will shift from
     * its current transition state, to `'entering'` for the duration of the
     * transition and then to the `'entered'` stage once it's complete. Let's take
     * the following example (we'll use the
     * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
     *
     * ```jsx
     * function App() {
     *   const [inProp, setInProp] = useState(false);
     *   return (
     *     <div>
     *       <Transition in={inProp} timeout={500}>
     *         {state => (
     *           // ...
     *         )}
     *       </Transition>
     *       <button onClick={() => setInProp(true)}>
     *         Click to Enter
     *       </button>
     *     </div>
     *   );
     * }
     * ```
     *
     * When the button is clicked the component will shift to the `'entering'` state
     * and stay there for 500ms (the value of `timeout`) before it finally switches
     * to `'entered'`.
     *
     * When `in` is `false` the same thing happens except the state moves from
     * `'exiting'` to `'exited'`.
     */

    var Transition = /*#__PURE__*/function (_React$Component) {
      _inheritsLoose(Transition, _React$Component);

      function Transition(props, context) {
        var _this;

        _this = _React$Component.call(this, props, context) || this;
        var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

        var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
        var initialStatus;
        _this.appearStatus = null;

        if (props.in) {
          if (appear) {
            initialStatus = EXITED;
            _this.appearStatus = ENTERING;
          } else {
            initialStatus = ENTERED;
          }
        } else {
          if (props.unmountOnExit || props.mountOnEnter) {
            initialStatus = UNMOUNTED;
          } else {
            initialStatus = EXITED;
          }
        }

        _this.state = {
          status: initialStatus
        };
        _this.nextCallback = null;
        return _this;
      }

      Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
        var nextIn = _ref.in;

        if (nextIn && prevState.status === UNMOUNTED) {
          return {
            status: EXITED
          };
        }

        return null;
      } // getSnapshotBeforeUpdate(prevProps) {
      //   let nextStatus = null
      //   if (prevProps !== this.props) {
      //     const { status } = this.state
      //     if (this.props.in) {
      //       if (status !== ENTERING && status !== ENTERED) {
      //         nextStatus = ENTERING
      //       }
      //     } else {
      //       if (status === ENTERING || status === ENTERED) {
      //         nextStatus = EXITING
      //       }
      //     }
      //   }
      //   return { nextStatus }
      // }
      ;

      var _proto = Transition.prototype;

      _proto.componentDidMount = function componentDidMount() {
        this.updateStatus(true, this.appearStatus);
      };

      _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
        var nextStatus = null;

        if (prevProps !== this.props) {
          var status = this.state.status;

          if (this.props.in) {
            if (status !== ENTERING && status !== ENTERED) {
              nextStatus = ENTERING;
            }
          } else {
            if (status === ENTERING || status === ENTERED) {
              nextStatus = EXITING;
            }
          }
        }

        this.updateStatus(false, nextStatus);
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        this.cancelNextCallback();
      };

      _proto.getTimeouts = function getTimeouts() {
        var timeout = this.props.timeout;
        var exit, enter, appear;
        exit = enter = appear = timeout;

        if (timeout != null && typeof timeout !== 'number') {
          exit = timeout.exit;
          enter = timeout.enter; // TODO: remove fallback for next major

          appear = timeout.appear !== undefined ? timeout.appear : enter;
        }

        return {
          exit: exit,
          enter: enter,
          appear: appear
        };
      };

      _proto.updateStatus = function updateStatus(mounting, nextStatus) {
        if (mounting === void 0) {
          mounting = false;
        }

        if (nextStatus !== null) {
          // nextStatus will always be ENTERING or EXITING.
          this.cancelNextCallback();

          if (nextStatus === ENTERING) {
            if (this.props.unmountOnExit || this.props.mountOnEnter) {
              var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this); // https://github.com/reactjs/react-transition-group/pull/749
              // With unmountOnExit or mountOnEnter, the enter animation should happen at the transition between `exited` and `entering`.
              // To make the animation happen,  we have to separate each rendering and avoid being processed as batched.

              if (node) forceReflow(node);
            }

            this.performEnter(mounting);
          } else {
            this.performExit();
          }
        } else if (this.props.unmountOnExit && this.state.status === EXITED) {
          this.setState({
            status: UNMOUNTED
          });
        }
      };

      _proto.performEnter = function performEnter(mounting) {
        var _this2 = this;

        var enter = this.props.enter;
        var appearing = this.context ? this.context.isMounting : mounting;

        var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing],
            maybeNode = _ref2[0],
            maybeAppearing = _ref2[1];

        var timeouts = this.getTimeouts();
        var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
        // if we are mounting and running this it means appear _must_ be set

        if (!mounting && !enter || config.disabled) {
          this.safeSetState({
            status: ENTERED
          }, function () {
            _this2.props.onEntered(maybeNode);
          });
          return;
        }

        this.props.onEnter(maybeNode, maybeAppearing);
        this.safeSetState({
          status: ENTERING
        }, function () {
          _this2.props.onEntering(maybeNode, maybeAppearing);

          _this2.onTransitionEnd(enterTimeout, function () {
            _this2.safeSetState({
              status: ENTERED
            }, function () {
              _this2.props.onEntered(maybeNode, maybeAppearing);
            });
          });
        });
      };

      _proto.performExit = function performExit() {
        var _this3 = this;

        var exit = this.props.exit;
        var timeouts = this.getTimeouts();
        var maybeNode = this.props.nodeRef ? undefined : ReactDOM.findDOMNode(this); // no exit animation skip right to EXITED

        if (!exit || config.disabled) {
          this.safeSetState({
            status: EXITED
          }, function () {
            _this3.props.onExited(maybeNode);
          });
          return;
        }

        this.props.onExit(maybeNode);
        this.safeSetState({
          status: EXITING
        }, function () {
          _this3.props.onExiting(maybeNode);

          _this3.onTransitionEnd(timeouts.exit, function () {
            _this3.safeSetState({
              status: EXITED
            }, function () {
              _this3.props.onExited(maybeNode);
            });
          });
        });
      };

      _proto.cancelNextCallback = function cancelNextCallback() {
        if (this.nextCallback !== null) {
          this.nextCallback.cancel();
          this.nextCallback = null;
        }
      };

      _proto.safeSetState = function safeSetState(nextState, callback) {
        // This shouldn't be necessary, but there are weird race conditions with
        // setState callbacks and unmounting in testing, so always make sure that
        // we can cancel any pending setState callbacks after we unmount.
        callback = this.setNextCallback(callback);
        this.setState(nextState, callback);
      };

      _proto.setNextCallback = function setNextCallback(callback) {
        var _this4 = this;

        var active = true;

        this.nextCallback = function (event) {
          if (active) {
            active = false;
            _this4.nextCallback = null;
            callback(event);
          }
        };

        this.nextCallback.cancel = function () {
          active = false;
        };

        return this.nextCallback;
      };

      _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
        this.setNextCallback(handler);
        var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
        var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

        if (!node || doesNotHaveTimeoutOrListener) {
          setTimeout(this.nextCallback, 0);
          return;
        }

        if (this.props.addEndListener) {
          var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],
              maybeNode = _ref3[0],
              maybeNextCallback = _ref3[1];

          this.props.addEndListener(maybeNode, maybeNextCallback);
        }

        if (timeout != null) {
          setTimeout(this.nextCallback, timeout);
        }
      };

      _proto.render = function render() {
        var status = this.state.status;

        if (status === UNMOUNTED) {
          return null;
        }

        var _this$props = this.props,
            children = _this$props.children;
            _this$props.in;
            _this$props.mountOnEnter;
            _this$props.unmountOnExit;
            _this$props.appear;
            _this$props.enter;
            _this$props.exit;
            _this$props.timeout;
            _this$props.addEndListener;
            _this$props.onEnter;
            _this$props.onEntering;
            _this$props.onEntered;
            _this$props.onExit;
            _this$props.onExiting;
            _this$props.onExited;
            _this$props.nodeRef;
            var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);

        return (
          /*#__PURE__*/
          // allows for nested Transitions
          React.createElement(TransitionGroupContext.Provider, {
            value: null
          }, typeof children === 'function' ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
        );
      };

      return Transition;
    }(React.Component);

    Transition.contextType = TransitionGroupContext;
    Transition.propTypes = process.env.NODE_ENV !== "production" ? {
      /**
       * A React reference to DOM element that need to transition:
       * https://stackoverflow.com/a/51127130/4671932
       *
       *   - When `nodeRef` prop is used, `node` is not passed to callback functions
       *      (e.g. `onEnter`) because user already has direct access to the node.
       *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
       *     `nodeRef` need to be provided to `Transition` with changed `key` prop
       *     (see
       *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
       */
      nodeRef: PropTypes.shape({
        current: typeof Element === 'undefined' ? PropTypes.any : function (propValue, key, componentName, location, propFullName, secret) {
          var value = propValue[key];
          return PropTypes.instanceOf(value && 'ownerDocument' in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
        }
      }),

      /**
       * A `function` child can be used instead of a React element. This function is
       * called with the current transition status (`'entering'`, `'entered'`,
       * `'exiting'`, `'exited'`), which can be used to apply context
       * specific props to a component.
       *
       * ```jsx
       * <Transition in={this.state.in} timeout={150}>
       *   {state => (
       *     <MyComponent className={`fade fade-${state}`} />
       *   )}
       * </Transition>
       * ```
       */
      children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,

      /**
       * Show the component; triggers the enter or exit states
       */
      in: PropTypes.bool,

      /**
       * By default the child component is mounted immediately along with
       * the parent `Transition` component. If you want to "lazy mount" the component on the
       * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
       * mounted, even on "exited", unless you also specify `unmountOnExit`.
       */
      mountOnEnter: PropTypes.bool,

      /**
       * By default the child component stays mounted after it reaches the `'exited'` state.
       * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
       */
      unmountOnExit: PropTypes.bool,

      /**
       * By default the child component does not perform the enter transition when
       * it first mounts, regardless of the value of `in`. If you want this
       * behavior, set both `appear` and `in` to `true`.
       *
       * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
       * > only adds an additional enter transition. However, in the
       * > `<CSSTransition>` component that first enter transition does result in
       * > additional `.appear-*` classes, that way you can choose to style it
       * > differently.
       */
      appear: PropTypes.bool,

      /**
       * Enable or disable enter transitions.
       */
      enter: PropTypes.bool,

      /**
       * Enable or disable exit transitions.
       */
      exit: PropTypes.bool,

      /**
       * The duration of the transition, in milliseconds.
       * Required unless `addEndListener` is provided.
       *
       * You may specify a single timeout for all transitions:
       *
       * ```jsx
       * timeout={500}
       * ```
       *
       * or individually:
       *
       * ```jsx
       * timeout={{
       *  appear: 500,
       *  enter: 300,
       *  exit: 500,
       * }}
       * ```
       *
       * - `appear` defaults to the value of `enter`
       * - `enter` defaults to `0`
       * - `exit` defaults to `0`
       *
       * @type {number | { enter?: number, exit?: number, appear?: number }}
       */
      timeout: function timeout(props) {
        var pt = timeoutsShape;
        if (!props.addEndListener) pt = pt.isRequired;

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        return pt.apply(void 0, [props].concat(args));
      },

      /**
       * Add a custom transition end trigger. Called with the transitioning
       * DOM node and a `done` callback. Allows for more fine grained transition end
       * logic. Timeouts are still used as a fallback if provided.
       *
       * **Note**: when `nodeRef` prop is passed, `node` is not passed.
       *
       * ```jsx
       * addEndListener={(node, done) => {
       *   // use the css transitionend event to mark the finish of a transition
       *   node.addEventListener('transitionend', done, false);
       * }}
       * ```
       */
      addEndListener: PropTypes.func,

      /**
       * Callback fired before the "entering" status is applied. An extra parameter
       * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
       *
       * **Note**: when `nodeRef` prop is passed, `node` is not passed.
       *
       * @type Function(node: HtmlElement, isAppearing: bool) -> void
       */
      onEnter: PropTypes.func,

      /**
       * Callback fired after the "entering" status is applied. An extra parameter
       * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
       *
       * **Note**: when `nodeRef` prop is passed, `node` is not passed.
       *
       * @type Function(node: HtmlElement, isAppearing: bool)
       */
      onEntering: PropTypes.func,

      /**
       * Callback fired after the "entered" status is applied. An extra parameter
       * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
       *
       * **Note**: when `nodeRef` prop is passed, `node` is not passed.
       *
       * @type Function(node: HtmlElement, isAppearing: bool) -> void
       */
      onEntered: PropTypes.func,

      /**
       * Callback fired before the "exiting" status is applied.
       *
       * **Note**: when `nodeRef` prop is passed, `node` is not passed.
       *
       * @type Function(node: HtmlElement) -> void
       */
      onExit: PropTypes.func,

      /**
       * Callback fired after the "exiting" status is applied.
       *
       * **Note**: when `nodeRef` prop is passed, `node` is not passed.
       *
       * @type Function(node: HtmlElement) -> void
       */
      onExiting: PropTypes.func,

      /**
       * Callback fired after the "exited" status is applied.
       *
       * **Note**: when `nodeRef` prop is passed, `node` is not passed
       *
       * @type Function(node: HtmlElement) -> void
       */
      onExited: PropTypes.func
    } : {}; // Name the function so it is clearer in the documentation

    function noop$1() {}

    Transition.defaultProps = {
      in: false,
      mountOnEnter: false,
      unmountOnExit: false,
      appear: false,
      enter: true,
      exit: true,
      onEnter: noop$1,
      onEntering: noop$1,
      onEntered: noop$1,
      onExit: noop$1,
      onExiting: noop$1,
      onExited: noop$1
    };
    Transition.UNMOUNTED = UNMOUNTED;
    Transition.EXITED = EXITED;
    Transition.ENTERING = ENTERING;
    Transition.ENTERED = ENTERED;
    Transition.EXITING = EXITING;
    var Transition$1 = Transition;

    var _addClass = function addClass$1(node, classes) {
      return node && classes && classes.split(' ').forEach(function (c) {
        return addClass(node, c);
      });
    };

    var removeClass = function removeClass(node, classes) {
      return node && classes && classes.split(' ').forEach(function (c) {
        return removeClass$1(node, c);
      });
    };
    /**
     * A transition component inspired by the excellent
     * [ng-animate](https://docs.angularjs.org/api/ngAnimate) library, you should
     * use it if you're using CSS transitions or animations. It's built upon the
     * [`Transition`](https://reactcommunity.org/react-transition-group/transition)
     * component, so it inherits all of its props.
     *
     * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
     * and `exit` states of the transition. The first class is applied and then a
     * second `*-active` class in order to activate the CSS transition. After the
     * transition, matching `*-done` class names are applied to persist the
     * transition state.
     *
     * ```jsx
     * function App() {
     *   const [inProp, setInProp] = useState(false);
     *   return (
     *     <div>
     *       <CSSTransition in={inProp} timeout={200} classNames="my-node">
     *         <div>
     *           {"I'll receive my-node-* classes"}
     *         </div>
     *       </CSSTransition>
     *       <button type="button" onClick={() => setInProp(true)}>
     *         Click to Enter
     *       </button>
     *     </div>
     *   );
     * }
     * ```
     *
     * When the `in` prop is set to `true`, the child component will first receive
     * the class `example-enter`, then the `example-enter-active` will be added in
     * the next tick. `CSSTransition` [forces a
     * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
     * between before adding the `example-enter-active`. This is an important trick
     * because it allows us to transition between `example-enter` and
     * `example-enter-active` even though they were added immediately one after
     * another. Most notably, this is what makes it possible for us to animate
     * _appearance_.
     *
     * ```css
     * .my-node-enter {
     *   opacity: 0;
     * }
     * .my-node-enter-active {
     *   opacity: 1;
     *   transition: opacity 200ms;
     * }
     * .my-node-exit {
     *   opacity: 1;
     * }
     * .my-node-exit-active {
     *   opacity: 0;
     *   transition: opacity 200ms;
     * }
     * ```
     *
     * `*-active` classes represent which styles you want to animate **to**, so it's
     * important to add `transition` declaration only to them, otherwise transitions
     * might not behave as intended! This might not be obvious when the transitions
     * are symmetrical, i.e. when `*-enter-active` is the same as `*-exit`, like in
     * the example above (minus `transition`), but it becomes apparent in more
     * complex transitions.
     *
     * **Note**: If you're using the
     * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)
     * prop, make sure to define styles for `.appear-*` classes as well.
     */


    var CSSTransition = /*#__PURE__*/function (_React$Component) {
      _inheritsLoose(CSSTransition, _React$Component);

      function CSSTransition() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
        _this.appliedClasses = {
          appear: {},
          enter: {},
          exit: {}
        };

        _this.onEnter = function (maybeNode, maybeAppearing) {
          var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing),
              node = _this$resolveArgument[0],
              appearing = _this$resolveArgument[1];

          _this.removeClasses(node, 'exit');

          _this.addClass(node, appearing ? 'appear' : 'enter', 'base');

          if (_this.props.onEnter) {
            _this.props.onEnter(maybeNode, maybeAppearing);
          }
        };

        _this.onEntering = function (maybeNode, maybeAppearing) {
          var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing),
              node = _this$resolveArgument2[0],
              appearing = _this$resolveArgument2[1];

          var type = appearing ? 'appear' : 'enter';

          _this.addClass(node, type, 'active');

          if (_this.props.onEntering) {
            _this.props.onEntering(maybeNode, maybeAppearing);
          }
        };

        _this.onEntered = function (maybeNode, maybeAppearing) {
          var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing),
              node = _this$resolveArgument3[0],
              appearing = _this$resolveArgument3[1];

          var type = appearing ? 'appear' : 'enter';

          _this.removeClasses(node, type);

          _this.addClass(node, type, 'done');

          if (_this.props.onEntered) {
            _this.props.onEntered(maybeNode, maybeAppearing);
          }
        };

        _this.onExit = function (maybeNode) {
          var _this$resolveArgument4 = _this.resolveArguments(maybeNode),
              node = _this$resolveArgument4[0];

          _this.removeClasses(node, 'appear');

          _this.removeClasses(node, 'enter');

          _this.addClass(node, 'exit', 'base');

          if (_this.props.onExit) {
            _this.props.onExit(maybeNode);
          }
        };

        _this.onExiting = function (maybeNode) {
          var _this$resolveArgument5 = _this.resolveArguments(maybeNode),
              node = _this$resolveArgument5[0];

          _this.addClass(node, 'exit', 'active');

          if (_this.props.onExiting) {
            _this.props.onExiting(maybeNode);
          }
        };

        _this.onExited = function (maybeNode) {
          var _this$resolveArgument6 = _this.resolveArguments(maybeNode),
              node = _this$resolveArgument6[0];

          _this.removeClasses(node, 'exit');

          _this.addClass(node, 'exit', 'done');

          if (_this.props.onExited) {
            _this.props.onExited(maybeNode);
          }
        };

        _this.resolveArguments = function (maybeNode, maybeAppearing) {
          return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] // here `maybeNode` is actually `appearing`
          : [maybeNode, maybeAppearing];
        };

        _this.getClassNames = function (type) {
          var classNames = _this.props.classNames;
          var isStringClassNames = typeof classNames === 'string';
          var prefix = isStringClassNames && classNames ? classNames + "-" : '';
          var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
          var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
          var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
          return {
            baseClassName: baseClassName,
            activeClassName: activeClassName,
            doneClassName: doneClassName
          };
        };

        return _this;
      }

      var _proto = CSSTransition.prototype;

      _proto.addClass = function addClass(node, type, phase) {
        var className = this.getClassNames(type)[phase + "ClassName"];

        var _this$getClassNames = this.getClassNames('enter'),
            doneClassName = _this$getClassNames.doneClassName;

        if (type === 'appear' && phase === 'done' && doneClassName) {
          className += " " + doneClassName;
        } // This is to force a repaint,
        // which is necessary in order to transition styles when adding a class name.


        if (phase === 'active') {
          if (node) forceReflow(node);
        }

        if (className) {
          this.appliedClasses[type][phase] = className;

          _addClass(node, className);
        }
      };

      _proto.removeClasses = function removeClasses(node, type) {
        var _this$appliedClasses$ = this.appliedClasses[type],
            baseClassName = _this$appliedClasses$.base,
            activeClassName = _this$appliedClasses$.active,
            doneClassName = _this$appliedClasses$.done;
        this.appliedClasses[type] = {};

        if (baseClassName) {
          removeClass(node, baseClassName);
        }

        if (activeClassName) {
          removeClass(node, activeClassName);
        }

        if (doneClassName) {
          removeClass(node, doneClassName);
        }
      };

      _proto.render = function render() {
        var _this$props = this.props;
            _this$props.classNames;
            var props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);

        return /*#__PURE__*/React.createElement(Transition$1, _extends$1({}, props, {
          onEnter: this.onEnter,
          onEntered: this.onEntered,
          onEntering: this.onEntering,
          onExit: this.onExit,
          onExiting: this.onExiting,
          onExited: this.onExited
        }));
      };

      return CSSTransition;
    }(React.Component);

    CSSTransition.defaultProps = {
      classNames: ''
    };
    CSSTransition.propTypes = process.env.NODE_ENV !== "production" ? _extends$1({}, Transition$1.propTypes, {
      /**
       * The animation classNames applied to the component as it appears, enters,
       * exits or has finished the transition. A single name can be provided, which
       * will be suffixed for each stage, e.g. `classNames="fade"` applies:
       *
       * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
       * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
       * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
       *
       * A few details to note about how these classes are applied:
       *
       * 1. They are _joined_ with the ones that are already defined on the child
       *    component, so if you want to add some base styles, you can use
       *    `className` without worrying that it will be overridden.
       *
       * 2. If the transition component mounts with `in={false}`, no classes are
       *    applied yet. You might be expecting `*-exit-done`, but if you think
       *    about it, a component cannot finish exiting if it hasn't entered yet.
       *
       * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
       *    allows you to define different behavior for when appearing is done and
       *    when regular entering is done, using selectors like
       *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
       *    an epic entrance animation when element first appears in the DOM using
       *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
       *    simply use `fade-enter-done` for defining both cases.
       *
       * Each individual classNames can also be specified independently like:
       *
       * ```js
       * classNames={{
       *  appear: 'my-appear',
       *  appearActive: 'my-active-appear',
       *  appearDone: 'my-done-appear',
       *  enter: 'my-enter',
       *  enterActive: 'my-active-enter',
       *  enterDone: 'my-done-enter',
       *  exit: 'my-exit',
       *  exitActive: 'my-active-exit',
       *  exitDone: 'my-done-exit',
       * }}
       * ```
       *
       * If you want to set these classes using CSS Modules:
       *
       * ```js
       * import styles from './styles.css';
       * ```
       *
       * you might want to use camelCase in your CSS file, that way could simply
       * spread them instead of listing them one by one:
       *
       * ```js
       * classNames={{ ...styles }}
       * ```
       *
       * @type {string | {
       *  appear?: string,
       *  appearActive?: string,
       *  appearDone?: string,
       *  enter?: string,
       *  enterActive?: string,
       *  enterDone?: string,
       *  exit?: string,
       *  exitActive?: string,
       *  exitDone?: string,
       * }}
       */
      classNames: classNamesShape,

      /**
       * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
       * applied.
       *
       * **Note**: when `nodeRef` prop is passed, `node` is not passed.
       *
       * @type Function(node: HtmlElement, isAppearing: bool)
       */
      onEnter: PropTypes.func,

      /**
       * A `<Transition>` callback fired immediately after the 'enter-active' or
       * 'appear-active' class is applied.
       *
       * **Note**: when `nodeRef` prop is passed, `node` is not passed.
       *
       * @type Function(node: HtmlElement, isAppearing: bool)
       */
      onEntering: PropTypes.func,

      /**
       * A `<Transition>` callback fired immediately after the 'enter' or
       * 'appear' classes are **removed** and the `done` class is added to the DOM node.
       *
       * **Note**: when `nodeRef` prop is passed, `node` is not passed.
       *
       * @type Function(node: HtmlElement, isAppearing: bool)
       */
      onEntered: PropTypes.func,

      /**
       * A `<Transition>` callback fired immediately after the 'exit' class is
       * applied.
       *
       * **Note**: when `nodeRef` prop is passed, `node` is not passed
       *
       * @type Function(node: HtmlElement)
       */
      onExit: PropTypes.func,

      /**
       * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
       *
       * **Note**: when `nodeRef` prop is passed, `node` is not passed
       *
       * @type Function(node: HtmlElement)
       */
      onExiting: PropTypes.func,

      /**
       * A `<Transition>` callback fired immediately after the 'exit' classes
       * are **removed** and the `exit-done` class is added to the DOM node.
       *
       * **Note**: when `nodeRef` prop is passed, `node` is not passed
       *
       * @type Function(node: HtmlElement)
       */
      onExited: PropTypes.func
    }) : {};
    var CSSTransition$1 = CSSTransition;

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }

    /**
     * Given `this.props.children`, return an object mapping key to child.
     *
     * @param {*} children `this.props.children`
     * @return {object} Mapping of key to child
     */

    function getChildMapping(children, mapFn) {
      var mapper = function mapper(child) {
        return mapFn && React.isValidElement(child) ? mapFn(child) : child;
      };

      var result = Object.create(null);
      if (children) React.Children.map(children, function (c) {
        return c;
      }).forEach(function (child) {
        // run the map function here instead so that the key is the computed one
        result[child.key] = mapper(child);
      });
      return result;
    }
    /**
     * When you're adding or removing children some may be added or removed in the
     * same render pass. We want to show *both* since we want to simultaneously
     * animate elements in and out. This function takes a previous set of keys
     * and a new set of keys and merges them with its best guess of the correct
     * ordering. In the future we may expose some of the utilities in
     * ReactMultiChild to make this easy, but for now React itself does not
     * directly have this concept of the union of prevChildren and nextChildren
     * so we implement it here.
     *
     * @param {object} prev prev children as returned from
     * `ReactTransitionChildMapping.getChildMapping()`.
     * @param {object} next next children as returned from
     * `ReactTransitionChildMapping.getChildMapping()`.
     * @return {object} a key set that contains all keys in `prev` and all keys
     * in `next` in a reasonable order.
     */

    function mergeChildMappings(prev, next) {
      prev = prev || {};
      next = next || {};

      function getValueForKey(key) {
        return key in next ? next[key] : prev[key];
      } // For each key of `next`, the list of keys to insert before that key in
      // the combined list


      var nextKeysPending = Object.create(null);
      var pendingKeys = [];

      for (var prevKey in prev) {
        if (prevKey in next) {
          if (pendingKeys.length) {
            nextKeysPending[prevKey] = pendingKeys;
            pendingKeys = [];
          }
        } else {
          pendingKeys.push(prevKey);
        }
      }

      var i;
      var childMapping = {};

      for (var nextKey in next) {
        if (nextKeysPending[nextKey]) {
          for (i = 0; i < nextKeysPending[nextKey].length; i++) {
            var pendingNextKey = nextKeysPending[nextKey][i];
            childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
          }
        }

        childMapping[nextKey] = getValueForKey(nextKey);
      } // Finally, add the keys which didn't appear before any key in `next`


      for (i = 0; i < pendingKeys.length; i++) {
        childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
      }

      return childMapping;
    }

    function getProp(child, prop, props) {
      return props[prop] != null ? props[prop] : child.props[prop];
    }

    function getInitialChildMapping(props, onExited) {
      return getChildMapping(props.children, function (child) {
        return React.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: true,
          appear: getProp(child, 'appear', props),
          enter: getProp(child, 'enter', props),
          exit: getProp(child, 'exit', props)
        });
      });
    }
    function getNextChildMapping(nextProps, prevChildMapping, onExited) {
      var nextChildMapping = getChildMapping(nextProps.children);
      var children = mergeChildMappings(prevChildMapping, nextChildMapping);
      Object.keys(children).forEach(function (key) {
        var child = children[key];
        if (!React.isValidElement(child)) return;
        var hasPrev = (key in prevChildMapping);
        var hasNext = (key in nextChildMapping);
        var prevChild = prevChildMapping[key];
        var isLeaving = React.isValidElement(prevChild) && !prevChild.props.in; // item is new (entering)

        if (hasNext && (!hasPrev || isLeaving)) {
          // console.log('entering', key)
          children[key] = React.cloneElement(child, {
            onExited: onExited.bind(null, child),
            in: true,
            exit: getProp(child, 'exit', nextProps),
            enter: getProp(child, 'enter', nextProps)
          });
        } else if (!hasNext && hasPrev && !isLeaving) {
          // item is old (exiting)
          // console.log('leaving', key)
          children[key] = React.cloneElement(child, {
            in: false
          });
        } else if (hasNext && hasPrev && React.isValidElement(prevChild)) {
          // item hasn't changed transition states
          // copy over the last transition props;
          // console.log('unchanged', key)
          children[key] = React.cloneElement(child, {
            onExited: onExited.bind(null, child),
            in: prevChild.props.in,
            exit: getProp(child, 'exit', nextProps),
            enter: getProp(child, 'enter', nextProps)
          });
        }
      });
      return children;
    }

    var values = Object.values || function (obj) {
      return Object.keys(obj).map(function (k) {
        return obj[k];
      });
    };

    var defaultProps$F = {
      component: 'div',
      childFactory: function childFactory(child) {
        return child;
      }
    };
    /**
     * The `<TransitionGroup>` component manages a set of transition components
     * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
     * components, `<TransitionGroup>` is a state machine for managing the mounting
     * and unmounting of components over time.
     *
     * Consider the example below. As items are removed or added to the TodoList the
     * `in` prop is toggled automatically by the `<TransitionGroup>`.
     *
     * Note that `<TransitionGroup>`  does not define any animation behavior!
     * Exactly _how_ a list item animates is up to the individual transition
     * component. This means you can mix and match animations across different list
     * items.
     */

    var TransitionGroup = /*#__PURE__*/function (_React$Component) {
      _inheritsLoose(TransitionGroup, _React$Component);

      function TransitionGroup(props, context) {
        var _this;

        _this = _React$Component.call(this, props, context) || this;

        var handleExited = _this.handleExited.bind(_assertThisInitialized(_this)); // Initial children should all be entering, dependent on appear


        _this.state = {
          contextValue: {
            isMounting: true
          },
          handleExited: handleExited,
          firstRender: true
        };
        return _this;
      }

      var _proto = TransitionGroup.prototype;

      _proto.componentDidMount = function componentDidMount() {
        this.mounted = true;
        this.setState({
          contextValue: {
            isMounting: false
          }
        });
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        this.mounted = false;
      };

      TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
        var prevChildMapping = _ref.children,
            handleExited = _ref.handleExited,
            firstRender = _ref.firstRender;
        return {
          children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
          firstRender: false
        };
      } // node is `undefined` when user provided `nodeRef` prop
      ;

      _proto.handleExited = function handleExited(child, node) {
        var currentChildMapping = getChildMapping(this.props.children);
        if (child.key in currentChildMapping) return;

        if (child.props.onExited) {
          child.props.onExited(node);
        }

        if (this.mounted) {
          this.setState(function (state) {
            var children = _extends$1({}, state.children);

            delete children[child.key];
            return {
              children: children
            };
          });
        }
      };

      _proto.render = function render() {
        var _this$props = this.props,
            Component = _this$props.component,
            childFactory = _this$props.childFactory,
            props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);

        var contextValue = this.state.contextValue;
        var children = values(this.state.children).map(childFactory);
        delete props.appear;
        delete props.enter;
        delete props.exit;

        if (Component === null) {
          return /*#__PURE__*/React.createElement(TransitionGroupContext.Provider, {
            value: contextValue
          }, children);
        }

        return /*#__PURE__*/React.createElement(TransitionGroupContext.Provider, {
          value: contextValue
        }, /*#__PURE__*/React.createElement(Component, props, children));
      };

      return TransitionGroup;
    }(React.Component);

    TransitionGroup.propTypes = process.env.NODE_ENV !== "production" ? {
      /**
       * `<TransitionGroup>` renders a `<div>` by default. You can change this
       * behavior by providing a `component` prop.
       * If you use React v16+ and would like to avoid a wrapping `<div>` element
       * you can pass in `component={null}`. This is useful if the wrapping div
       * borks your css styles.
       */
      component: PropTypes.any,

      /**
       * A set of `<Transition>` components, that are toggled `in` and out as they
       * leave. the `<TransitionGroup>` will inject specific transition props, so
       * remember to spread them through if you are wrapping the `<Transition>` as
       * with our `<Fade>` example.
       *
       * While this component is meant for multiple `Transition` or `CSSTransition`
       * children, sometimes you may want to have a single transition child with
       * content that you want to be transitioned out and in when you change it
       * (e.g. routes, images etc.) In that case you can change the `key` prop of
       * the transition child as you change its content, this will cause
       * `TransitionGroup` to transition the child out and back in.
       */
      children: PropTypes.node,

      /**
       * A convenience prop that enables or disables appear animations
       * for all children. Note that specifying this will override any defaults set
       * on individual children Transitions.
       */
      appear: PropTypes.bool,

      /**
       * A convenience prop that enables or disables enter animations
       * for all children. Note that specifying this will override any defaults set
       * on individual children Transitions.
       */
      enter: PropTypes.bool,

      /**
       * A convenience prop that enables or disables exit animations
       * for all children. Note that specifying this will override any defaults set
       * on individual children Transitions.
       */
      exit: PropTypes.bool,

      /**
       * You may need to apply reactive updates to a child as it is exiting.
       * This is generally done by using `cloneElement` however in the case of an exiting
       * child the element has already been removed and not accessible to the consumer.
       *
       * If you do need to update a child as it leaves you can provide a `childFactory`
       * to wrap every child, even the ones that are leaving.
       *
       * @type Function(child: ReactElement) -> ReactElement
       */
      childFactory: PropTypes.func
    } : {};
    TransitionGroup.defaultProps = defaultProps$F;
    var TransitionGroup$1 = TransitionGroup;

    var _leaveRenders, _enterRenders;

    function areChildrenDifferent(oldChildren, newChildren) {
      if (oldChildren === newChildren) return false;

      if (React.isValidElement(oldChildren) && React.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {
        return false;
      }

      return true;
    }
    /**
     * Enum of modes for SwitchTransition component
     * @enum { string }
     */


    var modes = {
      out: 'out-in',
      in: 'in-out'
    };

    var callHook = function callHook(element, name, cb) {
      return function () {
        var _element$props;

        element.props[name] && (_element$props = element.props)[name].apply(_element$props, arguments);
        cb();
      };
    };

    var leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function (_ref) {
      var current = _ref.current,
          changeState = _ref.changeState;
      return React.cloneElement(current, {
        in: false,
        onExited: callHook(current, 'onExited', function () {
          changeState(ENTERING, null);
        })
      });
    }, _leaveRenders[modes.in] = function (_ref2) {
      var current = _ref2.current,
          changeState = _ref2.changeState,
          children = _ref2.children;
      return [current, React.cloneElement(children, {
        in: true,
        onEntered: callHook(children, 'onEntered', function () {
          changeState(ENTERING);
        })
      })];
    }, _leaveRenders);
    var enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function (_ref3) {
      var children = _ref3.children,
          changeState = _ref3.changeState;
      return React.cloneElement(children, {
        in: true,
        onEntered: callHook(children, 'onEntered', function () {
          changeState(ENTERED, React.cloneElement(children, {
            in: true
          }));
        })
      });
    }, _enterRenders[modes.in] = function (_ref4) {
      var current = _ref4.current,
          children = _ref4.children,
          changeState = _ref4.changeState;
      return [React.cloneElement(current, {
        in: false,
        onExited: callHook(current, 'onExited', function () {
          changeState(ENTERED, React.cloneElement(children, {
            in: true
          }));
        })
      }), React.cloneElement(children, {
        in: true
      })];
    }, _enterRenders);
    /**
     * A transition component inspired by the [vue transition modes](https://vuejs.org/v2/guide/transitions.html#Transition-Modes).
     * You can use it when you want to control the render between state transitions.
     * Based on the selected mode and the child's key which is the `Transition` or `CSSTransition` component, the `SwitchTransition` makes a consistent transition between them.
     *
     * If the `out-in` mode is selected, the `SwitchTransition` waits until the old child leaves and then inserts a new child.
     * If the `in-out` mode is selected, the `SwitchTransition` inserts a new child first, waits for the new child to enter and then removes the old child.
     *
     * **Note**: If you want the animation to happen simultaneously
     * (that is, to have the old child removed and a new child inserted **at the same time**),
     * you should use
     * [`TransitionGroup`](https://reactcommunity.org/react-transition-group/transition-group)
     * instead.
     *
     * ```jsx
     * function App() {
     *  const [state, setState] = useState(false);
     *  return (
     *    <SwitchTransition>
     *      <CSSTransition
     *        key={state ? "Goodbye, world!" : "Hello, world!"}
     *        addEndListener={(node, done) => node.addEventListener("transitionend", done, false)}
     *        classNames='fade'
     *      >
     *        <button onClick={() => setState(state => !state)}>
     *          {state ? "Goodbye, world!" : "Hello, world!"}
     *        </button>
     *      </CSSTransition>
     *    </SwitchTransition>
     *  );
     * }
     * ```
     *
     * ```css
     * .fade-enter{
     *    opacity: 0;
     * }
     * .fade-exit{
     *    opacity: 1;
     * }
     * .fade-enter-active{
     *    opacity: 1;
     * }
     * .fade-exit-active{
     *    opacity: 0;
     * }
     * .fade-enter-active,
     * .fade-exit-active{
     *    transition: opacity 500ms;
     * }
     * ```
     */

    var SwitchTransition = /*#__PURE__*/function (_React$Component) {
      _inheritsLoose(SwitchTransition, _React$Component);

      function SwitchTransition() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
        _this.state = {
          status: ENTERED,
          current: null
        };
        _this.appeared = false;

        _this.changeState = function (status, current) {
          if (current === void 0) {
            current = _this.state.current;
          }

          _this.setState({
            status: status,
            current: current
          });
        };

        return _this;
      }

      var _proto = SwitchTransition.prototype;

      _proto.componentDidMount = function componentDidMount() {
        this.appeared = true;
      };

      SwitchTransition.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
        if (props.children == null) {
          return {
            current: null
          };
        }

        if (state.status === ENTERING && props.mode === modes.in) {
          return {
            status: ENTERING
          };
        }

        if (state.current && areChildrenDifferent(state.current, props.children)) {
          return {
            status: EXITING
          };
        }

        return {
          current: React.cloneElement(props.children, {
            in: true
          })
        };
      };

      _proto.render = function render() {
        var _this$props = this.props,
            children = _this$props.children,
            mode = _this$props.mode,
            _this$state = this.state,
            status = _this$state.status,
            current = _this$state.current;
        var data = {
          children: children,
          current: current,
          changeState: this.changeState,
          status: status
        };
        var component;

        switch (status) {
          case ENTERING:
            component = enterRenders[mode](data);
            break;

          case EXITING:
            component = leaveRenders[mode](data);
            break;

          case ENTERED:
            component = current;
        }

        return /*#__PURE__*/React.createElement(TransitionGroupContext.Provider, {
          value: {
            isMounting: !this.appeared
          }
        }, component);
      };

      return SwitchTransition;
    }(React.Component);

    SwitchTransition.propTypes = process.env.NODE_ENV !== "production" ? {
      /**
       * Transition modes.
       * `out-in`: Current element transitions out first, then when complete, the new element transitions in.
       * `in-out`: New element transitions in first, then when complete, the current element transitions out.
       *
       * @type {'out-in'|'in-out'}
       */
      mode: PropTypes.oneOf([modes.in, modes.out]),

      /**
       * Any `Transition` or `CSSTransition` component.
       */
      children: PropTypes.oneOfType([PropTypes.element.isRequired])
    } : {};
    SwitchTransition.defaultProps = {
      mode: modes.out
    };
    var SwitchTransition$1 = SwitchTransition;

    var _extends_1 = createCommonjsModule(function (module) {
    function _extends() {
      module.exports = _extends = Object.assign ? Object.assign.bind() : function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _extends.apply(this, arguments);
    }
    module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;
    });

    var _extends = /*@__PURE__*/getDefaultExportFromCjs(_extends_1);

    var _typeof_1 = createCommonjsModule(function (module) {
    function _typeof(obj) {
      "@babel/helpers - typeof";

      return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
    }
    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
    });

    var toPrimitive = createCommonjsModule(function (module) {
    var _typeof = _typeof_1["default"];
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
    });

    var toPropertyKey = createCommonjsModule(function (module) {
    var _typeof = _typeof_1["default"];

    function _toPropertyKey(arg) {
      var key = toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
    });

    var defineProperty$1 = createCommonjsModule(function (module) {
    function _defineProperty(obj, key, value) {
      key = toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
    });

    var _defineProperty$2 = /*@__PURE__*/getDefaultExportFromCjs(defineProperty$1);

    var IconContext = React.createContext({
      prefixCls: 'arco',
    });

    function ownKeys$R(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$S(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$R(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$R(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconCheckCircleFillComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$S(_objectSpread$S({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-check-circle-fill")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        fillRule: "evenodd",
        stroke: "none",
        d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm10.207-24.379a1 1 0 0 0 0-1.414l-1.414-1.414a1 1 0 0 0-1.414 0L22 26.172l-4.878-4.88a1 1 0 0 0-1.415 0l-1.414 1.415a1 1 0 0 0 0 1.414l7 7a1 1 0 0 0 1.414 0l11.5-11.5Z",
        clipRule: "evenodd"
      }));
    }

    var IconCheckCircleFill = /*#__PURE__*/React.forwardRef(IconCheckCircleFillComponent);
    IconCheckCircleFill.defaultProps = {
      isIcon: true
    };
    IconCheckCircleFill.displayName = 'IconCheckCircleFill';
    var IconCheckCircleFill$1 = IconCheckCircleFill;

    function ownKeys$Q(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$R(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$Q(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$Q(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconCloseCircleFillComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$R(_objectSpread$R({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-close-circle-fill")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        fillRule: "evenodd",
        stroke: "none",
        d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm4.955-27.771-4.95 4.95-4.95-4.95a1 1 0 0 0-1.414 0l-1.414 1.414a1 1 0 0 0 0 1.414l4.95 4.95-4.95 4.95a1 1 0 0 0 0 1.414l1.414 1.414a1 1 0 0 0 1.414 0l4.95-4.95 4.95 4.95a1 1 0 0 0 1.414 0l1.414-1.414a1 1 0 0 0 0-1.414l-4.95-4.95 4.95-4.95a1 1 0 0 0 0-1.414l-1.414-1.414a1 1 0 0 0-1.414 0Z",
        clipRule: "evenodd"
      }));
    }

    var IconCloseCircleFill = /*#__PURE__*/React.forwardRef(IconCloseCircleFillComponent);
    IconCloseCircleFill.defaultProps = {
      isIcon: true
    };
    IconCloseCircleFill.displayName = 'IconCloseCircleFill';
    var IconCloseCircleFill$1 = IconCloseCircleFill;

    function ownKeys$P(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$Q(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$P(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$P(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconInfoCircleFillComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$Q(_objectSpread$Q({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-info-circle-fill")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        fillRule: "evenodd",
        stroke: "none",
        d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm2-30a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2Zm0 17h1a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-6a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h1v-8a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h3a1 1 0 0 1 1 1v11Z",
        clipRule: "evenodd"
      }));
    }

    var IconInfoCircleFill = /*#__PURE__*/React.forwardRef(IconInfoCircleFillComponent);
    IconInfoCircleFill.defaultProps = {
      isIcon: true
    };
    IconInfoCircleFill.displayName = 'IconInfoCircleFill';
    var IconInfoCircleFill$1 = IconInfoCircleFill;

    function ownKeys$O(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$P(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$O(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$O(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconExclamationCircleFillComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$P(_objectSpread$P({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-exclamation-circle-fill")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        fillRule: "evenodd",
        stroke: "none",
        d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4 4 12.954 4 24s8.954 20 20 20Zm-2-11a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v2Zm4-18a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V15Z",
        clipRule: "evenodd"
      }));
    }

    var IconExclamationCircleFill = /*#__PURE__*/React.forwardRef(IconExclamationCircleFillComponent);
    IconExclamationCircleFill.defaultProps = {
      isIcon: true
    };
    IconExclamationCircleFill.displayName = 'IconExclamationCircleFill';
    var IconExclamationCircleFill$1 = IconExclamationCircleFill;

    function ownKeys$N(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$O(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$N(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$N(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconCloseComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$O(_objectSpread$O({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-close")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M9.857 9.858 24 24m0 0 14.142 14.142M24 24 38.142 9.858M24 24 9.857 38.142"
      }));
    }

    var IconClose = /*#__PURE__*/React.forwardRef(IconCloseComponent);
    IconClose.defaultProps = {
      isIcon: true
    };
    IconClose.displayName = 'IconClose';
    var IconClose$1 = IconClose;

    var opt = Object.prototype.toString;
    function isArray$1(obj) {
        return opt.call(obj) === '[object Array]';
    }
    function isObject$1(obj) {
        return opt.call(obj) === '[object Object]';
    }
    function isString(obj) {
        return opt.call(obj) === '[object String]';
    }
    function isNumber(obj) {
        return opt.call(obj) === '[object Number]' && obj === obj; // eslint-disable-line
    }
    function isFile(obj) {
        return opt.call(obj) === '[object File]';
    }
    function isUndefined(obj) {
        return obj === undefined;
    }
    function isNull(obj) {
        return obj === null;
    }
    function isNullOrUndefined(obj) {
        return obj === null || obj === undefined;
    }
    function isFunction$1(obj) {
        return typeof obj === 'function';
    }
    function isEmptyObject(obj) {
        return isObject$1(obj) && Object.keys(obj).length === 0;
    }
    function isDayjs(time) {
        // dayjs.isDayjs 在实际应用场景，比如多个版本的 dayjs 会失效
        return (isObject$1(time) &&
            (('$y' in time &&
                '$M' in time &&
                '$D' in time &&
                '$d' in time &&
                '$H' in time &&
                '$m' in time &&
                '$s' in time) ||
                time._isAMomentObject) // 兼容 moment 的验证
        );
    }

    function warning(condition, message) {
        if (process.env.NODE_ENV !== 'production' && console) {
            if (condition) {
                console.error("[@arco-design/web-react]: " + message);
            }
        }
    }

    var __read$1w = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$B = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    function cs () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var length = args.length;
        var classNames = [];
        var _loop_1 = function (i) {
            var v = args[i];
            if (!v) {
                return "continue";
            }
            if (isString(v)) {
                classNames.push(v);
            }
            else if (isArray$1(v)) {
                classNames = classNames.concat(v);
            }
            else if (isObject$1(v)) {
                Object.keys(v).forEach(function (k) {
                    if (v[k]) {
                        classNames.push(k);
                    }
                });
            }
            else {
                warning(true, 'arguments must be one of string/array/object.');
            }
        };
        for (var i = 0; i < length; i++) {
            _loop_1(i);
        }
        return __spreadArray$B([], __read$1w(new Set(classNames)), false).join(' ');
    }

    var dayjs_min = createCommonjsModule(function (module, exports) {
    !function(t,e){module.exports=e();}(commonjsGlobal,(function(){var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",f="month",h="quarter",c="year",d="date",l="Invalid Date",$=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(t){var e=["th","st","nd","rd"],n=t%100;return "["+t+(e[(n-20)%10]||e[n]||e[0])+"]"}},m=function(t,e,n){var r=String(t);return !r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return (e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return -t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return +(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return {M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},g="en",D={};D[g]=M;var p=function(t){return t instanceof _},S=function t(e,n,r){var i;if(!e)return g;if("string"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split("-");if(!i&&u.length>1)return t(u[0])}else {var a=e.name;D[a]=e,i=a;}return !r&&i&&(g=i),i||!r&&g},w=function(t,e){if(p(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},O=v;O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t);}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init();},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},m.$utils=function(){return O},m.isValid=function(){return !(this.$d.toString()===l)},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return w(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<w(t)},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),l=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return O.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v="set"+(this.$u?"UTC":"");switch(h){case c:return r?l(1,0):l(31,11);case f:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+"Hours",0);case u:return $(v+"Minutes",1);case s:return $(v+"Seconds",2);case i:return $(v+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=O.p(t),h="set"+(this.$u?"UTC":""),l=(n={},n[a]=h+"Date",n[d]=h+"Date",n[f]=h+"Month",n[c]=h+"FullYear",n[u]=h+"Hours",n[s]=h+"Minutes",n[i]=h+"Seconds",n[r]=h+"Milliseconds",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d;}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[O.p(t)]()},m.add=function(r,h){var d,l=this;r=Number(r);var $=O.p(h),y=function(t){var e=w(l);return O.w(e.date(e.date()+Math.round(t*r)),l)};if($===f)return this.set(f,this.$M+r);if($===c)return this.set(c,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return O.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=O.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,f=n.months,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},c=function(t){return O.s(s%12||12,t,"0")},d=n.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r},$={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:O.s(a+1,2,"0"),MMM:h(n.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,"0"),d:String(this.$W),dd:h(n.weekdaysMin,this.$W,o,2),ddd:h(n.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,"0"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,"0"),s:String(this.$s),ss:O.s(this.$s,2,"0"),SSS:O.s(this.$ms,3,"0"),Z:i};return r.replace(y,(function(t,e){return e||$[t]||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,v=this-M,g=O.m(this,M);return g=($={},$[c]=g/12,$[f]=g,$[h]=g/3,$[o]=(v-m)/6048e5,$[a]=(v-m)/864e5,$[u]=v/n,$[s]=v/e,$[i]=v/t,$)[y]||v,l?g:O.a(g)},m.daysInMonth=function(){return this.endOf(f).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return O.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),T=_.prototype;return w.prototype=T,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",f],["$y",c],["$D",d]].forEach((function(t){T[t[1]]=function(e){return this.$g(e,t[0],t[1])};})),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t)},w.en=D[g],w.Ls=D,w.p={},w}));
    });

    createCommonjsModule(function (module, exports) {
    !function(e,_){module.exports=_(dayjs_min);}(commonjsGlobal,(function(e){function _(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var t=_(e),d={name:"zh-cn",weekdays:"星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),weekdaysShort:"周日_周一_周二_周三_周四_周五_周六".split("_"),weekdaysMin:"日_一_二_三_四_五_六".split("_"),months:"一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),monthsShort:"1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),ordinal:function(e,_){return "W"===_?e+"周":e+"日"},weekStart:1,yearStart:4,formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY年M月D日",LLL:"YYYY年M月D日Ah点mm分",LLLL:"YYYY年M月D日ddddAh点mm分",l:"YYYY/M/D",ll:"YYYY年M月D日",lll:"YYYY年M月D日 HH:mm",llll:"YYYY年M月D日dddd HH:mm"},relativeTime:{future:"%s内",past:"%s前",s:"几秒",m:"1 分钟",mm:"%d 分钟",h:"1 小时",hh:"%d 小时",d:"1 天",dd:"%d 天",M:"1 个月",MM:"%d 个月",y:"1 年",yy:"%d 年"},meridiem:function(e,_){var t=100*e+_;return t<600?"凌晨":t<900?"早上":t<1100?"上午":t<1300?"中午":t<1800?"下午":"晚上"}};return t.default.locale(d,null,!0),d}));
    });

    var Calendar = {
        formatYear: 'YYYY 年',
        formatMonth: 'YYYY 年 MM 月',
        today: '今天',
        view: {
            month: '月',
            year: '年',
            week: '周',
            day: '日',
        },
        month: {
            long: {
                January: '一月',
                February: '二月',
                March: '三月',
                April: '四月',
                May: '五月',
                June: '六月',
                July: '七月',
                August: '八月',
                September: '九月',
                October: '十月',
                November: '十一月',
                December: '十二月',
            },
            short: {
                January: '一月',
                February: '二月',
                March: '三月',
                April: '四月',
                May: '五月',
                June: '六月',
                July: '七月',
                August: '八月',
                September: '九月',
                October: '十月',
                November: '十一月',
                December: '十二月',
            },
        },
        week: {
            long: {
                self: '周',
                monday: '周一',
                tuesday: '周二',
                wednesday: '周三',
                thursday: '周四',
                friday: '周五',
                saturday: '周六',
                sunday: '周日',
            },
            short: {
                self: '周',
                monday: '一',
                tuesday: '二',
                wednesday: '三',
                thursday: '四',
                friday: '五',
                saturday: '六',
                sunday: '日',
            },
        },
    };
    var zhCN = {
        locale: 'zh-CN',
        dayjsLocale: 'zh-cn',
        Calendar: Calendar,
        DatePicker: {
            Calendar: Calendar,
            placeholder: {
                date: '请选择日期',
                week: '请选择周',
                month: '请选择月份',
                year: '请选择年份',
                quarter: '请选择季度',
            },
            placeholders: {
                date: ['开始日期', '结束日期'],
                week: ['开始周', '结束周'],
                month: ['开始月份', '结束月份'],
                year: ['开始年份', '结束年份'],
                quarter: ['开始季度', '结束季度'],
            },
            selectTime: '选择时间',
            selectDate: '选择日期',
            today: '今天',
            now: '此刻',
            ok: '确定',
        },
        Drawer: {
            okText: '确定',
            cancelText: '取消',
        },
        Empty: {
            noData: '暂无数据',
        },
        Modal: {
            okText: '确定',
            cancelText: '取消',
        },
        Pagination: {
            goto: '前往',
            page: '页',
            countPerPage: '条/页',
            total: '共 {0} 条',
            prev: '上一页',
            next: '下一页',
            currentPage: '第 {0} 页',
            prevSomePages: '向前 {0} 页',
            nextSomePages: '向后 {0} 页',
            pageSize: '页码',
        },
        Popconfirm: {
            okText: '确定',
            cancelText: '取消',
        },
        Table: {
            okText: '确定',
            resetText: '重置',
            sortAscend: '点击升序',
            sortDescend: '点击降序',
            cancelSort: '取消排序',
        },
        TimePicker: {
            ok: '确定',
            placeholder: '请选择时间',
            placeholders: ['开始时间', '结束时间'],
            now: '此刻',
        },
        Progress: {
            success: '完成',
            error: '失败',
        },
        Upload: {
            start: '开始',
            cancel: '取消',
            delete: '删除',
            reupload: '点击重试',
            upload: '点击上传',
            preview: '预览',
            drag: '点击或拖拽文件到此处上传',
            dragHover: '释放文件并开始上传',
            error: '上传失败',
        },
        Typography: {
            copy: '复制',
            copied: '已复制',
            edit: '编辑',
            fold: '折叠',
            unfold: '展开',
        },
        Transfer: {
            resetText: '重置',
        },
        ImagePreview: {
            fullScreen: '全屏',
            rotateRight: '向右旋转',
            rotateLeft: '向左旋转',
            zoomIn: '放大',
            zoomOut: '缩小',
            originalSize: '原始尺寸',
        },
        Form: {
            validateMessages: {
                required: '#{field} 是必填项',
                type: {
                    string: '#{field} 不是合法的文本类型',
                    number: '#{field} 不是合法的数字类型',
                    boolean: '#{field} 不是合法的布尔类型',
                    array: '#{field} 不是合法的数组类型',
                    object: '#{field} 不是合法的对象类型',
                    url: '#{field} 不是合法的 url 地址',
                    email: '#{field} 不是合法的邮箱地址',
                    ip: '#{field} 不是合法的 IP 地址',
                },
                number: {
                    min: '`#{value}` 小于最小值 `#{min}`',
                    max: '`#{value}` 大于最大值 `#{max}`',
                    equal: '`#{value}` 不等于 `#{equal}`',
                    range: '`#{value}` 不在 `#{min} ~ #{max}` 范围内',
                    positive: '`#{value}` 不是正数',
                    negative: '`#{value}` 不是负数',
                },
                array: {
                    length: '`#{field}` 个数不等于 #{length}',
                    minLength: '`#{field}` 个数最少为 #{minLength}',
                    maxLength: '`#{field}` 个数最多为 #{maxLength}',
                    includes: '#{field} 不包含 #{includes}',
                    deepEqual: '#{field} 不等于 #{deepEqual}',
                    empty: '`#{field}` 不是空数组',
                },
                string: {
                    minLength: '字符数最少为 #{minLength}',
                    maxLength: '字符数最多为 #{maxLength}',
                    length: '字符数必须是 #{length}',
                    match: '`#{value}` 不符合模式 #{pattern}',
                    uppercase: '`#{value}` 必须全大写',
                    lowercase: '`#{value}` 必须全小写',
                },
                object: {
                    deepEqual: '`#{field}` 不等于期望值',
                    hasKeys: '`#{field}` 不包含必须字段',
                    empty: '`#{field}` 不是对象',
                },
                boolean: {
                    true: '期望是 `true`',
                    false: '期望是 `false`',
                },
            },
        },
    };

    // Less lighten
    function hexToRgb(hex) {
        var rgb = [];
        var _hex = hex.substr(1);
        // converts #abc to #aabbcc
        if (hex.length === 3) {
            _hex = hex.replace(/(.)/g, '$1$1');
        }
        _hex.replace(/../g, function (color) {
            rgb.push(parseInt(color, 0x10));
        });
        return {
            r: rgb[0],
            g: rgb[1],
            b: rgb[2],
            rgb: "rgb(" + rgb.join(',') + ")",
        };
    }
    function getRgb(color) {
        var rgb = hexToRgb(color);
        return { r: rgb.r, g: rgb.g, b: rgb.b };
    }
    function getHsl(color) {
        var rgb = getRgb(color);
        var hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
        return { h: hsl.h, s: hsl.s, l: hsl.l };
    }
    function rgbToHsl(r, g, b) {
        var _r = r / 255;
        var _g = g / 255;
        var _b = b / 255;
        var max = Math.max(_r, _g, _b);
        var min = Math.min(_r, _g, _b);
        var l = (max + min) / 2;
        var h;
        var s;
        if (max === min) {
            h = 0;
            s = 0;
        }
        else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case _r:
                    h = (_g - _b) / d + (_g < _b ? 6 : 0);
                    break;
                case _g:
                    h = (_b - _r) / d + 2;
                    break;
                case _b:
                    h = (_r - _g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return {
            h: h,
            s: s,
            l: l,
            hsl: "hsl(" + h * 360 + ", " + s * 100 + "%, " + l * 100 + "%)",
        };
    }
    function lighten(color, percent) {
        var hsl = getHsl(color);
        var h = +hsl.h;
        var s = +hsl.s;
        var l = +hsl.l * 100 + +percent;
        // return `hsl(${h * 360}, ${s * 100}%, ${l}%)`;
        var res = hsltorgb([h * 360, s * 100, l]);
        return res.join(',');
    }
    // copy from https://github.com/Qix-/color-convert/blob/master/conversions.js
    function hsltorgb(hsl) {
        var h = hsl[0] / 360;
        var s = hsl[1] / 100;
        var l = hsl[2] / 100;
        var t2;
        var t3;
        var val;
        if (s === 0) {
            val = l * 255;
            return [val, val, val];
        }
        if (l < 0.5) {
            t2 = l * (1 + s);
        }
        else {
            t2 = l + s - l * s;
        }
        var t1 = 2 * l - t2;
        var rgb = [0, 0, 0];
        for (var i = 0; i < 3; i++) {
            t3 = h + (1 / 3) * -(i - 1);
            if (t3 < 0) {
                t3++;
            }
            if (t3 > 1) {
                t3--;
            }
            if (6 * t3 < 1) {
                val = t1 + (t2 - t1) * 6 * t3;
            }
            else if (2 * t3 < 1) {
                val = t2;
            }
            else if (3 * t3 < 2) {
                val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
            }
            else {
                val = t1;
            }
            rgb[i] = val * 255;
        }
        return rgb;
    }

    var _a;
    var __SECRET_INTERNALS__ = '__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED';
    var CopyReactDOM = ReactDOM;
    var copyRender;
    var isReact18 = Number((_a = CopyReactDOM.version) === null || _a === void 0 ? void 0 : _a.split('.')[0]) > 17;
    var updateUsingClientEntryPoint = function (skipWarning) {
        // https://github.com/facebook/react/blob/17806594cc28284fe195f918e8d77de3516848ec/packages/react-dom/npm/client.js#L10
        // Avoid console warning
        if (isObject$1(CopyReactDOM[__SECRET_INTERNALS__])) {
            CopyReactDOM[__SECRET_INTERNALS__].usingClientEntryPoint = skipWarning;
        }
    };
    var createRoot;
    try {
        createRoot = CopyReactDOM.createRoot;
    }
    catch (_) {
        //
    }
    if (isReact18 && createRoot) {
        copyRender = function (app, container) {
            updateUsingClientEntryPoint(true);
            var root = createRoot(container);
            updateUsingClientEntryPoint(false);
            root.render(app);
            root._unmount = function () {
                setTimeout(function () {
                    var _a;
                    (_a = root === null || root === void 0 ? void 0 : root.unmount) === null || _a === void 0 ? void 0 : _a.call(root);
                });
            };
            return root;
        };
    }
    else {
        copyRender = function (app, container) {
            CopyReactDOM.render(app, container);
            return {
                render: function (app) {
                    CopyReactDOM.render(app, container);
                },
                _unmount: function () {
                    CopyReactDOM.unmountComponentAtNode(container);
                },
            };
        };
    }
    var render = copyRender;

    var __extends$b = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$2d = (undefined && undefined.__assign) || function () {
        __assign$2d = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$2d.apply(this, arguments);
    };
    /* eslint-disable react/no-unused-state */

    function getId(noticeProps) {
        if (noticeProps === null || noticeProps === void 0 ? void 0 : noticeProps.id) {
            return noticeProps === null || noticeProps === void 0 ? void 0 : noticeProps.id;
        }
        return "arco_notice_id_" + Math.random().toFixed(10).slice(2);
    }
    var BaseNotice = /** @class */ (function (_super) {
        __extends$b(BaseNotice, _super);
        function BaseNotice(props) {
            var _this = _super.call(this, props) || this;
            _this.add = function (noticeProps) {
                var id = getId(noticeProps);
                _this.setState(function (prevState) {
                    var oldNotices = prevState.notices;
                    // update notice
                    if (noticeProps.id && ~oldNotices.findIndex(function (notice) { return notice.id === noticeProps.id; })) {
                        _this.update(noticeProps);
                        return prevState;
                    }
                    return {
                        notices: oldNotices.concat(__assign$2d(__assign$2d({}, noticeProps), { id: id })),
                        position: noticeProps.position,
                    };
                });
                return id;
            };
            _this.update = function (newNotice) {
                var updatedNotices = _this.state.notices.map(function (oldNotice) {
                    if (newNotice.id === oldNotice.id) {
                        newNotice.update = true;
                        return newNotice;
                    }
                    return oldNotice;
                });
                _this.setState({
                    notices: updatedNotices,
                }, function () {
                    var notices = _this.state.notices.map(function (oldNotice) {
                        if (newNotice.id === oldNotice.id && oldNotice.update) {
                            delete oldNotice.update;
                        }
                        return oldNotice;
                    });
                    _this.setState({ notices: notices });
                });
            };
            _this.clear = function () {
                _this.setState({
                    notices: [],
                });
            };
            _this.state = {
                notices: [],
                position: 'topRight',
            };
            _this.remove = _this.remove.bind(_this);
            return _this;
        }
        BaseNotice.prototype.remove = function (id) {
            var newNotices = this.state.notices.filter(function (notice) { return notice.id !== id; });
            this.setState({
                notices: newNotices,
            });
        };
        return BaseNotice;
    }(React.Component));
    var BaseNotification = BaseNotice;

    function ownKeys$M(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$N(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$M(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$M(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconLoadingComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$N(_objectSpread$N({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-loading")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M42 24c0 9.941-8.059 18-18 18S6 33.941 6 24 14.059 6 24 6"
      }));
    }

    var IconLoading = /*#__PURE__*/React.forwardRef(IconLoadingComponent);
    IconLoading.defaultProps = {
      isIcon: true
    };
    IconLoading.displayName = 'IconLoading';
    var IconLoading$1 = IconLoading;

    var __assign$2c = (undefined && undefined.__assign) || function () {
        __assign$2c = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$2c.apply(this, arguments);
    };
    var __rest$16 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function IconHover(props) {
        var _a;
        var children = props.children, className = props.className, disabled = props.disabled, prefix = props.prefix, _b = props.size, size = _b === void 0 ? 'default' : _b, rest = __rest$16(props, ["children", "className", "disabled", "prefix", "size"]);
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var prefixCls = getPrefixCls('icon-hover');
        return (React.createElement("span", __assign$2c({ className: cs(prefixCls, (_a = {},
                _a[prefix + "-icon-hover"] = prefix,
                _a[prefixCls + "-size-" + size] = size && size !== 'default',
                _a[prefixCls + "-disabled"] = disabled,
                _a), className), onClick: props.onClick }, rest), children));
    }

    var __extends$a = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var Notice = /** @class */ (function (_super) {
        __extends$a(Notice, _super);
        function Notice() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.startTimer = function () {
                var _a = _this.props, duration = _a.duration, onClose = _a.onClose, id = _a.id;
                // 自动关闭
                if (duration !== 0) {
                    _this.timer = window.setTimeout(function () {
                        onClose && onClose(id);
                        _this.removeTimer();
                    }, duration);
                }
            };
            _this.removeTimer = function () {
                if (_this.timer) {
                    window.clearTimeout(_this.timer);
                    _this.timer = null;
                }
            };
            _this.onClose = function () {
                _this.props.onClose && _this.props.onClose(_this.props.id);
            };
            _this.renderIcon = function () {
                var _a = _this.props, showIcon = _a.showIcon, icon = _a.icon, type = _a.type, prefixCls = _a.prefixCls, iconPrefix = _a.iconPrefix;
                var content;
                if (icon) {
                    content = icon;
                }
                else if (showIcon) {
                    switch (type) {
                        case 'info':
                            content = React.createElement(IconInfoCircleFill$1, null);
                            break;
                        case 'success':
                            content = React.createElement(IconCheckCircleFill$1, null);
                            break;
                        case 'error':
                            content = React.createElement(IconCloseCircleFill$1, null);
                            break;
                        case 'warning':
                            content = React.createElement(IconExclamationCircleFill$1, null);
                            break;
                        case 'loading':
                            content = React.createElement(IconLoading$1, null);
                            break;
                    }
                    content = (React.createElement(IconContext.Provider, { value: iconPrefix ? { prefixCls: iconPrefix } : {} }, content));
                }
                return React.createElement("span", { className: prefixCls + "-icon" }, content);
            };
            _this.onMouseEnter = function () {
                _this.removeTimer();
            };
            _this.onMouseLeave = function () {
                // An update operation may be triggered after mouseEnter to start a new timer.
                // mouseEnter(clear) => clickBtn => update(new timer) => mouseLeave
                _this.removeTimer();
                _this.startTimer();
            };
            return _this;
        }
        Notice.prototype.componentDidMount = function () {
            this.startTimer();
        };
        Notice.prototype.componentDidUpdate = function (nextProps) {
            if (nextProps.duration !== this.props.duration || this.props.update) {
                this.removeTimer();
                this.startTimer();
            }
        };
        Notice.prototype.componentWillUnmount = function () {
            this.removeTimer();
        };
        Notice.prototype.render = function () {
            var _a;
            var _b = this.props, title = _b.title, content = _b.content, showIcon = _b.showIcon, className = _b.className, style = _b.style, type = _b.type, btn = _b.btn, icon = _b.icon, prefixCls = _b.prefixCls, closable = _b.closable, noticeType = _b.noticeType, iconPrefix = _b.iconPrefix, rtl = _b.rtl;
            var classNames = cs(prefixCls, prefixCls + "-" + type, (_a = {},
                _a[prefixCls + "-closable"] = closable,
                _a[prefixCls + "-rtl"] = rtl,
                _a), className);
            var _closable = 'closable' in this.props ? closable : true;
            var shouldRenderIcon = showIcon;
            if (type === 'normal' && !icon) {
                shouldRenderIcon = false;
            }
            if (noticeType === 'message') {
                _closable = closable;
                return (React.createElement("div", { style: { textAlign: 'center' }, onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave },
                    React.createElement("div", { className: classNames, style: style, role: "alert" },
                        shouldRenderIcon && this.renderIcon(),
                        React.createElement("span", { className: prefixCls + "-content" }, content),
                        _closable && (React.createElement(IconHover, { prefix: prefixCls, className: prefixCls + "-close-btn", onClick: this.onClose },
                            React.createElement(IconClose$1, null))))));
            }
            if (noticeType === 'notification') {
                return (React.createElement("div", { onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave },
                    React.createElement("div", { className: classNames, style: style, role: "alert" },
                        shouldRenderIcon && React.createElement("div", { className: prefixCls + "-left" }, this.renderIcon()),
                        React.createElement("div", { className: prefixCls + "-right" },
                            title && React.createElement("div", { className: prefixCls + "-title" }, title),
                            React.createElement("div", { className: prefixCls + "-content" }, content),
                            btn && React.createElement("div", { className: prefixCls + "-btn-wrapper" }, btn)),
                        _closable && (React.createElement(IconHover, { prefix: prefixCls, className: prefixCls + "-close-btn", onClick: this.onClose },
                            React.createElement(IconContext.Provider, { value: iconPrefix ? { prefixCls: iconPrefix } : {} },
                                React.createElement(IconClose$1, null)))))));
            }
        };
        Notice.defaultProps = {
            type: 'info',
            showIcon: true,
            noticeType: 'message',
            duration: 3000,
        };
        return Notice;
    }(React.Component));
    var Notice$1 = Notice;

    var __read$1v = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$A = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var ContextHolderElement = React.forwardRef(function (_props, ref) {
        var configContext = React.useContext(ConfigContext);
        var _a = __read$1v(React.useState([]), 2), instances = _a[0], setInstances = _a[1];
        function addInstance(ins) {
            setInstances(function (originInstances) { return __spreadArray$A(__spreadArray$A([], __read$1v(originInstances), false), [ins], false); });
        }
        function removeInstance(ins) {
            setInstances(function (originInstances) { return originInstances.filter(function (originIns) { return ins !== originIns; }); });
        }
        function getContextConfig() {
            return configContext;
        }
        React.useImperativeHandle(ref, function () { return ({
            addInstance: addInstance,
            removeInstance: removeInstance,
            getContextConfig: getContextConfig,
        }); });
        return (React.createElement(React.Fragment, null, React.Children.map(instances, function (child, index) { return React.cloneElement(child, { key: index }); })));
    });
    var ContextHolderElement$1 = ContextHolderElement;

    var __assign$2b = (undefined && undefined.__assign) || function () {
        __assign$2b = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$2b.apply(this, arguments);
    };
    function useMessage(commonConfig) {
        if (commonConfig === void 0) { commonConfig = {}; }
        var maxCount = commonConfig.maxCount, _a = commonConfig.duration, duration = _a === void 0 ? 3000 : _a, _prefixCls = commonConfig.prefixCls;
        var contextHolderRef = React.createRef();
        var holderEle = React.createElement(ContextHolderElement$1, { ref: contextHolderRef });
        var messageInstance = {};
        var notice;
        function addNotice(config) {
            var prefixCls, rtl;
            if (contextHolderRef.current) {
                var contextConfig = contextHolderRef.current.getContextConfig();
                rtl = contextConfig.rtl;
                prefixCls = contextConfig.prefixCls;
            }
            var mergedPrefixCls = _prefixCls || prefixCls;
            var _noticeProps = __assign$2b({ position: 'top', duration: duration }, config);
            var position = _noticeProps.position, transitionClassNames = _noticeProps.transitionClassNames;
            var id;
            if (messageInstance[position]) {
                var notices = messageInstance[position].state.notices;
                if (notices.length >= maxCount) {
                    var updated = notices[0];
                    id = updated.id;
                    notices.shift();
                    messageInstance[position].add(__assign$2b(__assign$2b({}, _noticeProps), { id: id }));
                }
                else {
                    id = messageInstance[position].add(_noticeProps);
                }
            }
            else {
                notice = (React.createElement(Message$1, { transitionClassNames: transitionClassNames, ref: function (instance) {
                        messageInstance[position] = instance;
                        if (messageInstance[position]) {
                            id = messageInstance[position].add(_noticeProps);
                        }
                    }, prefixCls: mergedPrefixCls, rtl: rtl }));
                contextHolderRef.current.addInstance(notice);
            }
            var close = function () {
                if (messageInstance[position]) {
                    messageInstance[position].remove(id);
                }
            };
            return close;
        }
        var messageFuncs = {};
        ['info', 'success', 'warning', 'error', 'normal'].forEach(function (type) {
            messageFuncs[type] = function (config) {
                var _config = isString(config) ? { content: config } : config;
                return addNotice(__assign$2b(__assign$2b({}, _config), { type: type }));
            };
        });
        return [messageFuncs, holderEle];
    }

    var __extends$9 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$2a = (undefined && undefined.__assign) || function () {
        __assign$2a = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$2a.apply(this, arguments);
    };
    var messageTypes = ['info', 'success', 'error', 'warning', 'loading', 'normal'];
    var messageInstance = {};
    var maxCount$1;
    var prefixCls$1;
    var duration$1;
    var container$1;
    var rtl$1;
    function addInstance(noticeProps) {
        var _noticeProps = __assign$2a({ position: 'top', duration: duration$1 }, noticeProps);
        var position = _noticeProps.position, transitionClassNames = _noticeProps.transitionClassNames, transitionTimeout = _noticeProps.transitionTimeout;
        var id;
        if (messageInstance[position]) {
            var notices = messageInstance[position].state.notices;
            if (notices.length >= maxCount$1) {
                var updated = notices[0];
                id = updated.id;
                notices.shift();
                messageInstance[position].add(__assign$2a(__assign$2a({}, _noticeProps), { id: id }));
            }
            else {
                id = messageInstance[position].add(_noticeProps);
            }
        }
        else {
            var div = document.createElement('div');
            (container$1 || document.body).appendChild(div);
            render(React.createElement(Message, { transitionClassNames: transitionClassNames, transitionTimeout: transitionTimeout, ref: function (instance) {
                    messageInstance[position] = instance;
                    id = messageInstance[position].add(_noticeProps);
                } }), div);
        }
        var result = function () {
            if (messageInstance[position]) {
                messageInstance[position].remove(id);
            }
        };
        return result;
    }
    var Message = /** @class */ (function (_super) {
        __extends$9(Message, _super);
        function Message() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.remove = function (id) {
                var noticeItem = _this.state.notices.find(function (item) { return item.id === id; });
                if (noticeItem) {
                    _this.update(__assign$2a(__assign$2a({}, noticeItem), { style: __assign$2a(__assign$2a({}, noticeItem.style), { opacity: 0 }) }));
                }
                // 100 是透明度动画结束的时间
                setTimeout(function () {
                    _super.prototype.remove.call(_this, id);
                }, 100);
            };
            return _this;
        }
        Message.prototype.render = function () {
            var _this = this;
            var _a = this.props, transitionClassNames = _a.transitionClassNames, _transitionTimeout = _a.transitionTimeout, _prefixCls = _a.prefixCls, _rtl = _a.rtl;
            var _b = this.state, notices = _b.notices, position = _b.position;
            var mergedPrefixCls = _prefixCls || prefixCls$1;
            var mergedRtl = !isUndefined(_rtl) ? _rtl : rtl$1;
            var prefixClsMessage = mergedPrefixCls ? mergedPrefixCls + "-message" : 'arco-message';
            var transitionTimeout = {
                enter: isNumber(_transitionTimeout === null || _transitionTimeout === void 0 ? void 0 : _transitionTimeout.enter) ? _transitionTimeout === null || _transitionTimeout === void 0 ? void 0 : _transitionTimeout.enter : 100,
                exit: isNumber(_transitionTimeout === null || _transitionTimeout === void 0 ? void 0 : _transitionTimeout.exit) ? _transitionTimeout === null || _transitionTimeout === void 0 ? void 0 : _transitionTimeout.exit : 300,
            };
            var classNames = cs(prefixClsMessage + "-wrapper", prefixClsMessage + "-wrapper-" + position);
            return (React.createElement("div", { className: classNames },
                React.createElement(TransitionGroup$1, { component: null }, notices.map(function (notice) { return (React.createElement(CSSTransition$1, { key: notice.id, timeout: transitionTimeout, classNames: transitionClassNames || "fadeMessage", onExit: function (e) {
                        e.style.height = e.scrollHeight + "px";
                    }, onExiting: function (e) {
                        e.style.height = 0;
                    }, onExited: function (e) {
                        e.style.height = 0;
                        notice.onClose && notice.onClose();
                    } },
                    React.createElement(Notice$1, __assign$2a({}, notice, { prefixCls: prefixClsMessage, iconPrefix: mergedPrefixCls, onClose: _this.remove, noticeType: "message", rtl: mergedRtl })))); }))));
        };
        Message.config = function (options) {
            if (options === void 0) { options = {}; }
            if (options.maxCount) {
                maxCount$1 = options.maxCount;
            }
            if (options.prefixCls) {
                prefixCls$1 = options.prefixCls;
            }
            if (options.duration) {
                duration$1 = options.duration;
            }
            if (options.rtl) {
                rtl$1 = options.rtl;
            }
            if (options.getContainer && options.getContainer() !== container$1) {
                container$1 = options.getContainer();
                Object.keys(messageInstance).forEach(function (notice) { return messageInstance[notice].clear(); });
                messageInstance = {};
            }
        };
        Message.clear = function () {
            Object.keys(messageInstance).forEach(function (ins) {
                messageInstance[ins].clear();
            });
        };
        Message.addInstance = addInstance;
        return Message;
    }(BaseNotification));
    messageTypes.forEach(function (type) {
        Message[type] = function (noticeProps) {
            var props = typeof noticeProps === 'string' ? { content: noticeProps } : noticeProps;
            return addInstance(__assign$2a(__assign$2a({}, props), { type: type }));
        };
    });
    Message.useMessage = useMessage;
    var Message$1 = Message;

    var __assign$29 = (undefined && undefined.__assign) || function () {
        __assign$29 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$29.apply(this, arguments);
    };
    function useNotification(commonConfig) {
        if (commonConfig === void 0) { commonConfig = {}; }
        var maxCount = commonConfig.maxCount, _a = commonConfig.duration, duration = _a === void 0 ? 3000 : _a, _prefixCls = commonConfig.prefixCls;
        var contextHolderRef = React.createRef();
        var holderEle = React.createElement(ContextHolderElement$1, { ref: contextHolderRef });
        var notificationInstance = {};
        var notice;
        function addNotice(noticeProps) {
            var prefixCls, rtl;
            if (contextHolderRef.current) {
                var contextConfig = contextHolderRef.current.getContextConfig();
                rtl = contextConfig.rtl;
                prefixCls = contextConfig.prefixCls;
            }
            var mergedPrefixCls = _prefixCls || prefixCls;
            var position = noticeProps.position;
            if (isUndefined(noticeProps.position)) {
                position = rtl ? 'topLeft' : 'topRight';
            }
            var _noticeProps = __assign$29({ duration: duration }, noticeProps);
            var id;
            if (notificationInstance[position]) {
                var notices = notificationInstance[position].state.notices;
                if (notices.length >= maxCount) {
                    var updated = notices[0];
                    id = updated.id;
                    notices.shift();
                    notificationInstance[position].add(__assign$29(__assign$29({}, _noticeProps), { id: id }));
                }
                else {
                    id = notificationInstance[position].add(_noticeProps);
                }
            }
            else {
                notice = (React.createElement(Notification$1, { ref: function (instance) {
                        notificationInstance[position] = instance;
                        if (notificationInstance[position]) {
                            id = notificationInstance[position].add(_noticeProps);
                        }
                    }, prefixCls: mergedPrefixCls, rtl: rtl }));
                contextHolderRef.current.addInstance(notice);
            }
            return notificationInstance[position];
        }
        var notificationFuncs = {};
        ['info', 'success', 'warning', 'error', 'normal'].forEach(function (type) {
            notificationFuncs[type] = function (config) {
                return addNotice(__assign$29(__assign$29({}, config), { type: type }));
            };
        });
        return [notificationFuncs, holderEle];
    }

    var __extends$8 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$28 = (undefined && undefined.__assign) || function () {
        __assign$28 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$28.apply(this, arguments);
    };
    var notificationTypes = ['info', 'success', 'error', 'warning', 'normal'];
    var notificationInstance = {};
    // global config
    var maxCount;
    var prefixCls;
    var duration;
    var container;
    var rtl;
    var Notification = /** @class */ (function (_super) {
        __extends$8(Notification, _super);
        function Notification() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.remove = function (id) {
                var noticeItem = _this.state.notices.find(function (item) { return item.id === id; });
                if (noticeItem) {
                    _this.update(__assign$28(__assign$28({}, noticeItem), { style: __assign$28(__assign$28({}, noticeItem.style), { opacity: 0 }) }));
                }
                // 200 是透明度动画结束的时间
                setTimeout(function () {
                    _super.prototype.remove.call(_this, id);
                }, 200);
            };
            return _this;
        }
        Notification.prototype.render = function () {
            var _a;
            var _this = this;
            var notices = this.state.notices;
            var _b = this.props, _prefixCls = _b.prefixCls, _rtl = _b.rtl;
            var position = this.state.position;
            var mergedRtl = !isUndefined(_rtl) ? _rtl : rtl;
            if (isUndefined(position)) {
                position = mergedRtl ? 'topLeft' : 'topRight';
            }
            var mergedPrefixCls = _prefixCls || prefixCls;
            var prefixClsNotification = mergedPrefixCls
                ? mergedPrefixCls + "-notification"
                : 'arco-notification';
            var transitionClass;
            if (position === 'topLeft' || position === 'bottomLeft') {
                transitionClass = 'slideNoticeLeft';
            }
            else {
                transitionClass = 'slideNoticeRight';
            }
            var classNames = cs(prefixClsNotification + "-wrapper", prefixClsNotification + "-wrapper-" + position, (_a = {}, _a[prefixClsNotification + "-wrapper-rtl"] = rtl, _a));
            return (React.createElement("div", { className: classNames },
                React.createElement(TransitionGroup$1, { component: null }, notices.map(function (notice) { return (React.createElement(CSSTransition$1, { key: notice.id, timeout: {
                        enter: 400,
                        exit: 300,
                    }, classNames: transitionClass, onExit: function (e) {
                        e.style.height = e.scrollHeight + "px";
                    }, onExiting: function (e) {
                        e.style.height = 0;
                    }, onExited: function (e) {
                        e.style.height = 0;
                        notice.onClose && notice.onClose();
                    } },
                    React.createElement(Notice$1, __assign$28({}, notice, { onClose: _this.remove, prefixCls: prefixClsNotification, iconPrefix: mergedPrefixCls, noticeType: "notification", rtl: mergedRtl })))); }))));
        };
        Notification.config = function (options) {
            if (options === void 0) { options = {}; }
            if (options.maxCount) {
                maxCount = options.maxCount;
            }
            if (options.prefixCls) {
                prefixCls = options.prefixCls;
            }
            if (isNumber(options.duration)) {
                duration = options.duration;
            }
            if (options.rtl) {
                rtl = options.rtl;
            }
            if (options.getContainer && options.getContainer() !== container) {
                container = options.getContainer();
                Object.keys(notificationInstance).forEach(function (notice) { return notificationInstance[notice].clear(); });
                notificationInstance = {};
            }
        };
        Notification.clear = function () {
            Object.keys(notificationInstance).forEach(function (ins) {
                notificationInstance[ins].clear();
            });
        };
        Notification.remove = function (id) {
            Object.keys(notificationInstance).forEach(function (ins) {
                notificationInstance[ins].remove(id);
            });
        };
        Notification.addInstance = function (noticeProps) {
            var position = noticeProps.position;
            if (isUndefined(noticeProps.position)) {
                position = rtl ? 'topLeft' : 'topRight';
            }
            var _noticeProps = __assign$28({ duration: duration }, noticeProps);
            if (notificationInstance[position]) {
                var notices = notificationInstance[position].state.notices;
                if (notices.length >= maxCount) {
                    var updated = notices[0];
                    notices.shift();
                    notificationInstance[position].add(__assign$28(__assign$28({}, _noticeProps), { id: updated.id }));
                }
                else {
                    notificationInstance[position].add(_noticeProps);
                }
                return notificationInstance[position];
            }
            var div = document.createElement('div');
            var instance = null;
            (container || document.body).appendChild(div);
            render(React.createElement(Notification, { ref: function (ref) {
                    notificationInstance[position] = ref;
                    notificationInstance[position].add(_noticeProps);
                    instance = notificationInstance[position];
                    return instance;
                } }), div);
        };
        return Notification;
    }(BaseNotification));
    notificationTypes.forEach(function (type) {
        Notification[type] = function (noticeProps) {
            return Notification.addInstance(__assign$28(__assign$28({}, noticeProps), { type: type }));
        };
    });
    Notification.useNotification = useNotification;
    var Notification$1 = Notification;

    function ownKeys$L(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$M(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$L(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$L(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconEmptyComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$M(_objectSpread$M({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-empty")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M24 5v6m7 1 4-4m-18 4-4-4m28.5 22H28s-1 3-4 3-4-3-4-3H6.5M40 41H8a2 2 0 0 1-2-2v-8.46a2 2 0 0 1 .272-1.007l6.15-10.54A2 2 0 0 1 14.148 18H33.85a2 2 0 0 1 1.728.992l6.149 10.541A2 2 0 0 1 42 30.541V39a2 2 0 0 1-2 2Z"
      }));
    }

    var IconEmpty = /*#__PURE__*/React.forwardRef(IconEmptyComponent);
    IconEmpty.defaultProps = {
      isIcon: true
    };
    IconEmpty.displayName = 'IconEmpty';
    var IconEmpty$1 = IconEmpty;

    var __assign$27 = (undefined && undefined.__assign) || function () {
        __assign$27 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$27.apply(this, arguments);
    };
    // delete keys from object
    function omit$1(obj, keys // string 为了某些没有声明的属性被omit
    ) {
        var clone = __assign$27({}, obj);
        keys.forEach(function (key) {
            if (key in clone) {
                delete clone[key];
            }
        });
        return clone;
    }

    var __assign$26 = (undefined && undefined.__assign) || function () {
        __assign$26 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$26.apply(this, arguments);
    };
    function useMergeProps(componentProps, defaultProps, globalComponentConfig) {
        var _ignorePropsFromGlobal = componentProps._ignorePropsFromGlobal;
        var _defaultProps = React.useMemo(function () {
            return __assign$26(__assign$26({}, defaultProps), (_ignorePropsFromGlobal ? {} : globalComponentConfig));
        }, [defaultProps, globalComponentConfig, _ignorePropsFromGlobal]);
        var props = React.useMemo(function () {
            // Must remove property of MergePropsOptions before passing it to component
            var mProps = omit$1(componentProps, ['_ignorePropsFromGlobal']);
            // https://github.com/facebook/react/blob/cae635054e17a6f107a39d328649137b83f25972/packages/react/src/ReactElement.js#L312
            for (var propName in _defaultProps) {
                if (mProps[propName] === undefined) {
                    mProps[propName] = _defaultProps[propName];
                }
            }
            return mProps;
        }, [componentProps, _defaultProps]);
        return props;
    }

    var __assign$25 = (undefined && undefined.__assign) || function () {
        __assign$25 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$25.apply(this, arguments);
    };
    var __rest$15 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function Empty(baseProps, ref) {
        var _a = React.useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, globalLocale = _a.locale, componentConfig = _a.componentConfig;
        var props = useMergeProps(baseProps, {}, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Empty);
        var style = props.style, className = props.className, description = props.description, icon = props.icon, imgSrc = props.imgSrc, rest = __rest$15(props, ["style", "className", "description", "icon", "imgSrc"]);
        var prefixCls = getPrefixCls('empty');
        var classNames = cs(prefixCls, className);
        var noData = globalLocale.Empty.noData;
        var alt = typeof description === 'string' ? description : 'empty';
        return (React.createElement("div", __assign$25({ ref: ref, className: classNames, style: style }, rest),
            React.createElement("div", { className: prefixCls + "-wrapper" },
                React.createElement("div", { className: prefixCls + "-image" }, imgSrc ? React.createElement("img", { alt: alt, src: imgSrc }) : icon || React.createElement(IconEmpty$1, null)),
                React.createElement("div", { className: prefixCls + "-description" }, description || noData))));
    }
    var EmptyComponent = React.forwardRef(Empty);
    EmptyComponent.displayName = 'Empty';
    var Empty$1 = React.memo(EmptyComponent);

    var __assign$24 = (undefined && undefined.__assign) || function () {
        __assign$24 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$24.apply(this, arguments);
    };
    var configProvider = {};
    function setConfigProviderProps(configProviderProps) {
        configProvider = __assign$24({}, configProviderProps);
    }
    function getConfigProviderProps() {
        return configProvider;
    }
    var modalConfig = {
        simple: true,
    };
    var setModalConfig = function (config) {
        modalConfig = __assign$24(__assign$24({}, modalConfig), config);
    };
    var getModalConfig = function () {
        return modalConfig;
    };
    var destroyList = [];

    var __assign$23 = (undefined && undefined.__assign) || function () {
        __assign$23 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$23.apply(this, arguments);
    };
    var colorList = {
        primaryColor: {
            default: '--arcoblue-6',
            hover: '--arcoblue-5',
            active: '--arcoblue-7',
        },
        successColor: {
            default: '--green-6',
            hover: '--green-5',
            active: '--green-7',
        },
        infoColor: {
            default: '--arcoblue-6',
            hover: '--arcoblue-5',
            active: '--arcoblue-7',
        },
        warningColor: {
            default: '--orangered-6',
            hover: '--orangered-5',
            active: '--orangered-7',
        },
        dangerColor: {
            default: '--red-6',
            hover: '--red-5',
            active: '--red-7',
        },
    };
    function setTheme(theme) {
        if (theme && isObject$1(theme)) {
            var root_1 = document.body;
            Object.keys(colorList).forEach(function (color) {
                if (theme[color]) {
                    root_1.style.setProperty(colorList[color].default, lighten(theme[color], 0));
                    if (!theme[color + "Hover"]) {
                        root_1.style.setProperty(colorList[color].hover, lighten(theme[color], 10));
                    }
                    if (!theme[color + "Active"]) {
                        root_1.style.setProperty(colorList[color].active, lighten(theme[color], -10));
                    }
                }
            });
        }
    }
    function renderEmpty(componentName) {
        switch (componentName) {
            default:
                return React.createElement(Empty$1, null);
        }
    }
    var defaultProps$E = {
        locale: zhCN,
        prefixCls: 'arco',
        getPopupContainer: function () { return document.body; },
        size: 'default',
        renderEmpty: renderEmpty,
        focusLock: {
            modal: { autoFocus: true },
            drawer: { autoFocus: true },
        },
    };
    var componentConfig = {};
    var ConfigContext = React.createContext(__assign$23({ getPrefixCls: function (componentName, customPrefix) {
            return (customPrefix || 'arco') + "-" + componentName;
        } }, defaultProps$E));
    function ConfigProvider(baseProps) {
        var props = useMergeProps(baseProps, defaultProps$E, componentConfig);
        var theme = props.theme, prefixCls = props.prefixCls, children = props.children, locale = props.locale, rtl = props.rtl, _a = props.effectGlobalNotice, effectGlobalNotice = _a === void 0 ? true : _a;
        React.useEffect(function () {
            setTheme(theme);
        }, [theme]);
        React.useEffect(function () {
            if (effectGlobalNotice) {
                Message$1.config({ prefixCls: prefixCls, rtl: rtl });
                Notification$1.config({ prefixCls: prefixCls, rtl: rtl });
            }
        }, [prefixCls, rtl, effectGlobalNotice]);
        function getPrefixCls(componentName, customPrefix) {
            return (customPrefix || prefixCls) + "-" + componentName;
        }
        var config = __assign$23(__assign$23({}, omit$1(props, ['children'])), { getPrefixCls: getPrefixCls });
        React.useEffect(function () {
            setConfigProviderProps({ locale: locale, prefixCls: prefixCls, rtl: rtl });
        }, [locale, prefixCls]);
        var child = children;
        if (prefixCls && prefixCls !== 'arco') {
            child = React.createElement(IconContext.Provider, { value: { prefixCls: prefixCls } }, children);
        }
        return React.createElement(ConfigContext.Provider, { value: config }, child);
    }
    ConfigProvider.ConfigContext = ConfigContext;
    ConfigProvider.displayName = 'ConfigProvider';
    ConfigContext.Consumer;

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    var isObject_1 = isObject;

    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

    var _freeGlobal = freeGlobal;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root = _freeGlobal || freeSelf || Function('return this')();

    var _root = root;

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = function() {
      return _root.Date.now();
    };

    var now_1 = now;

    /** Used to match a single whitespace character. */
    var reWhitespace = /\s/;

    /**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
     * character of `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the index of the last non-whitespace character.
     */
    function trimmedEndIndex(string) {
      var index = string.length;

      while (index-- && reWhitespace.test(string.charAt(index))) {}
      return index;
    }

    var _trimmedEndIndex = trimmedEndIndex;

    /** Used to match leading whitespace. */
    var reTrimStart = /^\s+/;

    /**
     * The base implementation of `_.trim`.
     *
     * @private
     * @param {string} string The string to trim.
     * @returns {string} Returns the trimmed string.
     */
    function baseTrim(string) {
      return string
        ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, '')
        : string;
    }

    var _baseTrim = baseTrim;

    /** Built-in value references. */
    var Symbol$1 = _root.Symbol;

    var _Symbol = Symbol$1;

    /** Used for built-in method references. */
    var objectProto$e = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$b = objectProto$e.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$e.toString;

    /** Built-in value references. */
    var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty$b.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }

    var _getRawTag = getRawTag;

    /** Used for built-in method references. */
    var objectProto$d = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto$d.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    var _objectToString = objectToString;

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? _getRawTag(value)
        : _objectToString(value);
    }

    var _baseGetTag = baseGetTag;

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    var isObjectLike_1 = isObjectLike;

    /** `Object#toString` result references. */
    var symbolTag$1 = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol$1(value) {
      return typeof value == 'symbol' ||
        (isObjectLike_1(value) && _baseGetTag(value) == symbolTag$1);
    }

    var isSymbol_1 = isSymbol$1;

    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol_1(value)) {
        return NAN;
      }
      if (isObject_1(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject_1(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = _baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    var toNumber_1 = toNumber;

    /** Error message constants. */
    var FUNC_ERROR_TEXT$2 = 'Expected a function';

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$1 = Math.max,
        nativeMin = Math.min;

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$2);
      }
      wait = toNumber_1(wait) || 0;
      if (isObject_1(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax$1(toNumber_1(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now_1();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now_1());
      }

      function debounced() {
        var time = now_1(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    var debounce_1 = debounce;

    /** Error message constants. */
    var FUNC_ERROR_TEXT$1 = 'Expected a function';

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle$1(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      if (isObject_1(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce_1(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    var throttle_1 = throttle$1;

    function isElement(el) {
      return el != null && typeof el === 'object' && el.nodeType === 1;
    }

    function canOverflow(overflow, skipOverflowHiddenElements) {
      if (skipOverflowHiddenElements && overflow === 'hidden') {
        return false;
      }

      return overflow !== 'visible' && overflow !== 'clip';
    }

    function isScrollable$1(el, skipOverflowHiddenElements) {
      if (el.clientHeight < el.scrollHeight || el.clientWidth < el.scrollWidth) {
        var style = getComputedStyle(el, null);
        return canOverflow(style.overflowY, skipOverflowHiddenElements) || canOverflow(style.overflowX, skipOverflowHiddenElements);
      }

      return false;
    }

    function alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) {
      if (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd || elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd) {
        return 0;
      }

      if (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize || elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize) {
        return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;
      }

      if (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize || elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize) {
        return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;
      }

      return 0;
    }

    var compute = (function (target, options) {
      var scrollMode = options.scrollMode,
          block = options.block,
          inline = options.inline,
          boundary = options.boundary,
          skipOverflowHiddenElements = options.skipOverflowHiddenElements;
      var checkBoundary = typeof boundary === 'function' ? boundary : function (node) {
        return node !== boundary;
      };

      if (!isElement(target)) {
        throw new TypeError('Invalid target');
      }

      var scrollingElement = document.scrollingElement || document.documentElement;
      var frames = [];
      var cursor = target;

      while (isElement(cursor) && checkBoundary(cursor)) {
        cursor = cursor.parentNode;

        if (cursor === scrollingElement) {
          frames.push(cursor);
          break;
        }

        if (cursor === document.body && isScrollable$1(cursor) && !isScrollable$1(document.documentElement)) {
          continue;
        }

        if (isScrollable$1(cursor, skipOverflowHiddenElements)) {
          frames.push(cursor);
        }
      }

      var viewportWidth = window.visualViewport ? visualViewport.width : innerWidth;
      var viewportHeight = window.visualViewport ? visualViewport.height : innerHeight;
      var viewportX = window.scrollX || pageXOffset;
      var viewportY = window.scrollY || pageYOffset;

      var _target$getBoundingCl = target.getBoundingClientRect(),
          targetHeight = _target$getBoundingCl.height,
          targetWidth = _target$getBoundingCl.width,
          targetTop = _target$getBoundingCl.top,
          targetRight = _target$getBoundingCl.right,
          targetBottom = _target$getBoundingCl.bottom,
          targetLeft = _target$getBoundingCl.left;

      var targetBlock = block === 'start' || block === 'nearest' ? targetTop : block === 'end' ? targetBottom : targetTop + targetHeight / 2;
      var targetInline = inline === 'center' ? targetLeft + targetWidth / 2 : inline === 'end' ? targetRight : targetLeft;
      var computations = [];

      for (var index = 0; index < frames.length; index++) {
        var frame = frames[index];

        var _frame$getBoundingCli = frame.getBoundingClientRect(),
            _height = _frame$getBoundingCli.height,
            _width = _frame$getBoundingCli.width,
            _top = _frame$getBoundingCli.top,
            right = _frame$getBoundingCli.right,
            bottom = _frame$getBoundingCli.bottom,
            _left = _frame$getBoundingCli.left;

        if (scrollMode === 'if-needed' && targetTop >= 0 && targetLeft >= 0 && targetBottom <= viewportHeight && targetRight <= viewportWidth && targetTop >= _top && targetBottom <= bottom && targetLeft >= _left && targetRight <= right) {
          return computations;
        }

        var frameStyle = getComputedStyle(frame);
        var borderLeft = parseInt(frameStyle.borderLeftWidth, 10);
        var borderTop = parseInt(frameStyle.borderTopWidth, 10);
        var borderRight = parseInt(frameStyle.borderRightWidth, 10);
        var borderBottom = parseInt(frameStyle.borderBottomWidth, 10);
        var blockScroll = 0;
        var inlineScroll = 0;
        var scrollbarWidth = 'offsetWidth' in frame ? frame.offsetWidth - frame.clientWidth - borderLeft - borderRight : 0;
        var scrollbarHeight = 'offsetHeight' in frame ? frame.offsetHeight - frame.clientHeight - borderTop - borderBottom : 0;

        if (scrollingElement === frame) {
          if (block === 'start') {
            blockScroll = targetBlock;
          } else if (block === 'end') {
            blockScroll = targetBlock - viewportHeight;
          } else if (block === 'nearest') {
            blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);
          } else {
            blockScroll = targetBlock - viewportHeight / 2;
          }

          if (inline === 'start') {
            inlineScroll = targetInline;
          } else if (inline === 'center') {
            inlineScroll = targetInline - viewportWidth / 2;
          } else if (inline === 'end') {
            inlineScroll = targetInline - viewportWidth;
          } else {
            inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);
          }

          blockScroll = Math.max(0, blockScroll + viewportY);
          inlineScroll = Math.max(0, inlineScroll + viewportX);
        } else {
          if (block === 'start') {
            blockScroll = targetBlock - _top - borderTop;
          } else if (block === 'end') {
            blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;
          } else if (block === 'nearest') {
            blockScroll = alignNearest(_top, bottom, _height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);
          } else {
            blockScroll = targetBlock - (_top + _height / 2) + scrollbarHeight / 2;
          }

          if (inline === 'start') {
            inlineScroll = targetInline - _left - borderLeft;
          } else if (inline === 'center') {
            inlineScroll = targetInline - (_left + _width / 2) + scrollbarWidth / 2;
          } else if (inline === 'end') {
            inlineScroll = targetInline - right + borderRight + scrollbarWidth;
          } else {
            inlineScroll = alignNearest(_left, right, _width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);
          }

          var scrollLeft = frame.scrollLeft,
              scrollTop = frame.scrollTop;
          blockScroll = Math.max(0, Math.min(scrollTop + blockScroll, frame.scrollHeight - _height + scrollbarHeight));
          inlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, frame.scrollWidth - _width + scrollbarWidth));
          targetBlock += scrollTop - blockScroll;
          targetInline += scrollLeft - inlineScroll;
        }

        computations.push({
          el: frame,
          top: blockScroll,
          left: inlineScroll
        });
      }

      return computations;
    });

    function isOptionsObject(options) {
      return options === Object(options) && Object.keys(options).length !== 0;
    }

    function defaultBehavior(actions, behavior) {
      if (behavior === void 0) {
        behavior = 'auto';
      }

      var canSmoothScroll = 'scrollBehavior' in document.body.style;
      actions.forEach(function (_ref) {
        var el = _ref.el,
            top = _ref.top,
            left = _ref.left;

        if (el.scroll && canSmoothScroll) {
          el.scroll({
            top: top,
            left: left,
            behavior: behavior
          });
        } else {
          el.scrollTop = top;
          el.scrollLeft = left;
        }
      });
    }

    function getOptions(options) {
      if (options === false) {
        return {
          block: 'end',
          inline: 'nearest'
        };
      }

      if (isOptionsObject(options)) {
        return options;
      }

      return {
        block: 'start',
        inline: 'nearest'
      };
    }

    function scrollIntoView(target, options) {
      var targetIsDetached = !target.ownerDocument.documentElement.contains(target);

      if (isOptionsObject(options) && typeof options.behavior === 'function') {
        return options.behavior(targetIsDetached ? [] : compute(target, options));
      }

      if (targetIsDetached) {
        return;
      }

      var computeOptions = getOptions(options);
      return defaultBehavior(compute(target, computeOptions), computeOptions.behavior);
    }

    // pick item from object
    function pick(obj, keys) {
        var clone = {};
        keys.forEach(function (key) {
            var k = key;
            if (key in obj) {
                clone[k] = obj[k];
            }
        });
        return clone;
    }
    function pickDataAttributes(obj) {
        var clone = {};
        obj &&
            Object.keys(obj).forEach(function (key) {
                var k = String(key);
                if (k.indexOf('data-') === 0) {
                    clone[k] = obj[k];
                }
                if (k.indexOf('aria-') === 0) {
                    clone[k] = obj[k];
                }
            });
        return clone;
    }

    var NOOP = function () { };
    function newArray(length) {
        return Array.apply(null, Array(length));
    }
    function pickTriggerPropsFromRest(rest) {
        return pick(rest, [
            'onMouseEnter',
            'onMouseLeave',
            'onMouseMove',
            'onContextMenu',
            'onClick',
            'onFocus',
            'onBlur',
            'tabIndex',
        ]);
    }

    var isServerRendering = (function () {
        try {
            return !(typeof window !== 'undefined' && document !== undefined);
        }
        catch (e) {
            return true;
        }
    })();
    var on = (function () {
        if (isServerRendering) {
            return NOOP;
        }
        return function (element, event, handler, options) {
            element && element.addEventListener(event, handler, options || false);
        };
    })();
    var off = (function () {
        if (isServerRendering) {
            return NOOP;
        }
        return function (element, event, handler, options) {
            element && element.removeEventListener(event, handler, options || false);
        };
    })();
    var contains$1 = function (root, ele) {
        if (!root) {
            return false;
        }
        if (root.contains) {
            return root.contains(ele);
        }
        var node = ele;
        while (node) {
            if (node === root) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    };
    var isScrollElement = function (element) {
        var clientHeight = element === document.documentElement ? element.clientHeight : element.offsetHeight;
        var clientWidth = element === document.documentElement ? element.clientWidth : element.offsetWidth;
        return element.scrollHeight > clientHeight || element.scrollWidth > clientWidth;
    };
    /**
     * 从当前节点向上查找所有的滚动元素
     * @param container 当前节点
     * @param top 查找到 top 节点就终止，不再继续查找
     * @returns
     */
    var getScrollElements = function (container, top) {
        if (top === void 0) { top = document.documentElement; }
        var scrollElements = [];
        var element = container;
        while (element && element !== top) {
            if (isScrollElement(element)) {
                scrollElements.push(element);
            }
            element = element.parentElement;
        }
        return scrollElements;
    };

    function useIsFirstRender() {
        var isFirst = React.useRef(true);
        React.useEffect(function () {
            isFirst.current = false;
        }, []);
        return isFirst.current;
    }

    var target = typeof window === 'undefined' ? global : window;
    var vendors = ['webkit', 'ms', 'moz', 'o'];
    var raf = target.requestAnimationFrame; // eslint-disable-line
    var caf = target.cancelAnimationFrame; // eslint-disable-line
    if (!raf || !caf) {
        vendors.some(function (prefix) {
            raf = target[prefix + "RequestAnimationFrame"];
            caf = target[prefix + "CancelAnimationFrame"] || target[prefix + "CancelRequestAnimationFrame"];
            return raf && caf;
        });
        if (!raf || !caf) {
            var lastTime_1 = 0;
            raf = function (cb) {
                var currentTime = Date.now();
                var diff = Math.max(0, 16 - (currentTime - lastTime_1));
                var timer = setTimeout(function () {
                    cb();
                    lastTime_1 = currentTime + diff;
                }, diff);
                return timer;
            };
            caf = function (timer) {
                clearTimeout(timer);
            };
        }
    }
    raf = raf.bind(target);
    caf = caf.bind(target);

    var __read$1u = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$z = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    function throttleByRaf (cb) {
        var timer = null;
        var throttle = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            timer && caf(timer);
            timer = raf(function () {
                cb.apply(void 0, __spreadArray$z([], __read$1u(args), false));
                timer = null;
            });
        };
        throttle.cancel = function () {
            caf(timer);
            timer = null;
        };
        return throttle;
    }

    /**
     * A collection of shims that provide minimal functionality of the ES6 collections.
     *
     * These implementations are not meant to be used outside of the ResizeObserver
     * modules as they cover only a limited range of use cases.
     */
    /* eslint-disable require-jsdoc, valid-jsdoc */
    var MapShim = (function () {
        if (typeof Map !== 'undefined') {
            return Map;
        }
        /**
         * Returns index in provided array that matches the specified key.
         *
         * @param {Array<Array>} arr
         * @param {*} key
         * @returns {number}
         */
        function getIndex(arr, key) {
            var result = -1;
            arr.some(function (entry, index) {
                if (entry[0] === key) {
                    result = index;
                    return true;
                }
                return false;
            });
            return result;
        }
        return /** @class */ (function () {
            function class_1() {
                this.__entries__ = [];
            }
            Object.defineProperty(class_1.prototype, "size", {
                /**
                 * @returns {boolean}
                 */
                get: function () {
                    return this.__entries__.length;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * @param {*} key
             * @returns {*}
             */
            class_1.prototype.get = function (key) {
                var index = getIndex(this.__entries__, key);
                var entry = this.__entries__[index];
                return entry && entry[1];
            };
            /**
             * @param {*} key
             * @param {*} value
             * @returns {void}
             */
            class_1.prototype.set = function (key, value) {
                var index = getIndex(this.__entries__, key);
                if (~index) {
                    this.__entries__[index][1] = value;
                }
                else {
                    this.__entries__.push([key, value]);
                }
            };
            /**
             * @param {*} key
             * @returns {void}
             */
            class_1.prototype.delete = function (key) {
                var entries = this.__entries__;
                var index = getIndex(entries, key);
                if (~index) {
                    entries.splice(index, 1);
                }
            };
            /**
             * @param {*} key
             * @returns {void}
             */
            class_1.prototype.has = function (key) {
                return !!~getIndex(this.__entries__, key);
            };
            /**
             * @returns {void}
             */
            class_1.prototype.clear = function () {
                this.__entries__.splice(0);
            };
            /**
             * @param {Function} callback
             * @param {*} [ctx=null]
             * @returns {void}
             */
            class_1.prototype.forEach = function (callback, ctx) {
                if (ctx === void 0) { ctx = null; }
                for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                    var entry = _a[_i];
                    callback.call(ctx, entry[1], entry[0]);
                }
            };
            return class_1;
        }());
    })();

    /**
     * Detects whether window and document objects are available in current environment.
     */
    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

    // Returns global object of a current environment.
    var global$1 = (function () {
        if (typeof global !== 'undefined' && global.Math === Math) {
            return global;
        }
        if (typeof self !== 'undefined' && self.Math === Math) {
            return self;
        }
        if (typeof window !== 'undefined' && window.Math === Math) {
            return window;
        }
        // eslint-disable-next-line no-new-func
        return Function('return this')();
    })();

    /**
     * A shim for the requestAnimationFrame which falls back to the setTimeout if
     * first one is not supported.
     *
     * @returns {number} Requests' identifier.
     */
    var requestAnimationFrame$1 = (function () {
        if (typeof requestAnimationFrame === 'function') {
            // It's required to use a bounded function because IE sometimes throws
            // an "Invalid calling object" error if rAF is invoked without the global
            // object on the left hand side.
            return requestAnimationFrame.bind(global$1);
        }
        return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
    })();

    // Defines minimum timeout before adding a trailing call.
    var trailingTimeout = 2;
    /**
     * Creates a wrapper function which ensures that provided callback will be
     * invoked only once during the specified delay period.
     *
     * @param {Function} callback - Function to be invoked after the delay period.
     * @param {number} delay - Delay after which to invoke callback.
     * @returns {Function}
     */
    function throttle (callback, delay) {
        var leadingCall = false, trailingCall = false, lastCallTime = 0;
        /**
         * Invokes the original callback function and schedules new invocation if
         * the "proxy" was called during current request.
         *
         * @returns {void}
         */
        function resolvePending() {
            if (leadingCall) {
                leadingCall = false;
                callback();
            }
            if (trailingCall) {
                proxy();
            }
        }
        /**
         * Callback invoked after the specified delay. It will further postpone
         * invocation of the original function delegating it to the
         * requestAnimationFrame.
         *
         * @returns {void}
         */
        function timeoutCallback() {
            requestAnimationFrame$1(resolvePending);
        }
        /**
         * Schedules invocation of the original function.
         *
         * @returns {void}
         */
        function proxy() {
            var timeStamp = Date.now();
            if (leadingCall) {
                // Reject immediately following calls.
                if (timeStamp - lastCallTime < trailingTimeout) {
                    return;
                }
                // Schedule new call to be in invoked when the pending one is resolved.
                // This is important for "transitions" which never actually start
                // immediately so there is a chance that we might miss one if change
                // happens amids the pending invocation.
                trailingCall = true;
            }
            else {
                leadingCall = true;
                trailingCall = false;
                setTimeout(timeoutCallback, delay);
            }
            lastCallTime = timeStamp;
        }
        return proxy;
    }

    // Minimum delay before invoking the update of observers.
    var REFRESH_DELAY = 20;
    // A list of substrings of CSS properties used to find transition events that
    // might affect dimensions of observed elements.
    var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
    // Check if MutationObserver is available.
    var mutationObserverSupported = typeof MutationObserver !== 'undefined';
    /**
     * Singleton controller class which handles updates of ResizeObserver instances.
     */
    var ResizeObserverController = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserverController.
         *
         * @private
         */
        function ResizeObserverController() {
            /**
             * Indicates whether DOM listeners have been added.
             *
             * @private {boolean}
             */
            this.connected_ = false;
            /**
             * Tells that controller has subscribed for Mutation Events.
             *
             * @private {boolean}
             */
            this.mutationEventsAdded_ = false;
            /**
             * Keeps reference to the instance of MutationObserver.
             *
             * @private {MutationObserver}
             */
            this.mutationsObserver_ = null;
            /**
             * A list of connected observers.
             *
             * @private {Array<ResizeObserverSPI>}
             */
            this.observers_ = [];
            this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
            this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
        }
        /**
         * Adds observer to observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be added.
         * @returns {void}
         */
        ResizeObserverController.prototype.addObserver = function (observer) {
            if (!~this.observers_.indexOf(observer)) {
                this.observers_.push(observer);
            }
            // Add listeners if they haven't been added yet.
            if (!this.connected_) {
                this.connect_();
            }
        };
        /**
         * Removes observer from observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be removed.
         * @returns {void}
         */
        ResizeObserverController.prototype.removeObserver = function (observer) {
            var observers = this.observers_;
            var index = observers.indexOf(observer);
            // Remove observer if it's present in registry.
            if (~index) {
                observers.splice(index, 1);
            }
            // Remove listeners if controller has no connected observers.
            if (!observers.length && this.connected_) {
                this.disconnect_();
            }
        };
        /**
         * Invokes the update of observers. It will continue running updates insofar
         * it detects changes.
         *
         * @returns {void}
         */
        ResizeObserverController.prototype.refresh = function () {
            var changesDetected = this.updateObservers_();
            // Continue running updates if changes have been detected as there might
            // be future ones caused by CSS transitions.
            if (changesDetected) {
                this.refresh();
            }
        };
        /**
         * Updates every observer from observers list and notifies them of queued
         * entries.
         *
         * @private
         * @returns {boolean} Returns "true" if any observer has detected changes in
         *      dimensions of it's elements.
         */
        ResizeObserverController.prototype.updateObservers_ = function () {
            // Collect observers that have active observations.
            var activeObservers = this.observers_.filter(function (observer) {
                return observer.gatherActive(), observer.hasActive();
            });
            // Deliver notifications in a separate cycle in order to avoid any
            // collisions between observers, e.g. when multiple instances of
            // ResizeObserver are tracking the same element and the callback of one
            // of them changes content dimensions of the observed target. Sometimes
            // this may result in notifications being blocked for the rest of observers.
            activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
            return activeObservers.length > 0;
        };
        /**
         * Initializes DOM listeners.
         *
         * @private
         * @returns {void}
         */
        ResizeObserverController.prototype.connect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already added.
            if (!isBrowser || this.connected_) {
                return;
            }
            // Subscription to the "Transitionend" event is used as a workaround for
            // delayed transitions. This way it's possible to capture at least the
            // final state of an element.
            document.addEventListener('transitionend', this.onTransitionEnd_);
            window.addEventListener('resize', this.refresh);
            if (mutationObserverSupported) {
                this.mutationsObserver_ = new MutationObserver(this.refresh);
                this.mutationsObserver_.observe(document, {
                    attributes: true,
                    childList: true,
                    characterData: true,
                    subtree: true
                });
            }
            else {
                document.addEventListener('DOMSubtreeModified', this.refresh);
                this.mutationEventsAdded_ = true;
            }
            this.connected_ = true;
        };
        /**
         * Removes DOM listeners.
         *
         * @private
         * @returns {void}
         */
        ResizeObserverController.prototype.disconnect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already removed.
            if (!isBrowser || !this.connected_) {
                return;
            }
            document.removeEventListener('transitionend', this.onTransitionEnd_);
            window.removeEventListener('resize', this.refresh);
            if (this.mutationsObserver_) {
                this.mutationsObserver_.disconnect();
            }
            if (this.mutationEventsAdded_) {
                document.removeEventListener('DOMSubtreeModified', this.refresh);
            }
            this.mutationsObserver_ = null;
            this.mutationEventsAdded_ = false;
            this.connected_ = false;
        };
        /**
         * "Transitionend" event handler.
         *
         * @private
         * @param {TransitionEvent} event
         * @returns {void}
         */
        ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
            var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
            // Detect whether transition may affect dimensions of an element.
            var isReflowProperty = transitionKeys.some(function (key) {
                return !!~propertyName.indexOf(key);
            });
            if (isReflowProperty) {
                this.refresh();
            }
        };
        /**
         * Returns instance of the ResizeObserverController.
         *
         * @returns {ResizeObserverController}
         */
        ResizeObserverController.getInstance = function () {
            if (!this.instance_) {
                this.instance_ = new ResizeObserverController();
            }
            return this.instance_;
        };
        /**
         * Holds reference to the controller's instance.
         *
         * @private {ResizeObserverController}
         */
        ResizeObserverController.instance_ = null;
        return ResizeObserverController;
    }());

    /**
     * Defines non-writable/enumerable properties of the provided target object.
     *
     * @param {Object} target - Object for which to define properties.
     * @param {Object} props - Properties to be defined.
     * @returns {Object} Target object.
     */
    var defineConfigurable = (function (target, props) {
        for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
            var key = _a[_i];
            Object.defineProperty(target, key, {
                value: props[key],
                enumerable: false,
                writable: false,
                configurable: true
            });
        }
        return target;
    });

    /**
     * Returns the global object associated with provided element.
     *
     * @param {Object} target
     * @returns {Object}
     */
    var getWindowOf = (function (target) {
        // Assume that the element is an instance of Node, which means that it
        // has the "ownerDocument" property from which we can retrieve a
        // corresponding global object.
        var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
        // Return the local global object if it's not possible extract one from
        // provided element.
        return ownerGlobal || global$1;
    });

    // Placeholder of an empty content rectangle.
    var emptyRect = createRectInit(0, 0, 0, 0);
    /**
     * Converts provided string to a number.
     *
     * @param {number|string} value
     * @returns {number}
     */
    function toFloat(value) {
        return parseFloat(value) || 0;
    }
    /**
     * Extracts borders size from provided styles.
     *
     * @param {CSSStyleDeclaration} styles
     * @param {...string} positions - Borders positions (top, right, ...)
     * @returns {number}
     */
    function getBordersSize(styles) {
        var positions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            positions[_i - 1] = arguments[_i];
        }
        return positions.reduce(function (size, position) {
            var value = styles['border-' + position + '-width'];
            return size + toFloat(value);
        }, 0);
    }
    /**
     * Extracts paddings sizes from provided styles.
     *
     * @param {CSSStyleDeclaration} styles
     * @returns {Object} Paddings box.
     */
    function getPaddings(styles) {
        var positions = ['top', 'right', 'bottom', 'left'];
        var paddings = {};
        for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
            var position = positions_1[_i];
            var value = styles['padding-' + position];
            paddings[position] = toFloat(value);
        }
        return paddings;
    }
    /**
     * Calculates content rectangle of provided SVG element.
     *
     * @param {SVGGraphicsElement} target - Element content rectangle of which needs
     *      to be calculated.
     * @returns {DOMRectInit}
     */
    function getSVGContentRect(target) {
        var bbox = target.getBBox();
        return createRectInit(0, 0, bbox.width, bbox.height);
    }
    /**
     * Calculates content rectangle of provided HTMLElement.
     *
     * @param {HTMLElement} target - Element for which to calculate the content rectangle.
     * @returns {DOMRectInit}
     */
    function getHTMLElementContentRect(target) {
        // Client width & height properties can't be
        // used exclusively as they provide rounded values.
        var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
        // By this condition we can catch all non-replaced inline, hidden and
        // detached elements. Though elements with width & height properties less
        // than 0.5 will be discarded as well.
        //
        // Without it we would need to implement separate methods for each of
        // those cases and it's not possible to perform a precise and performance
        // effective test for hidden elements. E.g. even jQuery's ':visible' filter
        // gives wrong results for elements with width & height less than 0.5.
        if (!clientWidth && !clientHeight) {
            return emptyRect;
        }
        var styles = getWindowOf(target).getComputedStyle(target);
        var paddings = getPaddings(styles);
        var horizPad = paddings.left + paddings.right;
        var vertPad = paddings.top + paddings.bottom;
        // Computed styles of width & height are being used because they are the
        // only dimensions available to JS that contain non-rounded values. It could
        // be possible to utilize the getBoundingClientRect if only it's data wasn't
        // affected by CSS transformations let alone paddings, borders and scroll bars.
        var width = toFloat(styles.width), height = toFloat(styles.height);
        // Width & height include paddings and borders when the 'border-box' box
        // model is applied (except for IE).
        if (styles.boxSizing === 'border-box') {
            // Following conditions are required to handle Internet Explorer which
            // doesn't include paddings and borders to computed CSS dimensions.
            //
            // We can say that if CSS dimensions + paddings are equal to the "client"
            // properties then it's either IE, and thus we don't need to subtract
            // anything, or an element merely doesn't have paddings/borders styles.
            if (Math.round(width + horizPad) !== clientWidth) {
                width -= getBordersSize(styles, 'left', 'right') + horizPad;
            }
            if (Math.round(height + vertPad) !== clientHeight) {
                height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
            }
        }
        // Following steps can't be applied to the document's root element as its
        // client[Width/Height] properties represent viewport area of the window.
        // Besides, it's as well not necessary as the <html> itself neither has
        // rendered scroll bars nor it can be clipped.
        if (!isDocumentElement(target)) {
            // In some browsers (only in Firefox, actually) CSS width & height
            // include scroll bars size which can be removed at this step as scroll
            // bars are the only difference between rounded dimensions + paddings
            // and "client" properties, though that is not always true in Chrome.
            var vertScrollbar = Math.round(width + horizPad) - clientWidth;
            var horizScrollbar = Math.round(height + vertPad) - clientHeight;
            // Chrome has a rather weird rounding of "client" properties.
            // E.g. for an element with content width of 314.2px it sometimes gives
            // the client width of 315px and for the width of 314.7px it may give
            // 314px. And it doesn't happen all the time. So just ignore this delta
            // as a non-relevant.
            if (Math.abs(vertScrollbar) !== 1) {
                width -= vertScrollbar;
            }
            if (Math.abs(horizScrollbar) !== 1) {
                height -= horizScrollbar;
            }
        }
        return createRectInit(paddings.left, paddings.top, width, height);
    }
    /**
     * Checks whether provided element is an instance of the SVGGraphicsElement.
     *
     * @param {Element} target - Element to be checked.
     * @returns {boolean}
     */
    var isSVGGraphicsElement = (function () {
        // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
        // interface.
        if (typeof SVGGraphicsElement !== 'undefined') {
            return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
        }
        // If it's so, then check that element is at least an instance of the
        // SVGElement and that it has the "getBBox" method.
        // eslint-disable-next-line no-extra-parens
        return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
            typeof target.getBBox === 'function'); };
    })();
    /**
     * Checks whether provided element is a document element (<html>).
     *
     * @param {Element} target - Element to be checked.
     * @returns {boolean}
     */
    function isDocumentElement(target) {
        return target === getWindowOf(target).document.documentElement;
    }
    /**
     * Calculates an appropriate content rectangle for provided html or svg element.
     *
     * @param {Element} target - Element content rectangle of which needs to be calculated.
     * @returns {DOMRectInit}
     */
    function getContentRect(target) {
        if (!isBrowser) {
            return emptyRect;
        }
        if (isSVGGraphicsElement(target)) {
            return getSVGContentRect(target);
        }
        return getHTMLElementContentRect(target);
    }
    /**
     * Creates rectangle with an interface of the DOMRectReadOnly.
     * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
     *
     * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
     * @returns {DOMRectReadOnly}
     */
    function createReadOnlyRect(_a) {
        var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
        // If DOMRectReadOnly is available use it as a prototype for the rectangle.
        var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
        var rect = Object.create(Constr.prototype);
        // Rectangle's properties are not writable and non-enumerable.
        defineConfigurable(rect, {
            x: x, y: y, width: width, height: height,
            top: y,
            right: x + width,
            bottom: height + y,
            left: x
        });
        return rect;
    }
    /**
     * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
     * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
     *
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} width - Rectangle's width.
     * @param {number} height - Rectangle's height.
     * @returns {DOMRectInit}
     */
    function createRectInit(x, y, width, height) {
        return { x: x, y: y, width: width, height: height };
    }

    /**
     * Class that is responsible for computations of the content rectangle of
     * provided DOM element and for keeping track of it's changes.
     */
    var ResizeObservation = /** @class */ (function () {
        /**
         * Creates an instance of ResizeObservation.
         *
         * @param {Element} target - Element to be observed.
         */
        function ResizeObservation(target) {
            /**
             * Broadcasted width of content rectangle.
             *
             * @type {number}
             */
            this.broadcastWidth = 0;
            /**
             * Broadcasted height of content rectangle.
             *
             * @type {number}
             */
            this.broadcastHeight = 0;
            /**
             * Reference to the last observed content rectangle.
             *
             * @private {DOMRectInit}
             */
            this.contentRect_ = createRectInit(0, 0, 0, 0);
            this.target = target;
        }
        /**
         * Updates content rectangle and tells whether it's width or height properties
         * have changed since the last broadcast.
         *
         * @returns {boolean}
         */
        ResizeObservation.prototype.isActive = function () {
            var rect = getContentRect(this.target);
            this.contentRect_ = rect;
            return (rect.width !== this.broadcastWidth ||
                rect.height !== this.broadcastHeight);
        };
        /**
         * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
         * from the corresponding properties of the last observed content rectangle.
         *
         * @returns {DOMRectInit} Last observed content rectangle.
         */
        ResizeObservation.prototype.broadcastRect = function () {
            var rect = this.contentRect_;
            this.broadcastWidth = rect.width;
            this.broadcastHeight = rect.height;
            return rect;
        };
        return ResizeObservation;
    }());

    var ResizeObserverEntry = /** @class */ (function () {
        /**
         * Creates an instance of ResizeObserverEntry.
         *
         * @param {Element} target - Element that is being observed.
         * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
         */
        function ResizeObserverEntry(target, rectInit) {
            var contentRect = createReadOnlyRect(rectInit);
            // According to the specification following properties are not writable
            // and are also not enumerable in the native implementation.
            //
            // Property accessors are not being used as they'd require to define a
            // private WeakMap storage which may cause memory leaks in browsers that
            // don't support this type of collections.
            defineConfigurable(this, { target: target, contentRect: contentRect });
        }
        return ResizeObserverEntry;
    }());

    var ResizeObserverSPI = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback function that is invoked
         *      when one of the observed elements changes it's content dimensions.
         * @param {ResizeObserverController} controller - Controller instance which
         *      is responsible for the updates of observer.
         * @param {ResizeObserver} callbackCtx - Reference to the public
         *      ResizeObserver instance which will be passed to callback function.
         */
        function ResizeObserverSPI(callback, controller, callbackCtx) {
            /**
             * Collection of resize observations that have detected changes in dimensions
             * of elements.
             *
             * @private {Array<ResizeObservation>}
             */
            this.activeObservations_ = [];
            /**
             * Registry of the ResizeObservation instances.
             *
             * @private {Map<Element, ResizeObservation>}
             */
            this.observations_ = new MapShim();
            if (typeof callback !== 'function') {
                throw new TypeError('The callback provided as parameter 1 is not a function.');
            }
            this.callback_ = callback;
            this.controller_ = controller;
            this.callbackCtx_ = callbackCtx;
        }
        /**
         * Starts observing provided element.
         *
         * @param {Element} target - Element to be observed.
         * @returns {void}
         */
        ResizeObserverSPI.prototype.observe = function (target) {
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
                return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
                throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            // Do nothing if element is already being observed.
            if (observations.has(target)) {
                return;
            }
            observations.set(target, new ResizeObservation(target));
            this.controller_.addObserver(this);
            // Force the update of observations.
            this.controller_.refresh();
        };
        /**
         * Stops observing provided element.
         *
         * @param {Element} target - Element to stop observing.
         * @returns {void}
         */
        ResizeObserverSPI.prototype.unobserve = function (target) {
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
                return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
                throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            // Do nothing if element is not being observed.
            if (!observations.has(target)) {
                return;
            }
            observations.delete(target);
            if (!observations.size) {
                this.controller_.removeObserver(this);
            }
        };
        /**
         * Stops observing all elements.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.disconnect = function () {
            this.clearActive();
            this.observations_.clear();
            this.controller_.removeObserver(this);
        };
        /**
         * Collects observation instances the associated element of which has changed
         * it's content rectangle.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.gatherActive = function () {
            var _this = this;
            this.clearActive();
            this.observations_.forEach(function (observation) {
                if (observation.isActive()) {
                    _this.activeObservations_.push(observation);
                }
            });
        };
        /**
         * Invokes initial callback function with a list of ResizeObserverEntry
         * instances collected from active resize observations.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.broadcastActive = function () {
            // Do nothing if observer doesn't have active observations.
            if (!this.hasActive()) {
                return;
            }
            var ctx = this.callbackCtx_;
            // Create ResizeObserverEntry instance for every active observation.
            var entries = this.activeObservations_.map(function (observation) {
                return new ResizeObserverEntry(observation.target, observation.broadcastRect());
            });
            this.callback_.call(ctx, entries, ctx);
            this.clearActive();
        };
        /**
         * Clears the collection of active observations.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.clearActive = function () {
            this.activeObservations_.splice(0);
        };
        /**
         * Tells whether observer has active observations.
         *
         * @returns {boolean}
         */
        ResizeObserverSPI.prototype.hasActive = function () {
            return this.activeObservations_.length > 0;
        };
        return ResizeObserverSPI;
    }());

    // Registry of internal observers. If WeakMap is not available use current shim
    // for the Map collection as it has all required methods and because WeakMap
    // can't be fully polyfilled anyway.
    var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
    /**
     * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
     * exposing only those methods and properties that are defined in the spec.
     */
    var ResizeObserver$2 = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback that is invoked when
         *      dimensions of the observed elements change.
         */
        function ResizeObserver(callback) {
            if (!(this instanceof ResizeObserver)) {
                throw new TypeError('Cannot call a class as a function.');
            }
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            var controller = ResizeObserverController.getInstance();
            var observer = new ResizeObserverSPI(callback, controller, this);
            observers.set(this, observer);
        }
        return ResizeObserver;
    }());
    // Expose public methods of ResizeObserver.
    [
        'observe',
        'unobserve',
        'disconnect'
    ].forEach(function (method) {
        ResizeObserver$2.prototype[method] = function () {
            var _a;
            return (_a = observers.get(this))[method].apply(_a, arguments);
        };
    });

    var index = (function () {
        // Export existing implementation if available.
        if (typeof global$1.ResizeObserver !== 'undefined') {
            return global$1.ResizeObserver;
        }
        return ResizeObserver$2;
    })();

    var __extends$7 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();

    var ResizeObserverComponent = /** @class */ (function (_super) {
        __extends$7(ResizeObserverComponent, _super);
        function ResizeObserverComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.componentWillUnmount = function () {
                if (_this.resizeObserver) {
                    _this.destroyResizeObserver();
                }
            };
            _this.createResizeObserver = function () {
                _this.resizeObserver = new index(function (entry) {
                    var onResize = _this.props.onResize;
                    onResize && onResize(entry);
                });
                _this.resizeObserver.observe(ReactDOM.findDOMNode(_this));
            };
            _this.destroyResizeObserver = function () {
                _this.resizeObserver && _this.resizeObserver.disconnect();
                _this.resizeObserver = null;
            };
            return _this;
        }
        ResizeObserverComponent.prototype.componentDidMount = function () {
            if (!React.isValidElement(this.props.children)) {
                console.warn('The children of ResizeObserver is invalid.');
            }
            else {
                this.createResizeObserver();
            }
        };
        ResizeObserverComponent.prototype.componentDidUpdate = function () {
            if (!this.resizeObserver && ReactDOM.findDOMNode(this)) {
                this.createResizeObserver();
            }
        };
        ResizeObserverComponent.prototype.render = function () {
            return this.props.children;
        };
        return ResizeObserverComponent;
    }(React.Component));
    var ResizeObserver$1 = ResizeObserverComponent;

    // Because useLayoutEffect in the ssr environment will report a warning
    // So when you need to use useLayoutEffect, use useIsomorphicLayoutEffect instead, it will use useEffect in the ssr environment to avoid this problem
    var useIsomorphicLayoutEffect = isServerRendering ? React.useEffect : React.useLayoutEffect;
    var useIsomorphicLayoutEffect$1 = useIsomorphicLayoutEffect;

    // https://github.com/LiikeJS/Liike/blob/master/src/ease.js
    var easeInBy = function (power) { return function (t) { return Math.pow(t, power); }; };
    var easeOutBy = function (power) { return function (t) { return 1 - Math.abs(Math.pow(t - 1, power)); }; };
    var easeInOutBy = function (power) { return function (t) { return t < 0.5 ? easeInBy(power)(t * 2) / 2 : easeOutBy(power)(t * 2 - 1) / 2 + 0.5; }; };

    var linear = function (t) { return t; };
    var quadIn = easeInBy(2);
    var quadOut = easeOutBy(2);
    var quadInOut = easeInOutBy(2);
    var cubicIn = easeInBy(3);
    var cubicOut = easeOutBy(3);
    var cubicInOut = easeInOutBy(3);
    var quartIn = easeInBy(4);
    var quartOut = easeOutBy(4);
    var quartInOut = easeInOutBy(4);
    var quintIn = easeInBy(5);
    var quintOut = easeOutBy(5);
    var quintInOut = easeInOutBy(5);
    var sineIn = function (t) { return 1 + Math.sin(Math.PI / 2 * t - Math.PI / 2); };
    var sineOut = function (t) { return Math.sin(Math.PI / 2 * t); };
    var sineInOut = function (t) { return (1 + Math.sin(Math.PI * t - Math.PI / 2)) / 2; };
    var bounceOut = function (t) {
      var s = 7.5625;
      var p = 2.75;

      if (t < 1 / p) {
        return s * t * t;
      }
      if (t < 2 / p) {
        t -= 1.5 / p;
        return s * t * t + 0.75;
      }
      if (t < 2.5 / p) {
        t -= 2.25 / p;
        return s * t * t + 0.9375;
      }
      t -= 2.625 / p;
      return s * t * t + 0.984375;
    };
    var bounceIn = function (t) { return 1 - bounceOut(1 - t); };
    var bounceInOut = function (t) { return t < 0.5 ? bounceIn(t * 2) * 0.5 : bounceOut(t * 2 - 1) * 0.5 + 0.5; };

    var easing = /*#__PURE__*/Object.freeze({
      linear: linear,
      quadIn: quadIn,
      quadOut: quadOut,
      quadInOut: quadInOut,
      cubicIn: cubicIn,
      cubicOut: cubicOut,
      cubicInOut: cubicInOut,
      quartIn: quartIn,
      quartOut: quartOut,
      quartInOut: quartInOut,
      quintIn: quintIn,
      quintOut: quintOut,
      quintInOut: quintInOut,
      sineIn: sineIn,
      sineOut: sineOut,
      sineInOut: sineInOut,
      bounceOut: bounceOut,
      bounceIn: bounceIn,
      bounceInOut: bounceInOut
    });

    var Tween = function Tween(settings) {
      var from = settings.from;
      var to = settings.to;
      var duration = settings.duration;
      var delay = settings.delay;
      var easing = settings.easing;
      var onStart = settings.onStart;
      var onUpdate = settings.onUpdate;
      var onFinish = settings.onFinish;

      for (var key in from) {
        if (to[key] === undefined) {
          to[key] = from[key];
        }
      }
      for (var key$1 in to) {
        if (from[key$1] === undefined) {
          from[key$1] = to[key$1];
        }
      }

      this.from = from;
      this.to = to;
      this.duration = duration || 500;
      this.delay = delay || 0;
      this.easing = easing || 'linear';
      this.onStart = onStart;
      this.onUpdate = onUpdate || function () { };
      this.onFinish = onFinish;
      this.startTime = Date.now() + this.delay;
      this.started = false;
      this.finished = false;
      this.timer = null;
      this.keys = {};
    };

    Tween.prototype.update = function update () {
      this.time = Date.now();
      // delay some time
      if (this.time < this.startTime) {
        return;
      }
      if (this.finished) {
        return;
      }
      // finish animation
      if (this.elapsed === this.duration) {
        if (!this.finished) {
          this.finished = true;
          this.onFinish && this.onFinish(this.keys);
        }
        return;
      }
      this.elapsed = this.time - this.startTime;
      this.elapsed = this.elapsed > this.duration ? this.duration : this.elapsed;
      for (var key in this.to) {
        this.keys[key] = this.from[key] + (this.to[key] - this.from[key]) * easing[this.easing](this.elapsed / this.duration);
      }
      if (!this.started) {
        this.onStart && this.onStart(this.keys);
        this.started = true;
      }
      this.onUpdate(this.keys);
    };

    Tween.prototype.start = function start () {
        var this$1$1 = this;

      this.startTime = Date.now() + this.delay;
      var tick = function () {
        this$1$1.update();
        this$1$1.timer = requestAnimationFrame(tick);
        if (this$1$1.finished) {
          cancelAnimationFrame(this$1$1.timer);
          this$1$1.timer = null;
        }
      };
      tick();
    };

    Tween.prototype.stop = function stop () {
      cancelAnimationFrame(this.timer);
      this.timer = null;
    };

    var __read$1t = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    function useStateWithPromise(defaultVal) {
        var _a = __read$1t(React.useState({
            value: defaultVal,
            resolve: function (e) {
            },
        }), 2), state = _a[0], setState = _a[1];
        React.useEffect(function () {
            state.resolve(state.value);
        }, [state]);
        return [
            state.value,
            function (updater) {
                return new Promise(function (resolve) {
                    setState(function (prevState) {
                        var nextVal = updater;
                        if (typeof updater === 'function') {
                            nextVal = updater(prevState.value);
                        }
                        return {
                            value: nextVal,
                            resolve: resolve,
                        };
                    });
                });
            },
        ];
    }

    var __assign$22 = (undefined && undefined.__assign) || function () {
        __assign$22 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$22.apply(this, arguments);
    };
    var __rest$14 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function Group$4(props, ref) {
        var className = props.className, style = props.style, children = props.children, rest = __rest$14(props, ["className", "style", "children"]);
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var prefixCls = getPrefixCls('btn-group');
        var classNames = cs(prefixCls, className);
        return (React.createElement("div", __assign$22({ ref: ref, className: classNames, style: style }, rest), children));
    }
    var GroupComponent = React.forwardRef(Group$4);
    GroupComponent.displayName = 'ButtonGroup';
    var Group$5 = GroupComponent;

    var __assign$21 = (undefined && undefined.__assign) || function () {
        __assign$21 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$21.apply(this, arguments);
    };
    var __rest$13 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$1s = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var regexTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
    function processChildren$1(children) {
        var childrenList = [];
        var isPrevChildPure = false;
        React.Children.forEach(children, function (child) {
            var isCurrentChildPure = typeof child === 'string' || typeof child === 'number';
            if (isCurrentChildPure && isPrevChildPure) {
                var lastIndex = childrenList.length - 1;
                var lastChild = childrenList[lastIndex];
                childrenList[lastIndex] = "" + lastChild + child;
            }
            else {
                childrenList.push(child);
            }
            isPrevChildPure = isCurrentChildPure;
        });
        return React.Children.map(childrenList, function (child) {
            return typeof child === 'string' ? React.createElement("span", null, child) : child;
        });
    }
    var defaultProps$D = {
        htmlType: 'button',
        type: 'default',
        shape: 'square',
    };
    function Button$2(baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, ctxSize = _b.size, autoInsertSpaceInButton = _b.autoInsertSpaceInButton, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$D, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Button);
        var style = props.style, className = props.className, children = props.children, htmlType = props.htmlType, type = props.type, status = props.status, size = props.size, shape = props.shape, href = props.href, anchorProps = props.anchorProps, disabled = props.disabled, loading = props.loading, loadingFixedWidth = props.loadingFixedWidth, icon = props.icon, iconOnly = props.iconOnly, onClick = props.onClick, long = props.long, rest = __rest$13(props, ["style", "className", "children", "htmlType", "type", "status", "size", "shape", "href", "anchorProps", "disabled", "loading", "loadingFixedWidth", "icon", "iconOnly", "onClick", "long"]);
        var iconNode = loading ? React.createElement(IconLoading$1, null) : icon;
        var _c = __read$1s(React.useState(false), 2), isTwoCNChar = _c[0], setIsTwoCNChar = _c[1];
        var innerButtonRef = React.useRef();
        var buttonRef = ref || innerButtonRef;
        React.useEffect(function () {
            if (autoInsertSpaceInButton && buttonRef && buttonRef.current) {
                var textContent = buttonRef.current.textContent;
                if (regexTwoCNChar.test(textContent)) {
                    if (!isTwoCNChar) {
                        setIsTwoCNChar(true);
                    }
                }
                else if (isTwoCNChar) {
                    setIsTwoCNChar(false);
                }
            }
        }, [buttonRef.current, autoInsertSpaceInButton]);
        var prefixCls = getPrefixCls('btn');
        var _type = type === 'default' ? 'secondary' : type;
        var classNames = cs(prefixCls, prefixCls + "-" + _type, prefixCls + "-size-" + (size || ctxSize), prefixCls + "-shape-" + shape, (_a = {},
            _a[prefixCls + "-long"] = long,
            _a[prefixCls + "-status-" + status] = status,
            _a[prefixCls + "-loading-fixed-width"] = loadingFixedWidth,
            _a[prefixCls + "-loading"] = loading,
            _a[prefixCls + "-link"] = href,
            _a[prefixCls + "-icon-only"] = iconOnly || (!children && children !== 0 && iconNode),
            _a[prefixCls + "-disabled"] = disabled,
            _a[prefixCls + "-two-chinese-chars"] = isTwoCNChar,
            _a[prefixCls + "-rtl"] = rtl,
            _a), className);
        var handleClick = function (event) {
            if (loading) {
                typeof (event === null || event === void 0 ? void 0 : event.preventDefault) === 'function' && event.preventDefault();
                return;
            }
            onClick && onClick(event);
        };
        var InnerContent = (React.createElement(React.Fragment, null,
            iconNode,
            processChildren$1(children)));
        if (href) {
            var _anchorProps = __assign$21({}, anchorProps);
            if (disabled) {
                delete _anchorProps.href;
            }
            else {
                _anchorProps.href = href;
            }
            return (React.createElement("a", __assign$21({ ref: buttonRef }, rest, _anchorProps, { style: style, className: classNames, onClick: handleClick }), InnerContent));
        }
        return (React.createElement("button", __assign$21({ ref: buttonRef }, rest, { style: style, className: classNames, type: htmlType, disabled: disabled, onClick: handleClick }), InnerContent));
    }
    var ForwardRefButton = React.forwardRef(Button$2);
    var ButtonComponent$1 = ForwardRefButton;
    ButtonComponent$1.__BYTE_BUTTON = true;
    ButtonComponent$1.Group = Group$5;
    ButtonComponent$1.displayName = 'Button';
    var Button$3 = ButtonComponent$1;

    function ownKeys$K(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$L(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$K(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$K(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconSearchComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$L(_objectSpread$L({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-search")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M33.072 33.071c6.248-6.248 6.248-16.379 0-22.627-6.249-6.249-16.38-6.249-22.628 0-6.248 6.248-6.248 16.379 0 22.627 6.248 6.248 16.38 6.248 22.628 0Zm0 0 8.485 8.485"
      }));
    }

    var IconSearch = /*#__PURE__*/React.forwardRef(IconSearchComponent);
    IconSearch.defaultProps = {
      isIcon: true
    };
    IconSearch.displayName = 'IconSearch';
    var IconSearch$1 = IconSearch;

    function usePrevious(value) {
        var ref = React.useRef();
        React.useEffect(function () {
            ref.current = value;
        });
        return ref.current;
    }

    var __read$1r = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    function useMergeValue(defaultStateValue, props) {
        var _a = props || {}, defaultValue = _a.defaultValue, value = _a.value;
        var firstRenderRef = React.useRef(true);
        var prevPropsValue = usePrevious(props.value);
        var _b = __read$1r(React.useState(!isUndefined(value) ? value : !isUndefined(defaultValue) ? defaultValue : defaultStateValue), 2), stateValue = _b[0], setStateValue = _b[1];
        React.useEffect(function () {
            // 第一次渲染时候，props.value 已经在useState里赋值给stateValue了，不需要再次赋值。
            if (firstRenderRef.current) {
                firstRenderRef.current = false;
                return;
            }
            // 外部value等于undefined，也就是一开始有值，后来变成了undefined（
            // 可能是移除了value属性，或者直接传入的undefined），那么就更新下内部的值。
            // 如果value有值，在下一步逻辑中直接返回了value，不需要同步到stateValue
            /**
             *  prevPropsValue !== value: https://github.com/arco-design/arco-design/issues/1686
             *  react18 严格模式下 useEffect 执行两次，可能出现 defaultValue 不生效的问题。
             */
            if (value === undefined && prevPropsValue !== value) {
                setStateValue(value);
            }
        }, [value]);
        var mergedValue = isUndefined(value) ? stateValue : value;
        return [mergedValue, setStateValue, stateValue];
    }

    var __assign$20 = (undefined && undefined.__assign) || function () {
        __assign$20 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$20.apply(this, arguments);
    };
    var __rest$12 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$1q = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var Search = React.forwardRef(function (props, ref) {
        var _a;
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var _b = __read$1q(useMergeValue('', {
            defaultValue: 'defaultValue' in props ? formatValue$2(props.defaultValue, props.maxLength) : undefined,
            value: 'value' in props ? formatValue$2(props.value, props.maxLength) : undefined,
        }), 2), value = _b[0], setValue = _b[1];
        var className = props.className, style = props.style, placeholder = props.placeholder, disabled = props.disabled, searchButton = props.searchButton, loading = props.loading, defaultValue = props.defaultValue, rest = __rest$12(props, ["className", "style", "placeholder", "disabled", "searchButton", "loading", "defaultValue"]);
        var prefixCls = getPrefixCls('input-search');
        var classNames = cs(prefixCls, (_a = {},
            _a[prefixCls + "-button"] = searchButton,
            _a), className);
        var onSearch = function (e) {
            !disabled && props.onSearch && props.onSearch(value);
            props.onPressEnter && props.onPressEnter(e);
        };
        return (React.createElement(Input$4, __assign$20({}, omit$1(rest, ['onSearch']), { disabled: disabled, className: classNames, style: style, ref: ref, placeholder: placeholder, addAfter: searchButton ? (React.createElement(Button$3, { disabled: disabled, size: rest.size, className: prefixCls + "-btn", type: "primary", onClick: onSearch, loading: loading, loadingFixedWidth: true, icon: searchButton === true && !loading && React.createElement(IconSearch$1, null) }, searchButton !== true && searchButton)) : null, suffix: !searchButton && (loading ? React.createElement(IconLoading$1, null) : React.createElement(IconSearch$1, { onClick: onSearch })), onChange: function (value, e) {
                setValue(value);
                props.onChange && props.onChange(value, e);
            }, defaultValue: defaultValue, onPressEnter: onSearch })));
    });
    Search.displayName = 'Search';
    var Search$1 = Search;

    var mirrorTextAreaStyle = "\n  position: absolute;\n  min-height: 0 !important;\n  max-height: none;\n  height:0;\n  visibility: hidden;\n  z-index: -100;\n  top: 0;\n  right: 0;\n";
    var mirrorTextAreaSizing = [
        'border-width',
        'box-sizing',
        'font-family',
        'font-weight',
        'font-size',
        'font-variant',
        'letter-spacing',
        'line-height',
        'padding-top',
        'padding-bottom',
        'padding-left',
        'padding-right',
        'text-indent',
        'text-rendering',
        'text-transform',
        'width',
    ];
    var mirrorTextArea;
    function setMirrorTextArea(originTextArea) {
        if (!mirrorTextArea) {
            mirrorTextArea = document.createElement('textarea');
            document.body.appendChild(mirrorTextArea);
        }
        var originStyle = window.getComputedStyle(originTextArea);
        var originSizingStyle = "\n    " + mirrorTextAreaSizing.map(function (attr) { return attr + ":" + originStyle.getPropertyValue(attr); }).join(';') + "\n  ";
        mirrorTextArea.setAttribute('style', "" + mirrorTextAreaStyle + originSizingStyle);
        var paddingSize = parseFloat(originStyle.getPropertyValue('padding-top')) +
            parseFloat(originStyle.getPropertyValue('padding-bottom'));
        var boxSizing = originStyle.getPropertyValue('box-sizing');
        var borderSize = parseFloat(originStyle.getPropertyValue('border-top-width')) +
            parseFloat(originStyle.getPropertyValue('border-bottom-width'));
        return {
            paddingSize: paddingSize,
            boxSizing: boxSizing,
            borderSize: borderSize,
        };
    }
    function autoSizeTextAreaHeight(autoSize, node) {
        var getRows = function () {
            var minRows;
            var maxRows;
            if (isObject$1(autoSize)) {
                minRows = autoSize.minRows;
                maxRows = autoSize.maxRows;
            }
            return {
                minRows: minRows,
                maxRows: maxRows,
            };
        };
        if (autoSize) {
            var _a = getRows(), minRows = _a.minRows, maxRows = _a.maxRows;
            var originTextNode = node;
            var _b = setMirrorTextArea(originTextNode), paddingSize = _b.paddingSize, boxSizing = _b.boxSizing, borderSize = _b.borderSize;
            mirrorTextArea.value = originTextNode.value || originTextNode.placeholder || '';
            var mirrorTextAreaHeight = mirrorTextArea.scrollHeight + borderSize;
            var minHeight = void 0;
            var maxHeight = void 0;
            var overflowY = void 0;
            if (minRows || maxRows) {
                mirrorTextArea.value = '';
                var singleRowHeight = mirrorTextArea.scrollHeight - paddingSize;
                if (isNumber(minRows)) {
                    minHeight = singleRowHeight * minRows;
                    if (boxSizing === 'border-box') {
                        minHeight += paddingSize;
                        minHeight += borderSize;
                    }
                    mirrorTextAreaHeight = Math.max(mirrorTextAreaHeight, minHeight);
                }
                if (isNumber(maxRows)) {
                    maxHeight = singleRowHeight * maxRows;
                    if (boxSizing === 'border-box') {
                        maxHeight += paddingSize;
                        maxHeight += borderSize;
                    }
                    overflowY = mirrorTextAreaHeight > maxHeight ? 'auto' : '';
                    maxHeight = Math.min(mirrorTextAreaHeight, maxHeight);
                }
            }
            var textAreaStyle = {};
            textAreaStyle.height = mirrorTextAreaHeight;
            if (minHeight) {
                textAreaStyle.minHeight = minHeight;
            }
            if (maxHeight) {
                textAreaStyle.maxHeight = maxHeight;
            }
            if (overflowY) {
                textAreaStyle.overflowY = overflowY;
            }
            return textAreaStyle;
        }
    }

    // keyboard keycode
    var Enter = {
        key: 'Enter',
        code: 13,
    };
    var Esc = {
        key: 'Escape',
        code: 27,
    };
    var Backspace = {
        key: 'Backspace',
        code: 8,
    };
    var Tab = {
        key: 'Tab',
        code: 9,
    };
    var ArrowUp = {
        key: 'ArrowUp',
        code: 38,
    };
    var ArrowDown = {
        key: 'ArrowDown',
        code: 40,
    };
    var ArrowLeft = {
        key: 'ArrowLeft',
        code: 37,
    };
    var ArrowRight = {
        key: 'ArrowRight',
        code: 39,
    };

    var __read$1p = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    // Handle input text like Chinese
    function useComposition(_a) {
        var value = _a.value, maxLength = _a.maxLength, onChange = _a.onChange, onKeyDown = _a.onKeyDown, onPressEnter = _a.onPressEnter, beforeTriggerValueChangeCallback = _a.beforeTriggerValueChangeCallback;
        var refIsComposition = React.useRef(false);
        var _b = __read$1p(React.useState(''), 2), compositionValue = _b[0], setCompositionValue = _b[1];
        var triggerValueChangeCallback = function (newValue, e) {
            if (beforeTriggerValueChangeCallback) {
                beforeTriggerValueChangeCallback(newValue);
            }
            if (onChange &&
                // https://github.com/arco-design/arco-design/issues/520
                // Avoid triggering onChange repeatedly for the same value
                // Compositionend is earlier than onchange in Firefox, different with chrome
                newValue !== value &&
                (maxLength === undefined || newValue.length <= maxLength)) {
                onChange(newValue, e);
            }
        };
        return {
            compositionValue: compositionValue,
            triggerValueChangeCallback: triggerValueChangeCallback,
            compositionHandler: function (e) {
                refIsComposition.current = e.type !== 'compositionend';
                if (!refIsComposition.current) {
                    setCompositionValue(undefined);
                    triggerValueChangeCallback(e.target.value, e);
                }
            },
            valueChangeHandler: function (e) {
                var newValue = e.target.value;
                if (!refIsComposition.current) {
                    compositionValue && setCompositionValue(undefined);
                    triggerValueChangeCallback(newValue, e);
                }
                else {
                    // https://github.com/arco-design/arco-design/issues/397
                    // compositionupdate => onchange
                    refIsComposition.current = false;
                    setCompositionValue(newValue);
                }
            },
            keyDownHandler: function (e) {
                var keyCode = e.keyCode || e.which;
                if (!refIsComposition.current) {
                    onKeyDown && onKeyDown(e);
                    if (keyCode === Enter.code) {
                        onPressEnter && onPressEnter(e);
                    }
                }
            },
        };
    }

    var __assign$1$ = (undefined && undefined.__assign) || function () {
        __assign$1$ = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1$.apply(this, arguments);
    };
    var __rest$11 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$1o = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var TextArea$1 = function (props, ref) {
        var _a, _b, _c;
        var className = props.className, style = props.style, wrapperStyle = props.wrapperStyle, placeholder = props.placeholder, disabled = props.disabled, error = props.error, propMaxLength = props.maxLength, showWordLimit = props.showWordLimit, allowClear = props.allowClear, onChange = props.onChange, onClear = props.onClear, onKeyDown = props.onKeyDown, onPressEnter = props.onPressEnter, rest = __rest$11(props, ["className", "style", "wrapperStyle", "placeholder", "disabled", "error", "maxLength", "showWordLimit", "allowClear", "onChange", "onClear", "onKeyDown", "onPressEnter"]);
        // Only for error judgement
        var wordLimitMaxLength = isObject$1(propMaxLength) ? propMaxLength.length : propMaxLength;
        // The real maxLength passed to input element
        var maxLength = isObject$1(propMaxLength)
            ? propMaxLength.errorOnly
                ? undefined
                : propMaxLength.length
            : propMaxLength;
        var textareaRef = React.useRef();
        var _d = __read$1o(React.useState({}), 2), textAreaStyle = _d[0], setTextAreaStyle = _d[1];
        var _e = __read$1o(useMergeValue('', {
            defaultValue: 'defaultValue' in props ? formatValue$2(props.defaultValue, maxLength) : undefined,
            value: 'value' in props ? formatValue$2(props.value, maxLength) : undefined,
        }), 2), value = _e[0], setValue = _e[1];
        var _f = useComposition({
            value: value,
            maxLength: maxLength,
            onChange: onChange,
            onKeyDown: onKeyDown,
            onPressEnter: onPressEnter,
            beforeTriggerValueChangeCallback: function (v) {
                if (!('value' in props) && (maxLength === undefined || v.length <= maxLength)) {
                    setValue(v);
                }
            },
        }), compositionValue = _f.compositionValue, compositionHandler = _f.compositionHandler, valueChangeHandler = _f.valueChangeHandler, keyDownHandler = _f.keyDownHandler, triggerValueChangeCallback = _f.triggerValueChangeCallback;
        var _g = React.useContext(ConfigContext), getPrefixCls = _g.getPrefixCls, rtl = _g.rtl;
        var prefixCls = getPrefixCls('textarea');
        if (disabled) {
            textAreaStyle.resize = 'none';
        }
        // set element focus and caret position
        var onFocus = function () {
            if (textareaRef.current && textareaRef.current.focus) {
                if (textareaRef.current.setSelectionRange) {
                    var caretPos = textareaRef.current.textContent.length;
                    // reference: https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange
                    textareaRef.current.setSelectionRange(caretPos, caretPos);
                }
                textareaRef.current.focus();
            }
        };
        var resizeTextAreaHeight = function () {
            var textAreaStyle = autoSizeTextAreaHeight(props.autoSize, textareaRef.current);
            if (textAreaStyle) {
                setTextAreaStyle(textAreaStyle);
            }
        };
        var handleClearClick = function (e) {
            e.stopPropagation();
            onFocus();
            triggerValueChangeCallback('', e);
            onClear && onClear();
        };
        useIsomorphicLayoutEffect$1(function () {
            resizeTextAreaHeight();
        }, [value]);
        React.useImperativeHandle(ref, function () { return ({
            dom: textareaRef.current,
            focus: function () {
                onFocus();
            },
            blur: function () {
                textareaRef.current && textareaRef.current.blur && textareaRef.current.blur();
            },
        }); }, []);
        var valueLength = value ? value.length : 0;
        var withWrapper = (wordLimitMaxLength && showWordLimit) || allowClear;
        var lengthError = React.useMemo(function () {
            if (!maxLength && wordLimitMaxLength) {
                return valueLength > wordLimitMaxLength;
            }
            return false;
        }, [valueLength, wordLimitMaxLength, maxLength]);
        var classNames = cs(prefixCls, (_a = {},
            _a[prefixCls + "-error"] = error || lengthError,
            _a[prefixCls + "-disabled"] = disabled,
            _a[prefixCls + "-rtl"] = rtl,
            _a), className);
        var TextAreaElement = (React.createElement("textarea", __assign$1$({}, omit$1(rest, ['autoSize', 'defaultValue']), { maxLength: maxLength, ref: textareaRef, style: __assign$1$(__assign$1$({}, style), textAreaStyle), className: classNames, placeholder: placeholder, disabled: disabled, value: compositionValue || value || '', onChange: valueChangeHandler, onKeyDown: keyDownHandler, onCompositionStart: compositionHandler, onCompositionUpdate: compositionHandler, onCompositionEnd: compositionHandler })));
        if (withWrapper) {
            var showClearIcon = !disabled && allowClear && value;
            var _h = __read$1o(rtl
                ? [wordLimitMaxLength, valueLength]
                : [valueLength, wordLimitMaxLength], 2), leftWord = _h[0], rightWord = _h[1];
            return (React.createElement("div", { className: cs(prefixCls + "-wrapper", (_b = {},
                    _b[prefixCls + "-clear-wrapper"] = allowClear,
                    _b[prefixCls + "-wrapper-rtl"] = rtl,
                    _b)), style: wrapperStyle },
                TextAreaElement,
                showClearIcon ? (React.createElement(IconHover, { className: prefixCls + "-clear-icon" },
                    React.createElement(IconClose$1, { onClick: handleClearClick, 
                        // keep focus status
                        onMouseDown: function (e) {
                            e.preventDefault();
                        } }))) : null,
                wordLimitMaxLength && showWordLimit && (React.createElement("span", { className: cs(prefixCls + "-word-limit", (_c = {},
                        _c[prefixCls + "-word-limit-error"] = lengthError,
                        _c)) },
                    leftWord,
                    "/",
                    rightWord))));
        }
        return TextAreaElement;
    };
    var TextAreaRef = React.forwardRef(TextArea$1);
    TextAreaRef.displayName = 'TextArea';
    var TextArea$2 = TextAreaRef;

    function ownKeys$J(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$K(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$J(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$J(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconEyeComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$K(_objectSpread$K({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-eye")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M24 37c6.627 0 12.627-4.333 18-13-5.373-8.667-11.373-13-18-13-6.627 0-12.627 4.333-18 13 5.373 8.667 11.373 13 18 13Z",
        clipRule: "evenodd"
      }), /*#__PURE__*/React.createElement("path", {
        d: "M29 24a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"
      }));
    }

    var IconEye = /*#__PURE__*/React.forwardRef(IconEyeComponent);
    IconEye.defaultProps = {
      isIcon: true
    };
    IconEye.displayName = 'IconEye';
    var IconEye$1 = IconEye;

    function ownKeys$I(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$J(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$I(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$I(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconEyeInvisibleComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$J(_objectSpread$J({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-eye-invisible")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M14 14.5c-2.69 2-5.415 5.33-8 9.5 5.373 8.667 11.373 13 18 13 3.325 0 6.491-1.09 9.5-3.271M17.463 12.5C19 11 21.75 11 24 11c6.627 0 12.627 4.333 18 13-1.766 2.848-3.599 5.228-5.5 7.14"
      }), /*#__PURE__*/React.createElement("path", {
        d: "M29 24a5 5 0 1 1-10 0 5 5 0 0 1 10 0ZM6.852 7.103l34.294 34.294"
      }));
    }

    var IconEyeInvisible = /*#__PURE__*/React.forwardRef(IconEyeInvisibleComponent);
    IconEyeInvisible.defaultProps = {
      isIcon: true
    };
    IconEyeInvisible.displayName = 'IconEyeInvisible';
    var IconEyeInvisible$1 = IconEyeInvisible;

    function useKeyboardEvent(props) {
        var getEventListeners = React.useCallback(function (callbacks) {
            return {
                onKeyDown: function (e) {
                    var _a, _b, _c, _d, _e, _f;
                    var keyCode = e.keyCode || e.which;
                    if (keyCode === Enter.code) {
                        (_a = callbacks.onPressEnter) === null || _a === void 0 ? void 0 : _a.call(callbacks, e);
                    }
                    if (keyCode === ArrowDown.code) {
                        (_b = callbacks.onArrowDown) === null || _b === void 0 ? void 0 : _b.call(callbacks, e);
                    }
                    if (keyCode === ArrowLeft.code) {
                        (_c = callbacks.onArrowLeft) === null || _c === void 0 ? void 0 : _c.call(callbacks, e);
                    }
                    if (keyCode === ArrowRight.code) {
                        (_d = callbacks.onArrowRight) === null || _d === void 0 ? void 0 : _d.call(callbacks, e);
                    }
                    if (keyCode === ArrowUp.code) {
                        (_e = callbacks.onArrowUp) === null || _e === void 0 ? void 0 : _e.call(callbacks, e);
                    }
                    (_f = props === null || props === void 0 ? void 0 : props.onKeyDown) === null || _f === void 0 ? void 0 : _f.call(props, e);
                },
            };
        }, []);
        return getEventListeners;
    }

    var __assign$1_ = (undefined && undefined.__assign) || function () {
        __assign$1_ = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1_.apply(this, arguments);
    };
    var __rest$10 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$1n = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var Password$1 = React.forwardRef(function (props, ref) {
        var _a;
        var _b = __read$1n(useMergeValue(false, {
            defaultValue: props.defaultVisibility,
            value: props.visibility,
        }), 2), visibility = _b[0], setVisibility = _b[1];
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var getKeyboardEvents = useKeyboardEvent();
        var className = props.className, _c = props.visibilityToggle, visibilityToggle = _c === void 0 ? true : _c, onVisibilityChange = props.onVisibilityChange, rest = __rest$10(props, ["className", "visibilityToggle", "onVisibilityChange"]);
        var prefixCls = getPrefixCls('input-password');
        var classNames = cs(prefixCls, (_a = {},
            _a[prefixCls + "-visibility"] = visibilityToggle,
            _a), className);
        var onClickVisibility = function (v) {
            if (!('visibility' in props)) {
                setVisibility(v);
            }
            onVisibilityChange && onVisibilityChange(v);
        };
        var icon = props.suffix;
        var handleClickVisibility = function () {
            onClickVisibility(!visibility);
        };
        if (visibilityToggle) {
            var IconProps = __assign$1_({ onClick: handleClickVisibility, 
                // 预防focus丢失
                onMouseDown: function (e) { return e.preventDefault(); }, onMouseUp: function (e) { return e.preventDefault(); } }, getKeyboardEvents({
                onPressEnter: handleClickVisibility,
            }));
            if (props.suffix) {
                icon = React.createElement("span", __assign$1_({}, IconProps), props.suffix);
            }
            else {
                var IconComponent = visibility ? IconEye$1 : IconEyeInvisible$1;
                icon = (React.createElement(IconComponent, __assign$1_({}, IconProps, {
                    focusable: undefined,
                    'aria-hidden': undefined,
                    tabIndex: 0,
                    className: prefixCls + "-visibility-icon",
                })));
            }
        }
        return (React.createElement(Input$4, __assign$1_({}, omit$1(rest, ['visibility', 'defaultVisibility']), { type: visibility ? 'text' : 'password', className: classNames, ref: ref, suffix: icon })));
    });
    Password$1.displayName = 'Password';
    var Password$2 = Password$1;

    // Replace empty string to &nbsp;
    function fillNBSP (str) {
        return typeof str === 'string' ? str.replace(/\s{2,}/g, function ($0) { return '\u00A0'.repeat($0.length); }) : str;
    }

    var __assign$1Z = (undefined && undefined.__assign) || function () {
        __assign$1Z = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1Z.apply(this, arguments);
    };
    var __rest$$ = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$1m = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var InputComponent = React.forwardRef(function (props, ref) {
        var _a;
        var allowClear = props.allowClear, error = props.error, disabled = props.disabled, placeholder = props.placeholder, className = props.className, style = props.style, height = props.height, prefixCls = props.prefixCls, hasParent = props.hasParent, size = props.size, value = props.value, autoFitWidth = props.autoFitWidth, onClear = props.onClear, readOnly = props.readOnly, onChange = props.onChange, onKeyDown = props.onKeyDown, onPressEnter = props.onPressEnter, propMaxLength = props.maxLength, rest = __rest$$(props, ["allowClear", "error", "disabled", "placeholder", "className", "style", "height", "prefixCls", "hasParent", "size", "value", "autoFitWidth", "onClear", "readOnly", "onChange", "onKeyDown", "onPressEnter", "maxLength"]);
        var otherProps = omit$1(rest, [
            'showWordLimit',
            'className',
            'defaultValue',
            'addBefore',
            'addAfter',
            'afterStyle',
            'beforeStyle',
            'prefix',
            'suffix',
        ]);
        var getKeyboardEvents = useKeyboardEvent();
        var refInput = React.useRef();
        var refInputMirror = React.useRef();
        var refPrevInputWidth = React.useRef(null);
        var _b = __read$1m(React.useState(null), 2), inputElementWidth = _b[0], setInputElementWidth = _b[1];
        var maxLength = isObject$1(propMaxLength)
            ? propMaxLength.errorOnly
                ? undefined
                : propMaxLength.length
            : propMaxLength;
        var _c = useComposition({ value: value, maxLength: maxLength, onChange: onChange, onKeyDown: onKeyDown, onPressEnter: onPressEnter }), compositionValue = _c.compositionValue, valueChangeHandler = _c.valueChangeHandler, compositionHandler = _c.compositionHandler, keyDownHandler = _c.keyDownHandler, triggerValueChangeCallback = _c.triggerValueChangeCallback;
        var inputClassNames = cs(prefixCls, prefixCls && (_a = {},
            _a[prefixCls + "-size-" + size] = size,
            _a[prefixCls + "-error"] = error,
            _a[prefixCls + "-disabled"] = disabled,
            _a), hasParent ? undefined : className);
        var inputProps = __assign$1Z(__assign$1Z({ 'aria-invalid': error }, otherProps), { readOnly: readOnly, maxLength: maxLength, disabled: disabled, placeholder: placeholder, value: compositionValue || value || '', className: inputClassNames, onKeyDown: keyDownHandler, onChange: valueChangeHandler, onCompositionStart: compositionHandler, onCompositionUpdate: compositionHandler, onCompositionEnd: compositionHandler });
        React.useImperativeHandle(ref, function () {
            return {
                dom: refInput.current,
                focus: function () {
                    refInput.current && refInput.current.focus && refInput.current.focus();
                },
                blur: function () {
                    refInput.current && refInput.current.blur && refInput.current.blur();
                },
            };
        }, []);
        var updateInputWidth = function () {
            if (refInputMirror.current && refInput.current) {
                // Unset width when need to show placeholder
                if (!inputProps.value && placeholder) {
                    setInputElementWidth(null);
                }
                else {
                    var width = refInputMirror.current.offsetWidth;
                    setInputElementWidth(width + (width ? 8 : 4));
                }
            }
        };
        // Set the initial width of <input>, and subsequent updates are triggered by ResizeObserver
        React.useEffect(function () { return autoFitWidth && updateInputWidth(); }, []);
        // Here also need placeholder to trigger updateInputWidth after user-input is cleared
        var mirrorValue = inputProps.value || placeholder;
        var handleClear = function (e) {
            if (refInput.current && refInput.current.focus) {
                refInput.current.focus();
            }
            triggerValueChangeCallback('', e);
            onClear && onClear();
        };
        return (React.createElement(React.Fragment, null,
            allowClear ? (React.createElement(React.Fragment, null,
                React.createElement("input", __assign$1Z({ ref: refInput }, inputProps)),
                !readOnly && !disabled && allowClear && value ? (React.createElement(IconHover, __assign$1Z({ tabIndex: 0, className: prefixCls + "-clear-icon" }, getKeyboardEvents({ onPressEnter: handleClear }), { onClick: function (e) {
                        e.stopPropagation();
                        handleClear(e);
                    } }),
                    React.createElement(IconClose$1
                    // keep focus status
                    , { 
                        // keep focus status
                        onMouseDown: function (e) {
                            e.preventDefault();
                        } }))) : null)) : (React.createElement("input", __assign$1Z({ ref: refInput }, inputProps, { style: hasParent
                    ? {}
                    : __assign$1Z(__assign$1Z(__assign$1Z({}, style), ('height' in props ? { height: height } : {})), (typeof inputElementWidth === 'number' ? { width: inputElementWidth } : {})) }))),
            autoFitWidth && (React.createElement(ResizeObserver$1, { onResize: function () {
                    var inputWidth = refInputMirror.current.offsetWidth;
                    if (typeof autoFitWidth === 'object') {
                        var delay = typeof autoFitWidth.delay === 'function'
                            ? autoFitWidth.delay(inputWidth, refPrevInputWidth.current)
                            : autoFitWidth.delay;
                        delay ? setTimeout(updateInputWidth, delay) : updateInputWidth();
                    }
                    else {
                        updateInputWidth();
                    }
                    refPrevInputWidth.current = inputWidth;
                } },
                React.createElement("span", { className: prefixCls + "-mirror", ref: refInputMirror }, fillNBSP(mirrorValue))))));
    });
    InputComponent.displayName = 'InputComponent';
    var InputComponent$1 = InputComponent;

    var __assign$1Y = (undefined && undefined.__assign) || function () {
        __assign$1Y = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1Y.apply(this, arguments);
    };
    var __rest$_ = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var Group$2 = React.forwardRef(function (props, ref) {
        var _a;
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var className = props.className, style = props.style, children = props.children, compact = props.compact, rest = __rest$_(props, ["className", "style", "children", "compact"]);
        var prefixCls = getPrefixCls('input-group');
        var classNames = cs(prefixCls, (_a = {},
            _a[prefixCls + "-compact"] = compact,
            _a), className);
        return (React.createElement("div", __assign$1Y({ ref: ref, className: classNames, style: style }, rest), children));
    });
    Group$2.displayName = 'InputGroup';
    var Group$3 = Group$2;

    var __assign$1X = (undefined && undefined.__assign) || function () {
        __assign$1X = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1X.apply(this, arguments);
    };
    var __read$1l = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var keepFocus$1 = function (e) {
        e.target.tagName !== 'INPUT' && e.preventDefault();
    };
    var inputAddon = function (className, node, style, onClick) {
        if (style === void 0) { style = {}; }
        return node ? (React.createElement("span", { style: style, className: className, onClick: onClick }, node)) : null;
    };
    function formatValue$2(value, maxLength) {
        var str = value !== null && !isUndefined(value) && !isString(value) ? String(value) : value || '';
        if (maxLength) {
            return str.slice(0, maxLength);
        }
        return str;
    }
    function Input$3(baseProps, ref) {
        var _a, _b, _c;
        var _d = React.useContext(ConfigContext), getPrefixCls = _d.getPrefixCls, ctxSize = _d.size, componentConfig = _d.componentConfig, rtl = _d.rtl;
        var props = useMergeProps(baseProps, {}, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Input);
        var className = props.className, style = props.style, addBefore = props.addBefore, addAfter = props.addAfter, suffix = props.suffix, prefix = props.prefix, beforeStyle = props.beforeStyle, afterStyle = props.afterStyle, height = props.height, disabled = props.disabled, maxLength = props.maxLength, showWordLimit = props.showWordLimit, allowClear = props.allowClear;
        var trueMaxLength = isObject$1(maxLength) ? maxLength.length : maxLength;
        var mergedMaxLength = isObject$1(maxLength) && maxLength.errorOnly ? undefined : trueMaxLength;
        var _e = __read$1l(React.useState(false), 2), focus = _e[0], setFocus = _e[1];
        var inputRef = React.useRef();
        var inputWrapperRef = React.useRef();
        var _f = __read$1l(useMergeValue('', {
            defaultValue: 'defaultValue' in props ? formatValue$2(props.defaultValue, mergedMaxLength) : undefined,
            value: 'value' in props ? formatValue$2(props.value, mergedMaxLength) : undefined,
        }), 2), value = _f[0], setValue = _f[1];
        React.useImperativeHandle(ref, function () { return inputRef.current; }, []);
        var onChange = function (value, e) {
            if (!('value' in props)) {
                setValue(value);
            }
            props.onChange && props.onChange(value, e);
        };
        var prefixCls = getPrefixCls('input');
        var size = props.size || ctxSize;
        var isCustomHeight = 'height' in props;
        var suffixElement = suffix;
        var valueLength = value ? value.length : 0;
        var lengthError = React.useMemo(function () {
            if (!mergedMaxLength && trueMaxLength) {
                return valueLength > trueMaxLength;
            }
            return false;
        }, [valueLength, trueMaxLength, mergedMaxLength]);
        if (trueMaxLength && showWordLimit) {
            var _g = __read$1l(rtl ? [trueMaxLength, valueLength] : [valueLength, trueMaxLength], 2), leftWord = _g[0], rightWord = _g[1];
            suffixElement = (React.createElement("span", { className: cs(prefixCls + "-word-limit", (_a = {},
                    _a[prefixCls + "-word-limit-error"] = lengthError,
                    _a)) },
                leftWord,
                "/",
                rightWord));
        }
        var classnames = cs(prefixCls + "-group-wrapper", prefixCls + "-group-wrapper-" + size, (_b = {},
            _b[prefixCls + "-custom-height"] = isCustomHeight,
            _b[prefixCls + "-has-suffix"] = suffixElement,
            _b[prefixCls + "-group-wrapper-disabled"] = disabled,
            _b[prefixCls + "-group-wrapper-rtl"] = rtl,
            _b), className);
        var needWrapper = addBefore || addAfter || suffixElement || prefix;
        var inputElement = (React.createElement(InputComponent$1, __assign$1X({ ref: inputRef }, props, { onFocus: function (e) {
                setFocus(true);
                props.onFocus && props.onFocus(e);
            }, onBlur: function (e) {
                setFocus(false);
                props.onBlur && props.onBlur(e);
            }, onChange: onChange, prefixCls: prefixCls, value: value, hasParent: !!needWrapper || allowClear, size: size })));
        var innerWrapperClassnames = cs(prefixCls + "-inner-wrapper", (_c = {},
            _c[prefixCls + "-inner-wrapper-error"] = props.error || lengthError,
            _c[prefixCls + "-inner-wrapper-disabled"] = disabled,
            _c[prefixCls + "-inner-wrapper-focus"] = focus,
            _c[prefixCls + "-inner-wrapper-has-prefix"] = prefix,
            _c[prefixCls + "-inner-wrapper-" + size] = size,
            _c[prefixCls + "-clear-wrapper"] = allowClear,
            _c[prefixCls + "-inner-wrapper-rtl"] = rtl,
            _c));
        return needWrapper ? (React.createElement("div", { className: classnames, style: __assign$1X(__assign$1X({}, style), (isCustomHeight ? { height: height } : {})) },
            React.createElement("span", { className: prefixCls + "-group" },
                inputAddon(prefixCls + "-group-addbefore", addBefore, beforeStyle),
                React.createElement("span", { className: innerWrapperClassnames, ref: inputWrapperRef, onMouseDown: function (e) {
                        // 直接的点击input的时候，不阻止默认行为，避免无法选中输入框里的输入文本
                        if (e.target.tagName !== 'INPUT') {
                            // 当使用React.Portal挂载的组件（tooltip, popover等）放在prefix，suffix里是，弹层中的内容无法被选中。
                            // contains 判断如果不包含在当前dom节点，则不阻止默认行为。
                            if (inputWrapperRef.current && contains$1(inputWrapperRef.current, e.target)) {
                                e.preventDefault();
                            }
                        }
                    }, onClick: function (e) {
                        // 当使用React.Portal挂载的组件（tooltip, popover等）放在prefix，suffix里时，弹出层被点击时，不应该focus input。
                        if (inputWrapperRef.current && contains$1(inputWrapperRef.current, e.target)) {
                            inputRef.current && inputRef.current.focus();
                        }
                    } },
                    inputAddon(prefixCls + "-group-prefix", prefix),
                    inputElement,
                    inputAddon(prefixCls + "-group-suffix", suffixElement)),
                inputAddon(prefixCls + "-group-addafter", addAfter, afterStyle)))) : allowClear ? (React.createElement("span", { className: cs(className, innerWrapperClassnames), style: __assign$1X(__assign$1X({}, style), (isCustomHeight ? { height: height } : {})), onMouseDown: keepFocus$1, onClick: function () {
                inputRef.current && inputRef.current.focus();
            } }, inputElement)) : (inputElement);
    }
    var InputElement = React.forwardRef(Input$3);
    InputElement.displayName = 'Input';
    InputElement.Search = Search$1;
    InputElement.TextArea = TextArea$2;
    InputElement.Password = Password$2;
    InputElement.Group = Group$3;
    var Input$4 = InputElement;

    var Portal$3 = function (props) {
        var getContainer = props.getContainer, children = props.children;
        var containerRef = React.useRef();
        var isFirstRender = useIsFirstRender();
        if ((isFirstRender || containerRef.current === null) && !isServerRendering) {
            containerRef.current = getContainer();
        }
        React.useEffect(function () {
            return function () {
                var container = containerRef.current;
                if (container && container.parentNode) {
                    container.parentNode.removeChild(container);
                    containerRef.current = null;
                }
            };
        }, []);
        return containerRef.current ? ReactDOM.createPortal(children, containerRef.current) : null;
    };
    var Portal$4 = Portal$3;

    var __assign$1W = (undefined && undefined.__assign) || function () {
        __assign$1W = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1W.apply(this, arguments);
    };
    // get element's position relative to root element
    function getElementPosition(element, elementRect, root) {
        if (!root || !element || isServerRendering) {
            return { left: 0, width: 0, height: 0, top: 0 };
        }
        // safari and chrome
        var bodyScroll = function (direction) { return document.documentElement[direction] || document.body[direction]; };
        var pageScrollTop = root === document.body ? bodyScroll('scrollTop') : root.scrollTop;
        var pageScrollLeft = root === document.body ? bodyScroll('scrollLeft') : root.scrollLeft;
        var left = elementRect.left, top = elementRect.top, width = elementRect.width, height = elementRect.height;
        // custom container
        var rootLeft = root === document.body ? 0 : root.getBoundingClientRect().left;
        var rootTop = root === document.body ? 0 : root.getBoundingClientRect().top;
        var pTop = top + pageScrollTop - rootTop;
        var pLeft = left + pageScrollLeft - rootLeft;
        return {
            left: pLeft,
            top: pTop,
            width: width,
            height: height,
        };
    }
    var getInsideValue = function (min, max, value) {
        if (value < min) {
            return min;
        }
        if (value > max) {
            return max;
        }
        return value;
    };
    var getPopupAlign = function (propsPopupAlign, showArrow) {
        var horizontalOffset = 0;
        var verticalOffset = 0;
        var resultPopupAlign = {};
        if (!showArrow) {
            resultPopupAlign = __assign$1W({}, propsPopupAlign);
        }
        else {
            resultPopupAlign = __assign$1W({ left: 12, right: 12, top: 12, bottom: 12 }, propsPopupAlign);
        }
        for (var key in resultPopupAlign) {
            if (isArray$1(resultPopupAlign[key])) {
                var index = 0;
                // top,bottom 时候，第二个参数是纵向偏移量
                if (['top', 'bottom'].indexOf(key) > -1) {
                    index = 1;
                    horizontalOffset = resultPopupAlign[key][0];
                }
                else {
                    verticalOffset = resultPopupAlign[key][1];
                }
                resultPopupAlign[key] = resultPopupAlign[key][index];
            }
        }
        return __assign$1W(__assign$1W({}, resultPopupAlign), { horizontalOffset: horizontalOffset, verticalOffset: verticalOffset });
    };
    var getChildRect = function (child, mouseLocation) {
        return mouseLocation
            ? {
                left: mouseLocation.clientX,
                top: mouseLocation.clientY,
                width: 0,
                height: 0,
                right: mouseLocation.clientX,
                bottom: mouseLocation.clientY,
            }
            : child.getBoundingClientRect();
    };
    var getStyle$2 = (function (props, content, child, mountContainer, mouseLocation) {
        var autoAlignPopupWidth = props.autoAlignPopupWidth, autoAlignPopupMinWidth = props.autoAlignPopupMinWidth, alignPoint = props.alignPoint, propsStyle = props.style;
        if (!child || !content || !mountContainer) {
            return {};
        }
        var style = {};
        // 如果跟随鼠标，相当于鼠标位置作为 child
        var childRect = getChildRect(child, alignPoint && mouseLocation);
        var _a = getElementPosition(child, childRect, mountContainer), left = _a.left, top = _a.top, width = _a.width, height = _a.height;
        var popupAlign = getPopupAlign(props.popupAlign, props.showArrow);
        var alignLeft = popupAlign.left || 0;
        var alignRight = popupAlign.right || 0;
        var alignTop = popupAlign.top || 0;
        var alignBottom = popupAlign.bottom || 0;
        // 通过props.style 传递的width优先级更高
        if (autoAlignPopupWidth && (propsStyle === null || propsStyle === void 0 ? void 0 : propsStyle.width) === undefined) {
            content.style.width = child.offsetWidth + "px";
        }
        if (autoAlignPopupMinWidth) {
            content.style.minWidth = child.offsetWidth + "px";
        }
        var realPosition = props.position;
        var arrowStyle = {};
        var autoPosition = function (direction) {
            var _a, _b;
            if (!props.autoFitPosition) {
                return;
            }
            // document.documentElement?.clientHeight 是为了排除横向滚动条的高度影响。
            var windowHeight = ((_a = document.documentElement) === null || _a === void 0 ? void 0 : _a.clientHeight) || window.innerHeight;
            var windowWidth = ((_b = document.documentElement) === null || _b === void 0 ? void 0 : _b.clientWidth) || window.innerWidth;
            var result = false; // 是否进行了位置调整
            // 视口左侧/顶部到 popupContainer 的距离
            var boundary = {
                left: left - childRect.left,
                top: top - childRect.top,
            };
            var _c = style.top, styleTop = _c === void 0 ? 0 : _c, _d = style.left, styleLeft = _d === void 0 ? 0 : _d;
            // 水平方向微调
            if (direction === 'top' || direction === 'bottom') {
                if (boundary.left > styleLeft && childRect.right > 12) {
                    // 左边被遮挡
                    style.left = Math.max(boundary.left, left - content.clientWidth);
                    style.left = Math.max(style.left, left - content.clientWidth + 24);
                }
                else if (styleLeft - boundary.left + content.clientWidth > windowWidth &&
                    windowWidth - childRect.left > 12) {
                    // 右侧被遮挡，右侧贴边。如果child在可视区内的宽度小于12，不进行位置调整
                    style.left = Math.max(boundary.left, boundary.left + windowWidth - content.clientWidth);
                    style.left = Math.max(style.left, left - content.clientWidth + 24);
                }
            }
            // 垂直方向微调
            if (direction === 'left' || direction === 'right') {
                if (boundary.top > styleTop && childRect.bottom > 12) {
                    // 上面
                    style.top = boundary.top;
                    style.top = Math.max(style.top, top - content.clientHeight + childRect.height / 2);
                }
                else if (styleTop - boundary.top + content.clientHeight > windowHeight &&
                    windowHeight - childRect.top > 12) {
                    // 向上微调位置，如果child在可视区内的高度小于12，不进行位置调整
                    style.top = Math.max(boundary.top, boundary.top + windowHeight - content.clientHeight);
                    style.top = Math.max(style.top, top - content.clientHeight + childRect.height / 2);
                }
            }
            if (direction === 'top' && boundary.top > styleTop) {
                // 上面被遮挡
                if (childRect.top < windowHeight - childRect.bottom) {
                    // 放到下面
                    style.top = Math.min(top + height + (alignTop || 0), boundary.top + windowHeight - content.clientHeight);
                    result = true;
                }
                else {
                    // 贴顶部边界
                    style.top = boundary.top;
                }
            }
            if (direction === 'bottom' && styleTop - boundary.top + content.clientHeight > windowHeight) {
                // 下部分被遮挡
                if (windowHeight - childRect.bottom < childRect.top) {
                    // 放到上面
                    style.top = Math.max(top - content.clientHeight - (alignBottom || 0), boundary.top);
                    result = true;
                }
                else {
                    // 贴底边界
                    style.top = boundary.top + windowHeight - content.clientHeight;
                }
            }
            if (direction === 'left' && boundary.left > styleLeft) {
                // 左边被遮挡
                if (childRect.left < windowWidth - childRect.right) {
                    // 放到右边
                    style.left = Math.min(width + left + alignRight, boundary.left + windowWidth - content.clientWidth);
                    result = true;
                }
                else {
                    style.left = boundary.left;
                }
            }
            if (direction === 'right' && styleLeft - boundary.left + content.clientWidth > windowWidth) {
                // 右边被遮挡
                if (windowWidth - childRect.right < childRect.left) {
                    // 放到左边
                    style.left = Math.max(left - content.clientWidth - alignLeft, boundary.left);
                    result = true;
                }
                else {
                    // 贴左边界
                    style.left = boundary.left + windowWidth - content.clientWidth;
                }
            }
            // 限制在popupContainer中，左侧最小为 0px
            if (style.left < 0) {
                style.left = 0;
            }
            else {
                // 限制在popupContainer中，左侧最大为 mountContainer.scrollWidth - content.clientWidth，保证弹出层在container内部
                var maxLeft = mountContainer.scrollWidth - content.clientWidth;
                style.left = Math.min(maxLeft, style.left);
            }
            return result;
        };
        var horizontalOffset = popupAlign.horizontalOffset || 0;
        var verticalOffset = popupAlign.verticalOffset || 0;
        switch (props.position) {
            case 'top': {
                style.top = top - content.clientHeight - alignTop;
                style.left = left + width / 2 - content.clientWidth / 2;
                autoPosition('top') && (realPosition = 'bottom');
                style.left += horizontalOffset;
                var arrowLeft_1 = left - Number(style.left) + width / 2;
                arrowStyle.left = getInsideValue(12, content.clientWidth - 12, arrowLeft_1);
                break;
            }
            case 'tl':
                style.top = top - content.clientHeight - alignTop;
                style.left = left;
                autoPosition('top') && (realPosition = 'bl');
                style.left += horizontalOffset;
                var arrowLeft = left - Number(style.left) + Math.min(width / 2, 50);
                arrowStyle.left = getInsideValue(12, content.clientWidth - 12, arrowLeft);
                break;
            case 'tr':
                style.top = -content.clientHeight + top - alignTop;
                style.left = left + width - content.clientWidth;
                autoPosition('top') && (realPosition = 'br');
                style.left += horizontalOffset;
                arrowLeft = left - Number(style.left) + Math.max(width / 2, width - 50);
                arrowStyle.left = getInsideValue(12, content.clientWidth - 12, arrowLeft);
                break;
            case 'bottom': {
                style.top = height + top + alignBottom;
                style.left = left + width / 2 - content.clientWidth / 2;
                autoPosition('bottom') && (realPosition = 'top');
                style.left += horizontalOffset;
                var arrowLeft_2 = left - Number(style.left) + width / 2;
                arrowStyle.left = getInsideValue(12, content.clientWidth - 12, arrowLeft_2);
                break;
            }
            case 'bl':
                style.top = height + top + alignBottom;
                style.left = left;
                autoPosition('bottom') && (realPosition = 'tl');
                style.left += horizontalOffset;
                arrowLeft = left - Number(style.left) + Math.min(width / 2, 50);
                arrowStyle.left = getInsideValue(12, content.clientWidth - 12, arrowLeft);
                break;
            case 'br':
                style.top = height + top + alignBottom;
                style.left = left + width - content.clientWidth;
                autoPosition('bottom') && (realPosition = 'tr');
                style.left += horizontalOffset;
                arrowLeft = left - Number(style.left) + Math.max(width / 2, width - 50);
                arrowStyle.left = getInsideValue(12, content.clientWidth - 12, arrowLeft);
                break;
            case 'left': {
                style.top = top + height / 2 - content.clientHeight / 2;
                style.left = left - content.clientWidth - alignLeft;
                autoPosition('left') && (realPosition = 'right');
                style.top += verticalOffset;
                var arrowTop_1 = top - Number(style.top) + height / 2;
                arrowStyle.top = getInsideValue(12, content.clientHeight - 12, arrowTop_1);
                break;
            }
            case 'lt':
                style.top = top;
                style.left = left - content.clientWidth - alignLeft;
                autoPosition('left') && (realPosition = 'rt');
                style.top += verticalOffset;
                var arrowTop = top - Number(style.top) + Math.min(height / 2, 50);
                arrowStyle.top = getInsideValue(12, content.clientHeight - 12, arrowTop);
                break;
            case 'lb':
                style.top = top + height - content.clientHeight;
                style.left = left - content.clientWidth - alignLeft;
                autoPosition('left') && (realPosition = 'rb');
                style.top += verticalOffset;
                arrowTop = top - Number(style.top) + Math.max(height / 2, height - 50);
                arrowStyle.top = getInsideValue(12, content.clientHeight - 12, arrowTop);
                break;
            case 'right': {
                style.top = top + height / 2 - content.clientHeight / 2;
                style.left = width + left + alignRight;
                autoPosition('right') && (realPosition = 'left');
                style.top += verticalOffset;
                var arrowTop_2 = top - Number(style.top) + height / 2;
                arrowStyle.top = getInsideValue(12, content.clientHeight - 12, arrowTop_2);
                break;
            }
            case 'rt':
                style.top = top;
                style.left = width + left + alignRight;
                autoPosition('right') && (realPosition = 'lt');
                style.top += verticalOffset;
                arrowTop = top - Number(style.top) + Math.min(height / 2, 50);
                arrowStyle.top = getInsideValue(12, content.clientHeight - 12, arrowTop);
                break;
            case 'rb':
                style.top = top + height - content.clientHeight;
                style.left = width + left + alignRight;
                autoPosition('right') && (realPosition = 'lb');
                style.top += verticalOffset;
                arrowTop = top - Number(style.top) + Math.max(height / 2, height - 50);
                arrowStyle.top = getInsideValue(12, content.clientHeight - 12, arrowTop);
                break;
        }
        return {
            style: style,
            arrowStyle: arrowStyle,
            realPosition: realPosition,
        };
    });

    var __assign$1V = (undefined && undefined.__assign) || function () {
        __assign$1V = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1V.apply(this, arguments);
    };
    function mergeProps(componentProps, defaultProps, globalComponentConfig) {
        var _defaultProps = __assign$1V(__assign$1V({}, defaultProps), globalComponentConfig);
        var props = __assign$1V({}, componentProps);
        // https://github.com/facebook/react/blob/cae635054e17a6f107a39d328649137b83f25972/packages/react/src/ReactElement.js#L312
        for (var propName in _defaultProps) {
            if (props[propName] === undefined) {
                props[propName] = _defaultProps[propName];
            }
        }
        return props;
    }

    var __extends$6 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$1U = (undefined && undefined.__assign) || function () {
        __assign$1U = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1U.apply(this, arguments);
    };
    function getDOMPos(dom) {
        if (!dom) {
            return {};
        }
        var _a = dom.getBoundingClientRect(), width = _a.width, height = _a.height, left = _a.left, right = _a.right;
        return {
            width: width,
            height: height,
            left: left,
            right: right,
        };
    }
    var EventsByTriggerNeed = [
        'onClick',
        'onMouseEnter',
        'onMouseLeave',
        'onMouseMove',
        'onFocus',
        'onBlur',
        'onContextMenu',
        'onKeyDown',
    ];
    function splitChildrenStyle(obj, keys) {
        var picked = {};
        var omitted = __assign$1U({}, obj);
        keys.forEach(function (key) {
            if (obj && key in obj) {
                picked[key] = obj[key];
                delete omitted[key];
            }
        });
        return { picked: picked, omitted: omitted };
    }
    var defaultProps$C = {
        blurToHide: true,
        // clickToClose: true,
        classNames: 'fadeIn',
        trigger: 'hover',
        position: 'bottom',
        duration: 200,
        unmountOnExit: true,
        popupAlign: {},
        popupHoverStay: true,
        clickOutsideToClose: true,
        escToClose: false,
        mouseLeaveToClose: true,
        containerScrollToClose: false,
        getDocument: function () { return window.document; },
        autoFixPosition: true,
        mouseEnterDelay: 100,
        mouseLeaveDelay: 100,
        autoFitPosition: true,
    };
    var Trigger = /** @class */ (function (_super) {
        __extends$6(Trigger, _super);
        function Trigger(props, context) {
            var _this = _super.call(this, props, context) || this;
            _this.delayTimer = null;
            _this.updatePositionTimer = null;
            // is popup open?
            _this.popupOpen = false;
            // if mousedown to hide popup, ignore onFocus
            _this.mousedownToHide = false;
            _this.hasPopupMouseDown = false;
            _this.unmount = false;
            _this.isDidMount = false;
            // 保存鼠标的位置
            _this.mouseLocation = {
                clientX: 0,
                clientY: 0,
            };
            // 保存当前的mount container dom元素
            _this.observerContainer = null;
            // 保存当前节点到 popupContainer 间的所有滚动元素
            _this.scrollElements = null;
            // container 触发 resize时执行
            _this.resizeObserver = new index(function () {
                _this.handleUpdatePosition();
            });
            _this.childrenDom = null;
            // 保存children节点的尺寸。 主要用于在弹出层动画前和动画完成后比较尺寸是否有变化。
            _this.childrenDomSize = {};
            _this.getMergedProps = function (baseProps) {
                var componentConfig = _this.context.componentConfig;
                var props = mergeProps(baseProps || _this.props, defaultProps$C, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Trigger);
                return props;
            };
            _this.getRootElement = function () {
                _this.childrenDom = ReactDOM.findDOMNode(_this);
                return _this.childrenDom;
            };
            _this.offScrollListeners = function () {
                (_this.scrollElements || []).forEach(function (item) {
                    off(item, 'scroll', _this.handleScroll);
                });
                _this.scrollElements = null;
            };
            _this.offWindowResize = function () {
                _this.handleWindowResize = false;
                off(window, 'resize', _this.handleUpdatePosition);
            };
            _this.offContainerResize = function () {
                if (_this.resizeObserver && _this.observerContainer) {
                    _this.resizeObserver.unobserve(_this.observerContainer);
                    _this.observerContainer = null;
                }
            };
            _this.handleScroll = function () {
                var currentProps = _this.getMergedProps();
                if (currentProps.containerScrollToClose) {
                    _this.setPopupVisible(false);
                }
                else if (currentProps.updateOnScroll) {
                    _this.handleUpdatePosition();
                }
            };
            _this.onContainersScroll = function (props) {
                var _a, _b;
                if (_this.scrollElements) {
                    return;
                }
                _this.scrollElements = getScrollElements(_this.childrenDom, (_a = _this.popupContainer) === null || _a === void 0 ? void 0 : _a.parentNode);
                // 弹出层挂载载 body 且 body 不是滚动元素时，需要额外检测 document.documentElement 是否是滚动元素
                // 默认 html,body 不限制宽高时，滚动事件仅能在 window 上监听
                // fix: https://github.com/arco-design/arco-design/issues/1599
                if (props.containerScrollToClose &&
                    ((_b = _this.popupContainer) === null || _b === void 0 ? void 0 : _b.parentNode) === document.body &&
                    _this.scrollElements.indexOf(document.body) === -1 &&
                    isScrollElement(document.documentElement)) {
                    _this.scrollElements.push(window);
                }
                _this.scrollElements.forEach(function (item) {
                    on(item, 'scroll', _this.handleScroll);
                });
            };
            _this.onContainerResize = function () {
                var _a;
                // containerParent 相当于是通过getPopupContainer传入的节点
                // 因为 this.popupContainer 会被挂载到getPopupContainer返回的节点上
                var containerParent = (_a = _this.popupContainer) === null || _a === void 0 ? void 0 : _a.parentNode;
                if (_this.resizeObserver && _this.observerContainer !== containerParent) {
                    // 说明containerParent变了，取消之前的监听，监听新的container
                    _this.offContainerResize();
                    containerParent && _this.resizeObserver.observe(containerParent);
                    _this.observerContainer = containerParent;
                }
            };
            // getPopupContainer 改变时候触发
            _this.handleUpdatePosition = throttleByRaf(function () {
                _this.updatePopupPosition();
            });
            _this.isClickTrigger = function () {
                var trigger = _this.getMergedProps().trigger;
                return [].concat(trigger).indexOf('click') > -1;
            };
            _this.isFocusTrigger = function () {
                var trigger = _this.getMergedProps().trigger;
                return [].concat(trigger).indexOf('focus') > -1;
            };
            _this.isHoverTrigger = function () {
                var trigger = _this.getMergedProps().trigger;
                return [].concat(trigger).indexOf('hover') > -1;
            };
            _this.isContextMenuTrigger = function () {
                var trigger = _this.getMergedProps().trigger;
                return [].concat(trigger).indexOf('contextMenu') > -1;
            };
            // 是否在鼠标移出触发节点和popup的时候隐藏弹出层
            _this.isMouseLeaveToClose = function () {
                return _this.isHoverTrigger() && _this.getMergedProps().mouseLeaveToClose;
            };
            // 是否在悬浮到popup的时候隐藏弹出层
            _this.isPopupHoverHide = function () {
                return _this.isHoverTrigger() && !_this.getMergedProps().popupHoverStay;
            };
            _this.isClickToHide = function () {
                if (_this.isClickTrigger() || _this.isContextMenuTrigger()) {
                    var _a = _this.getMergedProps().clickToClose, clickToClose = _a === void 0 ? true : _a;
                    return clickToClose;
                }
                // 2.44.0 及之前版本 clickToClose 对 hover触发不生效。
                // 2.44.1 之后只有在props直接传入clickToClose 时才生效于 hover 触发方式，避免如以下用法前后表现不一致
                // <Trigger><Trigger trigger="click"><button>sss</button></a></Trigger></Trigger>
                return _this.isHoverTrigger() && _this.props.clickToClose;
            };
            _this.isBlurToHide = function () {
                return _this.isFocusTrigger() && _this.getMergedProps().blurToHide;
            };
            _this.clearTimer = function () {
                if (_this.updatePositionTimer) {
                    if (_this.updatePositionTimer.cancel) {
                        _this.updatePositionTimer.cancel();
                    }
                    else {
                        clearTimeout(_this.updatePositionTimer);
                        _this.updatePositionTimer = null;
                    }
                }
                if (_this.delayTimer) {
                    clearTimeout(_this.delayTimer);
                    _this.delayTimer = null;
                }
                if (_this.mouseDownTimeout) {
                    clearTimeout(_this.mouseDownTimeout);
                    _this.mouseDownTimeout = null;
                }
            };
            _this.offClickOutside = function () {
                if (_this.handleClickOutside) {
                    var getDocument = _this.getMergedProps().getDocument;
                    var root = isFunction$1(getDocument) && getDocument();
                    off(root, 'mousedown', _this.onClickOutside);
                    _this.handleClickOutside = false;
                }
            };
            _this.getTransformOrigin = function (position) {
                var _a, _b;
                var content = _this.triggerRef;
                if (!content)
                    return {};
                var _c = _this.getMergedProps(), showArrow = _c.showArrow, classNames = _c.classNames;
                var top = (showArrow && ((_a = _this.arrowStyle) === null || _a === void 0 ? void 0 : _a.top)) || 0;
                var left = (showArrow && ((_b = _this.arrowStyle) === null || _b === void 0 ? void 0 : _b.left)) || 0;
                top = top ? top + "px" : '';
                left = left ? left + "px" : '';
                var transformOrigin = {
                    top: (left || '50%') + " 100% 0",
                    tl: (left || '15px') + " 100% 0",
                    tr: (left || content.clientWidth - 15 + "px") + " 100% 0",
                    bottom: (left || '50%') + " 0 0",
                    bl: (left || '15px') + " 0 0",
                    br: (left || content.clientWidth - 15 + "px") + " 0 0",
                    left: "100% " + (top || '50%') + " 0",
                    lt: "100% " + (top || '15px') + " 0",
                    lb: "100% " + (top || content.clientHeight - 15 + "px") + " 0",
                    right: "0 " + (top || '50%') + " 0",
                    rt: "0 " + (top || '15px') + " 0",
                    rb: "0 " + (top || content.clientHeight - 15 + "px") + " 0",
                };
                // tooltip popover popconfirm
                if (classNames && classNames.indexOf('zoom') > -1) {
                    return {
                        transformOrigin: transformOrigin[position],
                    };
                }
                if (classNames === 'slideDynamicOrigin') {
                    var origin_1 = '0% 0%';
                    if (['top', 'tl', 'tr'].indexOf(position) > -1) {
                        origin_1 = '100% 100%';
                    }
                    return {
                        transformOrigin: origin_1,
                    };
                }
                return {};
            };
            // 下拉框存在初始translateY/translateX，需要根据真实的弹出位置确定
            _this.getTransformTranslate = function () {
                if (_this.getMergedProps().classNames !== 'slideDynamicOrigin') {
                    return '';
                }
                switch (_this.realPosition) {
                    case 'bottom':
                    case 'bl':
                    case 'br':
                        return 'scaleY(0.9) translateY(-4px)';
                    case 'top':
                    case 'tl':
                    case 'tr':
                        return 'scaleY(0.9) translateY(4px)';
                    default:
                        return '';
                }
            };
            _this.getPopupStyle = function () {
                if (_this.unmount || !_this.popupContainer) {
                    return;
                }
                var mountContainer = _this.popupContainer;
                var content = _this.triggerRef;
                var child = _this.getRootElement();
                // offsetParent=null when display:none or position: fixed
                if (!child.offsetParent && !child.getClientRects().length) {
                    return _this.state.popupStyle;
                }
                var _a = getStyle$2(_this.getMergedProps(), content, child, mountContainer, _this.mouseLocation), style = _a.style, arrowStyle = _a.arrowStyle, realPosition = _a.realPosition;
                _this.realPosition = realPosition || _this.getMergedProps().position;
                _this.arrowStyle = arrowStyle || {};
                return __assign$1U(__assign$1U({}, style), _this.getTransformOrigin(_this.realPosition));
            };
            _this.showPopup = function (callback) {
                if (callback === void 0) { callback = function () { }; }
                var popupStyle = _this.getPopupStyle();
                _this.setState({
                    popupStyle: popupStyle,
                }, callback);
            };
            _this.update = throttleByRaf(function (callback) {
                if (_this.unmount || !_this.state.popupVisible) {
                    return;
                }
                var popupStyle = _this.getPopupStyle();
                _this.setState({
                    popupStyle: popupStyle,
                }, function () {
                    callback && callback();
                });
            });
            _this.updatePopupPosition = function (delay, callback) {
                if (delay === void 0) { delay = 0; }
                var currentVisible = _this.state.popupVisible;
                if (!currentVisible) {
                    return;
                }
                if (delay < 4) {
                    _this.updatePositionTimer = _this.update(callback);
                    return;
                }
                _this.updatePositionTimer = setTimeout(function () {
                    var popupStyle = _this.getPopupStyle();
                    _this.setState({
                        popupStyle: popupStyle,
                    }, function () {
                        callback && callback();
                    });
                }, delay);
            };
            _this.setPopupVisible = function (visible, delay, callback) {
                if (delay === void 0) { delay = 0; }
                var mergedProps = _this.getMergedProps();
                var onVisibleChange = mergedProps.onVisibleChange;
                var currentVisible = _this.state.popupVisible;
                if (visible !== currentVisible) {
                    _this.delayToDo(delay, function () {
                        onVisibleChange && onVisibleChange(visible);
                        if (!('popupVisible' in mergedProps)) {
                            if (visible) {
                                _this.setState({
                                    popupVisible: true,
                                }, function () {
                                    _this.showPopup(callback);
                                });
                            }
                            else {
                                _this.setState({
                                    popupVisible: false,
                                }, function () {
                                    callback && callback();
                                });
                            }
                        }
                        else {
                            callback && callback();
                        }
                    });
                }
                else {
                    callback && callback();
                }
            };
            _this.delayToDo = function (delay, callback) {
                if (delay) {
                    _this.clearDelayTimer();
                    _this.delayTimer = setTimeout(function () {
                        callback();
                        _this.clearDelayTimer();
                    }, delay);
                }
                else {
                    callback();
                }
            };
            // 点击非popup内部，非children内部的节点，触发clickoutside 逻辑
            _this.onClickOutside = function (e) {
                var _a = _this.getMergedProps(), onClickOutside = _a.onClickOutside, clickOutsideToClose = _a.clickOutsideToClose;
                var triggerNode = _this.triggerRef;
                var childrenDom = _this.getRootElement();
                if (!contains$1(triggerNode, e.target) &&
                    !contains$1(childrenDom, e.target) &&
                    !_this.hasPopupMouseDown) {
                    onClickOutside && onClickOutside();
                    if (clickOutsideToClose) {
                        // 以下判断条件避免onVisibleChange触发两次
                        // blurToHide 为true时不需要执行，因为onBlur里会执行setPopupVisible
                        // hover 触发方式，不执行以下逻辑。因为mouseLeave里会执行setPopupVisible
                        if (!_this.isBlurToHide() && !_this.isHoverTrigger()) {
                            _this.setPopupVisible(false);
                        }
                    }
                }
            };
            _this.onKeyDown = function (e) {
                var keyCode = e.keyCode || e.which;
                _this.triggerPropsEvent('onKeyDown', e);
                if (keyCode === Esc.code) {
                    _this.onPressEsc(e);
                }
            };
            _this.onPressEsc = function (e) {
                var escToClose = _this.getMergedProps().escToClose;
                if (escToClose && e && e.key === Esc.key && _this.state.popupVisible) {
                    _this.setPopupVisible(false);
                }
            };
            _this.onMouseEnter = function (e) {
                var mouseEnterDelay = _this.getMergedProps().mouseEnterDelay;
                _this.triggerPropsEvent('onMouseEnter', e);
                _this.clearDelayTimer();
                _this.setPopupVisible(true, mouseEnterDelay || 0);
            };
            _this.onMouseMove = function (e) {
                _this.triggerPropsEvent('onMouseMove', e);
                _this.setMouseLocation(e);
                if (_this.state.popupVisible) {
                    _this.update();
                }
            };
            _this.onMouseLeave = function (e) {
                var mouseLeaveDelay = _this.getMergedProps().mouseLeaveDelay;
                _this.clearDelayTimer();
                _this.triggerPropsEvent('onMouseLeave', e);
                if (_this.isMouseLeaveToClose()) {
                    if (_this.state.popupVisible) {
                        _this.setPopupVisible(false, mouseLeaveDelay || 0);
                    }
                }
            };
            _this.onPopupMouseEnter = function () {
                _this.clearDelayTimer();
            };
            _this.onPopupMouseLeave = function (e) {
                _this.onMouseLeave(e);
            };
            _this.setMouseLocation = function (e) {
                if (_this.getMergedProps().alignPoint) {
                    _this.mouseLocation = {
                        clientX: e.clientX,
                        clientY: e.clientY,
                    };
                }
            };
            _this.onContextMenu = function (e) {
                e.preventDefault();
                _this.triggerPropsEvent('onContextMenu', e);
                _this.setMouseLocation(e);
                if (!_this.state.popupVisible) {
                    _this.setPopupVisible(true, 0);
                }
                else {
                    // 更新位置
                    _this.getMergedProps().alignPoint && _this.update();
                }
            };
            _this.clickToHidePopup = function (e) {
                var popupVisible = _this.state.popupVisible;
                if (popupVisible) {
                    _this.mousedownToHide = true;
                }
                _this.triggerPropsEvent('onClick', e);
                if (_this.isClickToHide() && popupVisible) {
                    _this.setPopupVisible(!popupVisible, 0);
                }
            };
            _this.onClick = function (e) {
                var popupVisible = _this.state.popupVisible;
                if (popupVisible) {
                    _this.mousedownToHide = true;
                }
                _this.triggerPropsEvent('onClick', e);
                _this.setMouseLocation(e);
                if (!_this.isClickToHide() && popupVisible) {
                    return;
                }
                _this.setPopupVisible(!popupVisible, 0);
            };
            _this.onFocus = function (e) {
                var focusDelay = _this.getMergedProps().focusDelay;
                var onFocus = function () {
                    _this.triggerPropsEvent('onFocus', e);
                };
                _this.clearDelayTimer();
                if (!_this.mousedownToHide) {
                    if (_this.state.popupVisible) {
                        onFocus && onFocus();
                    }
                    else {
                        _this.setPopupVisible(true, focusDelay || 0, onFocus);
                    }
                }
                _this.mousedownToHide = false;
            };
            _this.onBlur = function (e) {
                _this.setPopupVisible(false, 200, function () { return _this.triggerPropsEvent('onBlur', e); });
            };
            _this.onResize = function () {
                if (_this.getMergedProps().autoFixPosition && _this.state.popupVisible) {
                    _this.updatePopupPosition();
                }
            };
            _this.onPopupMouseDown = function () {
                _this.hasPopupMouseDown = true;
                clearTimeout(_this.mouseDownTimeout);
                _this.mouseDownTimeout = setTimeout(function () {
                    _this.hasPopupMouseDown = false;
                }, 0);
            };
            // 当 children 中的元素 disabled 时，不能正确触发 hover 等事件，所以当监测到对应
            // 组件有 disabled 时，给元素加一层 span，处理事件，模拟样式
            _this.getChild = function () {
                var children = _this.props.children;
                var element = children;
                var elementType = (element && typeof element !== 'string' && element.type);
                var child = children;
                if (['string', 'number'].indexOf(typeof children) > -1 || React.Children.count(children) > 1) {
                    child = React.createElement("span", null, children);
                }
                else if (element &&
                    elementType &&
                    (elementType.__BYTE_BUTTON === true ||
                        elementType.__BYTE_CHECKBOX === true ||
                        elementType.__BYTE_SWITCH === true ||
                        elementType.__BYTE_RADIO === true ||
                        elementType === 'button') &&
                    element.props.disabled) {
                    // 从样式中提取出会影响布局的到上层 span 样式中。
                    var _a = splitChildrenStyle(element.props.style, [
                        'position',
                        'left',
                        'right',
                        'top',
                        'bottom',
                        'float',
                        'display',
                        'zIndex',
                    ]), picked = _a.picked, omitted = _a.omitted;
                    child = (React.createElement("span", { className: element.props.className, style: __assign$1U(__assign$1U({ display: 'inline-block' }, picked), { cursor: 'not-allowed' }) }, React.cloneElement(element, {
                        style: __assign$1U(__assign$1U({}, omitted), { pointerEvents: 'none' }),
                        className: undefined,
                    })));
                }
                // 防止为空报错
                return child || React.createElement("span", null);
            };
            // 创建的dom节点插入getPopupContainer。
            _this.appendToContainer = function (node) {
                caf(_this.rafId);
                if (_this.isDidMount) {
                    var getGlobalPopupContainer = _this.context.getPopupContainer;
                    var getPopupContainer = _this.getMergedProps().getPopupContainer;
                    var gpc = getPopupContainer || getGlobalPopupContainer;
                    var rootElement = _this.getRootElement();
                    var parent_1 = gpc(rootElement);
                    if (parent_1) {
                        parent_1.appendChild(node);
                        return;
                    }
                }
                _this.rafId = raf(function () {
                    _this.appendToContainer(node);
                });
            };
            _this.getContainer = function () {
                var popupContainer = document.createElement('div');
                popupContainer.style.width = '100%';
                popupContainer.style.position = 'absolute';
                popupContainer.style.top = '0';
                popupContainer.style.left = '0';
                _this.popupContainer = popupContainer;
                _this.appendToContainer(popupContainer);
                return popupContainer;
            };
            // 1. 触发直接附加到 Trigger 上的事件，大多是Trigger直接嵌套Trigger的情况
            // 2. 触发children上直接被附加的事件
            _this.triggerPropsEvent = function (eventName, e) {
                var child = _this.getChild();
                var childHandler = child && child.props && child.props[eventName];
                var props = _this.getMergedProps();
                if (isFunction$1(childHandler)) {
                    childHandler(e);
                }
                if (isFunction$1(props[eventName])) {
                    props[eventName](e);
                }
            };
            // 触发 children/ trigger 组件上被附加的事件
            _this.triggerOriginEvent = function (eventName) {
                var child = _this.getChild();
                var childHandler = child && child.props && child.props[eventName];
                var propsHandler = _this.getMergedProps()[eventName];
                if (isFunction$1(propsHandler) && isFunction$1(childHandler)) {
                    return function (e) {
                        childHandler(e);
                        propsHandler(e);
                    };
                }
                return childHandler || propsHandler;
            };
            var mergedProps = _this.getMergedProps(props);
            var popupVisible = 'popupVisible' in mergedProps ? mergedProps.popupVisible : mergedProps.defaultPopupVisible;
            _this.popupOpen = !!popupVisible;
            _this.state = {
                popupVisible: !!popupVisible,
                popupStyle: {},
            };
            return _this;
        }
        Trigger.getDerivedStateFromProps = function (nextProps, state) {
            if ('popupVisible' in nextProps && nextProps.popupVisible !== state.popupVisible) {
                return {
                    popupVisible: nextProps.popupVisible,
                };
            }
            return null;
        };
        Trigger.prototype.componentDidMount = function () {
            this.componentDidUpdate(this.getMergedProps());
            this.isDidMount = true;
            this.unmount = false;
            this.childrenDom = this.getRootElement();
            if (this.state.popupVisible) {
                this.childrenDomSize = getDOMPos(this.childrenDom);
            }
        };
        Trigger.prototype.componentDidUpdate = function (_prevProps) {
            var prevProps = this.getMergedProps(_prevProps);
            var currentProps = this.getMergedProps();
            if (!prevProps.popupVisible && currentProps.popupVisible) {
                this.update();
            }
            var popupVisible = this.state.popupVisible;
            this.popupOpen = popupVisible;
            var getDocument = currentProps.getDocument;
            if (!popupVisible) {
                this.offClickOutside();
                this.offContainerResize();
                this.offWindowResize();
                this.offScrollListeners();
                return;
            }
            var rect = getDOMPos(this.childrenDom);
            // children节点的尺寸改变，主要是处理children 存在scale等动画属性，或者移动位置的时候，popup 的位置有问题
            if (JSON.stringify(rect) !== JSON.stringify(this.childrenDomSize)) {
                this.updatePopupPosition();
                this.childrenDomSize = rect;
            }
            // popupVisible为true
            this.onContainerResize();
            if (currentProps.updateOnScroll || currentProps.containerScrollToClose) {
                this.onContainersScroll(currentProps);
            }
            if (!this.handleWindowResize) {
                on(window, 'resize', this.handleUpdatePosition);
                this.handleWindowResize = true;
            }
            if (!this.handleClickOutside) {
                var root = isFunction$1(getDocument) && getDocument();
                if (root) {
                    // clickOutside 必须监听mousedown。
                    // 1. 如果事件目标元素在click后被移除，document.onclick被触发时已经没有该元素，会错误触发clickOutside逻辑，隐藏popup。
                    // 2. 点击label标签，会触发对应input元素的点击事件，导致触发clickOutside，隐藏popup。
                    on(root, 'mousedown', this.onClickOutside);
                    this.handleClickOutside = true;
                }
            }
        };
        Trigger.prototype.componentWillUnmount = function () {
            this.unmount = true;
            this.offClickOutside();
            this.clearTimer();
            this.offWindowResize();
            this.offScrollListeners();
            this.offContainerResize();
            caf(this.rafId);
        };
        Trigger.prototype.clearDelayTimer = function () {
            if (this.delayTimer) {
                clearTimeout(this.delayTimer);
                this.delayTimer = null;
            }
        };
        Trigger.prototype.render = function () {
            var _a, _b, _c;
            var _this = this;
            var _d;
            var _e = this.getMergedProps(), children = _e.children, style = _e.style, className = _e.className, arrowProps = _e.arrowProps, disabled = _e.disabled, popup = _e.popup, classNames = _e.classNames, duration = _e.duration, unmountOnExit = _e.unmountOnExit, alignPoint = _e.alignPoint, autoAlignPopupWidth = _e.autoAlignPopupWidth, position = _e.position, childrenPrefix = _e.childrenPrefix, showArrow = _e.showArrow, dropdownPopupStyle = _e.popupStyle, __onExit = _e.__onExit, __onExited = _e.__onExited;
            var isExistChildren = children || children === 0;
            var _f = this.context, getPrefixCls = _f.getPrefixCls, zIndex = _f.zIndex, rtl = _f.rtl;
            var _g = this.state, popupVisible = _g.popupVisible, popupStyle = _g.popupStyle;
            if (!popup) {
                return null;
            }
            var mergeProps = {};
            var popupEventProps = {
                onMouseDown: this.onPopupMouseDown,
            };
            if (this.isHoverTrigger() && !disabled) {
                mergeProps.onMouseEnter = this.onMouseEnter;
                mergeProps.onMouseLeave = this.onMouseLeave;
                mergeProps.onClick = this.clickToHidePopup;
                if (alignPoint) {
                    mergeProps.onMouseMove = this.onMouseMove;
                }
                if (!this.isPopupHoverHide()) {
                    popupEventProps.onMouseEnter = this.onPopupMouseEnter;
                    popupEventProps.onMouseLeave = this.onPopupMouseLeave;
                }
            }
            else {
                mergeProps.onMouseEnter = this.triggerOriginEvent('onMouseEnter');
                mergeProps.onMouseLeave = this.triggerOriginEvent('onMouseLeave');
            }
            if (this.isContextMenuTrigger() && !disabled) {
                mergeProps.onContextMenu = this.onContextMenu;
                mergeProps.onClick = this.clickToHidePopup;
            }
            else {
                mergeProps.onContextMenu = this.triggerOriginEvent('onContextMenu');
            }
            if (this.isClickTrigger() && !disabled) {
                mergeProps.onClick = this.onClick;
            }
            else {
                mergeProps.onClick = mergeProps.onClick || this.triggerOriginEvent('onClick');
            }
            if (this.isFocusTrigger() && !disabled) {
                mergeProps.onFocus = this.onFocus;
                if (this.isBlurToHide()) {
                    mergeProps.onBlur = this.onBlur;
                }
            }
            else {
                mergeProps.onFocus = this.triggerOriginEvent('onFocus');
                mergeProps.onBlur = this.triggerOriginEvent('onBlur');
            }
            if (!disabled) {
                mergeProps.onKeyDown = this.onKeyDown;
            }
            else {
                mergeProps.onKeyDown = this.triggerOriginEvent('onKeyDown');
            }
            var child = this.getChild();
            var popupChildren = React.Children.only(popup());
            if (child.props.className) {
                mergeProps.className = child.props.className;
            }
            if (childrenPrefix && popupVisible) {
                mergeProps.className = mergeProps.className
                    ? mergeProps.className + " " + childrenPrefix + "-open"
                    : childrenPrefix + "-open";
            }
            // 只有在focus触发时，设置tabIndex，点击tab键，能触发focus事件，展示弹出框
            if (this.isFocusTrigger()) {
                mergeProps.tabIndex = disabled ? -1 : 0;
            }
            var prefixCls = getPrefixCls('trigger');
            var popupClassName = cs(prefixCls, childrenPrefix, prefixCls + "-position-" + position, (_a = {}, _a[prefixCls + "-rtl"] = rtl, _a), className);
            var childrenComponent = isExistChildren && (React.createElement(ResizeObserver$1, { onResize: this.onResize }, React.cloneElement(child, __assign$1U({}, mergeProps))));
            var portalContent = (React.createElement(CSSTransition$1, { in: !!popupVisible, timeout: duration, classNames: classNames, unmountOnExit: unmountOnExit, appear: true, mountOnEnter: true, onEnter: function (e) {
                    e.style.display = 'initial';
                    e.style.pointerEvents = 'none';
                    if (classNames === 'slideDynamicOrigin') {
                        // 下拉菜单
                        e.style.transform = _this.getTransformTranslate();
                    }
                }, onEntering: function (e) {
                    if (classNames === 'slideDynamicOrigin') {
                        // 下拉菜单
                        e.style.transform = '';
                    }
                }, onEntered: function (e) {
                    e.style.pointerEvents = 'auto';
                    _this.forceUpdate();
                }, onExit: function (e) {
                    // 避免消失动画时对元素的快速点击触发意外的操作
                    e.style.pointerEvents = 'none';
                    __onExit === null || __onExit === void 0 ? void 0 : __onExit(e);
                }, onExited: function (e) {
                    e.style.display = 'none';
                    // 这里立即设置为null是为了在setState popupStyle引起重新渲染时，能触发 Portal的卸载事件。移除父节点。
                    // 否则只有在下个循环中 triggerRef 才会变为null，需要重新forceUpdate，才能触发Portal的unmount。
                    if (unmountOnExit) {
                        _this.triggerRef = null;
                    }
                    _this.setState({ popupStyle: {} });
                    __onExited === null || __onExited === void 0 ? void 0 : __onExited(e);
                } },
                React.createElement(ResizeObserver$1, { onResize: function () {
                        var target = _this.triggerRef;
                        if (target) {
                            // Avoid the flickering problem caused by the size change and positioning not being recalculated in time.
                            // TODO: Consider changing the popup style directly  in the next major version
                            var popupStyle_1 = _this.getPopupStyle();
                            var style_1 = _this.props.style || {};
                            target.style.top = String(style_1.top || popupStyle_1.top + "px");
                            target.style.left = String(style_1.left || popupStyle_1.left + "px");
                        }
                        _this.onResize();
                    } },
                    React.createElement("span", __assign$1U({ ref: function (node) { return (_this.triggerRef = node); }, "trigger-placement": this.realPosition, style: __assign$1U(__assign$1U(__assign$1U({ width: autoAlignPopupWidth && (style === null || style === void 0 ? void 0 : style.width) === undefined
                                ? (_d = this.childrenDomSize) === null || _d === void 0 ? void 0 : _d.width
                                : '' }, popupStyle), { position: 'absolute', zIndex: zIndex || '' }), style) }, popupEventProps, { className: popupClassName }, pickDataAttributes(this.props)),
                        React.createElement(popupChildren.type, __assign$1U({ ref: popupChildren.ref }, popupChildren.props, { style: __assign$1U(__assign$1U({}, popupChildren.props.style), dropdownPopupStyle) })),
                        (showArrow || arrowProps) && (React.createElement("div", { className: cs(prefixCls + "-arrow-container", (_b = {},
                                _b[childrenPrefix + "-arrow-container"] = childrenPrefix,
                                _b)) },
                            React.createElement("div", __assign$1U({}, arrowProps, { className: cs(prefixCls + "-arrow", (_c = {},
                                    _c[childrenPrefix + "-arrow"] = childrenPrefix,
                                    _c), arrowProps === null || arrowProps === void 0 ? void 0 : arrowProps.className), style: __assign$1U(__assign$1U({}, this.arrowStyle), arrowProps === null || arrowProps === void 0 ? void 0 : arrowProps.style) }))))))));
            // 如果 triggerRef 不存在，说明弹出层内容被销毁，可以隐藏portal。
            var portal = popupVisible || this.triggerRef ? (React.createElement(Portal$4, { getContainer: this.getContainer }, portalContent)) : null;
            return isExistChildren ? (React.createElement(React.Fragment, null,
                childrenComponent,
                portal)) : (portal);
        };
        Trigger.displayName = 'Trigger';
        Trigger.contextType = ConfigContext;
        return Trigger;
    }(React.PureComponent));
    var Trigger$1 = Trigger;

    var __assign$1T = (undefined && undefined.__assign) || function () {
        __assign$1T = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1T.apply(this, arguments);
    };
    var __rest$Z = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function OptGroup(props, ref) {
        var prefixCls = props.prefixCls, label = props.label, rest = __rest$Z(props, ["prefixCls", "label"]);
        return (React.createElement("li", __assign$1T({ ref: ref, className: prefixCls + "-group-title" }, omit$1(rest, ['_key', 'children', 'isSelectOptGroup'])), label));
    }
    var ForwardRefOptGroup = React.forwardRef(OptGroup);
    var OptGroupComponent = ForwardRefOptGroup;
    OptGroupComponent.__ARCO_SELECT_OPTGROUP__ = true;
    var OptGroup$1 = OptGroupComponent;

    var __assign$1S = (undefined && undefined.__assign) || function () {
        __assign$1S = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1S.apply(this, arguments);
    };
    var __read$1k = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$y = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var defaultContextValue$1 = {
        isCheckboxGroup: false,
        checkboxGroupValue: [],
        onGroupChange: function () { },
        registerValue: function () { },
        unRegisterValue: function () { },
    };
    var CheckboxGroupContext = React.createContext(defaultContextValue$1);
    function Group$1(props) {
        var _a;
        var _b = __read$1k(useMergeValue([], {
            defaultValue: 'defaultValue' in props ? props.defaultValue || [] : undefined,
            value: 'value' in props ? props.value || [] : undefined,
        }), 2), value = _b[0], setValue = _b[1];
        var _c = __read$1k(React.useState([]), 2), allOptionValues = _c[0], setAllOptionValues = _c[1];
        var _d = React.useContext(ConfigContext), getPrefixCls = _d.getPrefixCls, rtl = _d.rtl;
        var disabled = props.disabled, options = props.options, style = props.style, className = props.className, error = props.error, children = props.children, _e = props.direction, direction = _e === void 0 ? 'horizontal' : _e;
        var prefixCls = getPrefixCls('checkbox');
        var classNames = cs(prefixCls + "-group", (_a = {},
            _a[prefixCls + "-group-is-error"] = error,
            _a[prefixCls + "-group-direction-" + direction] = direction,
            _a[prefixCls + "-group-rtl"] = rtl,
            _a), className);
        var onChange = React.useCallback(function (optionValue, checked, e) {
            var newVal = value.slice();
            if (checked) {
                newVal.push(optionValue);
            }
            else {
                newVal.splice(value.indexOf(optionValue), 1);
            }
            setValue(newVal);
            props.onChange &&
                props.onChange(newVal.filter(function (v) { return allOptionValues.indexOf(v) > -1; }), e);
        }, [value, props.onChange, allOptionValues]);
        return (React.createElement("span", __assign$1S({ className: classNames, style: style }, pickTriggerPropsFromRest(props)),
            React.createElement(CheckboxGroupContext.Provider, { value: {
                    isCheckboxGroup: true,
                    checkboxGroupValue: value,
                    onGroupChange: onChange,
                    disabled: disabled,
                    registerValue: function (value) {
                        setAllOptionValues(function (allOptionValues) {
                            return Array.from(new Set(__spreadArray$y(__spreadArray$y([], __read$1k(allOptionValues), false), [value], false)));
                        });
                    },
                    unRegisterValue: function (value) {
                        setAllOptionValues(function (allOptionValues) {
                            return allOptionValues.filter(function (x) { return x !== value; });
                        });
                    },
                } }, isArray$1(options)
                ? options.map(function (option) {
                    var label = isObject$1(option) ? option.label : option;
                    var checkValue = isObject$1(option) ? option.value : option;
                    var icon = isObject$1(option) ? option.icon : undefined;
                    return (React.createElement(Checkbox$2, { disabled: disabled || (isObject$1(option) && option.disabled), key: checkValue, value: checkValue, icon: icon }, label));
                })
                : children)));
    }
    Group$1.displayName = 'CheckboxGroup';

    var __read$1j = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$x = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var useCheckbox = function (values, defaultSelected) {
        var _a = __read$1j(React.useState(__spreadArray$x([], __read$1j((defaultSelected || [])), false)), 2), selected = _a[0], setSelected = _a[1];
        var _b = React.useMemo(function () {
            // 判断是否选中
            var isSelected = function (value) {
                return selected.indexOf(value) > -1;
            };
            // 设置选中
            var setValueSelected = function (value, selectStatus) {
                var list = isArray$1(value) ? value : [value];
                var newSelected;
                if (selectStatus) {
                    newSelected = __spreadArray$x(__spreadArray$x([], __read$1j(selected), false), __read$1j(list), false);
                }
                else {
                    newSelected = selected.filter(function (x) { return list.indexOf(x) === -1; });
                }
                setSelected(Array.from(new Set(newSelected)));
            };
            return {
                isSelected: isSelected,
                setValueSelected: setValueSelected,
            };
        }, [selected]), isSelected = _b.isSelected, setValueSelected = _b.setValueSelected;
        var _c = React.useMemo(function () {
            var selectAll = function () {
                setSelected(values);
            };
            var unSelectAll = function () {
                setSelected([]);
            };
            var toggle = function (value) {
                if (value === void 0) { value = values; }
                var list = isArray$1(value) ? value : [value];
                var newSelected = __spreadArray$x([], __read$1j(selected), false);
                list.forEach(function (x) {
                    var index = newSelected.indexOf(x);
                    if (index > -1) {
                        newSelected.splice(index, 1);
                    }
                    else {
                        newSelected.push(x);
                    }
                });
                setSelected(newSelected);
            };
            var isAllSelected = function () {
                return values.every(function (x) { return isSelected(x); });
            };
            /**
             * 是否部分选中
             */
            var isPartialSelected = function () {
                return values.some(function (x) { return isSelected(x); }) && !isAllSelected();
            };
            return {
                selectAll: selectAll,
                unSelectAll: unSelectAll,
                toggle: toggle,
                isAllSelected: isAllSelected,
                isPartialSelected: isPartialSelected,
            };
        }, [selected, values, isSelected]), selectAll = _c.selectAll, unSelectAll = _c.unSelectAll, toggle = _c.toggle, isAllSelected = _c.isAllSelected, isPartialSelected = _c.isPartialSelected;
        return {
            selected: selected,
            setSelected: setSelected,
            setValueSelected: setValueSelected,
            selectAll: selectAll,
            unSelectAll: unSelectAll,
            toggle: toggle,
            isSelected: isSelected,
            isAllSelected: isAllSelected,
            isPartialSelected: isPartialSelected,
        };
    };
    var useCheckbox$1 = useCheckbox;

    function IconCheck$2(_a) {
        var className = _a.className;
        return (React.createElement("svg", { className: className, "aria-hidden": true, focusable: false, viewBox: "0 0 1024 1024", width: "200", height: "200", fill: "currentColor" },
            React.createElement("path", { d: "M877.44815445 206.10060629a64.72691371 64.72691371 0 0 0-95.14856334 4.01306852L380.73381888 685.46812814 235.22771741 533.48933518a64.72691371 64.72691371 0 0 0-92.43003222-1.03563036l-45.82665557 45.82665443a64.72691371 64.72691371 0 0 0-0.90617629 90.61767965l239.61903446 250.10479331a64.72691371 64.72691371 0 0 0 71.19960405 15.14609778 64.33855261 64.33855261 0 0 0 35.08198741-21.23042702l36.24707186-42.71976334 40.5190474-40.77795556-3.36579926-3.49525333 411.40426297-486.74638962a64.72691371 64.72691371 0 0 0-3.88361443-87.64024149l-45.3088404-45.43829334z", "p-id": "840" })));
    }

    var __assign$1R = (undefined && undefined.__assign) || function () {
        __assign$1R = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1R.apply(this, arguments);
    };
    var __rest$Y = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$1i = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    function Checkbox$1(baseProps, ref) {
        var _a;
        var inputRef = React.useRef(null);
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, {}, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Checkbox);
        var context = React.useContext(CheckboxGroupContext);
        var prefixCls = getPrefixCls('checkbox');
        var onGroupChange = context.onGroupChange;
        var mergeProps = __assign$1R({}, props);
        if (context.isCheckboxGroup) {
            mergeProps.checked = context.checkboxGroupValue.indexOf(props.value) !== -1;
            mergeProps.disabled = 'disabled' in props ? props.disabled : context.disabled;
        }
        var disabled = mergeProps.disabled, children = mergeProps.children, className = mergeProps.className, value = mergeProps.value, style = mergeProps.style, indeterminate = mergeProps.indeterminate, error = mergeProps.error, rest = __rest$Y(mergeProps, ["disabled", "children", "className", "value", "style", "indeterminate", "error"]);
        var _c = __read$1i(useMergeValue(false, {
            value: mergeProps.checked,
            defaultValue: mergeProps.defaultChecked,
        }), 2), checked = _c[0], setChecked = _c[1];
        var classNames = cs(prefixCls, (_a = {},
            _a[prefixCls + "-disabled"] = !!disabled,
            _a[prefixCls + "-indeterminate"] = !!indeterminate,
            _a[prefixCls + "-checked"] = checked,
            _a[prefixCls + "-rtl"] = rtl,
            _a.error = error,
            _a), className);
        React.useEffect(function () {
            context.registerValue(value);
            return function () {
                context.unRegisterValue(value);
            };
        }, [value]);
        var onChange = React.useCallback(function (e) {
            e.persist();
            e.stopPropagation();
            setChecked(e.target.checked);
            if (context.isCheckboxGroup) {
                onGroupChange && onGroupChange(props.value, e.target.checked, e);
            }
            props.onChange && props.onChange(e.target.checked, e);
        }, [onGroupChange, context.isCheckboxGroup, props.onChange, props.value]);
        var onLabelClick = React.useCallback(function (e) {
            if (isFunction$1(props.children)) {
                // 避免children中含有表单元素造成label无法触发input的onchange的情况
                e.preventDefault();
                inputRef.current && inputRef.current.click();
            }
            rest.onClick && rest.onClick(e);
        }, [props.children, rest.onClick]);
        var icon = React.createElement(IconCheck$2, { className: prefixCls + "-mask-icon" });
        if (mergeProps.icon) {
            if (React.isValidElement(mergeProps.icon)) {
                icon = React.cloneElement(mergeProps.icon, {
                    className: prefixCls + "-mask-icon",
                });
            }
            else {
                icon = mergeProps.icon;
            }
        }
        return (React.createElement("label", __assign$1R({ ref: ref, "aria-disabled": disabled }, omit$1(rest, ['onChange']), { onClick: onLabelClick, className: classNames, style: style }),
            React.createElement("input", { value: value, disabled: !!disabled, ref: inputRef, checked: !!checked, onChange: onChange, 
                // To avoid triggering onChange twice in Select if it's used in Select option.
                onClick: function (e) { return e.stopPropagation(); }, type: "checkbox" }),
            isFunction$1(children) ? (children({ checked: checked, indeterminate: indeterminate })) : (React.createElement(React.Fragment, null,
                React.createElement(IconHover, { prefix: prefixCls, className: prefixCls + "-mask-wrapper", disabled: checked || disabled || indeterminate },
                    React.createElement("div", { className: prefixCls + "-mask" }, icon)),
                children && React.createElement("span", { className: prefixCls + "-text" }, children)))));
    }
    var CheckboxComponent = React.forwardRef(Checkbox$1);
    CheckboxComponent.displayName = 'Checkbox';
    CheckboxComponent.Group = Group$1;
    CheckboxComponent.useCheckbox = useCheckbox$1;
    var Checkbox$2 = CheckboxComponent;

    var __assign$1Q = (undefined && undefined.__assign) || function () {
        __assign$1Q = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1Q.apply(this, arguments);
    };
    var __rest$X = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function Option$3(props, ref) {
        var _a, _b;
        var style = props.style, className = props.className, wrapperClassName = props.wrapperClassName, disabled = props.disabled, prefixCls = props.prefixCls, rtl = props.rtl, propValue = props.value, propChildren = props.children, _isMultipleMode = props._isMultipleMode, _isUserCreatedOption = props._isUserCreatedOption, _isUserCreatingOption = props._isUserCreatingOption, _valueActive = props._valueActive, _valueSelect = props._valueSelect, _onMouseEnter = props._onMouseEnter, _onMouseLeave = props._onMouseLeave, _onClick = props._onClick, rest = __rest$X(props, ["style", "className", "wrapperClassName", "disabled", "prefixCls", "rtl", "value", "children", "_isMultipleMode", "_isUserCreatedOption", "_isUserCreatingOption", "_valueActive", "_valueSelect", "_onMouseEnter", "_onMouseLeave", "_onClick"]);
        var value = 'value' in props ? propValue : "" + propChildren;
        var childNode = 'children' in props ? propChildren : "" + propValue;
        var isChecked = _isMultipleMode
            ? _valueSelect.indexOf(value) !== -1
            : _valueSelect === value;
        var optionLabelProps = __assign$1Q({ style: style, className: cs(prefixCls + "-option", (_a = {},
                _a[prefixCls + "-option-selected"] = isChecked,
                _a[prefixCls + "-option-disabled"] = disabled,
                _a[prefixCls + "-option-hover"] = value === _valueActive,
                _a[prefixCls + "-option-empty"] = !childNode && childNode !== 0,
                _a[prefixCls + "-option-rtl"] = rtl,
                _a), className), onMouseEnter: function (event) {
                _onMouseEnter && _onMouseEnter(value);
                rest.onMouseEnter && rest.onMouseEnter(event);
            }, onMouseLeave: function (event) {
                _onMouseLeave && _onMouseLeave();
                rest.onMouseLeave && rest.onMouseLeave(event);
            }, onClick: function (event) {
                _onClick && _onClick(value, disabled);
                rest.onClick && rest.onClick(event);
            } }, omit$1(rest, ['_key', 'extra', 'isSelectOption', 'onClick', 'onMouseEnter', 'onMouseLeave']));
        var wrapperProps = {
            ref: ref,
            role: 'option',
            'aria-selected': isChecked,
        };
        // Mark the option that created/creating by user self
        _isUserCreatedOption && Object.assign(wrapperProps, { 'data-user-created': true });
        _isUserCreatingOption && Object.assign(wrapperProps, { 'data-user-creating': true });
        if (_isMultipleMode) {
            return (React.createElement("li", __assign$1Q({}, wrapperProps, { className: cs(prefixCls + "-option-wrapper", (_b = {},
                    _b[prefixCls + "-option-wrapper-selected"] = isChecked,
                    _b[prefixCls + "-option-wrapper-disabled"] = disabled,
                    _b), wrapperClassName) }),
                React.createElement(Checkbox$2, { "aria-hidden": "true", className: prefixCls + "-checkbox", checked: isChecked, disabled: disabled, onChange: optionLabelProps.onClick }),
                React.createElement("span", __assign$1Q({}, optionLabelProps), childNode)));
        }
        return (React.createElement("li", __assign$1Q({}, wrapperProps, optionLabelProps), childNode));
    }
    var ForwordRefOption = React.forwardRef(Option$3);
    var OptionComponent = ForwordRefOption;
    OptionComponent.__ARCO_SELECT_OPTION__ = true;
    var Option$4 = OptionComponent;

    var stringifyHotkey = function (k) {
        return JSON.stringify({
            code: k.code,
            ctrl: !!k.ctrl,
            shift: !!k.shift,
            alt: !!k.alt,
            meta: !!k.meta,
        });
    };
    /**
     * @param hotkeyMap - 快捷键描述对象
     */
    function getHotkeyHandler(hotkeyMap) {
        var map = {};
        hotkeyMap.forEach(function (callback, hotkey) {
            hotkey = typeof hotkey === 'number' ? { code: hotkey } : hotkey;
            map[stringifyHotkey(hotkey)] = callback;
        });
        return function (event) {
            var key = stringifyHotkey({
                code: event.keyCode || event.which,
                ctrl: !!event.ctrlKey,
                shift: !!event.shiftKey,
                alt: !!event.altKey,
                meta: !!event.metaKey,
            });
            var callback = map[key];
            if (callback) {
                event.stopPropagation();
                if (callback(event) === false) {
                    event.preventDefault();
                }
            }
        };
    }

    function ownKeys$H(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$I(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$H(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$H(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconDownComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$I(_objectSpread$I({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-down")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M39.6 17.443 24.043 33 8.487 17.443"
      }));
    }

    var IconDown = /*#__PURE__*/React.forwardRef(IconDownComponent);
    IconDown.defaultProps = {
      isIcon: true
    };
    IconDown.displayName = 'IconDown';
    var IconDown$1 = IconDown;

    var __assign$1P = (undefined && undefined.__assign) || function () {
        __assign$1P = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1P.apply(this, arguments);
    };
    var __rest$W = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$1h = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    // 色板里的 12 个颜色
    var COLORS = [
        'red',
        'orangered',
        'orange',
        'gold',
        'lime',
        'green',
        'cyan',
        'blue',
        'arcoblue',
        'purple',
        'pinkpurple',
        'magenta',
        'gray',
    ];
    var defaultProps$B = {
        size: 'default',
    };
    function Tag(baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var getKeyboardEvents = useKeyboardEvent();
        var props = useMergeProps(baseProps, defaultProps$B, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Tag);
        var className = props.className, style = props.style, children = props.children, color = props.color, closable = props.closable, checkable = props.checkable, defaultChecked = props.defaultChecked, size = props.size, onClose = props.onClose, onCheck = props.onCheck, icon = props.icon, closeIcon = props.closeIcon, bordered = props.bordered, rest = __rest$W(props, ["className", "style", "children", "color", "closable", "checkable", "defaultChecked", "size", "onClose", "onCheck", "icon", "closeIcon", "bordered"]);
        var prefixCls = getPrefixCls('tag');
        var _c = __read$1h(React.useState('visible' in props ? props.visible : true), 2), visible = _c[0], setVisible = _c[1];
        var _d = __read$1h(React.useState('checked' in props ? props.checked : defaultChecked), 2), checked = _d[0], setChecked = _d[1];
        var _e = __read$1h(React.useState(), 2), loading = _e[0], setLoading = _e[1];
        // controlled
        var mergedChecked = 'checked' in props ? props.checked : checked;
        var mergedVisible = 'visible' in props ? props.visible : visible;
        function onHandleClose(e) {
            var ret = onClose && onClose(e);
            if (ret && ret.then) {
                setLoading(true);
                ret
                    .then(function () {
                    setLoading(false);
                    setVisible(false);
                })
                    .catch(function () {
                    setLoading(false);
                });
            }
            else {
                setVisible(false);
            }
        }
        function onHandleCheck() {
            var newChecked = !mergedChecked;
            if (!('checked' in props)) {
                setChecked(newChecked);
            }
            onCheck && onCheck(newChecked);
        }
        var _color = color ? (COLORS.indexOf(color) !== -1 ? color : '') : '';
        var _checked = checkable ? mergedChecked : true;
        var classNames = cs(prefixCls, (_a = {},
            _a[prefixCls + "-loading"] = loading,
            _a[prefixCls + "-hide"] = !mergedVisible,
            _a[prefixCls + "-" + _color] = _color,
            _a[prefixCls + "-checkable"] = checkable,
            _a[prefixCls + "-checked"] = _checked,
            _a[prefixCls + "-size-" + size] = size,
            _a[prefixCls + "-bordered"] = bordered,
            _a[prefixCls + "-custom-color"] = _checked && color && !_color,
            _a[prefixCls + "-rtl"] = rtl,
            _a), className);
        var colorStyle = __assign$1P({}, style);
        if (color && !_color && _checked) {
            colorStyle.backgroundColor = color;
            colorStyle.borderColor = color;
        }
        var otherProps = omit$1(rest, ['visible']);
        if (checkable) {
            otherProps.onClick = onHandleCheck;
        }
        return (React.createElement("div", __assign$1P({ ref: ref, style: colorStyle, className: classNames }, otherProps),
            icon && React.createElement("span", { className: prefixCls + "-icon" }, icon),
            React.createElement("span", { className: prefixCls + "-content" }, children),
            closable && !loading && closeIcon !== null && (React.createElement(IconHover, __assign$1P({ prefix: prefixCls, className: prefixCls + "-close-btn", onClick: onHandleClose, role: "button", tabIndex: 0 }, getKeyboardEvents({ onPressEnter: onHandleClose }), { "aria-label": "Close" }), closeIcon !== undefined ? closeIcon : React.createElement(IconClose$1, null))),
            loading && (React.createElement("span", { className: prefixCls + "-loading-icon" },
                React.createElement(IconLoading$1, null)))));
    }
    var TagComponent = React.forwardRef(Tag);
    TagComponent.displayName = 'Tag';
    var Tag$1 = TagComponent;

    var __read$1g = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    function Item$5(props) {
        var _a;
        var prefixCls = props.prefixCls, style = props.style, children = props.children, direction = props.direction, disabled = props.disabled, _b = props.droppable, droppable = _b === void 0 ? true : _b, onDrop = props.onDrop, onDragStart = props.onDragStart, onDragEnd = props.onDragEnd, onDragOver = props.onDragOver, onDragLeave = props.onDragLeave;
        var refItem = React.useRef(null);
        var refDraggedTimer = React.useRef(null);
        var _c = __read$1g(React.useState('none'), 2), dragStatus = _c[0], setDragStatus = _c[1];
        var _d = __read$1g(React.useState(false), 2), dragOver = _d[0], setDragOver = _d[1];
        var _e = __read$1g(React.useState(null), 2), dragPosition = _e[0], setDragPosition = _e[1];
        React.useEffect(function () {
            return function () {
                refDraggedTimer.current && clearTimeout(refDraggedTimer.current);
            };
        }, []);
        React.useEffect(function () {
            if (dragStatus === 'dragged') {
                refDraggedTimer.current = setTimeout(function () { return setDragStatus('none'); }, 1000);
            }
        }, [dragStatus]);
        return (React.createElement("li", { draggable: true, ref: refItem, style: style, className: cs(prefixCls + "-item", (_a = {},
                _a[prefixCls + "-item-" + dragStatus] = dragStatus !== 'none',
                _a[prefixCls + "-item-gap-" + dragPosition] = dragPosition,
                _a[prefixCls + "-item-disabled"] = disabled,
                _a[prefixCls + "-item-dragover"] = dragOver,
                _a)), onDragStart: function (event) {
                event.stopPropagation();
                setDragStatus('dragging');
                try {
                    // ie throw error
                    // firefox-need-it
                    event.dataTransfer.setData('text/plain', '');
                }
                catch (error) { }
                onDragStart && onDragStart(event);
            }, onDragEnd: function (event) {
                event.stopPropagation();
                setDragOver(false);
                setDragStatus('dragged');
                onDragEnd && onDragEnd(event);
            }, onDragOver: function (event) {
                if (droppable) {
                    event.stopPropagation();
                    event.preventDefault();
                    var rect = refItem.current.getBoundingClientRect();
                    if (direction === 'vertical') {
                        setDragPosition(event.pageY > window.pageYOffset + rect.top + rect.height / 2 ? 'bottom' : 'top');
                    }
                    else {
                        setDragPosition(event.pageX > window.pageXOffset + rect.left + rect.width / 2 ? 'right' : 'left');
                    }
                    setDragOver(true);
                    onDragOver && onDragOver(event);
                }
            }, onDragLeave: function (event) {
                if (droppable) {
                    event.stopPropagation();
                    setDragOver(false);
                    onDragLeave && onDragLeave(event);
                }
            }, onDrop: function (event) {
                if (droppable) {
                    event.stopPropagation();
                    event.preventDefault();
                    setDragOver(false);
                    setDragPosition(null);
                    setDragStatus('none');
                    onDrop && onDrop(event, dragPosition);
                }
            } }, children));
    }

    var __read$1f = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    function Draggable(props) {
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var prefixCls = getPrefixCls('draggable');
        var className = props.className, children = props.children, _a = props.direction, direction = _a === void 0 ? 'vertical' : _a, onIndexChange = props.onIndexChange, itemWrapperStyle = props.itemWrapperStyle;
        var _b = __read$1f(React.useState(null), 2), dragItemIndex = _b[0], setDragItemIndex = _b[1];
        return (React.createElement("div", { className: cs(prefixCls, className) }, React.Children.map(children, function (child, index) {
            return (React.createElement(Item$5, { style: itemWrapperStyle, prefixCls: prefixCls, direction: direction, onDragStart: function () { return setDragItemIndex(index); }, onDragEnd: function () { return setDragItemIndex(null); }, onDrop: function (_, dropPosition) {
                    var prevIndex = dragItemIndex;
                    var nextIndex = dropPosition === 'left' || dropPosition === 'top' ? index : index + 1;
                    if (onIndexChange && prevIndex !== nextIndex) {
                        onIndexChange(nextIndex, prevIndex);
                    }
                } }, child));
        })));
    }

    var __assign$1O = (undefined && undefined.__assign) || function () {
        __assign$1O = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1O.apply(this, arguments);
    };
    var __awaiter$6 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$6 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __rest$V = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$1e = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$w = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var CSS_TRANSITION_DURATION = 300;
    var REACT_KEY_FOR_INPUT = "__input_" + Math.random().toFixed(10).slice(2);
    // 输入框粘贴会先触发 onPaste 后触发 onChange，但 onChange 的 value 中不包含换行符
    // 如果刚刚因为粘贴触发过分词，则 onChange 不再进行分词尝试
    var THRESHOLD_TOKEN_SEPARATOR_TRIGGER$1 = 100;
    var keepFocus = function (e) {
        e.target.tagName !== 'INPUT' && e.preventDefault();
    };
    var formatValue$1 = function (value) {
        if (!isArray$1(value)) {
            return [];
        }
        return value.map(function (item) {
            return isObject$1(item)
                ? __assign$1O(__assign$1O({}, item), { label: 'label' in item ? item.label : item.value, value: item.value, closable: item.closable }) : {
                label: item,
                value: item,
            };
        });
    };
    // Deal with the delay of recomputing input width
    var useComputeAutoWidthDelay = function (value) {
        var refDelay = React.useRef(0);
        var refPrevValueLength = React.useRef(value.length);
        React.useEffect(function () {
            refDelay.current =
                value.length === 0 && refPrevValueLength.current > 0 ? CSS_TRANSITION_DURATION : 0;
            refPrevValueLength.current = value.length;
        }, [value]);
        return refDelay;
    };
    var UsedTransitionGroup = function (_a) {
        var prefixCls = _a.prefixCls, children = _a.children, animation = _a.animation;
        return animation ? (React.createElement(TransitionGroup$1, { component: "div", className: prefixCls + "-inner" }, children)) : (React.createElement("div", { className: prefixCls + "-inner" }, children));
    };
    var defaultProps$A = {
        animation: true,
        validate: function (inputValue, values) { return inputValue && values.every(function (item) { return item.value !== inputValue; }); },
    };
    function InputTag(baseProps, ref) {
        var _a;
        var _this = this;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, ctxSize = _b.size, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$A, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.InputTag);
        var className = props.className, style = props.style, placeholder = props.placeholder, error = props.error, disabled = props.disabled, readOnly = props.readOnly, allowClear = props.allowClear, autoFocus = props.autoFocus, labelInValue = props.labelInValue, disableInput = props.disableInput, animation = props.animation, saveOnBlur = props.saveOnBlur, dragToSort = props.dragToSort, icon = props.icon, suffix = props.suffix, tokenSeparators = props.tokenSeparators, validate = props.validate, renderTag = props.renderTag, tagClassName = props.tagClassName, onInputChange = props.onInputChange, onKeyDown = props.onKeyDown, onPaste = props.onPaste, onChange = props.onChange, onFocus = props.onFocus, onBlur = props.onBlur, onPressEnter = props.onPressEnter, onRemove = props.onRemove, onClear = props.onClear, onClick = props.onClick, rest = __rest$V(props, ["className", "style", "placeholder", "error", "disabled", "readOnly", "allowClear", "autoFocus", "labelInValue", "disableInput", "animation", "saveOnBlur", "dragToSort", "icon", "suffix", "tokenSeparators", "validate", "renderTag", "tagClassName", "onInputChange", "onKeyDown", "onPaste", "onChange", "onFocus", "onBlur", "onPressEnter", "onRemove", "onClear", "onClick"]);
        var prefixCls = getPrefixCls('input-tag');
        var size = 'size' in props ? props.size : ctxSize;
        var refInput = React.useRef();
        var refTSLastSeparateTriggered = React.useRef(null);
        var _c = __read$1e(React.useState(false), 2), focused = _c[0], setFocused = _c[1];
        var _d = __read$1e(useMergeValue([], {
            defaultValue: 'defaultValue' in props ? formatValue$1(props.defaultValue) : undefined,
            value: 'value' in props ? formatValue$1(props.value) : undefined,
        }), 2), value = _d[0], setValue = _d[1];
        var _e = __read$1e(useMergeValue('', {
            value: props.inputValue,
        }), 2), inputValue = _e[0], setInputValue = _e[1];
        var refDelay = useComputeAutoWidthDelay(value);
        var draggable = !!(dragToSort && !readOnly && !disabled);
        React.useImperativeHandle(ref, function () {
            var _a, _b;
            return {
                blur: (_a = refInput.current) === null || _a === void 0 ? void 0 : _a.blur,
                focus: (_b = refInput.current) === null || _b === void 0 ? void 0 : _b.focus,
            };
        }, []);
        var valueChangeHandler = function (value, reason) {
            if (disabled || readOnly) {
                return;
            }
            if (!('value' in props)) {
                setValue(value);
            }
            onChange && onChange(labelInValue ? value : value.map(function (x) { return x.value; }), reason);
        };
        var tagCloseHandler = function (itemValue, index, event) {
            onRemove && onRemove(itemValue, index, event);
            valueChangeHandler(__spreadArray$w(__spreadArray$w([], __read$1e(value.slice(0, index)), false), __read$1e(value.slice(index + 1)), false), 'remove');
        };
        var hotkeyHandler = getHotkeyHandler(new Map([
            [
                Backspace.code,
                function (event) {
                    if (!event.target.value && value.length) {
                        for (var index = value.length - 1; index >= 0; index--) {
                            var itemValue = value[index];
                            if (itemValue.closable !== false) {
                                tagCloseHandler(itemValue, index, event);
                                return;
                            }
                        }
                    }
                },
            ],
        ]));
        var tryAddInputValueToTag = function () { return __awaiter$6(_this, void 0, void 0, function () {
            var validateResult, _a, error_1;
            return __generator$6(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 4, , 5]);
                        if (!(typeof validate === 'function')) return [3 /*break*/, 2];
                        return [4 /*yield*/, validate(inputValue, value)];
                    case 1:
                        _a = _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        _a = true;
                        _b.label = 3;
                    case 3:
                        validateResult = _a;
                        if (validateResult) {
                            valueChangeHandler(value.concat({
                                value: validateResult === true ? inputValue : validateResult,
                                label: inputValue,
                            }), 'add');
                            setInputValue('');
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        error_1 = _b.sent();
                        console.error(error_1);
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        }); };
        var mergedRenderTag = function (item, index) {
            var _a;
            var itemValue = item.value, label = item.label;
            var closable = !readOnly && !disabled && item.closable !== false;
            var onClose = function (event) {
                tagCloseHandler(item, index, event);
            };
            if (renderTag) {
                return renderTag({
                    value: itemValue,
                    label: label,
                    closable: closable,
                    onClose: onClose,
                }, index, value);
            }
            return (React.createElement(Tag$1, { visible: true, className: cs(prefixCls + "-tag", (_a = {},
                    _a[tagClassName] = tagClassName,
                    _a)), closable: closable, closeIcon: icon && icon.removeIcon, title: typeof label === 'string' ? label : undefined, onClose: onClose }, fillNBSP(label)));
        };
        var handleTokenSeparators = function (str) {
            var hasSeparator = false;
            if (isArray$1(tokenSeparators) && tokenSeparators.length) {
                var rawSplitText = str.split(new RegExp("[" + tokenSeparators.join('') + "]"));
                if (rawSplitText.length > 1) {
                    // remove empty string
                    var splitText = rawSplitText.filter(function (str) { return str; });
                    if (splitText.length) {
                        valueChangeHandler(value.concat(splitText.map(function (text) { return ({
                            value: text,
                            label: text,
                            closable: true,
                        }); })), 'add');
                        hasSeparator = true;
                    }
                }
            }
            return hasSeparator;
        };
        var clearIcon = allowClear && !disabled && !readOnly && value.length ? (React.createElement(IconHover, { size: size, key: "clearIcon", className: prefixCls + "-clear-icon", onClick: function (e) {
                var _a;
                e.stopPropagation();
                valueChangeHandler([], 'clear');
                if (!focused) {
                    (_a = refInput.current) === null || _a === void 0 ? void 0 : _a.focus();
                }
                onClear && onClear();
            }, onMouseDown: keepFocus }, (icon && icon.clearIcon) || React.createElement(IconClose$1, null))) : null;
        var hasSuffix = !!(clearIcon || suffix);
        var disableInputComponent = disabled || disableInput;
        // CSSTransition needs to be a direct child of TransitionGroup, otherwise the animation will NOT work
        // https://github.com/arco-design/arco-design/issues/622
        var childrenWithAnimation = value
            .map(function (x, i) {
            // Check whether two tags have same value. If so, set different key for them to avoid only rendering one tag.
            var isRepeat = value.findIndex(function (item) { return item.value === x.value; }) !== i;
            var eleTag = mergedRenderTag(x, i);
            return React.isValidElement(eleTag) ? (React.createElement(CSSTransition$1, { key: typeof x.value === 'object' ? i : isRepeat ? x.value + "-" + i : x.value, timeout: CSS_TRANSITION_DURATION, classNames: "zoomIn" }, eleTag)) : (eleTag);
        })
            .concat(React.createElement(CSSTransition$1, { key: REACT_KEY_FOR_INPUT, timeout: CSS_TRANSITION_DURATION, classNames: "zoomIn" },
            React.createElement(InputComponent$1, { autoComplete: "off", size: size, disabled: disableInputComponent, readOnly: readOnly, ref: refInput, autoFocus: autoFocus, placeholder: !value.length ? placeholder : '', prefixCls: prefixCls + "-input", autoFitWidth: {
                    delay: function () { return refDelay.current; },
                }, onPressEnter: function (e) { return __awaiter$6(_this, void 0, void 0, function () {
                    return __generator$6(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                inputValue && e.preventDefault();
                                onPressEnter === null || onPressEnter === void 0 ? void 0 : onPressEnter(e);
                                return [4 /*yield*/, tryAddInputValueToTag()];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); }, onFocus: function (e) {
                    if (!disableInputComponent && !readOnly) {
                        setFocused(true);
                        onFocus === null || onFocus === void 0 ? void 0 : onFocus(e);
                    }
                }, onBlur: function (e) { return __awaiter$6(_this, void 0, void 0, function () {
                    return __generator$6(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                setFocused(false);
                                onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
                                if (!saveOnBlur) return [3 /*break*/, 2];
                                return [4 /*yield*/, tryAddInputValueToTag()];
                            case 1:
                                _a.sent();
                                _a.label = 2;
                            case 2:
                                setInputValue('');
                                return [2 /*return*/];
                        }
                    });
                }); }, value: inputValue, onChange: function (value, event) {
                    var inputType = event.nativeEvent.inputType;
                    if ((inputType === 'insertFromPaste' &&
                        Date.now() - refTSLastSeparateTriggered.current <
                            THRESHOLD_TOKEN_SEPARATOR_TRIGGER$1) ||
                        handleTokenSeparators(value)) {
                        setInputValue('');
                    }
                    else {
                        setInputValue(value);
                    }
                    // Only fire callback on user input to ensure parent component can get real input value on controlled mode.
                    onInputChange === null || onInputChange === void 0 ? void 0 : onInputChange(value, event);
                }, onKeyDown: function (event) {
                    hotkeyHandler(event);
                    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(event);
                }, onPaste: function (event) {
                    if (handleTokenSeparators(event.clipboardData.getData('text'))) {
                        refTSLastSeparateTriggered.current = Date.now();
                    }
                    onPaste === null || onPaste === void 0 ? void 0 : onPaste(event);
                } })));
        return (React.createElement("div", __assign$1O({}, omit$1(rest, ['size', 'defaultValue', 'value', 'inputValue']), { style: style, className: cs(prefixCls, (_a = {},
                _a[prefixCls + "-size-" + size] = size,
                _a[prefixCls + "-disabled"] = disabled,
                _a[prefixCls + "-error"] = error,
                _a[prefixCls + "-focus"] = focused,
                _a[prefixCls + "-readonly"] = readOnly,
                _a[prefixCls + "-has-suffix"] = hasSuffix,
                _a[prefixCls + "-has-placeholder"] = !value.length,
                _a[prefixCls + "-rtl"] = rtl,
                _a), className), onMouseDown: function (event) {
                focused && keepFocus(event);
            }, onClick: function (e) {
                var _a;
                !focused && ((_a = refInput.current) === null || _a === void 0 ? void 0 : _a.focus());
                if (onClick) {
                    onClick(e);
                }
            } }),
            React.createElement("div", { className: prefixCls + "-view" },
                draggable ? (React.createElement(UsedTransitionGroup, { key: "transitionGroupWithDrag", prefixCls: prefixCls, animation: animation },
                    React.createElement(Draggable, { itemWrapperStyle: { display: 'inline-block' }, direction: "horizontal", onIndexChange: function (index, prevIndex) {
                            var moveItem = function (arr, fromIndex, toIndex) {
                                arr = arr.slice();
                                var isMoveLeft = fromIndex > toIndex;
                                var _a = __read$1e(arr.splice(fromIndex, 1), 1), item = _a[0];
                                arr.splice(isMoveLeft ? toIndex : toIndex - 1, 0, item);
                                return arr;
                            };
                            valueChangeHandler(moveItem(value, prevIndex, index), 'sort');
                        } }, childrenWithAnimation))) : (React.createElement(UsedTransitionGroup, { prefixCls: prefixCls, animation: animation }, childrenWithAnimation)),
                hasSuffix && (React.createElement("div", { className: prefixCls + "-suffix", onMouseDown: keepFocus },
                    clearIcon,
                    suffix)))));
    }
    var InputTagRef = React.forwardRef(InputTag);
    InputTagRef.displayName = 'InputTag';
    var InputTag$1 = InputTagRef;

    // return an object with specify keys
    function include(obj, keys) {
        var clone = {};
        Object.keys(obj).forEach(function (key) {
            if (keys.indexOf(key) !== -1) {
                clone[key] = obj[key];
            }
        });
        return clone;
    }

    var __read$1d = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    function useForceUpdate() {
        var _a = __read$1d(React.useReducer(function (v) { return v + 1; }, 0), 2), dispatch = _a[1];
        return dispatch;
    }

    var __assign$1N = (undefined && undefined.__assign) || function () {
        __assign$1N = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1N.apply(this, arguments);
    };
    var __rest$U = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$1c = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var SearchStatus = {
        BEFORE: 0,
        EDITING: 1,
        NONE: 2,
    };
    var SelectView = function (props, ref) {
        var _a, _b, _c;
        var style = props.style, className = props.className, size = props.size, bordered = props.bordered, allowClear = props.allowClear, allowCreate = props.allowCreate, error = props.error, loading = props.loading, disabled = props.disabled, animation = props.animation, prefixCls = props.prefixCls, suffixIcon = props.suffixIcon, arrowIcon = props.arrowIcon, removeIcon = props.removeIcon, clearIcon = props.clearIcon, placeholder = props.placeholder, renderView = props.renderView, renderText = props.renderText, value = props.value, inputValue = props.inputValue, popupVisible = props.popupVisible, maxTagCount = props.maxTagCount, isMultiple = props.isMultiple, isEmptyValue = props.isEmptyValue, prefix = props.prefix, ariaControls = props.ariaControls, renderTag = props.renderTag, dragToSort = props.dragToSort, addBefore = props.addBefore, 
        // addAfter,
        onKeyDown = props.onKeyDown, onChangeInputValue = props.onChangeInputValue, onPaste = props.onPaste, onClear = props.onClear, onFocus = props.onFocus, onBlur = props.onBlur, onRemoveCheckedItem = props.onRemoveCheckedItem, onSort = props.onSort, rtl = props.rtl, rest = __rest$U(props, ["style", "className", "size", "bordered", "allowClear", "allowCreate", "error", "loading", "disabled", "animation", "prefixCls", "suffixIcon", "arrowIcon", "removeIcon", "clearIcon", "placeholder", "renderView", "renderText", "value", "inputValue", "popupVisible", "maxTagCount", "isMultiple", "isEmptyValue", "prefix", "ariaControls", "renderTag", "dragToSort", "addBefore", "onKeyDown", "onChangeInputValue", "onPaste", "onClear", "onFocus", "onBlur", "onRemoveCheckedItem", "onSort", "rtl"]);
        // refs
        var refInput = React.useRef(null);
        var refWrapper = React.useRef(null);
        // state
        var _d = React.useContext(ConfigContext), ctxSize = _d.size, getPrefixCls = _d.getPrefixCls;
        var _e = __read$1c(React.useState(SearchStatus.NONE), 2), searchStatus = _e[0], setSearchStatus = _e[1];
        var _f = __read$1c(React.useState(false), 2), focused = _f[0], setFocused = _f[1];
        var forceUpdate = useForceUpdate();
        // TODO：Will the search be completely controlled by showSearch? Next major version needs to be considered
        var showSearch = 'showSearch' in props ? props.showSearch : isMultiple;
        var canFocusInput = showSearch || allowCreate;
        var mergedSize = size || ctxSize;
        var mergedFocused = focused || popupVisible;
        var isRetainInputValueSearch = isObject$1(showSearch) && showSearch.retainInputValue;
        // the formatted text of value.
        var renderedValue = !isMultiple && value !== undefined ? renderText(value).text : '';
        // Avoid losing focus caused by clicking certain icons
        var keepFocus = function (event) {
            event && event.preventDefault();
        };
        var handleFocus = function (action) {
            var element = canFocusInput ? refInput.current : refWrapper.current;
            if (element) {
                action === 'focus' ? element.focus() : element.blur();
            }
        };
        var tryTriggerFocusChange = function (action, event) {
            // The focus event at this time should be triggered by the input element
            if (canFocusInput && event.target === refWrapper.current) {
                return;
            }
            if (action === 'focus') {
                setFocused(true);
                onFocus && onFocus(event);
            }
            else {
                setFocused(false);
                onBlur && onBlur(event);
            }
        };
        var tryTriggerKeyDown = function (event) {
            // The keyboard event at this time should be triggered by the input element, ignoring the bubbling up keyboard event
            if (canFocusInput && event.currentTarget === refWrapper.current) {
                return;
            }
            // Prevent the default behavior of the browser when pressing Enter, to avoid submit event in <form>
            var keyCode = event.keyCode || event.which;
            if (keyCode === Enter.code) {
                event.preventDefault();
            }
            onKeyDown && onKeyDown(event);
        };
        React.useEffect(function () {
            handleFocus(popupVisible ? 'focus' : 'blur');
            if (canFocusInput) {
                setSearchStatus(popupVisible ? SearchStatus.BEFORE : SearchStatus.NONE);
            }
        }, [popupVisible]);
        React.useImperativeHandle(ref, function () { return ({
            dom: refWrapper.current,
            focus: handleFocus.bind(null, 'focus'),
            blur: handleFocus.bind(null, 'blur'),
            getWidth: function () { return refWrapper.current && refWrapper.current.clientWidth; },
        }); });
        var mergedArrowIcon = 'arrowIcon' in props ? (arrowIcon === null ? null : (React.createElement("div", { className: prefixCls + "-arrow-icon" }, arrowIcon))) : (React.createElement("div", { className: prefixCls + "-arrow-icon" },
            React.createElement(IconDown$1, null)));
        var mergedSuffixIcon = loading ? (React.createElement("span", { className: prefixCls + "-loading-icon" },
            React.createElement(IconLoading$1, null))) : suffixIcon ? (React.createElement("span", { className: prefixCls + "-suffix-icon" }, suffixIcon)) : props.showSearch && popupVisible ? (React.createElement("div", { className: prefixCls + "-search-icon" },
            React.createElement(IconSearch$1, null))) : (mergedArrowIcon);
        // event handling of input box
        var inputEventHandlers = {
            paste: onPaste,
            keyDown: tryTriggerKeyDown,
            focus: function (event) {
                event.stopPropagation();
                tryTriggerFocusChange('focus', event);
            },
            blur: function (event) {
                event.stopPropagation();
                tryTriggerFocusChange('blur', event);
            },
            change: function (newValue, event) {
                setSearchStatus(SearchStatus.EDITING);
                onChangeInputValue && onChangeInputValue(newValue, event);
            },
        };
        var renderSingle = function () {
            var _a, _b;
            var _inputValue;
            switch (searchStatus) {
                case SearchStatus.BEFORE:
                    _inputValue = inputValue || (isRetainInputValueSearch ? renderedValue : '');
                    break;
                case SearchStatus.EDITING:
                    _inputValue = inputValue || '';
                    break;
                default:
                    _inputValue = renderedValue;
                    break;
            }
            var inputProps = {
                style: { width: '100%' },
                // _inputValue after renderText(value) may be rich text, but the value of <input> cannot be object
                value: typeof _inputValue !== 'object' ? _inputValue : '',
                // Allow placeholder to display the selected value first when searching
                placeholder: canFocusInput && renderedValue && typeof renderedValue !== 'object'
                    ? renderedValue
                    : placeholder,
            };
            if (canFocusInput) {
                inputProps.onPaste = inputEventHandlers.paste;
                inputProps.onKeyDown = inputEventHandlers.keyDown;
                inputProps.onFocus = inputEventHandlers.focus;
                inputProps.onBlur = inputEventHandlers.blur;
                inputProps.onChange = inputEventHandlers.change;
            }
            else {
                // Avoid input getting focus by Tab
                // Do NOT pass [disabled] to <input>, otherwise the click event will not be triggered
                // https://stackoverflow.com/questions/7833854/jquery-detect-click-on-disabled-submit-button
                inputProps.tabIndex = -1;
                inputProps.style.pointerEvents = 'none';
            }
            // <input> is used to input and display placeholder, in other cases use <span> to display value to support displaying rich text
            var needShowInput = !!((mergedFocused && canFocusInput) || isEmptyValue);
            return (React.createElement("span", { className: prefixCls + "-view-selector" },
                React.createElement(InputComponent$1, __assign$1N({ "aria-hidden": !needShowInput || undefined, ref: refInput, disabled: disabled, className: cs(prefixCls + "-view-input", (_a = {},
                        _a[prefixCls + "-hidden"] = !needShowInput,
                        _a)), autoComplete: "off" }, inputProps)),
                React.createElement("span", { className: cs(prefixCls + "-view-value", (_b = {},
                        _b[prefixCls + "-view-value-mirror"] = needShowInput,
                        _b)) }, fillNBSP(isEmptyValue ? inputProps.placeholder : _inputValue))));
        };
        var renderMultiple = function () {
            var usedValue = isUndefined(value) ? [] : [].concat(value);
            var maxTagCountNumber = isObject$1(maxTagCount) ? maxTagCount.count : maxTagCount;
            var maxTagCountRender = isObject$1(maxTagCount) && isFunction$1(maxTagCount.render)
                ? maxTagCount.render
                : function (invisibleCount) { return "+" + invisibleCount + "..."; };
            var usedMaxTagCount = typeof maxTagCountNumber === 'number' ? Math.max(maxTagCountNumber, 0) : usedValue.length;
            var tagsToShow = [];
            var lastClosableTagIndex = -1;
            for (var i = usedValue.length - 1; i >= 0; i--) {
                var v = usedValue[i];
                var result = renderText(v);
                if (i < usedMaxTagCount) {
                    tagsToShow.unshift({
                        value: v,
                        label: result.text,
                        closable: !result.disabled,
                    });
                }
                if (!result.disabled && lastClosableTagIndex === -1) {
                    lastClosableTagIndex = i;
                }
            }
            var invisibleTagCount = usedValue.length - usedMaxTagCount;
            if (invisibleTagCount > 0) {
                tagsToShow.push({
                    label: maxTagCountRender(invisibleTagCount),
                    closable: false,
                    // InputTag needs to extract value as key
                    value: '__arco_value_tag_placeholder',
                });
            }
            var eventHandlers = {
                onPaste: inputEventHandlers.paste,
                onKeyDown: inputEventHandlers.keyDown,
                onFocus: inputEventHandlers.focus,
                onBlur: inputEventHandlers.blur,
                onInputChange: inputEventHandlers.change,
                onRemove: function (value, index, event) {
                    // Should always delete the last option value when press Backspace
                    var keyCode = event.keyCode || event.which;
                    if (keyCode === Backspace.code && lastClosableTagIndex > -1) {
                        value = usedValue[lastClosableTagIndex];
                        index = lastClosableTagIndex;
                    }
                    // If there is a limit on the maximum number of tags, the parameters passed into InputTag need to be recalculated
                    maxTagCount && forceUpdate();
                    onRemoveCheckedItem && onRemoveCheckedItem(value, index, event);
                },
            };
            return (React.createElement(InputTag$1
            // Avoid when clicking outside the browser window, InputTag out of focus
            , __assign$1N({ 
                // Avoid when clicking outside the browser window, InputTag out of focus
                className: mergedFocused ? getPrefixCls('input-tag') + "-focus" : '', ref: refInput, disabled: disabled, dragToSort: dragToSort, disableInput: !showSearch, animation: animation, placeholder: placeholder, value: tagsToShow, inputValue: inputValue, size: mergedSize, tagClassName: prefixCls + "-tag", renderTag: renderTag, icon: { removeIcon: removeIcon }, onChange: function (value, reason) {
                    if (onSort && reason === 'sort') {
                        onSort(value);
                    }
                } }, eventHandlers)));
        };
        var needAddBefore = addBefore !== null && addBefore !== undefined;
        // const needAddAfter = addAfter !== null && addAfter !== undefined;
        var needAddAfter = false;
        var needWrapper = needAddBefore || needAddAfter;
        var innerClassNames = cs(prefixCls, prefixCls + "-" + (isMultiple ? 'multiple' : 'single'), (_a = {},
            _a[prefixCls + "-show-search"] = showSearch,
            _a[prefixCls + "-open"] = popupVisible,
            _a[prefixCls + "-size-" + mergedSize] = mergedSize,
            _a[prefixCls + "-focused"] = mergedFocused,
            _a[prefixCls + "-error"] = error,
            _a[prefixCls + "-disabled"] = disabled,
            _a[prefixCls + "-no-border"] = !bordered,
            _a[prefixCls + "-rtl"] = rtl,
            _a));
        var dataAttributes = pickDataAttributes(rest);
        var propsAppendToRoot = __assign$1N({ style: style, className: className }, dataAttributes);
        var mergedClearIcon = !disabled && !isEmptyValue && allowClear ? (React.createElement(IconHover, { size: mergedSize, key: "clearIcon", className: prefixCls + "-clear-icon", onClick: onClear, onMouseDown: keepFocus }, clearIcon !== undefined && clearIcon !== null ? clearIcon : React.createElement(IconClose$1, null))) : null;
        var eleSelectView = (React.createElement("div", __assign$1N({ role: "combobox", "aria-haspopup": "listbox", "aria-autocomplete": "list", "aria-expanded": popupVisible, "aria-disabled": disabled, "aria-controls": ariaControls }, include(rest, ['onClick', 'onMouseEnter', 'onMouseLeave']), { ref: refWrapper, tabIndex: disabled ? -1 : 0, style: needWrapper ? undefined : style }, (needWrapper ? {} : propsAppendToRoot), { className: needWrapper ? innerClassNames : cs(innerClassNames, propsAppendToRoot.className), 
            // When there is an input box, the keyboard events are handled inside the input box to avoid triggering redundant events in the Chinese input method
            onKeyDown: tryTriggerKeyDown, onFocus: function (event) {
                if (!disabled && !dragToSort) {
                    // Focus on the input, otherwise you need to press the Tab key twice to focus on the input box
                    if (canFocusInput) {
                        refInput.current && refInput.current.focus();
                    }
                    else {
                        tryTriggerFocusChange('focus', event);
                    }
                }
            }, onBlur: function (event) { return tryTriggerFocusChange('blur', event); } }),
            React.createElement("div", { title: typeof renderedValue === 'string' ? renderedValue : undefined, className: cs(prefixCls + "-view", (_b = {},
                    _b[prefixCls + "-view-with-prefix"] = prefix,
                    _b)), onClick: function (e) { return popupVisible && canFocusInput && e.stopPropagation(); } },
                prefix && (React.createElement("div", { "aria-hidden": "true", className: cs(prefixCls + "-prefix"), onMouseDown: function (event) { return focused && keepFocus(event); } }, prefix)),
                isMultiple ? renderMultiple() : renderSingle(),
                React.createElement("div", { "aria-hidden": "true", className: prefixCls + "-suffix", onMouseDown: function (event) { return focused && keepFocus(event); } },
                    mergedClearIcon,
                    mergedSuffixIcon))));
        eleSelectView = typeof renderView === 'function' ? renderView(eleSelectView) : eleSelectView;
        if (!needWrapper) {
            return eleSelectView;
        }
        return (React.createElement("div", __assign$1N({}, propsAppendToRoot, { className: cs(prefixCls + "-wrapper", (_c = {},
                _c[prefixCls + "-wrapper-rtl"] = rtl,
                _c), propsAppendToRoot.className) }),
            needAddBefore && React.createElement("div", { className: prefixCls + "-addbefore" }, addBefore),
            eleSelectView));
    };
    var SelectViewComponent = React.forwardRef(SelectView);
    SelectViewComponent.displayName = 'SelectView';
    var SelectView$1 = SelectViewComponent;

    // 计算字符串长度，中文字符占两个长度
    function getStringLength (str) {
        var len = 0;
        for (var i = 0; i < str.length; i++) {
            if (str.charCodeAt(i) > 127 || str.charCodeAt(i) === 94) {
                len += 2;
            }
            else {
                len++;
            }
        }
        return len;
    }

    var __rest$T = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    /**
     * 为了计算方便，定位元素的下标可能返回数组长度，代表最后一个元素
     */
    var GHOST_ITEM_KEY = '__rc_ghost_item__';
    /**
     * 根据滚动条当前的滚动百分比，计算出基准元素
     * 在基准元素的上方和下方渲染可见区域的其他元素
     */
    function getLocationItem(scrollPtg, total) {
        var itemIndex = Math.floor(scrollPtg * total);
        var itemTopPtg = itemIndex / total;
        var offsetPtg = (scrollPtg - itemTopPtg) / (1 / total);
        return {
            index: itemIndex,
            // scrollPtg >= itemTopPtg，计算结果为元素应当补充的滚动距离相对自身高度的偏移量
            offsetPtg: Number.isNaN(offsetPtg) ? 0 : offsetPtg,
        };
    }
    /**
     * 获取HTML元素高度
     */
    function getNodeHeight(node, needMargin) {
        if (needMargin === void 0) { needMargin = false; }
        var element = ReactDOM.findDOMNode(node);
        var marginVertical = 0;
        if (needMargin) {
            var _a = window.getComputedStyle(node), marginTop = _a.marginTop, marginBottom = _a.marginBottom;
            marginVertical = Number(marginTop.replace(/\D/g, '')) + Number(marginBottom.replace(/\D/g, ''));
            marginVertical = isNaN(marginVertical) ? 0 : marginVertical;
        }
        return element ? element.offsetHeight + marginVertical : 0;
    }
    /**
     * 获取有效的scrollTop值
     * Safari的缓动效果会获得负值的scrollTop
     */
    function getValidScrollTop(scrollTop, scrollRange) {
        return scrollTop < 0 ? 0 : scrollTop > scrollRange ? scrollRange : scrollTop;
    }
    /**
     * 视口已滚动距离 / 总可滚动距离
     */
    function getScrollPercentage(_a) {
        var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
        var scrollRange = scrollHeight - clientHeight;
        return scrollRange <= 0 ? 0 : getValidScrollTop(scrollTop, scrollRange) / scrollRange;
    }
    /**
     * 计算需要渲染的元素的开始下标、结束下标和用于定位的元素下标
     */
    function getRangeIndex(scrollPtg, itemCount, visibleCount) {
        var _a = getLocationItem(scrollPtg, itemCount), index = _a.index, offsetPtg = _a.offsetPtg;
        var beforeCount = Math.ceil(scrollPtg * visibleCount);
        var afterCount = Math.ceil((1 - scrollPtg) * visibleCount);
        return {
            itemIndex: index,
            itemOffsetPtg: offsetPtg,
            startIndex: Math.max(0, index - beforeCount),
            endIndex: Math.min(itemCount - 1, index + afterCount),
        };
    }
    /**
     * 计算元素相对于视口顶部的偏移量
     */
    function getItemRelativeTop(_a) {
        var itemHeight = _a.itemHeight, itemOffsetPtg = _a.itemOffsetPtg, scrollPtg = _a.scrollPtg, clientHeight = _a.clientHeight;
        return Math.floor(clientHeight * scrollPtg - itemHeight * itemOffsetPtg);
    }
    /**
     * 计算元素相对于整个滚动区域顶部的偏移量
     */
    function getItemAbsoluteTop(_a) {
        var scrollTop = _a.scrollTop, rest = __rest$T(_a, ["scrollTop"]);
        return scrollTop + getItemRelativeTop(rest);
    }
    /**
     * 计算某一指定下标的元素相对于视口顶部的偏移量
     */
    function getCompareItemRelativeTop(_a) {
        var locatedItemRelativeTop = _a.locatedItemRelativeTop, locatedItemIndex = _a.locatedItemIndex, compareItemIndex = _a.compareItemIndex, startIndex = _a.startIndex, endIndex = _a.endIndex, getItemKey = _a.getItemKey, itemElementHeights = _a.itemElementHeights, itemHeight = _a.itemHeight;
        var compareItemTop = locatedItemRelativeTop;
        var compareItemKey = getItemKey(compareItemIndex);
        if (compareItemIndex <= locatedItemIndex) {
            for (var index = locatedItemIndex; index >= startIndex; index -= 1) {
                var key = getItemKey(index);
                if (key === compareItemKey) {
                    break;
                }
                var prevItemKey = getItemKey(index - 1);
                compareItemTop -= itemElementHeights[prevItemKey] || itemHeight;
            }
        }
        else {
            for (var index = locatedItemIndex; index <= endIndex; index += 1) {
                var key = getItemKey(index);
                if (key === compareItemKey) {
                    break;
                }
                compareItemTop += itemElementHeights[key] || itemHeight;
            }
        }
        return compareItemTop;
    }
    function getLongestItemIndex(data) {
        var result = -1;
        var length = 0;
        data.forEach(function (item, index) {
            var _a;
            item = typeof item === 'string' ? item : (_a = item.props) === null || _a === void 0 ? void 0 : _a.children;
            if (typeof item === 'string') {
                var _length = getStringLength(item);
                if (_length > length) {
                    length = _length;
                    result = index;
                }
            }
        });
        return result;
    }

    // https://github.com/react-component/virtual-list/blob/master/src/utils/algorithmUtil.ts
    /**
     * Get index with specific start index one by one. e.g.
     * min: 3, max: 9, start: 6
     *
     * Return index is:
     * [0]: 6
     * [1]: 7
     * [2]: 5
     * [3]: 8
     * [4]: 4
     * [5]: 9
     * [6]: 3
     */
    function getIndexByStartLoc(min, max, start, index) {
        var beforeCount = start - min;
        var afterCount = max - start;
        var balanceCount = Math.min(beforeCount, afterCount) * 2;
        // Balance
        if (index <= balanceCount) {
            var stepIndex = Math.floor(index / 2);
            if (index % 2) {
                return start + stepIndex + 1;
            }
            return start - stepIndex;
        }
        // One is out of range
        if (beforeCount > afterCount) {
            return start - (index - afterCount);
        }
        return start + (index - beforeCount);
    }
    /**
     * We assume that 2 list has only 1 item diff and others keeping the order.
     * So we can use dichotomy algorithm to find changed one.
     */
    function findListDiffIndex(originList, targetList, getKey) {
        var originLen = originList.length;
        var targetLen = targetList.length;
        var shortList;
        var longList;
        if (originLen === 0 && targetLen === 0) {
            return null;
        }
        if (originLen < targetLen) {
            shortList = originList;
            longList = targetList;
        }
        else {
            shortList = targetList;
            longList = originList;
        }
        var notExistKey = { __EMPTY_ITEM__: true };
        function getItemKey(item, index) {
            return item !== undefined ? getKey(item, index) : notExistKey;
        }
        // Loop to find diff one
        var diffIndex = null;
        var multiple = Math.abs(originLen - targetLen) !== 1;
        for (var i = 0; i < longList.length; i += 1) {
            var shortKey = getItemKey(shortList[i], i);
            var longKey = getItemKey(longList[i], i);
            if (shortKey !== longKey) {
                diffIndex = i;
                multiple = multiple || shortKey !== getItemKey(longList[i + 1], i + 1);
                break;
            }
        }
        return diffIndex === null ? null : { index: diffIndex, multiple: multiple };
    }

    var __assign$1M = (undefined && undefined.__assign) || function () {
        __assign$1M = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1M.apply(this, arguments);
    };

    /**
     * Create visual height for content
     */
    var Filler = function (_a) {
        var height = _a.height, offset = _a.offset, children = _a.children, propsOuterStyle = _a.outerStyle;
        var outerStyle = {};
        var innerStyle = {
            display: 'flex',
            flexDirection: 'column',
        };
        if (offset !== undefined) {
            outerStyle = __assign$1M({ height: height, position: 'relative', overflow: 'hidden', zIndex: 0 }, propsOuterStyle);
            innerStyle = __assign$1M(__assign$1M({}, innerStyle), { transform: "translateY(" + offset + "px)", position: 'absolute', left: 0, right: 0, top: 0 });
        }
        return (React.createElement("div", { style: outerStyle },
            React.createElement("div", { style: innerStyle }, children)));
    };
    var Filler$1 = Filler;

    var __assign$1L = (undefined && undefined.__assign) || function () {
        __assign$1L = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1L.apply(this, arguments);
    };
    var __rest$S = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$1b = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    // height of the virtual element, used to calculate total height of the virtual list
    var DEFAULT_VIRTUAL_ITEM_HEIGHT = 32;
    var KEY_VIRTUAL_ITEM_HEIGHT = "__virtual_item_height_" + Math.random().toFixed(5).slice(2);
    // after collecting the real height of the first screen element, calculate the virtual ItemHeight to trigger list re-rendering
    var useComputeVirtualItemHeight = function (refItemHeightMap) {
        var forceUpdate = useForceUpdate();
        var heightMap = refItemHeightMap.current;
        React.useEffect(function () {
            // virtual item height should be static as possible, otherwise it is easy to cause jitter
            if (Object.keys(heightMap).length && !heightMap[KEY_VIRTUAL_ITEM_HEIGHT]) {
                heightMap[KEY_VIRTUAL_ITEM_HEIGHT] = Object.entries(heightMap).reduce(function (sum, _a, currentIndex, array) {
                    var _b = __read$1b(_a, 2), currentHeight = _b[1];
                    var nextSum = sum + currentHeight;
                    return currentIndex === array.length - 1 ? Math.round(nextSum / array.length) : nextSum;
                }, 0);
                forceUpdate();
            }
        }, [Object.keys(heightMap).length]);
    };
    // cache the constructed results of child nodes to avoid redrawing of child nodes caused by re-construction during drawing
    var useCacheChildrenNodes = function (children) {
        var refCacheMap = React.useRef({});
        var refPrevChildren = React.useRef(children);
        React.useEffect(function () {
            refPrevChildren.current = children;
        }, [children]);
        // children change means state of parent component is updated, so clear cache
        if (children !== refPrevChildren.current) {
            refCacheMap.current = {};
        }
        return function (item, index, props) {
            if (!refCacheMap.current.hasOwnProperty(index)) {
                refCacheMap.current[index] = children(item, index, props);
            }
            return refCacheMap.current[index];
        };
    };
    var VirtualList = React.forwardRef(function (props, ref) {
        var style = props.style, className = props.className, children = props.children, _a = props.data, data = _a === void 0 ? [] : _a, itemKey = props.itemKey, _b = props.threshold, threshold = _b === void 0 ? 100 : _b, _c = props.wrapper, WrapperTagName = _c === void 0 ? 'div' : _c, _d = props.height, propHeight = _d === void 0 ? '100%' : _d, _e = props.isStaticItemHeight, isStaticItemHeight = _e === void 0 ? true : _e, propItemHeight = props.itemHeight, measureLongestItem = props.measureLongestItem, scrollOptions = props.scrollOptions, onScroll = props.onScroll, _f = props.needFiller, needFiller = _f === void 0 ? true : _f, outerStyle = props.outerStyle, restProps = __rest$S(props, ["style", "className", "children", "data", "itemKey", "threshold", "wrapper", "height", "isStaticItemHeight", "itemHeight", "measureLongestItem", "scrollOptions", "onScroll", "needFiller", "outerStyle"]);
        // Compatible with setting the height of the list through style.maxHeight
        var styleListMaxHeight = (style && style.maxHeight) || propHeight;
        var refItemHeightMap = React.useRef({});
        var _g = __read$1b(React.useState(200), 2), stateHeight = _g[0], setStateHeight = _g[1];
        var renderChild = useCacheChildrenNodes(children);
        useComputeVirtualItemHeight(refItemHeightMap);
        // Elements with the same height, the height of the item is based on the first rendering
        var itemCount = data.length;
        var itemHeight = propItemHeight ||
            refItemHeightMap.current[KEY_VIRTUAL_ITEM_HEIGHT] ||
            DEFAULT_VIRTUAL_ITEM_HEIGHT;
        var viewportHeight = isNumber(styleListMaxHeight) ? styleListMaxHeight : stateHeight;
        var itemCountVisible = Math.ceil(viewportHeight / itemHeight);
        var itemTotalHeight = itemHeight * itemCount;
        var isVirtual = threshold !== null && itemCount >= threshold && itemTotalHeight > viewportHeight;
        var refList = React.useRef(null);
        var refRafId = React.useRef(null);
        var refLockScroll = React.useRef(false);
        var refIsVirtual = React.useRef(isVirtual);
        // The paddingTop of the record scrolling list is used to correct the scrolling distance
        var scrollListPadding = React.useMemo(function () {
            if (refList.current) {
                var getPadding = function (property) {
                    return +window.getComputedStyle(refList.current)[property].replace(/\D/g, '');
                };
                return {
                    top: getPadding('paddingTop'),
                    bottom: getPadding('paddingBottom'),
                };
            }
            return { top: 0, bottom: 0 };
        }, [refList.current]);
        var _h = __read$1b(useStateWithPromise({
            // measure status
            status: 'NONE',
            // render range info
            startIndex: 0,
            endIndex: 0,
            itemIndex: 0,
            itemOffsetPtg: 0,
            // scroll info
            startItemTop: 0,
            scrollTop: 0,
        }), 2), state = _h[0], setState = _h[1];
        var prevData = usePrevious(data) || [];
        var isFirstRender = useIsFirstRender();
        var getItemKey = function (item, index) {
            return typeof itemKey === 'function'
                ? itemKey(item, index)
                : typeof itemKey === 'string'
                    ? item[itemKey]
                    : item.key || index;
        };
        var getItemKeyByIndex = function (index, items) {
            if (items === void 0) { items = data; }
            if (index === items.length) {
                return GHOST_ITEM_KEY;
            }
            var item = items[index];
            return item !== undefined ? getItemKey(item, index) : null;
        };
        var getCachedItemHeight = function (key) {
            return refItemHeightMap.current[key] || itemHeight;
        };
        var internalScrollTo = function (relativeScroll) {
            var compareItemIndex = relativeScroll.itemIndex, compareItemRelativeTop = relativeScroll.relativeTop;
            var _a = refList.current, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
            var originScrollTop = state.scrollTop;
            var maxScrollTop = scrollHeight - clientHeight;
            var bestSimilarity = Number.MAX_VALUE;
            var bestScrollTop = null;
            var bestItemIndex = null;
            var bestItemOffsetPtg = null;
            var bestStartIndex = null;
            var bestEndIndex = null;
            var missSimilarity = 0;
            for (var i = 0; i < maxScrollTop; i++) {
                var scrollTop = getIndexByStartLoc(0, maxScrollTop, originScrollTop, i);
                var scrollPtg = getScrollPercentage({ scrollTop: scrollTop, scrollHeight: scrollHeight, clientHeight: clientHeight });
                var _b = getRangeIndex(scrollPtg, itemCount, itemCountVisible), itemIndex = _b.itemIndex, itemOffsetPtg = _b.itemOffsetPtg, startIndex = _b.startIndex, endIndex = _b.endIndex;
                if (startIndex <= compareItemIndex && compareItemIndex <= endIndex) {
                    var locatedItemRelativeTop = getItemRelativeTop({
                        itemHeight: getCachedItemHeight(getItemKeyByIndex(itemIndex)),
                        itemOffsetPtg: itemOffsetPtg,
                        clientHeight: clientHeight,
                        scrollPtg: scrollPtg,
                    });
                    var compareItemTop = getCompareItemRelativeTop({
                        locatedItemRelativeTop: locatedItemRelativeTop,
                        locatedItemIndex: itemIndex,
                        compareItemIndex: compareItemIndex,
                        startIndex: startIndex,
                        endIndex: endIndex,
                        itemHeight: itemHeight,
                        getItemKey: getItemKeyByIndex,
                        itemElementHeights: refItemHeightMap.current,
                    });
                    var similarity = Math.abs(compareItemTop - compareItemRelativeTop);
                    if (similarity < bestSimilarity) {
                        bestSimilarity = similarity;
                        bestScrollTop = scrollTop;
                        bestItemIndex = itemIndex;
                        bestItemOffsetPtg = itemOffsetPtg;
                        bestStartIndex = startIndex;
                        bestEndIndex = endIndex;
                        missSimilarity = 0;
                    }
                    else {
                        missSimilarity += 1;
                    }
                }
                if (missSimilarity > 10) {
                    break;
                }
            }
            if (bestScrollTop !== null) {
                refLockScroll.current = true;
                refList.current.scrollTop = bestScrollTop;
                setState(__assign$1L(__assign$1L({}, state), { status: 'MEASURE_START', scrollTop: bestScrollTop, itemIndex: bestItemIndex, itemOffsetPtg: bestItemOffsetPtg, startIndex: bestStartIndex, endIndex: bestEndIndex }));
            }
            refRafId.current = raf(function () {
                refLockScroll.current = false;
            });
        };
        // Record the current element position when the real list is scrolled, and ensure that the position is correct after switching to the virtual list
        var rawListScrollHandler = function (event) {
            var _a = refList.current, rawScrollTop = _a.scrollTop, clientHeight = _a.clientHeight, scrollHeight = _a.scrollHeight;
            var scrollTop = getValidScrollTop(rawScrollTop, scrollHeight - clientHeight);
            var scrollPtg = getScrollPercentage({
                scrollTop: scrollTop,
                clientHeight: clientHeight,
                scrollHeight: scrollHeight,
            });
            var _b = getLocationItem(scrollPtg, itemCount), index = _b.index, offsetPtg = _b.offsetPtg;
            setState(__assign$1L(__assign$1L({}, state), { scrollTop: scrollTop, itemIndex: index, itemOffsetPtg: offsetPtg }));
            event && onScroll && onScroll(event);
        };
        // Modify the state and recalculate the position in the next render
        var virtualListScrollHandler = function (event, isInit) {
            if (isInit === void 0) { isInit = false; }
            // Do NOT use refList.current.scrollHeight
            // We should use Filler's height as total scroll height
            // Filler's translate style may make refList.current.scrollHeight larger than Filler's height
            var scrollHeight = itemTotalHeight;
            var _a = refList.current, rawScrollTop = _a.scrollTop, clientHeight = _a.clientHeight;
            var scrollTop = getValidScrollTop(rawScrollTop, scrollHeight - clientHeight);
            // Prevent jitter
            if (!isInit && (scrollTop === state.scrollTop || refLockScroll.current)) {
                return;
            }
            var scrollPtg = getScrollPercentage({
                scrollTop: scrollTop,
                clientHeight: clientHeight,
                scrollHeight: scrollHeight,
            });
            var _b = getRangeIndex(scrollPtg, itemCount, itemCountVisible), itemIndex = _b.itemIndex, itemOffsetPtg = _b.itemOffsetPtg, startIndex = _b.startIndex, endIndex = _b.endIndex;
            setState(__assign$1L(__assign$1L({}, state), { scrollTop: scrollTop, itemIndex: itemIndex, itemOffsetPtg: itemOffsetPtg, startIndex: startIndex, endIndex: endIndex, status: 'MEASURE_START' }));
            event && onScroll && onScroll(event);
        };
        React.useEffect(function () {
            return function () {
                refRafId.current && caf(refRafId.current);
            };
        }, []);
        // rerender when the number of visible elements changes
        React.useEffect(function () {
            if (refList.current) {
                if (isFirstRender) {
                    refList.current.scrollTop = 0;
                }
                virtualListScrollHandler(null, true);
            }
        }, [itemCountVisible]);
        // Handle additions and deletions of list items or switching the virtual state
        React.useEffect(function () {
            var changedItemIndex = null;
            var switchTo = refIsVirtual.current !== isVirtual ? (isVirtual ? 'virtual' : 'raw') : '';
            refIsVirtual.current = isVirtual;
            if (viewportHeight && prevData.length !== data.length) {
                var diff = findListDiffIndex(prevData, data, getItemKey);
                changedItemIndex = diff ? diff.index : null;
            }
            // No need to correct the position when the number of elements in the real list changes
            if (switchTo || (isVirtual && changedItemIndex)) {
                var clientHeight = refList.current.clientHeight;
                var locatedItemRelativeTop = getItemRelativeTop({
                    itemHeight: getCachedItemHeight(getItemKeyByIndex(state.itemIndex, prevData)),
                    itemOffsetPtg: state.itemOffsetPtg,
                    scrollPtg: getScrollPercentage({
                        scrollTop: state.scrollTop,
                        scrollHeight: prevData.length * itemHeight,
                        clientHeight: clientHeight,
                    }),
                    clientHeight: clientHeight,
                });
                if (switchTo === 'raw') {
                    var rawTop = locatedItemRelativeTop;
                    for (var index = 0; index < state.itemIndex; index++) {
                        rawTop -= getCachedItemHeight(getItemKeyByIndex(index));
                    }
                    refList.current.scrollTop = -rawTop;
                    refLockScroll.current = true;
                    refRafId.current = raf(function () {
                        refLockScroll.current = false;
                    });
                }
                else {
                    internalScrollTo({
                        itemIndex: state.itemIndex,
                        relativeTop: locatedItemRelativeTop,
                    });
                }
            }
        }, [data, isVirtual]);
        useIsomorphicLayoutEffect$1(function () {
            if (state.status === 'MEASURE_START') {
                var _a = refList.current, scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
                var scrollPtg = getScrollPercentage({
                    scrollTop: scrollTop,
                    scrollHeight: scrollHeight,
                    clientHeight: clientHeight,
                });
                // Calculate the top value of the first rendering element
                var startItemTop = getItemAbsoluteTop({
                    scrollPtg: scrollPtg,
                    clientHeight: clientHeight,
                    scrollTop: scrollTop - (scrollListPadding.top + scrollListPadding.bottom) * scrollPtg,
                    itemHeight: getCachedItemHeight(getItemKeyByIndex(state.itemIndex)),
                    itemOffsetPtg: state.itemOffsetPtg,
                });
                for (var index = state.itemIndex - 1; index >= state.startIndex; index--) {
                    startItemTop -= getCachedItemHeight(getItemKeyByIndex(index));
                }
                setState(__assign$1L(__assign$1L({}, state), { startItemTop: startItemTop, status: 'MEASURE_DONE' }));
            }
        }, [state]);
        React.useImperativeHandle(ref, function () { return ({
            dom: refList.current,
            // Scroll to a certain height or an element
            scrollTo: function (arg) {
                refRafId.current && caf(refRafId.current);
                refRafId.current = raf(function () {
                    var _a;
                    if (typeof arg === 'number') {
                        refList.current.scrollTop = arg;
                        return;
                    }
                    var index = 'index' in arg
                        ? arg.index
                        : 'key' in arg
                            ? data.findIndex(function (item, index) { return getItemKey(item, index) === arg.key; })
                            : 0;
                    var item = data[index];
                    if (!item) {
                        return;
                    }
                    var align = typeof arg === 'object' && ((_a = arg.options) === null || _a === void 0 ? void 0 : _a.block)
                        ? arg.options.block
                        : (scrollOptions === null || scrollOptions === void 0 ? void 0 : scrollOptions.block) || 'nearest';
                    var _b = refList.current, clientHeight = _b.clientHeight, scrollTop = _b.scrollTop;
                    if (isVirtual && !isStaticItemHeight) {
                        if (align === 'nearest') {
                            var itemIndex = state.itemIndex, itemOffsetPtg = state.itemOffsetPtg;
                            if (Math.abs(itemIndex - index) < itemCountVisible) {
                                var itemTop = getItemRelativeTop({
                                    itemHeight: getCachedItemHeight(getItemKeyByIndex(itemIndex)),
                                    itemOffsetPtg: itemOffsetPtg,
                                    clientHeight: clientHeight,
                                    scrollPtg: getScrollPercentage(refList.current),
                                });
                                if (index < itemIndex) {
                                    for (var i = index; i < itemIndex; i++) {
                                        itemTop -= getCachedItemHeight(getItemKeyByIndex(i));
                                    }
                                }
                                else {
                                    for (var i = itemIndex; i < index; i++) {
                                        itemTop += getCachedItemHeight(getItemKeyByIndex(i));
                                    }
                                }
                                // When the target element is within the field of view, exit directly
                                if (itemTop < 0 || itemTop > clientHeight) {
                                    align = itemTop < 0 ? 'start' : 'end';
                                }
                                else {
                                    return;
                                }
                            }
                            else {
                                align = index < itemIndex ? 'start' : 'end';
                            }
                        }
                        setState(__assign$1L(__assign$1L({}, state), { startIndex: Math.max(0, index - itemCountVisible), endIndex: Math.min(itemCount - 1, index + itemCountVisible) })).then(function () {
                            var itemHeight = getCachedItemHeight(getItemKey(item, index));
                            internalScrollTo({
                                itemIndex: index,
                                relativeTop: align === 'start'
                                    ? 0
                                    : (clientHeight - itemHeight) / (align === 'center' ? 2 : 1),
                            });
                        });
                    }
                    else {
                        var indexItemHeight = getCachedItemHeight(getItemKeyByIndex(index));
                        var itemTop = 0;
                        for (var i = 0; i < index; i++) {
                            itemTop += getCachedItemHeight(getItemKeyByIndex(i));
                        }
                        var itemBottom = itemTop + indexItemHeight;
                        var itemMiddle = itemTop + indexItemHeight / 2;
                        // If item is visible, skip scrolling
                        if (itemMiddle > scrollTop && itemMiddle < clientHeight + scrollTop) {
                            return;
                        }
                        if (align === 'nearest') {
                            if (itemTop < scrollTop) {
                                align = 'start';
                            }
                            else if (itemBottom > scrollTop + clientHeight) {
                                align = 'end';
                            }
                        }
                        var viewportHeight_1 = clientHeight - indexItemHeight;
                        refList.current.scrollTop =
                            itemTop - (align === 'start' ? 0 : viewportHeight_1 / (align === 'center' ? 2 : 1));
                    }
                });
            },
        }); }, [data, itemHeight, state]);
        var renderChildren = function (list, startIndex) {
            return list.map(function (item, index) {
                var originIndex = startIndex + index;
                var node = renderChild(item, originIndex, {
                    style: {},
                });
                var key = getItemKey(item, originIndex);
                return React.cloneElement(node, {
                    key: key,
                    ref: function (ele) {
                        var heightMap = refItemHeightMap.current;
                        // Minimize the measurement of element height as much as possible to avoid frequent triggering of browser reflow
                        // Method getNodeHeight get the clientHeight from the DOM referred by React ref. If result is wrong, check the ref of this element
                        if (ele &&
                            state.status === 'MEASURE_START' &&
                            (!isStaticItemHeight || heightMap[key] === undefined)) {
                            if (isStaticItemHeight) {
                                if (!heightMap[KEY_VIRTUAL_ITEM_HEIGHT]) {
                                    heightMap[KEY_VIRTUAL_ITEM_HEIGHT] = getNodeHeight(ele, true);
                                }
                                heightMap[key] = heightMap[KEY_VIRTUAL_ITEM_HEIGHT];
                            }
                            else {
                                heightMap[key] = getNodeHeight(ele, true);
                            }
                        }
                    },
                });
            });
        };
        // Render the widest element to provide the maximum width of the container initially
        var refLongestItemIndex = React.useRef(null);
        // Don't add `renderChild` to the array dependency, it will change every time when rerender
        React.useEffect(function () {
            refLongestItemIndex.current = null;
        }, [data]);
        var renderLongestItem = function () {
            if (measureLongestItem) {
                var index = refLongestItemIndex.current === null
                    ? getLongestItemIndex(data)
                    : refLongestItemIndex.current;
                var item = data[index];
                refLongestItemIndex.current = index;
                return item ? (React.createElement("div", { style: { height: 1, overflow: 'hidden', opacity: 0 } }, renderChild(item, index, { style: {} }))) : null;
            }
            return null;
        };
        return (React.createElement(ResizeObserver$1, { onResize: function () {
                if (refList.current && !isNumber(styleListMaxHeight)) {
                    var clientHeight = refList.current.clientHeight;
                    setStateHeight(clientHeight);
                }
            } },
            React.createElement(WrapperTagName, __assign$1L({ ref: refList, style: __assign$1L(__assign$1L({ overflowY: 'auto', overflowAnchor: 'none' }, style), { maxHeight: styleListMaxHeight }), className: className, onScroll: isVirtual ? virtualListScrollHandler : rawListScrollHandler }, restProps), isVirtual ? (React.createElement(React.Fragment, null,
                React.createElement(Filler$1, { height: itemTotalHeight, offset: state.status === 'MEASURE_DONE' ? state.startItemTop : 0, outerStyle: outerStyle }, renderChildren(data.slice(state.startIndex, state.endIndex + 1), state.startIndex)),
                renderLongestItem())) : needFiller ? (React.createElement(Filler$1, { height: viewportHeight }, renderChildren(data, 0))) : (renderChildren(data, 0)))));
    });
    VirtualList.displayName = 'VirtualList';
    var VirtualList$1 = VirtualList;

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    var isArray_1 = isArray;

    /** Used to match property names within property paths. */
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/;

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray_1(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol_1(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    var _isKey = isKey;

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag$1 = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject_1(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = _baseGetTag(value);
      return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    var isFunction_1 = isFunction;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = _root['__core-js_shared__'];

    var _coreJsData = coreJsData;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    var _isMasked = isMasked;

    /** Used for built-in method references. */
    var funcProto$2 = Function.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$2 = funcProto$2.toString;

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$2.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    var _toSource = toSource;

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;

    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;

    /** Used for built-in method references. */
    var funcProto$1 = Function.prototype,
        objectProto$c = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$1 = funcProto$1.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$a = objectProto$c.hasOwnProperty;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar$1, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject_1(value) || _isMasked(value)) {
        return false;
      }
      var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
      return pattern.test(_toSource(value));
    }

    var _baseIsNative = baseIsNative;

    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }

    var _getValue = getValue;

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = _getValue(object, key);
      return _baseIsNative(value) ? value : undefined;
    }

    var _getNative = getNative;

    /* Built-in method references that are verified to be native. */
    var nativeCreate = _getNative(Object, 'create');

    var _nativeCreate = nativeCreate;

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
      this.size = 0;
    }

    var _hashClear = hashClear;

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    var _hashDelete = hashDelete;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

    /** Used for built-in method references. */
    var objectProto$b = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$9 = objectProto$b.hasOwnProperty;

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (_nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$2 ? undefined : result;
      }
      return hasOwnProperty$9.call(data, key) ? data[key] : undefined;
    }

    var _hashGet = hashGet;

    /** Used for built-in method references. */
    var objectProto$a = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$8.call(data, key);
    }

    var _hashHas = hashHas;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
      return this;
    }

    var _hashSet = hashSet;

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = _hashClear;
    Hash.prototype['delete'] = _hashDelete;
    Hash.prototype.get = _hashGet;
    Hash.prototype.has = _hashHas;
    Hash.prototype.set = _hashSet;

    var _Hash = Hash;

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    var _listCacheClear = listCacheClear;

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    var eq_1 = eq;

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq_1(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    var _assocIndexOf = assocIndexOf;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype;

    /** Built-in value references. */
    var splice = arrayProto.splice;

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    var _listCacheDelete = listCacheDelete;

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    var _listCacheGet = listCacheGet;

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return _assocIndexOf(this.__data__, key) > -1;
    }

    var _listCacheHas = listCacheHas;

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    var _listCacheSet = listCacheSet;

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = _listCacheClear;
    ListCache.prototype['delete'] = _listCacheDelete;
    ListCache.prototype.get = _listCacheGet;
    ListCache.prototype.has = _listCacheHas;
    ListCache.prototype.set = _listCacheSet;

    var _ListCache = ListCache;

    /* Built-in method references that are verified to be native. */
    var Map$1 = _getNative(_root, 'Map');

    var _Map = Map$1;

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new _Hash,
        'map': new (_Map || _ListCache),
        'string': new _Hash
      };
    }

    var _mapCacheClear = mapCacheClear;

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    var _isKeyable = isKeyable;

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return _isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    var _getMapData = getMapData;

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = _getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    var _mapCacheDelete = mapCacheDelete;

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return _getMapData(this, key).get(key);
    }

    var _mapCacheGet = mapCacheGet;

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return _getMapData(this, key).has(key);
    }

    var _mapCacheHas = mapCacheHas;

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = _getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    var _mapCacheSet = mapCacheSet;

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = _mapCacheClear;
    MapCache.prototype['delete'] = _mapCacheDelete;
    MapCache.prototype.get = _mapCacheGet;
    MapCache.prototype.has = _mapCacheHas;
    MapCache.prototype.set = _mapCacheSet;

    var _MapCache = MapCache;

    /** Error message constants. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || _MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = _MapCache;

    var memoize_1 = memoize;

    /** Used as the maximum memoize cache size. */
    var MAX_MEMOIZE_SIZE = 500;

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize_1(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    var _memoizeCapped = memoizeCapped;

    /** Used to match property names within property paths. */
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

    /** Used to match backslashes in property paths. */
    var reEscapeChar = /\\(\\)?/g;

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = _memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    var _stringToPath = stringToPath;

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    var _arrayMap = arrayMap;

    /** Used as references for various `Number` constants. */
    var INFINITY$1 = 1 / 0;

    /** Used to convert symbols to primitives and strings. */
    var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
        symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray_1(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return _arrayMap(value, baseToString) + '';
      }
      if (isSymbol_1(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
    }

    var _baseToString = baseToString;

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : _baseToString(value);
    }

    var toString_1 = toString;

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray_1(value)) {
        return value;
      }
      return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
    }

    var _castPath = castPath;

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0;

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol_1(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    var _toKey = toKey;

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = _castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[_toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    var _baseGet = baseGet;

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : _baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    var get_1 = get;

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
        reHasRegExpChar = RegExp(reRegExpChar.source);

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString_1(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    var escapeRegExp_1 = escapeRegExp;

    function getHighlightText(_a) {
        var nodeList = _a.nodeList, pattern = _a.pattern, highlightClassName = _a.highlightClassName;
        if (!pattern) {
            return nodeList;
        }
        var transformNode = function (node) {
            if (node && node.props && typeof node.props.children === 'string') {
                return React.cloneElement(node, undefined, React.createElement(HighlightText, { text: node.props.children, keyword: pattern, highlightClassName: highlightClassName }));
            }
            return node;
        };
        return isArray$1(nodeList) ? nodeList.map(function (node) { return transformNode(node); }) : transformNode(nodeList);
    }
    function HighlightText(_a) {
        var text = _a.text, keyword = _a.keyword, highlightClassName = _a.highlightClassName;
        if (!keyword)
            return React.createElement(React.Fragment, null, text);
        // 注意这里的括号，这里使用了带capture group功能的正则，来split字符串
        // 从而在strArr中可以保留匹配文本
        var re = new RegExp("(" + escapeRegExp_1(keyword) + ")", 'i');
        var strArr = text.split(re);
        return (React.createElement(React.Fragment, null, strArr.map(function (item, index) {
            return re.test(item) ? (React.createElement("span", { key: index, className: highlightClassName }, item)) : (React.createElement("span", { key: index }, item));
        })));
    }

    var __assign$1K = (undefined && undefined.__assign) || function () {
        __assign$1K = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1K.apply(this, arguments);
    };
    function preventDefaultEvent(e) {
        e && e.preventDefault();
    }
    function isEmptyValue$2(value, isMultiple) {
        // Illegal value is considered as unselected
        return isMultiple ? !isArray$1(value) || !value.length : value === undefined;
    }
    function getValidValue(value, isMultiple, labelInValue) {
        // Compatible when labelInValue is set, value is passed in the object
        if (labelInValue) {
            if (isMultiple) {
                value = Array.isArray(value)
                    ? value.map(function (item) { return (isObject$1(item) && 'label' in item ? item.value : item); })
                    : value;
            }
            else {
                value = isObject$1(value) && 'label' in value ? value.value : value;
            }
        }
        return isEmptyValue$2(value, isMultiple)
            ? isMultiple
                ? Array.isArray(value)
                    ? value
                    : []
                : undefined
            : value;
    }
    function isSelectOption(child) {
        return get_1(child, 'props.isSelectOption') || get_1(child, 'type.__ARCO_SELECT_OPTION__');
    }
    function isSelectOptGroup(child) {
        return get_1(child, 'props.isSelectOptGroup') || get_1(child, 'type.__ARCO_SELECT_OPTGROUP__');
    }
    function flatChildren(_a, _b, 
    // 递归过程中需要持续传递的数据
    _c) {
        var children = _a.children, options = _a.options, filterOption = _a.filterOption;
        var _d = _b.inputValue, inputValue = _d === void 0 ? '' : _d, userCreatedOptions = _b.userCreatedOptions, userCreatingOption = _b.userCreatingOption, prefixCls = _b.prefixCls;
        var 
        // 递归过程中需要持续传递的数据
        _e = _c === void 0 ? {} : _c, _f = _e.optionInfoMap, optionInfoMap = _f === void 0 ? new Map() : _f, _g = _e.optionValueList, optionValueList = _g === void 0 ? [] : _g, _h = _e.customNodeCount, customNodeCount = _h === void 0 ? 0 : _h;
        // 是否存在 OptGroup
        var hasOptGroup = false;
        // 是否存在 children 不为字符串的 Option
        var hasComplexLabelInOptions = false;
        // 经过 value 去重并且包含了 OptGroup 的 children 数组
        var childrenList = [];
        var optionIndexListForArrowKey = [];
        var getChildValue = function (child) {
            var propValue = get_1(child, 'props.value');
            var propChildren = get_1(child, 'props.children');
            return propValue === undefined && propChildren !== null && propChildren !== undefined
                ? propChildren.toString()
                : propValue;
        };
        var getChildKey = function (_a, key, isGroupTitle) {
            var label = _a.label, value = _a.value;
            // 处理自定义节点的 key 值
            if (!label && !value && !key) {
                customNodeCount++;
                return "custom_node_" + customNodeCount;
            }
            return isGroupTitle
                ? key || "group_" + label
                : key || typeof value + "_" + value || label + "_" + optionInfoMap.size;
        };
        var handleOption = function (child, origin) {
            var optionValue = getChildValue(child);
            var isValidOption = true;
            if (filterOption === true) {
                isValidOption =
                    optionValue !== undefined &&
                        String(optionValue).toLowerCase().indexOf(inputValue.toLowerCase()) !== -1;
            }
            else if (typeof filterOption === 'function') {
                isValidOption = !inputValue || filterOption(inputValue, child);
            }
            if (!optionInfoMap.get(optionValue)) {
                if (!('_key' in child.props)) {
                    child = React.cloneElement(child, {
                        _key: getChildKey(child.props, child.key),
                    });
                }
                var index = optionInfoMap.size;
                var option = __assign$1K(__assign$1K({ child: child }, child.props), { value: optionValue, _index: index, _origin: origin, _valid: isValidOption });
                optionInfoMap.set(optionValue, option);
                optionValueList.push(optionValue);
                if (isValidOption) {
                    childrenList.push(child);
                    if (!option.disabled) {
                        optionIndexListForArrowKey.push(index);
                    }
                }
            }
            if (typeof child.props.children !== 'string') {
                hasComplexLabelInOptions = true;
            }
        };
        var extendChildren = function (arr, origin) {
            if (origin && isArray$1(arr) && arr.length) {
                arr.forEach(function (option) {
                    option =
                        isString(option) || isNumber(option)
                            ? {
                                label: option,
                                value: option,
                            }
                            : option;
                    var child = (React.createElement(Option$4, { _key: getChildKey(option), value: option.value, disabled: option.disabled === true, extra: option.extra }, fillNBSP(option.label)));
                    handleOption(child, origin);
                });
            }
        };
        if (userCreatingOption) {
            extendChildren([userCreatingOption], 'userCreatingOption');
        }
        if (children) {
            React.Children.map(children, function (child) {
                if (isSelectOptGroup(child)) {
                    var _a = child.props, children_1 = _a.children, options_1 = _a.options;
                    var _b = flatChildren({ children: children_1, options: options_1, filterOption: filterOption }, { inputValue: inputValue, prefixCls: prefixCls }, { optionInfoMap: optionInfoMap, optionValueList: optionValueList, customNodeCount: customNodeCount }), _childrenList = _b.childrenList, _optionIndexListForArrowKey = _b.optionIndexListForArrowKey, _hasComplexLabelInOptions = _b.hasComplexLabelInOptions;
                    if (_childrenList.length) {
                        childrenList.push(React.cloneElement(child, {
                            children: null,
                            _key: getChildKey(child.props, child.key, true),
                        }));
                        childrenList = childrenList.concat(_childrenList);
                        optionIndexListForArrowKey = optionIndexListForArrowKey.concat(_optionIndexListForArrowKey);
                        hasOptGroup = true;
                        hasComplexLabelInOptions = hasComplexLabelInOptions || _hasComplexLabelInOptions;
                    }
                }
                else if (isSelectOption(child)) {
                    handleOption(child, 'children');
                }
                else if (isObject$1(child) && child.props) {
                    childrenList.push(React.cloneElement(child, {
                        _key: getChildKey(child.props, child.key),
                    }));
                }
            });
        }
        extendChildren(options, 'options');
        extendChildren(userCreatedOptions, 'userCreatedOptions');
        return {
            childrenList: getHighlightText({
                nodeList: childrenList,
                pattern: inputValue,
                highlightClassName: prefixCls + "-highlight",
            }),
            optionInfoMap: optionInfoMap,
            optionValueList: optionValueList,
            optionIndexListForArrowKey: optionIndexListForArrowKey,
            hasOptGroup: hasOptGroup,
            hasComplexLabelInOptions: hasComplexLabelInOptions,
        };
    }

    var __read$1a = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    var globalInstanceIdMap = {};
    /**
     * Provide unique component name while using this hook
     * In react 18, React.useId is a better way to choose
     * Related issue: https://github.com/arco-design/arco-design/issues/958
     */
    function useId(prefix) {
        var _a = __read$1a(React.useState(), 2), id = _a[0], setId = _a[1];
        // Update ID in next render to avoid SSR [prop dit not match] error
        React.useEffect(function () {
            globalInstanceIdMap[prefix] = prefix in globalInstanceIdMap ? globalInstanceIdMap[prefix] : 0;
            setId(globalInstanceIdMap[prefix]);
            globalInstanceIdMap[prefix] += 1;
        }, []);
        return typeof id === 'number' ? "" + prefix + id : undefined;
    }

    var __assign$1J = (undefined && undefined.__assign) || function () {
        __assign$1J = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1J.apply(this, arguments);
    };
    var __read$19 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __values$1 = (undefined && undefined.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __spreadArray$v = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    // 输入框粘贴会先触发 onPaste 后触发 onChange，但 onChange 的 value 中不包含换行符
    // 如果刚刚因为粘贴触发过分词，则 onChange 不再进行分词尝试
    var THRESHOLD_TOKEN_SEPARATOR_TRIGGER = 100;
    var defaultProps$z = {
        trigger: 'click',
        bordered: true,
        filterOption: true,
        unmountOnExit: true,
        defaultActiveFirstOption: true,
    };
    function Select$2(baseProps, ref) {
        var _a = React.useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, renderEmpty = _a.renderEmpty, componentConfig = _a.componentConfig, rtl = _a.rtl;
        var props = useMergeProps(baseProps, defaultProps$z, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Select);
        var children = props.children, renderFormat = props.renderFormat, defaultActiveFirstOption = props.defaultActiveFirstOption, disabled = props.disabled, unmountOnExit = props.unmountOnExit, notFoundContent = props.notFoundContent, showSearch = props.showSearch, tokenSeparators = props.tokenSeparators, options = props.options, filterOption = props.filterOption, labelInValue = props.labelInValue, getPopupContainer = props.getPopupContainer, trigger = props.trigger, triggerElement = props.triggerElement, triggerProps = props.triggerProps, dropdownRender = props.dropdownRender, dropdownMenuStyle = props.dropdownMenuStyle, dropdownMenuClassName = props.dropdownMenuClassName, virtualListProps = props.virtualListProps, 
        // events
        onChange = props.onChange, onDeselect = props.onDeselect, onClear = props.onClear, onSearch = props.onSearch, onFocus = props.onFocus, onBlur = props.onBlur, onPopupScroll = props.onPopupScroll, onVisibleChange = props.onVisibleChange, onInputValueChange = props.onInputValueChange, onPaste = props.onPaste, onKeyDown = props.onKeyDown;
        // TODO 兼容逻辑，3.0 移除 tags 模式
        var mode = props.mode, allowCreate = props.allowCreate;
        if (mode === 'tags') {
            mode = 'multiple';
            allowCreate = true;
            warning(true, "[Arco Select] The 'tags' mode will be removed in the next major version, please use {mode: \"multiple\", allowCreate: true} instead.");
        }
        var prefixCls = getPrefixCls('select');
        var isMultipleMode = mode === 'multiple';
        // TODO: 统一 useMergeValue 函数的表现
        var _b = __read$19(React.useState(getValidValue(props.defaultValue, isMultipleMode, labelInValue)), 2), stateValue = _b[0], setValue = _b[1];
        var value = 'value' in props ? getValidValue(props.value, isMultipleMode, labelInValue) : stateValue;
        var _c = __read$19(useMergeValue('', {
            value: 'inputValue' in props ? props.inputValue || '' : undefined,
        }), 3), inputValue = _c[0], setInputValue = _c[1], stateInputValue = _c[2];
        var _d = __read$19(useMergeValue(false, {
            defaultValue: props.defaultPopupVisible,
            value: 'popupVisible' in props
                ? props.popupVisible
                : triggerProps && 'popupVisible' in triggerProps
                    ? triggerProps.popupVisible
                    : undefined,
        }), 2), popupVisible = _d[0], setPopupVisible = _d[1];
        // allowCreate 时，用户正在创建的选项值
        var _e = __read$19(React.useState(null), 2), userCreatingOption = _e[0], setUserCreatingOption = _e[1];
        // allowCreate 时，由用户输入而扩展到选项中的值
        var _f = __read$19(React.useState([]), 2), userCreatedOptions = _f[0], setUserCreatedOptions = _f[1];
        // 具有选中态或者 hover 态的 option 的 value
        var _g = __read$19(React.useState(isArray$1(value) ? value[0] : value), 2), valueActive = _g[0], setValueActive = _g[1];
        // 缓存较为耗时的 flatChildren 的结果
        var _h = React.useMemo(function () {
            return flatChildren({ children: children, options: options, filterOption: filterOption }, {
                prefixCls: prefixCls,
                inputValue: inputValue,
                userCreatedOptions: userCreatedOptions,
                userCreatingOption: userCreatingOption,
            });
        }, [children, options, filterOption, inputValue, userCreatingOption, userCreatedOptions]), childrenList = _h.childrenList, optionInfoMap = _h.optionInfoMap, optionValueList = _h.optionValueList, optionIndexListForArrowKey = _h.optionIndexListForArrowKey, hasOptGroup = _h.hasOptGroup, hasComplexLabelInOptions = _h.hasComplexLabelInOptions;
        // ref
        var refWrapper = React.useRef(null);
        var refTrigger = React.useRef(null);
        var refSelectView = React.useRef(null);
        // 用来保存 value 和选中项的映射
        var refValueMap = React.useRef([]);
        // 用 none 表示目前处于键盘操作中，忽略鼠标的 onMouseEnter 和 onMouseLeave 事件
        var refKeyboardArrowDirection = React.useRef(null);
        // 触发 onInputValueChange 回调的值
        var refOnInputChangeCallbackValue = React.useRef(inputValue);
        // 触发 onInputValueChange 回调的原因
        var refOnInputChangeCallbackReason = React.useRef(null);
        // 上次成功触发自动分词的时间
        var refTSLastSeparateTriggered = React.useRef(0);
        // Whether in the hidden animation of drop-down
        var refPopupExiting = React.useRef(false);
        // Unique ID of this select instance
        var instancePopupID = useId(prefixCls + "-popup-");
        var isNoOptionSelected = isEmptyValue$2(value, isMultipleMode);
        var valueActiveDefault = defaultActiveFirstOption
            ? optionValueList[optionIndexListForArrowKey[0]]
            : undefined;
        var scrollIntoView = function (optionValue) {
            var _a;
            var activeOption = optionInfoMap.get(optionValue);
            if (refWrapper.current && ((_a = activeOption === null || activeOption === void 0 ? void 0 : activeOption.child) === null || _a === void 0 ? void 0 : _a.props)) {
                refWrapper.current.scrollTo({ key: activeOption.child.props._key });
            }
        };
        // Try to update inputValue and trigger onInputValueChange callback
        var tryUpdateInputValue = function (value, reason) {
            if (value !== refOnInputChangeCallbackValue.current ||
                reason !== refOnInputChangeCallbackReason.current) {
                setInputValue(value);
                refOnInputChangeCallbackValue.current = value;
                refOnInputChangeCallbackReason.current = reason;
                onInputValueChange && onInputValueChange(value, reason);
            }
        };
        // 尝试更新 popupVisible，触发 onVisibleChange
        var tryUpdatePopupVisible = function (value) {
            if (popupVisible !== value) {
                setPopupVisible(value);
                onVisibleChange && onVisibleChange(value);
                triggerProps && triggerProps.onVisibleChange && triggerProps.onVisibleChange(value);
            }
        };
        // 处理模式切换时 value 格式的校正
        React.useEffect(function () {
            if (isMultipleMode) {
                if (!Array.isArray(value)) {
                    setValue(value === undefined ? [] : [value]);
                }
            }
            else if (Array.isArray(value)) {
                setValue(value.length === 0 ? undefined : value[0]);
            }
        }, [isMultipleMode, value]);
        // 选项下拉框显示/隐藏时的一些自动行为
        React.useEffect(function () {
            if (popupVisible) {
                // 重新设置 hover 态的 Option
                var firstValue = isArray$1(value) ? value[0] : value;
                var nextValueActive_1 = !isNoOptionSelected && optionInfoMap.has(firstValue) ? firstValue : valueActiveDefault;
                setValueActive(nextValueActive_1);
                // 在弹出框动画结束之后再执行scrollIntoView，否则会有不必要的滚动产生
                setTimeout(function () { return scrollIntoView(nextValueActive_1); });
            }
        }, [popupVisible]);
        // 处理键盘选择Option时的列表滚动
        React.useEffect(function () {
            if (refKeyboardArrowDirection.current === 'up' ||
                refKeyboardArrowDirection.current === 'down') {
                scrollIntoView(valueActive);
                refKeyboardArrowDirection.current = 'none';
            }
        }, [valueActive]);
        // 选项列表改变后，将 active 选项重置
        React.useEffect(function () {
            setValueActive(valueActiveDefault);
        }, [JSON.stringify(childrenList.map(function (child) { var _a; return (_a = child === null || child === void 0 ? void 0 : child.props) === null || _a === void 0 ? void 0 : _a.value; }))]);
        // 更新 refValueMap，避免数组规模无节制扩大
        React.useEffect(function () {
            refValueMap.current = refValueMap.current.filter(function (x) {
                return isMultipleMode
                    ? isArray$1(value) && value.indexOf(x.value) > -1
                    : x.value === value;
            });
        }, [value, isMultipleMode]);
        // allowCreate 时，value 改变时更新下拉框选项
        React.useEffect(function () {
            // 将无对应下拉框选项的 value 当作自定义 tag，将 value 中不存在的 valueTag 移除
            if (allowCreate && Array.isArray(value)) {
                var newUserCreatedOptions = value.filter(function (v) {
                    var _a;
                    var option = optionInfoMap.get(v) || ((_a = refValueMap.current.find(function (item) { return item.value === v; })) === null || _a === void 0 ? void 0 : _a.option);
                    return !option || option._origin === 'userCreatingOption';
                });
                var validUserCreatedOptions = userCreatedOptions.filter(function (tag) { return value.indexOf(tag) !== -1; });
                var _userCreatedOptions = validUserCreatedOptions.concat(newUserCreatedOptions);
                if (_userCreatedOptions.toString() !== userCreatedOptions.toString()) {
                    setUserCreatedOptions(_userCreatedOptions);
                }
            }
        }, [value]);
        // allowCreate 时，根据输入内容动态修改下拉框选项
        React.useEffect(function () {
            if (allowCreate) {
                // 避免正在输入的内容覆盖已有的选项
                setUserCreatingOption(optionInfoMap.has(inputValue) ? null : inputValue);
            }
        }, [inputValue]);
        // 在 inputValue 变化时，适时触发 onSearch
        React.useEffect(function () {
            var reason = refOnInputChangeCallbackReason.current;
            if (stateInputValue === inputValue && (reason === 'manual' || reason === 'optionListHide')) {
                onSearch && onSearch(inputValue, reason);
            }
        }, [inputValue]);
        var getOptionInfoByValue = function (value) {
            var option = optionInfoMap.get(value);
            if (option) {
                var index = refValueMap.current.findIndex(function (item) { return item.value === value; });
                if (index > -1) {
                    refValueMap.current.splice(index, 1, { value: value, option: option });
                }
                else {
                    refValueMap.current.push({ value: value, option: option });
                }
                return option;
            }
            var item = refValueMap.current.find(function (x) { return x.value === value; });
            return item && item.option;
        };
        // 使用方向键选择时，获取下一个 active option 的值
        var getValueActive = function (direction) {
            if (!optionIndexListForArrowKey.length) {
                return undefined;
            }
            if (valueActive === undefined || !optionInfoMap.has(valueActive)) {
                return optionValueList[optionIndexListForArrowKey[0]];
            }
            var activeOption = optionInfoMap.get(valueActive);
            var activeIndex = activeOption._index;
            var _index = optionIndexListForArrowKey.indexOf(activeIndex);
            var _length = optionIndexListForArrowKey.length;
            return optionValueList[optionIndexListForArrowKey[((direction === 'up' ? _index - 1 : _index + 1) + _length) % _length]];
        };
        // Object should be returned when labelInValue is true
        var getValueAndOptionForCallback = function (stateValue, isEmpty) {
            if (isEmpty === void 0) { isEmpty = isEmptyValue$2(stateValue, isMultipleMode); }
            var value = stateValue;
            var option = stateValue === undefined
                ? undefined
                : Array.isArray(stateValue)
                    ? stateValue.map(getOptionInfoByValue)
                    : getOptionInfoByValue(stateValue);
            if (labelInValue && !isEmpty) {
                var getOptionLabel_1 = function (optionValue, optionInfo) {
                    var e_1, _a;
                    if (optionInfo) {
                        return optionInfo.children;
                    }
                    // https://github.com/arco-design/arco-design/issues/442
                    // Make sure parameter value has valid label if props.value is already set
                    var propValue = 'value' in props ? props.value : 'defaultValue' in props ? props.defaultValue : null;
                    // Multiple mode
                    if (Array.isArray(propValue)) {
                        try {
                            for (var propValue_1 = __values$1(propValue), propValue_1_1 = propValue_1.next(); !propValue_1_1.done; propValue_1_1 = propValue_1.next()) {
                                var item = propValue_1_1.value;
                                if (isObject$1(item) && item.value === optionValue) {
                                    return item.label;
                                }
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (propValue_1_1 && !propValue_1_1.done && (_a = propValue_1.return)) _a.call(propValue_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                    }
                    // Single mode
                    else if (isObject$1(propValue) && propValue.value === optionValue) {
                        return propValue.label;
                    }
                };
                if (Array.isArray(stateValue)) {
                    value = stateValue.map(function (optionValue, index) { return ({
                        value: optionValue,
                        label: getOptionLabel_1(optionValue, option[index]),
                    }); });
                }
                else {
                    value = { value: stateValue, label: getOptionLabel_1(stateValue, option) };
                }
            }
            return { option: option, value: value };
        };
        var tryUpdateSelectValue = function (value) {
            setValue(value);
            if (onChange) {
                var paramsForCallback = getValueAndOptionForCallback(value);
                onChange(paramsForCallback.value, paramsForCallback.option);
            }
        };
        // 多选时，选择一个选项
        var checkOption = function (valueToAdd) {
            var option = optionInfoMap.get(valueToAdd);
            if (option) {
                var newValue = value.concat(valueToAdd);
                tryUpdateSelectValue(newValue);
            }
        };
        // 多选时，取消一个选项
        var uncheckOption = function (valueToRemove) {
            // 取消选中时不需要检查option是否存在，因为可能已被外部剔除了此选项
            var newValue = value.filter(function (v) { return v !== valueToRemove; });
            tryUpdateSelectValue(newValue);
            if (onDeselect) {
                var paramsForCallback = getValueAndOptionForCallback(valueToRemove, false);
                onDeselect(paramsForCallback.value, paramsForCallback.option);
            }
        };
        var handleOptionClick = function (optionValue, disabled) {
            if (disabled) {
                return;
            }
            if (isMultipleMode) {
                value.indexOf(optionValue) === -1
                    ? checkOption(optionValue)
                    : uncheckOption(optionValue);
                // 点击一个选项时，清空输入框内容
                if (!isObject$1(showSearch) || !showSearch.retainInputValueWhileSelect) {
                    tryUpdateInputValue('', 'optionChecked');
                }
            }
            else {
                if (optionValue !== value) {
                    tryUpdateSelectValue(optionValue);
                }
                setTimeout(function () {
                    tryUpdatePopupVisible(false);
                });
            }
        };
        // 注册快捷键
        var hotkeyHandler = getHotkeyHandler(new Map([
            [Esc.code, function () { return tryUpdatePopupVisible(false); }],
            [
                Enter.code,
                function () {
                    if (popupVisible) {
                        var option = optionInfoMap.get(valueActive);
                        option && handleOptionClick(valueActive, option.disabled);
                    }
                    else {
                        tryUpdatePopupVisible(true);
                    }
                },
            ],
            [
                Tab.code,
                // 按tab键切换，关闭开启的弹出框
                function () { return tryUpdatePopupVisible(false); },
            ],
            [
                ArrowUp.code,
                function () {
                    if (popupVisible) {
                        refKeyboardArrowDirection.current = 'up';
                        setValueActive(getValueActive('up'));
                        return false;
                    }
                },
            ],
            [
                ArrowDown.code,
                function () {
                    if (popupVisible) {
                        refKeyboardArrowDirection.current = 'down';
                        setValueActive(getValueActive('down'));
                        return false;
                    }
                },
            ],
        ]));
        var renderPopup = function () {
            var _a;
            // 没有设置弹出框的 width 时，需要在虚拟列表渲染的瞬间获得子元素的最大宽度
            var needMeasureLongestItem = (triggerProps === null || triggerProps === void 0 ? void 0 : triggerProps.autoAlignPopupWidth) === false;
            // Option 存在复杂子元素时，让获得最长子元素变得困难，此时直接禁用虚拟滚动
            var needForbidVirtual = needMeasureLongestItem && hasComplexLabelInOptions;
            var mergedNotFoundContent = 'notFoundContent' in props ? notFoundContent : renderEmpty('Select');
            // 选项列表元素
            var eleOptionList = childrenList.length ? (React.createElement(VirtualList$1, __assign$1J({ id: instancePopupID, role: "listbox", style: dropdownMenuStyle, className: cs(prefixCls + "-popup-inner", dropdownMenuClassName), ref: refWrapper, data: childrenList, height: null, isStaticItemHeight: !hasOptGroup, measureLongestItem: needMeasureLongestItem, itemKey: function (child) { return child.props._key; }, onMouseDown: preventDefaultEvent, onMouseMove: function () {
                    refKeyboardArrowDirection.current = null;
                }, onScroll: function (e) { return onPopupScroll && onPopupScroll(e.target); } }, virtualListProps, { threshold: needForbidVirtual ? null : virtualListProps === null || virtualListProps === void 0 ? void 0 : virtualListProps.threshold }), function (child) {
                var _a;
                if (isSelectOptGroup(child)) {
                    return React.createElement(child.type, __assign$1J({}, child.props, { prefixCls: prefixCls }));
                }
                if (isSelectOption(child)) {
                    var optionValue = (_a = child.props) === null || _a === void 0 ? void 0 : _a.value;
                    var optionProps = {
                        prefixCls: prefixCls,
                        rtl: rtl,
                        _valueActive: valueActive,
                        _valueSelect: value,
                        _isMultipleMode: isMultipleMode,
                        _isUserCreatingOption: allowCreate && userCreatingOption === optionValue,
                        _isUserCreatedOption: allowCreate && userCreatedOptions.indexOf(optionValue) > -1,
                        _onClick: handleOptionClick,
                        _onMouseEnter: function (value) {
                            refKeyboardArrowDirection.current === null && setValueActive(value);
                        },
                        _onMouseLeave: function () {
                            refKeyboardArrowDirection.current === null && setValueActive(undefined);
                        },
                    };
                    return child && React.createElement(child.type, __assign$1J({}, child.props, optionProps));
                }
                return child;
            })) : null;
            // Avoid drop-down box jitter when user is creating a selection
            var isUserCreating = allowCreate && inputValue;
            // Dropdown-placeholder when there is no options
            var eleNoOptionPlaceholder = mergedNotFoundContent && !isUserCreating ? (React.createElement("div", { style: dropdownMenuStyle, className: cs(prefixCls + "-popup-inner", dropdownMenuClassName) }, mergedNotFoundContent)) : null;
            return (React.createElement("div", { className: cs(prefixCls + "-popup", (_a = {},
                    _a[prefixCls + "-popup-hidden"] = eleOptionList === null && eleNoOptionPlaceholder === null,
                    _a[prefixCls + "-popup-multiple"] = isMultipleMode,
                    _a)), 
                // Make sure hotkey works when dropdown layer get focused
                tabIndex: -1, onKeyDown: function (e) { return hotkeyHandler(e); } }, typeof dropdownRender === 'function'
                ? dropdownRender(eleOptionList || eleNoOptionPlaceholder)
                : eleOptionList || eleNoOptionPlaceholder));
        };
        var handleTokenSeparators = function (str) {
            var hasSeparator = false;
            if (isMultipleMode && isArray$1(tokenSeparators) && tokenSeparators.length) {
                var rawValues_1 = str.split(new RegExp("[" + tokenSeparators.join('') + "]"));
                // 输入了分隔符的情况
                if (rawValues_1.length > 1) {
                    var splitValues = rawValues_1.filter(function (v, index) { return v && rawValues_1.indexOf(v) === index; });
                    var newValue_1 = value.slice(0);
                    var needUpdate_1 = false;
                    splitValues.forEach(function (v) {
                        if (newValue_1.indexOf(v) === -1 && (allowCreate || optionInfoMap.get(v))) {
                            newValue_1.push(v);
                            needUpdate_1 = true;
                        }
                    });
                    if (needUpdate_1) {
                        tryUpdateSelectValue(newValue_1);
                    }
                    hasSeparator = true;
                }
            }
            return hasSeparator;
        };
        // SelectView组件事件处理
        var selectViewEventHandlers = {
            onFocus: onFocus,
            onBlur: function (event) {
                onBlur === null || onBlur === void 0 ? void 0 : onBlur(event);
                // when drop-down is always hidden, input-text needs to be cleared after blur
                !popupVisible && !refPopupExiting.current && tryUpdateInputValue('', 'optionListHide');
            },
            onKeyDown: function (event) {
                // 处理特殊功能键的自动分词
                if (event.target.tagName === 'INPUT' && event.target.value) {
                    var isTab = event.key === Tab.key;
                    var isEnter = event.key === Enter.key;
                    if (isEnter || isTab) {
                        var suffix = isEnter ? '\n' : isTab ? '\t' : '';
                        if (handleTokenSeparators(event.target.value + suffix)) {
                            refTSLastSeparateTriggered.current = Date.now();
                            // 回车后不会触发 onChangeInputValue 回调，所以在这里直接清空输入框
                            tryUpdateInputValue('', 'tokenSeparator');
                        }
                    }
                }
                // 处理快捷键
                hotkeyHandler(event);
                onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(event);
            },
            onChangeInputValue: function (value, _a) {
                var inputType = _a.nativeEvent.inputType;
                if ((inputType === 'insertFromPaste' &&
                    Date.now() - refTSLastSeparateTriggered.current < THRESHOLD_TOKEN_SEPARATOR_TRIGGER) ||
                    handleTokenSeparators(value)) {
                    tryUpdateInputValue('', 'tokenSeparator');
                }
                else {
                    tryUpdateInputValue(value, 'manual');
                }
                if (!popupVisible && value) {
                    tryUpdatePopupVisible(true);
                }
            },
            onPaste: function (e) {
                if (handleTokenSeparators(e.clipboardData.getData('text'))) {
                    refTSLastSeparateTriggered.current = Date.now();
                }
                onPaste === null || onPaste === void 0 ? void 0 : onPaste(e);
            },
            // Option Items
            onRemoveCheckedItem: function (_, index, event) {
                event.stopPropagation();
                uncheckOption(value[index]);
            },
            onClear: function (event) {
                event.stopPropagation();
                if (isMultipleMode) {
                    // 保留已经被选中但被disabled的选项值
                    var newValue = value.filter(function (v) {
                        var item = optionInfoMap.get(v);
                        return item && item.disabled;
                    });
                    tryUpdateSelectValue(newValue);
                }
                else {
                    tryUpdateSelectValue(undefined);
                }
                tryUpdateInputValue('', 'manual');
                onClear === null || onClear === void 0 ? void 0 : onClear(popupVisible);
            },
        };
        React.useImperativeHandle(ref, function () {
            var _a;
            return ({
                dom: (_a = refSelectView.current) === null || _a === void 0 ? void 0 : _a.dom,
                focus: function () {
                    refSelectView.current && refSelectView.current.focus();
                },
                blur: function () {
                    refSelectView.current && refSelectView.current.blur();
                },
                hotkeyHandler: hotkeyHandler,
                activeOptionValue: valueActive,
                getOptionInfoByValue: getOptionInfoByValue,
                getOptionInfoList: function () { return __spreadArray$v([], __read$19(optionInfoMap.values()), false).filter(function (info) { return info._valid; }); },
            });
        }, [hotkeyHandler, optionInfoMap, valueActive]);
        var renderView = function (eleView) {
            return (React.createElement(Trigger$1, __assign$1J({ ref: function (ref) { return (refTrigger.current = ref); }, popup: renderPopup, trigger: trigger, disabled: disabled, getPopupContainer: getPopupContainer, classNames: "slideDynamicOrigin", autoAlignPopupWidth: true, popupAlign: { bottom: 4 }, popupVisible: popupVisible, unmountOnExit: unmountOnExit, onVisibleChange: tryUpdatePopupVisible, __onExit: function () {
                    refPopupExiting.current = true;
                }, __onExited: function () {
                    refPopupExiting.current = false;
                    tryUpdateInputValue('', 'optionListHide');
                } }, omit$1(triggerProps, ['popupVisible', 'onVisibleChange'])), eleView));
        };
        var usedTriggerElement = typeof triggerElement === 'function'
            ? triggerElement(getValueAndOptionForCallback(value))
            : triggerElement;
        return (React.createElement(ResizeObserver$1, { onResize: function () { return refTrigger.current.updatePopupPosition(); } }, usedTriggerElement !== undefined && usedTriggerElement !== null ? (renderView(usedTriggerElement)) : (React.createElement(SelectView$1, __assign$1J({}, props, selectViewEventHandlers, { ref: refSelectView, 
            // state
            value: value, inputValue: inputValue, popupVisible: popupVisible, 
            // other
            rtl: rtl, prefixCls: prefixCls, ariaControls: instancePopupID, isEmptyValue: isNoOptionSelected, isMultiple: isMultipleMode, onSort: tryUpdateSelectValue, renderText: function (value) {
                var option = getOptionInfoByValue(value);
                var text = value;
                if (isFunction$1(renderFormat)) {
                    var paramsForCallback = getValueAndOptionForCallback(value, false);
                    text = renderFormat(paramsForCallback.option || null, paramsForCallback.value);
                }
                else {
                    var foundLabelFromProps = false;
                    if (labelInValue) {
                        var propValue = props.value || props.defaultValue;
                        if (Array.isArray(propValue)) {
                            var targetLabeledValue = propValue.find(function (item) { return isObject$1(item) && item.value === value; });
                            if (targetLabeledValue) {
                                text = targetLabeledValue.label;
                                foundLabelFromProps = true;
                            }
                        }
                        else if (isObject$1(propValue)) {
                            text = propValue.label;
                            foundLabelFromProps = true;
                        }
                    }
                    if (!foundLabelFromProps && option && 'children' in option) {
                        text = option.children;
                    }
                }
                return {
                    text: text,
                    disabled: option && option.disabled,
                };
            }, renderView: renderView })))));
    }
    var ForwardRefSelect = React.forwardRef(Select$2);
    var SelectComponent = ForwardRefSelect;
    SelectComponent.displayName = 'Select';
    SelectComponent.Option = Option$4;
    SelectComponent.OptGroup = OptGroup$1;
    var Select$3 = SelectComponent;

    var __assign$1I = (undefined && undefined.__assign) || function () {
        __assign$1I = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1I.apply(this, arguments);
    };
    var __rest$R = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var defaultProps$y = {
        position: 'top',
        trigger: 'hover',
        escToClose: false,
        unmountOnExit: true,
        blurToHide: true,
        popupHoverStay: true,
    };
    function Tooltip(baseProps, ref) {
        var _a = React.useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, componentConfig = _a.componentConfig;
        var props = useMergeProps(baseProps, defaultProps$y, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Tooltip);
        var style = props.style, className = props.className, children = props.children, trigger = props.trigger, escToClose = props.escToClose, defaultPopupVisible = props.defaultPopupVisible, position = props.position, unmountOnExit = props.unmountOnExit, popupVisible = props.popupVisible, tooltipPrefixCls = props.prefixCls, blurToHide = props.blurToHide, popupHoverStay = props.popupHoverStay, disabled = props.disabled, onVisibleChange = props.onVisibleChange, triggerProps = props.triggerProps, childrenPrefix = props.childrenPrefix, getPopupContainer = props.getPopupContainer, content = props.content, mini = props.mini, color = props.color, rest = __rest$R(props, ["style", "className", "children", "trigger", "escToClose", "defaultPopupVisible", "position", "unmountOnExit", "popupVisible", "prefixCls", "blurToHide", "popupHoverStay", "disabled", "onVisibleChange", "triggerProps", "childrenPrefix", "getPopupContainer", "content", "mini", "color"]);
        var refTrigger = React.useRef();
        var updatePopupPosition = function (delay, callback) {
            if (delay === void 0) { delay = 0; }
            refTrigger.current && refTrigger.current.updatePopupPosition(delay, callback);
        };
        React.useImperativeHandle(ref, function () { return ({
            updatePopupPosition: updatePopupPosition,
        }); }, []);
        var prefixCls = tooltipPrefixCls || getPrefixCls('tooltip');
        var otherProps = __assign$1I(__assign$1I(__assign$1I({}, pick(rest, EventsByTriggerNeed)), pickDataAttributes(rest)), triggerProps);
        var renderedContent = isFunction$1(content) ? content() : content;
        // it is important to note that this method has its limitations
        // it fails in cases such as content = <>&nbsp;&nbsp;</>
        var isEmpty = function (content) {
            if (content === null || content === undefined || content === false) {
                return true;
            }
            if (typeof content === 'string' && content.trim() === '') {
                return true;
            }
            return false;
        };
        if ('popupVisible' in props) {
            otherProps.popupVisible = popupVisible;
        }
        else if (isEmpty(renderedContent)) {
            // hide if empty content
            otherProps.popupVisible = false;
        }
        if (otherProps.showArrow !== false || otherProps.arrowProps) {
            otherProps.arrowProps = otherProps.arrowProps || {};
            if (color) {
                otherProps.arrowProps.style = __assign$1I({ backgroundColor: color }, otherProps.arrowProps.style);
            }
        }
        return (React.createElement(Trigger$1, __assign$1I({ style: __assign$1I({ maxWidth: 350 }, style), className: className, ref: refTrigger, classNames: "zoomInFadeOut", duration: {
                enter: 300,
                exit: 100,
            }, popup: function () {
                var _a;
                return (React.createElement("div", { style: { backgroundColor: color }, className: cs(prefixCls + "-content", prefixCls + "-content-" + position, (_a = {},
                        _a[prefixCls + "-mini"] = mini,
                        _a)), role: "tooltip" },
                    React.createElement("div", { className: prefixCls + "-content-inner" }, renderedContent)));
            }, position: position, disabled: disabled, trigger: trigger, escToClose: escToClose, showArrow: true, popupAlign: {
                left: 12,
                right: 12,
                top: 12,
                bottom: 12,
            }, mouseEnterDelay: 200, mouseLeaveDelay: 200, unmountOnExit: unmountOnExit, popupHoverStay: popupHoverStay, blurToHide: blurToHide, childrenPrefix: childrenPrefix || prefixCls, getPopupContainer: getPopupContainer, onVisibleChange: onVisibleChange, defaultPopupVisible: defaultPopupVisible }, otherProps), children));
    }
    var TooltipComponent = React.forwardRef(Tooltip);
    TooltipComponent.displayName = 'Tooltip';
    var Tooltip$1 = TooltipComponent;

    var __assign$1H = (undefined && undefined.__assign) || function () {
        __assign$1H = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1H.apply(this, arguments);
    };
    var __rest$Q = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var defaultProps$x = {
        position: 'top',
        trigger: 'hover',
        unmountOnExit: true,
    };
    function Popover(baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$x, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Popover);
        var style = props.style, className = props.className, children = props.children, position = props.position, getPopupContainer = props.getPopupContainer, trigger = props.trigger, defaultPopupVisible = props.defaultPopupVisible, popupVisible = props.popupVisible, triggerProps = props.triggerProps, unmountOnExit = props.unmountOnExit, onVisibleChange = props.onVisibleChange, content = props.content, title = props.title, rest = __rest$Q(props, ["style", "className", "children", "position", "getPopupContainer", "trigger", "defaultPopupVisible", "popupVisible", "triggerProps", "unmountOnExit", "onVisibleChange", "content", "title"]);
        var prefixCls = getPrefixCls('popover');
        return (React.createElement(Tooltip$1, __assign$1H({}, rest, { ref: ref, style: __assign$1H({ maxWidth: 350 }, style), className: className, prefixCls: prefixCls, getPopupContainer: getPopupContainer, position: position, trigger: trigger, content: React.createElement("div", { className: cs(prefixCls + "-inner", (_a = {}, _a[prefixCls + "-inner-rtl"] = rtl, _a)) },
                title ? React.createElement("div", { className: prefixCls + "-title" }, title) : null,
                React.createElement("div", { className: prefixCls + "-inner-content" }, content)), popupHoverStay: true, unmountOnExit: unmountOnExit, triggerProps: triggerProps, defaultPopupVisible: defaultPopupVisible, onVisibleChange: onVisibleChange || (triggerProps ? triggerProps.onVisibleChange : undefined), childrenPrefix: prefixCls }, ('popupVisible' in props ? { popupVisible: popupVisible } : {})), typeof children === 'string' ? React.createElement("span", null, children) : children));
    }
    var PopoverComponent = React.forwardRef(Popover);
    PopoverComponent.displayName = 'Popover';
    var Popover$1 = PopoverComponent;

    var __read$18 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    function Count(_a) {
        var _b;
        var prefixCls = _a.prefixCls, maxCount = _a.maxCount, count = _a.count, className = _a.className, style = _a.style;
        var _c = __read$18(React.useState(false), 2), isEntered = _c[0], setIsEntered = _c[1];
        var oldCount = usePrevious(count);
        var isChanged = count !== oldCount;
        return (React.createElement(CSSTransition$1, { classNames: "badge-zoom", in: count > 0, timeout: 300, appear: true, mountOnEnter: true, unmountOnExit: true, onEntered: function () {
                setIsEntered(true);
            } },
            React.createElement("span", { className: className, style: style },
                React.createElement("span", { key: count, className: cs((_b = {}, _b[prefixCls + "-number-text"] = isEntered && isChanged, _b)) }, maxCount && count > maxCount ? maxCount + "+" : count))));
    }

    var __assign$1G = (undefined && undefined.__assign) || function () {
        __assign$1G = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1G.apply(this, arguments);
    };
    var __rest$P = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$17 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var InnerColors = [
        'red',
        'orangered',
        'orange',
        'gold',
        'lime',
        'green',
        'cyan',
        'arcoblue',
        'purple',
        'pinkpurple',
        'magenta',
        'gray',
    ];
    var defaultProps$w = {
        count: 0,
        maxCount: 99,
    };
    function Badge(baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$w, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Badge);
        var count = props.count, text = props.text, className = props.className, dotClassName = props.dotClassName, dot = props.dot, maxCount = props.maxCount, color = props.color, propsDotStyle = props.dotStyle, offset = props.offset, style = props.style, status = props.status, children = props.children, restProps = __rest$P(props, ["count", "text", "className", "dotClassName", "dot", "maxCount", "color", "dotStyle", "offset", "style", "status", "children"]);
        var prefixCls = getPrefixCls('badge');
        var dotStyle = __assign$1G({}, (propsDotStyle || {}));
        var _c = __read$17(offset || [], 2), leftOffset = _c[0], topOffset = _c[1];
        if (leftOffset) {
            dotStyle.marginRight = -leftOffset;
        }
        if (topOffset) {
            dotStyle.marginTop = topOffset;
        }
        var getDom = function () {
            var _a, _b;
            if (isObject$1(count)) {
                return (React.createElement("span", { className: cs(prefixCls + "-custom-dot", dotClassName), style: dotStyle }, count));
            }
            var colorStyle = !color || InnerColors.indexOf(color) > -1 ? {} : { backgroundColor: color };
            // display a red dot if color and status are NOT set
            if (text && !color && !status) {
                return (React.createElement("span", { className: cs(prefixCls + "-text", dotClassName), style: dotStyle }, text));
            }
            if (status || (color && count <= 0)) {
                return (React.createElement("span", { className: prefixCls + "-status-wrapper" },
                    React.createElement("span", { className: cs(prefixCls + "-status-dot", (_a = {},
                            _a[prefixCls + "-status-" + status] = status,
                            _a[prefixCls + "-color-" + color] = color,
                            _a), dotClassName), style: __assign$1G(__assign$1G({}, colorStyle), dotStyle) }),
                    text && React.createElement("span", { className: prefixCls + "-status-text" }, text)));
            }
            if ((dot || color) && count > 0) {
                return (React.createElement(CSSTransition$1, { classNames: "badge-zoom", in: dot || !!color, timeout: 200, appear: true, mountOnEnter: true, unmountOnExit: true },
                    React.createElement("span", { className: cs(prefixCls + "-dot", (_b = {},
                            _b[prefixCls + "-color-" + color] = color,
                            _b), dotClassName), style: __assign$1G(__assign$1G({}, colorStyle), dotStyle) })));
            }
            return (React.createElement(Count, { prefixCls: prefixCls, className: cs(prefixCls + "-number", dotClassName), style: __assign$1G(__assign$1G({}, colorStyle), dotStyle), maxCount: maxCount, count: count }));
        };
        return (React.createElement("span", __assign$1G({ className: cs(prefixCls, (_a = {},
                _a[prefixCls + "-status"] = status,
                _a[prefixCls + "-no-children"] = !children,
                _a[prefixCls + "-rtl"] = rtl,
                _a), className), ref: ref, style: style }, restProps),
            children,
            getDom()));
    }
    var BadgeComponent = React.forwardRef(Badge);
    BadgeComponent.displayName = 'Badge';
    var Badge$1 = BadgeComponent;

    function ownKeys$G(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$H(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$G(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$G(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconMoreComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$H(_objectSpread$H({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-more")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        stroke: "none",
        d: "M38 25v-2h2v2h-2ZM23 25v-2h2v2h-2ZM8 25v-2h2v2H8Z"
      }), /*#__PURE__*/React.createElement("path", {
        d: "M38 25v-2h2v2h-2ZM23 25v-2h2v2h-2ZM8 25v-2h2v2H8Z"
      }));
    }

    var IconMore = /*#__PURE__*/React.forwardRef(IconMoreComponent);
    IconMore.defaultProps = {
      isIcon: true
    };
    IconMore.displayName = 'IconMore';
    var IconMore$1 = IconMore;

    var __assign$1F = (undefined && undefined.__assign) || function () {
        __assign$1F = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1F.apply(this, arguments);
    };
    var __read$16 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var defaultProps$v = {
        position: 'br',
        trigger: 'hover',
        type: 'default',
        icon: React.createElement(IconMore$1, null),
        unmountOnExit: true,
    };
    function Button(baseProps, ref) {
        var _a;
        var componentConfig = React.useContext(ConfigContext).componentConfig;
        var props = useMergeProps(baseProps, defaultProps$v, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig['Dropdown.Button']);
        var className = props.className, style = props.style, children = props.children, disabled = props.disabled, droplist = props.droplist, _b = props.position, position = _b === void 0 ? 'br' : _b, _c = props.trigger, trigger = _c === void 0 ? 'hover' : _c, _d = props.type, type = _d === void 0 ? 'default' : _d, size = props.size, _e = props.icon, icon = _e === void 0 ? React.createElement(IconMore$1, null) : _e, _f = props.unmountOnExit, unmountOnExit = _f === void 0 ? true : _f, onClick = props.onClick, onVisibleChange = props.onVisibleChange, buttonProps = props.buttonProps, buttonsRender = props.buttonsRender;
        var leftButton = (React.createElement(Button$3, __assign$1F({ disabled: disabled, type: type, size: size, onClick: onClick }, buttonProps), children));
        var rightButton = (React.createElement(Button$3, { disabled: disabled, type: type, size: size, icon: icon }));
        if (buttonsRender) {
            _a = __read$16(buttonsRender([leftButton, rightButton]), 2), leftButton = _a[0], rightButton = _a[1];
        }
        var disableTrigger = disabled ||
            !rightButton ||
            (rightButton.props && rightButton.props.loading);
        return (React.createElement(Button$3.Group, __assign$1F({ className: className, style: style, ref: ref }, pickDataAttributes(props)),
            leftButton,
            React.createElement(Dropdown$1, { disabled: disabled, droplist: droplist, position: position, trigger: trigger, unmountOnExit: unmountOnExit, onVisibleChange: onVisibleChange, triggerProps: {
                    disabled: disableTrigger,
                } }, rightButton)));
    }
    var ButtonComponent = React.forwardRef(Button);
    ButtonComponent.displayName = 'DropdownButton';
    var Button$1 = ButtonComponent;

    var __assign$1E = (undefined && undefined.__assign) || function () {
        __assign$1E = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1E.apply(this, arguments);
    };
    var __rest$O = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$15 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __values = (undefined && undefined.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __spreadArray$u = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var defaultProps$u = {
        position: 'bl',
        trigger: 'hover',
        unmountOnExit: true,
    };
    function Dropdown(baseProps, _) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$u, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Button);
        var trigger = props.trigger, droplist = props.droplist, children = props.children, position = props.position, disabled = props.disabled, unmountOnExit = props.unmountOnExit, triggerProps = props.triggerProps, getPopupContainer = props.getPopupContainer, onVisibleChange = props.onVisibleChange, rest = __rest$O(props, ["trigger", "droplist", "children", "position", "disabled", "unmountOnExit", "triggerProps", "getPopupContainer", "onVisibleChange"]);
        var prefixCls = getPrefixCls('dropdown');
        var triggerRef = React.useRef(null);
        var _c = __read$15(useMergeValue(false, {
            defaultValue: props.defaultPopupVisible,
            value: props.popupVisible,
        }), 2), popupVisible = _c[0], setPopupVisible = _c[1];
        var getPopupContent = function () {
            return React.Children.only(droplist || React.createElement("span", null));
        };
        var changePopupVisible = function (visible) {
            setPopupVisible(visible);
            onVisibleChange && onVisibleChange(visible);
            triggerProps && triggerProps.onVisibleChange && triggerProps.onVisibleChange(visible);
        };
        var handleVisibleChange = function (visible) {
            if (visible !== popupVisible) {
                changePopupVisible(visible);
            }
        };
        var renderPopup = function () {
            var e_1, _a, _b;
            var content = getPopupContent();
            // props.isMenu: Compatible Menu.defaultProps.isMenu = true
            if (get_1(content, 'type.__ARCO_MENU__') || get_1(content, 'props.isMenu')) {
                var isEmpty = true;
                try {
                    for (var _c = __values(React.Children.toArray(content.props.children)), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var child = _d.value;
                        if (child !== null && child !== undefined) {
                            isEmpty = false;
                            break;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return React.cloneElement(content, {
                    prefixCls: cs(prefixCls + "-menu", (_b = {},
                        _b[prefixCls + "-menu-hidden"] = isEmpty,
                        _b)),
                    inDropdown: true,
                    selectable: false,
                    onClickMenuItem: function () {
                        var _a;
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        var returnValueOfOnClickMenuItem = null;
                        // Trigger onClickMenuItem first
                        var content = getPopupContent();
                        if (content.props.onClickMenuItem) {
                            returnValueOfOnClickMenuItem = (_a = content.props).onClickMenuItem.apply(_a, __spreadArray$u([], __read$15(args), false));
                        }
                        // Set focus to avoid onblur
                        var child = triggerRef.current && triggerRef.current.getRootElement();
                        child && child.focus && child.focus();
                        // Trigger onVisibleChange. Outer component can determine whether to change the state based on the current visibility value.
                        if (returnValueOfOnClickMenuItem instanceof Promise) {
                            returnValueOfOnClickMenuItem.finally(function () { return changePopupVisible(false); });
                        }
                        else if (returnValueOfOnClickMenuItem !== false) {
                            changePopupVisible(false);
                        }
                    },
                });
            }
            return content;
        };
        return (React.createElement(Trigger$1, __assign$1E({ ref: function (ref) { return (triggerRef.current = ref); }, classNames: "slideDynamicOrigin", childrenPrefix: prefixCls, trigger: trigger, popup: renderPopup, mouseEnterDelay: 400, mouseLeaveDelay: 400, disabled: disabled, unmountOnExit: unmountOnExit, position: position, popupVisible: popupVisible, popupAlign: {
                left: 4,
                right: 4,
                top: 4,
                bottom: 4,
            }, getPopupContainer: getPopupContainer, alignPoint: trigger === 'contextMenu' }, pick(rest, EventsByTriggerNeed), pickDataAttributes(rest), omit$1(triggerProps, ['onVisibleChange']), { onVisibleChange: handleVisibleChange }), React.isValidElement(children)
            ? React.cloneElement(children, __assign$1E(__assign$1E({}, (typeof disabled === 'boolean' ? { disabled: disabled } : {})), { className: cs((_a = {},
                    _a[prefixCls + "-popup-visible"] = popupVisible,
                    _a[[prefixCls] + "-rtl"] = rtl,
                    _a), children.props.className) }))
            : children));
    }
    var ForwardRefDropdown = React.forwardRef(Dropdown);
    var DropdownComponent = ForwardRefDropdown;
    DropdownComponent.displayName = 'Dropdown';
    DropdownComponent.Button = Button$1;
    var Dropdown$1 = DropdownComponent;

    var MenuContext = React.createContext({});
    var MenuContext$1 = MenuContext;

    var __read$14 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$t = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    function MenuIndent(props) {
        var prefixCls = props.prefixCls, levelIndent = props.levelIndent;
        var collapse = React.useContext(MenuContext$1).collapse;
        var level = props.level - 1;
        return !collapse && level > 0 ? (React.createElement("span", null, __spreadArray$t([], __read$14(new Array(level)), false).map(function (_, index) {
            return (React.createElement("span", { key: index, className: prefixCls + "-indent", style: { width: levelIndent } }));
        }))) : null;
    }

    var __assign$1D = (undefined && undefined.__assign) || function () {
        __assign$1D = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1D.apply(this, arguments);
    };
    var __read$13 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$s = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };

    var PROPS_NEED_TO_BE_PASSED_IN_SUBMENU = ['popup', 'triggerProps', 'selectable'];
    // Expand MenuGroup to get an array only contains MenuItem and SubMenu
    var flatMenuGroup = function (children) {
        var validMenuItems = [];
        React.Children.forEach(children, function (item) {
            var _a;
            var menuType = (_a = item === null || item === void 0 ? void 0 : item.type) === null || _a === void 0 ? void 0 : _a.menuType;
            if (menuType === 'MenuItem' || menuType === 'SubMenu') {
                validMenuItems.push(item);
            }
            else if (menuType === 'MenuGroup') {
                validMenuItems = validMenuItems.concat(flatMenuGroup(item.props.children));
            }
        });
        return validMenuItems;
    };
    var generateInfoMap = function (children, keyPath, result) {
        if (keyPath === void 0) { keyPath = []; }
        if (result === void 0) { result = {}; }
        var validChildrenList = flatMenuGroup(children);
        validChildrenList.forEach(function (item, index) {
            var _a;
            var _b, _c;
            var key = item.key;
            var menuType = item.type.menuType;
            var _keyPath = __spreadArray$s([key], __read$13(keyPath), false);
            var info = {
                keyPath: [],
                prev: ((_b = validChildrenList[index - 1]) === null || _b === void 0 ? void 0 : _b.key) || null,
                next: ((_c = validChildrenList[index + 1]) === null || _c === void 0 ? void 0 : _c.key) || null,
            };
            if (index === 0 || index === validChildrenList.length - 1) {
                var parentKey = _keyPath[1];
                var propertyName = index === 0 ? 'firstChild' : 'lastChild';
                if (parentKey) {
                    result[parentKey] = __assign$1D(__assign$1D({}, result[parentKey]), (_a = {}, _a[propertyName] = key, _a));
                }
            }
            switch (menuType) {
                case 'SubMenu':
                    info.keyPath = _keyPath;
                    generateInfoMap(item.props.children, _keyPath, result);
                    break;
                case 'MenuItem':
                    info.keyPath = _keyPath;
                    info.disabled = item.props.disabled;
                    break;
            }
            result[key] = __assign$1D(__assign$1D({}, result[key]), info);
        });
        return result;
    };
    var processChildren = function (children, props) {
        return React.Children.map(children, function (item, index) {
            if (!item || !item.props) {
                return item;
            }
            var isHTMLElement = typeof item.type === 'string';
            var isMenuSubComponent = item.type && item.type.menuType;
            // 处理 <div> 包裹 MenuItem 之类的情况
            if (!isMenuSubComponent && item.props.children) {
                var _props = isHTMLElement ? {} : props;
                return React.cloneElement(item, __assign$1D(__assign$1D({}, _props), { _key: item.key, children: processChildren(item.props.children, props) }));
            }
            return isHTMLElement
                ? item
                : React.cloneElement(item, __assign$1D(__assign$1D(__assign$1D({}, props), item.props), { _key: item.key || "$menu-" + index }));
        });
    };
    function isChildrenSelected(children, keys) {
        var find = false;
        function loop(_children) {
            if (!_children || find) {
                return;
            }
            React.Children.forEach(_children, function (c) {
                if (c && c.props && c.type && !find) {
                    var menuType = c.type.menuType;
                    var selectable = c.props.selectable;
                    if (menuType === 'MenuItem') {
                        find = keys.indexOf(c.key) !== -1;
                    }
                    else if (menuType === 'SubMenu' && selectable) {
                        find = keys.indexOf(c.key) !== -1;
                    }
                    if (!find && c.props.children) {
                        loop(c.props.children);
                    }
                }
            });
        }
        loop(children);
        return find;
    }

    var __assign$1C = (undefined && undefined.__assign) || function () {
        __assign$1C = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1C.apply(this, arguments);
    };
    var __rest$N = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function Item$3(props, ref) {
        var _a;
        var _key = props._key, children = props.children, level = props.level, disabled = props.disabled, className = props.className, style = props.style, _b = props.wrapper, WrapperTagName = _b === void 0 ? 'div' : _b, onClick = props.onClick, rest = __rest$N(props, ["_key", "children", "level", "disabled", "className", "style", "wrapper", "onClick"]);
        var _c = React.useContext(MenuContext$1), prefixCls = _c.prefixCls, mode = _c.mode, collapse = _c.collapse, inDropdown = _c.inDropdown, levelIndent = _c.levelIndent, selectedKeys = _c.selectedKeys, autoScrollIntoView = _c.autoScrollIntoView, scrollConfig = _c.scrollConfig, tooltipProps = _c.tooltipProps, onClickMenuItem = _c.onClickMenuItem;
        var refElement = React.useRef(null);
        var isFirstRender = useIsFirstRender();
        var needTextIndent = mode === 'vertical' && level > 1;
        var needTooltip = collapse && !inDropdown && level === 1;
        var isSelected = selectedKeys && ~selectedKeys.indexOf(_key);
        React.useEffect(function () {
            var shouldScroll = isSelected && autoScrollIntoView;
            if (refElement.current && shouldScroll) {
                // 首次渲染需要等待展开动画结束之后滚动
                setTimeout(function () {
                    scrollIntoView(refElement.current, __assign$1C({ behavior: 'smooth', block: 'start', scrollMode: 'if-needed', boundary: document.body }, scrollConfig));
                }, isFirstRender ? 500 : 0);
            }
        }, [isSelected, autoScrollIntoView]);
        var menuItemClickHandler = function (event) {
            if (!disabled) {
                onClickMenuItem(_key, event);
                onClick && onClick(event);
            }
        };
        var itemElement = (React.createElement(WrapperTagName, __assign$1C({ tabIndex: disabled ? -1 : 0, role: "menuitem", ref: function (_ref) {
                ref = _ref;
                refElement.current = ref;
            }, style: style, className: cs(prefixCls + "-item", (_a = {},
                _a[prefixCls + "-disabled"] = disabled,
                _a[prefixCls + "-selected"] = isSelected,
                // 存在缩进dom
                _a[prefixCls + "-item-indented"] = needTextIndent && !collapse,
                _a), className), onClick: menuItemClickHandler, onKeyDown: function (event) {
                var keyCode = event.keyCode || event.which;
                if (keyCode === Enter.code) {
                    menuItemClickHandler(event);
                }
            } }, omit$1(rest, ['key', '_key'].concat(PROPS_NEED_TO_BE_PASSED_IN_SUBMENU))),
            needTextIndent && !collapse ? (React.createElement(React.Fragment, null,
                React.createElement(MenuIndent, { prefixCls: prefixCls, levelIndent: levelIndent, level: level }),
                React.createElement("span", { className: prefixCls + "-item-inner", style: {
                        display: 'block',
                    } }, children))) : (children),
            isSelected && mode === 'horizontal' ? (React.createElement("div", { className: prefixCls + "-selected-label" })) : null));
        return needTooltip ? (React.createElement(Tooltip$1, __assign$1C({ trigger: "hover", content: React.createElement("span", null, children), position: "right", triggerProps: __assign$1C({ className: prefixCls + "-item-tooltip" }, ((tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.triggerProps) || {})) }, omit$1(tooltipProps, ['triggerProps'])), itemElement)) : (itemElement);
    }
    var ForwardRefItem$1 = React.forwardRef(Item$3);
    var ItemComponent$1 = ForwardRefItem$1;
    ItemComponent$1.displayName = 'MenuItem';
    ItemComponent$1.menuType = 'MenuItem';
    var Item$4 = ItemComponent$1;

    function ItemGroup(props, ref) {
        var children = props.children, title = props.title, level = props.level, className = props.className, style = props.style;
        var _a = React.useContext(MenuContext$1), prefixCls = _a.prefixCls, levelIndent = _a.levelIndent;
        var childrenLevel = level === 1 ? level + 1 : level;
        var childrenList = processChildren(children, { level: childrenLevel });
        return (React.createElement("div", { ref: ref, className: cs(prefixCls + "-group", className), style: style },
            React.createElement("div", { className: prefixCls + "-group-title" },
                React.createElement(MenuIndent, { level: level, prefixCls: prefixCls, levelIndent: levelIndent }),
                React.createElement("span", null, title)),
            childrenList));
    }
    var ForwardRefItemGroup = React.forwardRef(ItemGroup);
    var ItemGroupComponent = ForwardRefItemGroup;
    ItemGroupComponent.displayName = 'MenuItemGroup';
    ItemGroupComponent.menuType = 'MenuGroup';
    var ItemGroup$1 = ItemGroupComponent;

    var __assign$1B = (undefined && undefined.__assign) || function () {
        __assign$1B = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1B.apply(this, arguments);
    };
    var __awaiter$5 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$5 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __rest$M = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$12 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    // Use visibility: hidden to avoid Menu.Item get focused by Tab key
    var CONTENT_HIDDEN_STYLE = { height: 0, visibility: 'hidden' };
    var SubMenuInline = function (props) {
        var _a;
        var _key = props._key, children = props.children, style = props.style, className = props.className, title = props.title, level = props.level, forwardedRef = props.forwardedRef, selectable = props.selectable, rest = __rest$M(props, ["_key", "children", "style", "className", "title", "level", "forwardedRef", "selectable"]);
        var _b = React.useContext(MenuContext$1), menuId = _b.id, prefixCls = _b.prefixCls, levelIndent = _b.levelIndent, _c = _b.openKeys, openKeys = _c === void 0 ? [] : _c, _d = _b.selectedKeys, selectedKeys = _d === void 0 ? [] : _d, icons = _b.icons, onClickSubMenu = _b.onClickSubMenu, onClickMenuItem = _b.onClickMenuItem;
        var baseClassName = prefixCls + "-inline";
        var isOpen = (openKeys === null || openKeys === void 0 ? void 0 : openKeys.indexOf(_key)) > -1;
        var isSelected = (selectable && selectedKeys.indexOf(props._key) > -1) ||
            isChildrenSelected(children, selectedKeys);
        var _e = __read$12(useStateWithPromise(isOpen ? { height: 'auto' } : CONTENT_HIDDEN_STYLE), 2), contentStyle = _e[0], setContentStyle = _e[1];
        var subMenuClickHandler = function (event) {
            onClickSubMenu(_key, level, 'inline');
            selectable && onClickMenuItem(_key, event);
        };
        // Unique ID of this instance
        var instanceId = useId(menuId + "-submenu-inline-");
        // Should omit these properties in Menu.Item
        var childrenList = processChildren(children, __assign$1B(__assign$1B({}, pick(rest, PROPS_NEED_TO_BE_PASSED_IN_SUBMENU)), { level: level + 1, selectable: selectable }));
        var header = (React.createElement("div", { tabIndex: 0, "aria-expanded": isOpen, "aria-controls": instanceId, className: cs(baseClassName + "-header", (_a = {},
                _a[prefixCls + "-selected"] = isSelected,
                _a)), onClick: subMenuClickHandler, onKeyDown: function (event) {
                var keyCode = event.keyCode || event.which;
                if (keyCode === Enter.code) {
                    subMenuClickHandler(event);
                }
            } },
            React.createElement(MenuIndent, { level: level, prefixCls: prefixCls, levelIndent: levelIndent }),
            React.createElement("span", null, title),
            React.createElement("span", { className: prefixCls + "-icon-suffix " + (isOpen ? 'is-open' : '') }, icons && icons.horizontalArrowDown ? icons.horizontalArrowDown : React.createElement(IconDown$1, null))));
        var content = (React.createElement("div", { id: instanceId, className: cs(baseClassName + "-content"), style: contentStyle }, childrenList));
        return (React.createElement("div", __assign$1B({ ref: forwardedRef, className: cs(baseClassName, className), style: style }, omit$1(rest, ['key', 'popup', 'triggerProps'])),
            header,
            React.createElement(CSSTransition$1, { in: isOpen, timeout: 200, classNames: baseClassName, unmountOnExit: false, onEnter: function (element) { return __awaiter$5(void 0, void 0, void 0, function () {
                    return __generator$5(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, setContentStyle(CONTENT_HIDDEN_STYLE)];
                            case 1:
                                _a.sent();
                                return [4 /*yield*/, setContentStyle({ height: element.scrollHeight })];
                            case 2:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); }, onEntered: function () {
                    setContentStyle({ height: 'auto' });
                }, onExit: function (element) { return __awaiter$5(void 0, void 0, void 0, function () {
                    return __generator$5(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, setContentStyle({ height: element.scrollHeight })];
                            case 1:
                                _a.sent();
                                return [4 /*yield*/, setContentStyle(CONTENT_HIDDEN_STYLE)];
                            case 2:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); } }, content)));
    };
    var SubMenuInline$1 = SubMenuInline;

    function ownKeys$F(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$G(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$F(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$F(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconRightComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$G(_objectSpread$G({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-right")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "m16 39.513 15.556-15.557L16 8.4"
      }));
    }

    var IconRight = /*#__PURE__*/React.forwardRef(IconRightComponent);
    IconRight.defaultProps = {
      isIcon: true
    };
    IconRight.displayName = 'IconRight';
    var IconRight$1 = IconRight;

    function ownKeys$E(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$F(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$E(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$E(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconLeftComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$F(_objectSpread$F({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-left")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M32 8.4 16.444 23.956 32 39.513"
      }));
    }

    var IconLeft = /*#__PURE__*/React.forwardRef(IconLeftComponent);
    IconLeft.defaultProps = {
      isIcon: true
    };
    IconLeft.displayName = 'IconLeft';
    var IconLeft$1 = IconLeft;

    var __assign$1A = (undefined && undefined.__assign) || function () {
        __assign$1A = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1A.apply(this, arguments);
    };
    var __rest$L = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$11 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var SubMenuPop = function (props) {
        var _a;
        var _key = props._key, children = props.children, style = props.style, className = props.className, title = props.title, level = props.level, selectable = props.selectable, forwardedRef = props.forwardedRef, propTriggerProps = props.triggerProps, rest = __rest$L(props, ["_key", "children", "style", "className", "title", "level", "selectable", "forwardedRef", "triggerProps"]);
        var _b = React.useContext(MenuContext$1), menuId = _b.id, prefixCls = _b.prefixCls, mode = _b.mode, inDropdown = _b.inDropdown, levelIndent = _b.levelIndent, _c = _b.selectedKeys, selectedKeys = _c === void 0 ? [] : _c, icons = _b.icons, contextTriggerProps = _b.triggerProps, onClickSubMenu = _b.onClickSubMenu, onClickMenuItem = _b.onClickMenuItem;
        var rtl = React.useContext(ConfigContext).rtl;
        var triggerProps = __assign$1A(__assign$1A({}, contextTriggerProps), propTriggerProps);
        var _d = __read$11(React.useState(false), 2), popupVisible = _d[0], setPopupVisible = _d[1];
        var baseClassName = prefixCls + "-pop";
        var isSelected = selectable && selectedKeys.indexOf(props._key) > -1;
        var needPopOnBottom = mode === 'horizontal' && !inDropdown;
        // Unique ID of this instance
        var instanceId = useId(menuId + "-submenu-pop-");
        var renderSuffix = function () {
            var MergedIconRight = icons && icons.popArrowRight ? icons.popArrowRight : rtl ? React.createElement(IconLeft$1, null) : React.createElement(IconRight$1, null);
            var MergedIconDown = icons && icons.horizontalArrowDown ? icons.horizontalArrowDown : React.createElement(IconDown$1, null);
            return (React.createElement("span", { className: prefixCls + "-icon-suffix" }, needPopOnBottom ? MergedIconDown : MergedIconRight));
        };
        var hasSelectedStatus = isChildrenSelected(children, selectedKeys) || isSelected;
        var popPosition = rtl ? ['br', 'lt'] : ['bl', 'rt'];
        var subMenuClickHandler = function (event) {
            onClickSubMenu(_key, level, 'pop');
            selectable && onClickMenuItem(_key, event);
        };
        return (React.createElement(Dropdown$1, { trigger: "hover", popupVisible: popupVisible, onVisibleChange: setPopupVisible, droplist: React.createElement(Menu$1, { id: instanceId, selectedKeys: selectedKeys, onClickMenuItem: function (key, event) {
                    onClickMenuItem(key, event);
                    setPopupVisible(false);
                } }, children), triggerProps: __assign$1A({ position: needPopOnBottom ? popPosition[0] : popPosition[1], showArrow: true, autoAlignPopupMinWidth: true, classNames: 'fadeIn', duration: 100, mouseEnterDelay: 50, mouseLeaveDelay: 50, className: cs(baseClassName + "-trigger", triggerProps && triggerProps.className) }, omit$1(triggerProps, ['className'])) },
            React.createElement("div", __assign$1A({ tabIndex: 0, "aria-haspopup": true, "aria-expanded": popupVisible, "aria-controls": instanceId, ref: forwardedRef, style: style, className: cs(baseClassName, baseClassName + "-header", (_a = {},
                    _a[prefixCls + "-selected"] = hasSelectedStatus,
                    _a), className), onClick: subMenuClickHandler, onKeyDown: function (event) {
                    var keyCode = event.keyCode || event.which;
                    if (keyCode === Enter.code) {
                        subMenuClickHandler(event);
                    }
                    else if (keyCode === ArrowLeft.code) {
                        setPopupVisible(false);
                    }
                    else if (keyCode === ArrowRight.code) {
                        setPopupVisible(true);
                    }
                } }, omit$1(rest, ['key', 'popup'])),
                React.createElement(MenuIndent, { prefixCls: prefixCls, levelIndent: levelIndent, level: level }),
                title,
                renderSuffix(),
                hasSelectedStatus && mode === 'horizontal' ? (React.createElement("div", { className: prefixCls + "-selected-label" })) : null)));
    };
    var SubMenuPop$1 = SubMenuPop;

    var __assign$1z = (undefined && undefined.__assign) || function () {
        __assign$1z = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1z.apply(this, arguments);
    };
    function SubMenu(props, ref) {
        var children = props.children, popup = props.popup, level = props.level;
        var _a = React.useContext(MenuContext$1), mode = _a.mode, collapse = _a.collapse, inDropdown = _a.inDropdown, collectInlineMenuKeys = _a.collectInlineMenuKeys;
        var forcePopup = !!(typeof popup === 'function' ? popup(level) : popup);
        var mergedPopup = forcePopup || collapse || inDropdown || mode !== 'vertical';
        var MergedMenu = mergedPopup ? SubMenuPop$1 : SubMenuInline$1;
        React.useEffect(function () {
            collectInlineMenuKeys(props._key);
            return function () {
                collectInlineMenuKeys(props._key, true);
            };
        }, []);
        return (React.createElement(MergedMenu, __assign$1z({ forwardedRef: ref }, props), children));
    }
    var ForwardRefSubMenu = React.forwardRef(SubMenu);
    var SubMenuComponent = ForwardRefSubMenu;
    SubMenuComponent.displayName = 'SubMenu';
    SubMenuComponent.menuType = 'SubMenu';
    var SubMenu$1 = SubMenuComponent;

    var transformNames = [
        'transform',
        'WebkitTransform',
        'msTransform',
        'MozTransform',
        'OTransform',
    ];
    function setTransformStyle(value) {
        var style = {};
        transformNames.forEach(function (name) {
            style[name] = value;
        });
        return style;
    }
    function getStyle$1(element, prop) {
        if (!element || !prop)
            return null;
        var styleName = prop;
        if (styleName === 'float') {
            styleName = 'cssFloat';
        }
        try {
            if (document.defaultView) {
                var computed = document.defaultView.getComputedStyle(element, '');
                return element.style[styleName] || computed ? computed[styleName] : '';
            }
        }
        catch (e) {
            return element.style[styleName];
        }
    }

    var __read$10 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$r = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var OVERFLOW_THRESHOLD = 5;
    function getNodeWidth(node) {
        // getBoundingClientRect will get a result like 20.45
        // Use Math.ceil to avoid menu item wrap in specific menu-width
        return node && Math.ceil(+node.getBoundingClientRect().width);
    }
    function translatePxToNumber(str) {
        var result = Number(str.replace('px', ''));
        return isNaN(result) ? 0 : result;
    }
    var OverflowWrap = function (props) {
        var children = props.children, _a = props.ellipsisText, ellipsisText = _a === void 0 ? '···' : _a;
        var prefixCls = React.useContext(MenuContext$1).prefixCls;
        var refUl = React.useRef(null);
        var _b = __read$10(React.useState(null), 2), lastVisibleIndex = _b[0], setLastVisibleIndex = _b[1];
        var overflowSubMenuClass = prefixCls + "-overflow-sub-menu";
        var overflowMenuItemClass = prefixCls + "-overflow-hidden-menu-item";
        var overflowSubMenuMirrorClass = prefixCls + "-overflow-sub-menu-mirror";
        function computeLastVisibleIndex() {
            if (!refUl.current) {
                return;
            }
            var ulElement = refUl.current;
            var maxWidth = getNodeWidth(ulElement) - OVERFLOW_THRESHOLD;
            var childNodeList = [].slice.call(ulElement.children);
            var menuItemIndex = 0;
            var currentItemRight = 0;
            var overflowSubMenuWidth = 0;
            // 注意 childrenNodeList.length !== React.Children.count(children) 所以需要用 menuItemIndex 来标记真实的 MenuItem 下标
            for (var i = 0; i < childNodeList.length; i++) {
                var node = childNodeList[i];
                var classNames = node.className.split(' ');
                var isOverflowSubMenu = classNames.indexOf(overflowSubMenuClass) > -1;
                var isOverflowSubMenuMirror = classNames.indexOf(overflowSubMenuMirrorClass) > -1;
                // 忽略 overflowSubMenu 的宽度，其宽度测量交由 overflowSubMenuMirror
                if (isOverflowSubMenu) {
                    continue;
                }
                var nodeWidth = getNodeWidth(node) +
                    translatePxToNumber(getStyle$1(node, 'marginLeft')) +
                    translatePxToNumber(getStyle$1(node, 'marginRight'));
                if (isOverflowSubMenuMirror) {
                    overflowSubMenuWidth = nodeWidth;
                    continue;
                }
                currentItemRight += nodeWidth;
                // 将要溢出的菜单项
                if (currentItemRight > maxWidth) {
                    setLastVisibleIndex(
                    // 判断如果将最后一个菜单项换为 ... 是否会超出宽度
                    menuItemIndex - (currentItemRight - nodeWidth + overflowSubMenuWidth <= maxWidth ? 1 : 2));
                    return;
                }
                menuItemIndex++;
            }
            // 全部可见
            setLastVisibleIndex(null);
        }
        var renderOverflowSubMenu = function (children, isMirror) {
            if (isMirror === void 0) { isMirror = false; }
            return (React.createElement(SubMenu$1, { title: React.createElement("span", null, ellipsisText), key: "arco-menu-overflow-sub-menu" + (isMirror ? '-mirror' : ''), className: isMirror ? overflowSubMenuMirrorClass : overflowSubMenuClass, children: children }));
        };
        var renderChildren = function () {
            var overflowSubMenu = null;
            var overflowSubMenuMirror = renderOverflowSubMenu(null, true);
            var originMenuItems = React.Children.map(children, function (child, index) {
                var item = child;
                if (lastVisibleIndex !== null) {
                    if (index > lastVisibleIndex) {
                        item = React.cloneElement(child, {
                            className: overflowMenuItemClass,
                        });
                    }
                    if (index === lastVisibleIndex + 1) {
                        var overflowedItems = React.Children.toArray(children)
                            .slice(lastVisibleIndex + 1)
                            .map(function (child) {
                            return React.cloneElement(child, { key: child.props._key });
                        });
                        overflowSubMenu = renderOverflowSubMenu(overflowedItems);
                    }
                }
                return item;
            });
            return __spreadArray$r(__spreadArray$r([overflowSubMenuMirror], __read$10(originMenuItems), false), [overflowSubMenu], false);
        };
        return (React.createElement(ResizeObserver$1, { onResize: computeLastVisibleIndex },
            React.createElement("div", { className: prefixCls + "-overflow-wrap", ref: refUl }, renderChildren())));
    };
    var OverflowWrap$1 = OverflowWrap;

    function ownKeys$D(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$E(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$D(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$D(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconDragDotVerticalComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$E(_objectSpread$E({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-drag-dot-vertical")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        stroke: "none",
        d: "M17 8h2v2h-2V8ZM17 23h2v2h-2v-2ZM17 38h2v2h-2v-2ZM29 8h2v2h-2V8ZM29 23h2v2h-2v-2ZM29 38h2v2h-2v-2Z"
      }), /*#__PURE__*/React.createElement("path", {
        d: "M17 8h2v2h-2V8ZM17 23h2v2h-2v-2ZM17 38h2v2h-2v-2ZM29 8h2v2h-2V8ZM29 23h2v2h-2v-2ZM29 38h2v2h-2v-2Z"
      }));
    }

    var IconDragDotVertical = /*#__PURE__*/React.forwardRef(IconDragDotVerticalComponent);
    IconDragDotVertical.defaultProps = {
      isIcon: true
    };
    IconDragDotVertical.displayName = 'IconDragDotVertical';
    var IconDragDotVertical$1 = IconDragDotVertical;

    function ownKeys$C(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$D(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$C(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$C(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconDragDotComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$D(_objectSpread$D({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-drag-dot")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        stroke: "none",
        d: "M40 17v2h-2v-2h2ZM25 17v2h-2v-2h2ZM10 17v2H8v-2h2ZM40 29v2h-2v-2h2ZM25 29v2h-2v-2h2ZM10 29v2H8v-2h2Z"
      }), /*#__PURE__*/React.createElement("path", {
        d: "M40 17v2h-2v-2h2ZM25 17v2h-2v-2h2ZM10 17v2H8v-2h2ZM40 29v2h-2v-2h2ZM25 29v2h-2v-2h2ZM10 29v2H8v-2h2Z"
      }));
    }

    var IconDragDot = /*#__PURE__*/React.forwardRef(IconDragDotComponent);
    IconDragDot.defaultProps = {
      isIcon: true
    };
    IconDragDot.displayName = 'IconDragDot';
    var IconDragDot$1 = IconDragDot;

    function ownKeys$B(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$C(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$B(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$B(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconCaretRightComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$C(_objectSpread$C({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-caret-right")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        stroke: "none",
        d: "M34.829 23.063c.6.48.6 1.394 0 1.874L17.949 38.44c-.785.629-1.949.07-1.949-.937V10.497c0-1.007 1.164-1.566 1.95-.937l16.879 13.503Z"
      }));
    }

    var IconCaretRight = /*#__PURE__*/React.forwardRef(IconCaretRightComponent);
    IconCaretRight.defaultProps = {
      isIcon: true
    };
    IconCaretRight.displayName = 'IconCaretRight';
    var IconCaretRight$1 = IconCaretRight;

    function ownKeys$A(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$B(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$A(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$A(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconCaretLeftComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$B(_objectSpread$B({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-caret-left")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        stroke: "none",
        d: "M13.171 24.937a1.2 1.2 0 0 1 0-1.874L30.051 9.56c.785-.629 1.949-.07 1.949.937v27.006c0 1.006-1.164 1.566-1.95.937L13.171 24.937Z"
      }));
    }

    var IconCaretLeft = /*#__PURE__*/React.forwardRef(IconCaretLeftComponent);
    IconCaretLeft.defaultProps = {
      isIcon: true
    };
    IconCaretLeft.displayName = 'IconCaretLeft';
    var IconCaretLeft$1 = IconCaretLeft;

    function ownKeys$z(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$A(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$z(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$z(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconCaretDownComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$A(_objectSpread$A({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-caret-down")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        stroke: "none",
        d: "M24.938 34.829a1.2 1.2 0 0 1-1.875 0L9.56 17.949c-.628-.785-.069-1.949.937-1.949h27.007c1.006 0 1.565 1.164.937 1.95L24.937 34.829Z"
      }));
    }

    var IconCaretDown = /*#__PURE__*/React.forwardRef(IconCaretDownComponent);
    IconCaretDown.defaultProps = {
      isIcon: true
    };
    IconCaretDown.displayName = 'IconCaretDown';
    var IconCaretDown$1 = IconCaretDown;

    function ownKeys$y(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$z(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$y(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$y(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconCaretUpComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$z(_objectSpread$z({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-caret-up")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        stroke: "none",
        d: "M23.063 13.171a1.2 1.2 0 0 1 1.875 0l13.503 16.88c.628.785.069 1.949-.937 1.949H10.497c-1.006 0-1.565-1.164-.937-1.95l13.503-16.879Z"
      }));
    }

    var IconCaretUp = /*#__PURE__*/React.forwardRef(IconCaretUpComponent);
    IconCaretUp.defaultProps = {
      isIcon: true
    };
    IconCaretUp.displayName = 'IconCaretUp';
    var IconCaretUp$1 = IconCaretUp;

    var __assign$1y = (undefined && undefined.__assign) || function () {
        __assign$1y = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1y.apply(this, arguments);
    };
    var __rest$K = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function ResizeTrigger(props) {
        var _a, _b;
        var className = props.className, direction = props.direction, icon = props.icon, onMouseDown = props.onMouseDown, onResize = props.onResize, children = props.children, _c = props.collapsible, collapsible = _c === void 0 ? {} : _c, _d = props.resizable, resizable = _d === void 0 ? true : _d, renderChildren = props.renderChildren, rest = __rest$K(props, ["className", "direction", "icon", "onMouseDown", "onResize", "children", "collapsible", "resizable", "renderChildren"]);
        var _e = React.useContext(ConfigContext), getPrefixCls = _e.getPrefixCls, rtl = _e.rtl;
        var prefixCls = getPrefixCls('resizebox-trigger');
        var isHorizontal = direction === 'horizontal';
        var rtlReverse = rtl && !isHorizontal;
        var classNames = cs(prefixCls, prefixCls + "-" + (isHorizontal ? 'horizontal' : 'vertical'), (_a = {}, _a[prefixCls + "-not-resizable"] = !resizable, _a), (_b = {}, _b[prefixCls + "-rtl"] = rtl, _b), className);
        var verticalTriggerIcon = rtlReverse
            ? [React.createElement(IconCaretRight$1, { key: "prev" }), React.createElement(IconCaretLeft$1, { key: "next" })]
            : [React.createElement(IconCaretLeft$1, { key: "prev" }), React.createElement(IconCaretRight$1, { key: "next" })];
        var prevCollapsedConfig = isObject$1(collapsible.prev)
            ? __assign$1y(__assign$1y({}, collapsible.prev), { icon: collapsible.prev.icon || (isHorizontal ? React.createElement(IconCaretUp$1, null) : verticalTriggerIcon[0]) }) : {};
        var nextCollapsedConfig = isObject$1(collapsible.next)
            ? __assign$1y(__assign$1y({}, collapsible.next), { icon: collapsible.next.icon || (isHorizontal ? React.createElement(IconCaretDown$1, null) : verticalTriggerIcon[1]) }) : {};
        var renderPrevCollapsedTrigger = function () {
            // 1. 传入了prev
            // 当前不在收缩状态，或者在反方向收缩状态时展示
            if ((prevCollapsedConfig.icon && !prevCollapsedConfig.collapsed) ||
                nextCollapsedConfig.collapsed) {
                return (React.createElement("span", { className: cs(prefixCls + "-icon", cs(prefixCls + "-prev")), onClick: prevCollapsedConfig.onClick }, prevCollapsedConfig.icon));
            }
            return React.createElement("span", { className: cs(prefixCls + "-icon-empty") });
        };
        var renderNextCollapsedTrigger = function () {
            if ((nextCollapsedConfig.icon && !nextCollapsedConfig.collapsed) ||
                prevCollapsedConfig.collapsed) {
                return (React.createElement("span", { className: cs(prefixCls + "-icon", cs(prefixCls + "-next")), onClick: nextCollapsedConfig.onClick }, nextCollapsedConfig.icon));
            }
            return React.createElement("span", { className: cs(prefixCls + "-icon-empty") });
        };
        var renderResizeTrigger = function () {
            if (resizable) {
                return (React.createElement("span", { className: prefixCls + "-icon" }, icon || (isHorizontal ? React.createElement(IconDragDot$1, null) : React.createElement(IconDragDotVertical$1, null))));
            }
            return React.createElement("span", { className: cs(prefixCls + "-icon-empty") });
        };
        var prev = renderPrevCollapsedTrigger();
        var trigger = renderResizeTrigger();
        var next = renderNextCollapsedTrigger();
        var renderIcon = function () {
            return (React.createElement("div", { className: prefixCls + "-icon-wrapper" },
                prev,
                trigger,
                next));
        };
        if (!resizable) {
            return (React.createElement("div", { className: classNames }, isFunction$1(renderChildren)
                ? renderChildren(prev, trigger, next)
                : children || renderIcon()));
        }
        return (React.createElement(ResizeObserver$1, { onResize: onResize },
            React.createElement("div", __assign$1y({}, omit$1(rest, ['style']), { className: classNames, onMouseDown: onMouseDown }), isFunction$1(renderChildren)
                ? renderChildren(prev, trigger, next)
                : children || renderIcon())));
    }

    var __read$$ = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var DIRECTION_HORIZONTAL$1 = 'horizontal';
    var DIRECTION_VERTICAL$2 = 'vertical';
    function Split(props, ref) {
        var _a;
        var style = props.style, className = props.className, _b = props.component, component = _b === void 0 ? 'div' : _b, _c = props.direction, direction = _c === void 0 ? 'horizontal' : _c, icon = props.icon, _d = props.size, size = _d === void 0 ? 0.5 : _d, min = props.min, max = props.max, panes = props.panes, disabled = props.disabled, trigger = props.trigger;
        var _e = React.useContext(ConfigContext), getPrefixCls = _e.getPrefixCls, rtl = _e.rtl;
        var prefixCls = getPrefixCls('resizebox-split');
        var isHorizontal = direction.includes(DIRECTION_HORIZONTAL$1);
        var isReverse = direction.includes('reverse');
        var rtlReverse = isHorizontal && rtl;
        var isTriggerHorizontal = !isHorizontal;
        var classNames = cs(prefixCls, prefixCls + "-" + (isHorizontal ? DIRECTION_HORIZONTAL$1 : DIRECTION_VERTICAL$2), (_a = {}, _a[prefixCls + "-rtl"] = rtl, _a), className);
        var _f = __read$$(panes, 2), firstPane = _f[0], secondPane = _f[1];
        var isPxSize = typeof size === 'string';
        var _g = __read$$(React.useState(parseFloat(size)), 2), offset = _g[0], setOffset = _g[1];
        var _h = __read$$(React.useState(0), 2), triggerSize = _h[0], setTriggerSize = _h[1];
        var recordRef = React.useRef({
            startX: 0,
            startY: 0,
            startWidth: 0,
            startHeight: 0,
            startOffset: 0,
            moving: false,
        });
        var wrapperRef = React.useRef();
        var paneContainers = React.useRef([]);
        React.useImperativeHandle(ref, function () { return wrapperRef.current; }, []);
        function px2percent(numerator, denominator) {
            return parseFloat(numerator) / parseFloat(denominator);
        }
        function getOffset(startSize, startOffset, startPosition, currentPosition) {
            var minOffset = min ? parseFloat(min) : 0;
            var maxOffset = max ? parseFloat(max) : isPxSize ? startSize : 1;
            var ratio = isReverse ? -1 : 1;
            var rtlRatio = rtlReverse ? -1 : 1;
            ratio *= rtlRatio;
            var moveOffset = isPxSize
                ? startOffset + (currentPosition - startPosition) * ratio
                : px2percent(startSize * startOffset + (currentPosition - startPosition) * ratio, startSize);
            moveOffset = Math.max(moveOffset, minOffset);
            moveOffset = Math.min(moveOffset, maxOffset);
            return moveOffset;
        }
        // 移动开始，记录初始值，绑定移动事件
        function onTriggerMouseDown(e) {
            var _a, _b;
            props.onMovingStart && props.onMovingStart();
            recordRef.current.moving = true;
            recordRef.current.startX = e.pageX;
            recordRef.current.startY = e.pageY;
            recordRef.current.startWidth = (_a = wrapperRef.current) === null || _a === void 0 ? void 0 : _a.offsetWidth;
            recordRef.current.startHeight = (_b = wrapperRef.current) === null || _b === void 0 ? void 0 : _b.offsetHeight;
            recordRef.current.startOffset = offset;
            on(window, 'mousemove', moving);
            on(window, 'touchmove', moving);
            on(window, 'mouseup', moveEnd);
            on(window, 'touchend', moveEnd);
            on(window, 'contextmenu', moveEnd);
            document.body.style.cursor = isTriggerHorizontal ? 'row-resize' : 'col-resize';
        }
        // 移动中，更新 firstPane 的占位大小
        function moving(e) {
            if (recordRef.current.moving) {
                /* eslint-disable */
                var newOffset = isHorizontal
                    ? getOffset(recordRef.current.startWidth, recordRef.current.startOffset, recordRef.current.startX, e.pageX)
                    : getOffset(recordRef.current.startHeight, recordRef.current.startOffset, recordRef.current.startY, e.pageY);
                setOffset(newOffset);
                props.onMoving && props.onMoving(e, isPxSize ? newOffset + "px" : newOffset);
            }
        }
        // 移动结束，解除事件绑定
        function moveEnd() {
            recordRef.current.moving = false;
            off(window, 'mousemove', moving);
            off(window, 'touchmove', moving);
            off(window, 'mouseup', moveEnd);
            off(window, 'touchend', moveEnd);
            off(window, 'contextmenu', moveEnd);
            document.body.style.cursor = 'default';
            props.onMovingEnd && props.onMovingEnd();
        }
        // 更新 trigger 大小
        function onTriggerResize(e) {
            var contentRect = e[0].contentRect;
            var newTriggerSize = contentRect[isTriggerHorizontal ? 'height' : 'width'];
            setTriggerSize(newTriggerSize);
        }
        // 根据 offset 和 triggerSize 计算 firstPane 的样式
        function getFirstPaneSize() {
            var unit = isPxSize ? 'px' : '%';
            if (!offset)
                return "0" + unit;
            var baseVal = isPxSize ? offset : offset * 100;
            return "calc(" + baseVal + unit + " - " + triggerSize / 2 + "px)";
        }
        React.useEffect(function () {
            props.onPaneResize && props.onPaneResize(paneContainers.current);
        }, [offset, triggerSize]);
        useIsomorphicLayoutEffect$1(function () {
            var newOffset = parseFloat(size);
            if (offset !== newOffset) {
                setOffset(newOffset);
            }
        }, [size]);
        var Tag = component;
        var firstPaneNode = (React.createElement("div", { className: cs(prefixCls + "-pane", 'first-pane'), style: { flexBasis: getFirstPaneSize() }, ref: function (el) {
                paneContainers.current[0] = el;
            } }, firstPane));
        var secondPaneNode = (React.createElement("div", { className: cs(prefixCls + "-pane", 'second-pane'), ref: function (el) {
                paneContainers.current[1] = el;
            } }, secondPane));
        var paneNodeArr = isReverse ? [secondPaneNode, firstPaneNode] : [firstPaneNode, secondPaneNode];
        return (React.createElement(Tag, { style: style, className: classNames, ref: wrapperRef },
            paneNodeArr[0],
            !disabled && (React.createElement(ResizeTrigger, { className: prefixCls + "-trigger", direction: isTriggerHorizontal ? DIRECTION_HORIZONTAL$1 : DIRECTION_VERTICAL$2, icon: icon, onMouseDown: onTriggerMouseDown, onResize: onTriggerResize }, trigger)),
            paneNodeArr[1]));
    }
    var SplitComponent = React.forwardRef(Split);
    SplitComponent.displayName = 'ResizeBoxSplit';
    var Split$1 = SplitComponent;

    var __assign$1x = (undefined && undefined.__assign) || function () {
        __assign$1x = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1x.apply(this, arguments);
    };
    var __rest$J = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$_ = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$q = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var DIRECTION_HORIZONTAL = 'horizontal';
    var DIRECTION_VERTICAL$1 = 'vertical';
    function SplitGroup(props, ref) {
        var _a, _b;
        var panes = props.panes, style = props.style, className = props.className, _c = props.component, component = _c === void 0 ? 'div' : _c, _d = props.direction, direction = _d === void 0 ? 'horizontal' : _d, icon = props.icon, rest = __rest$J(props, ["panes", "style", "className", "component", "direction", "icon"]);
        var _e = React.useContext(ConfigContext), getPrefixCls = _e.getPrefixCls, rtl = _e.rtl;
        var defaultOffset = 1 / panes.length;
        var wrapperRef = React.useRef();
        var recordRef = React.useRef(new Array(panes.length).fill({
            moving: false,
            startOffset: 0,
            startPosition: 0,
        }));
        var paneContainers = React.useRef([]);
        var movingIndex = React.useRef(0);
        var prevOffsets = React.useRef([]);
        var _f = __read$_(React.useState(new Array(panes.length).fill(defaultOffset)), 2), offsets = _f[0], setOffsets = _f[1];
        var _g = __read$_(React.useState(false), 2), isMoving = _g[0], setIsMoving = _g[1];
        var _h = __read$_(React.useState(new Array(panes.length).fill(0)), 2), triggerSize = _h[0], setTriggerSize = _h[1];
        var _j = __read$_(React.useState(new Array(Math.max(panes.length - 1, 0)).fill({ prev: false, next: false })), 2), collapsedStatus = _j[0], setCollapsedStatus = _j[1];
        var prefixCls = getPrefixCls('resizebox-split-group');
        var isHorizontal = direction === DIRECTION_HORIZONTAL;
        var rtlReverse = isHorizontal && rtl;
        var isTriggerHorizontal = !isHorizontal;
        var classNames = cs(prefixCls, prefixCls + "-" + (isHorizontal ? DIRECTION_HORIZONTAL : DIRECTION_VERTICAL$1), (_a = {}, _a[prefixCls + "-moving"] = isMoving, _a), (_b = {}, _b[prefixCls + "-rtl"] = rtl, _b), className);
        var Tag = component;
        // 获取初始的 offset, 将传入的size 都转为像素值。
        var getInitialOffsets = function () {
            var newOffsets = [];
            panes.forEach(function (pane) {
                var size = pane.size;
                if (!isUndefined(size)) {
                    newOffsets.push(formatSize(size));
                }
                else {
                    newOffsets.push(undefined);
                }
            });
            // 剩余的空间均分给没有设置 size 的面板
            var noSizeArr = newOffsets.filter(function (size) { return !size; });
            var remainPercent = 1 -
                newOffsets.reduce(function (a, b) {
                    var formatA = a || 0;
                    var formatB = b || 0;
                    return formatA + formatB;
                }, 0);
            var averagePercent = remainPercent / noSizeArr.length;
            newOffsets = newOffsets.map(function (size) {
                if (!isUndefined(size)) {
                    return size;
                }
                return averagePercent;
            });
            return newOffsets;
        };
        // 计算每一个面板的占位像素，需要减去前面跟当前伸缩杆的宽度
        var getPaneSize = function (index) {
            var prevTriggerSize = triggerSize[index - 1] || 0;
            var currentTriggerSize = triggerSize[index];
            var baseVal = offsets[index] * 100;
            var unit = '%';
            return "calc(" + baseVal + unit + " - " + (prevTriggerSize + currentTriggerSize) / 2 + "px)";
        };
        // 入参 百分比/像素值 => 全部转化为百分比(响应式)
        function formatSize(size) {
            var totalPX = isHorizontal ? wrapperRef.current.offsetWidth : wrapperRef.current.offsetHeight;
            if (!size || (isNumber(size) && size < 0)) {
                return 0;
            }
            var percent = isString(size) ? parseFloat(size) / totalPX : size;
            return Math.min(percent, 1);
        }
        // 计算阈值，因为伸缩杆会影响到当前面板 跟 下一个面板。所以同时计算两个阈值。
        var getMinAndMax = function (index) {
            var next = Math.min(index + 1, panes.length - 1);
            var totalOffset = offsets[index] + offsets[next];
            var currentMin = formatSize(panes[index].min) || 0;
            var currentMax = formatSize(panes[index].max) || totalOffset;
            var nextMin = formatSize(panes[next].min) || 0;
            var nextMax = formatSize(panes[next].max) || totalOffset;
            //  min 的优先级高于 max
            currentMax = Math.min(totalOffset - nextMin, currentMax);
            nextMax = Math.min(totalOffset - currentMin, nextMax);
            return {
                currentMin: currentMin,
                currentMax: currentMax,
                nextMin: nextMin,
                nextMax: nextMax,
            };
        };
        // 拖拽时，获取新的占位距离。影响当前面板跟下一个面板的占位值。
        var getNewOffsets = function (startOffset, startPosition, currentPosition) {
            var current = movingIndex.current;
            var next = current + 1;
            var newOffsets = __spreadArray$q([], __read$_(offsets), false);
            var ratio = rtlReverse ? -1 : 1;
            var currentPercent = offsets[current];
            var nextPercent = offsets[next];
            var totalPercent = currentPercent + nextPercent;
            var _a = getMinAndMax(current), minOffset = _a.currentMin, maxOffset = _a.currentMax;
            var moveOffset = startOffset + formatSize((currentPosition - startPosition) * ratio + "px");
            moveOffset = Math.max(minOffset, moveOffset);
            moveOffset = Math.min(maxOffset, moveOffset);
            newOffsets[current] = moveOffset;
            // 保证 totalOffset = nextOffset + currentOffset  不变。
            newOffsets[next] = totalPercent - moveOffset;
            return newOffsets;
        };
        function onTriggerResize(e, index) {
            var contentRect = e[0].contentRect;
            var currentSize = contentRect[isTriggerHorizontal ? 'height' : 'width'];
            var newTriggerSize = __spreadArray$q([], __read$_(triggerSize), false);
            newTriggerSize[index] = currentSize;
            setTriggerSize(newTriggerSize);
        }
        // 判断快速收缩按钮是否展示
        var getCollapsedConfig = function (index) {
            var collapsible = panes[index].collapsible;
            if (!isObject$1(collapsible)) {
                collapsible = !collapsible ? {} : { prev: true, next: true };
            }
            var prev = collapsible.prev, next = collapsible.next;
            if (!prev && !next) {
                return {};
            }
            if (!collapsedStatus[index]) {
                return {};
            }
            // 传入了prev的配置，或者 没有传入 prev 的配置，但是已经处于向下收缩完毕状态
            var hasPrev = !!prev || (!prev && collapsedStatus[index].next);
            // 传入了next的配置，或者 没有传入 next 的配置，但是已经处于向上收缩完毕状态
            var hasNext = !!next || (!next && collapsedStatus[index].prev);
            return { hasPrev: hasPrev, hasNext: hasNext };
        };
        // 移动开始，记录初始值，绑定移动事件
        function onTriggerMouseDown(e, index) {
            props.onMovingStart && props.onMovingStart(index);
            movingIndex.current = index;
            var currentRecord = recordRef.current[index];
            currentRecord.moving = true;
            currentRecord.startOffset = offsets[index];
            currentRecord.startPosition = isHorizontal ? e.pageX : e.pageY;
            setIsMoving(true);
            on(window, 'mousemove', moving);
            on(window, 'touchmove', moving);
            on(window, 'mouseup', moveEnd);
            on(window, 'touchend', moveEnd);
            on(window, 'contextmenu', moveEnd);
            document.body.style.cursor = isTriggerHorizontal ? 'row-resize' : 'col-resize';
        }
        // 移动中，更新 当前面板跟下一个面板 占位大小
        function moving(e) {
            var index = movingIndex.current;
            var currentRecord = recordRef.current[index];
            var totalPX = isHorizontal ? wrapperRef.current.offsetWidth : wrapperRef.current.offsetHeight;
            if (currentRecord.moving) {
                var newOffsets = getNewOffsets(currentRecord.startOffset, currentRecord.startPosition, isHorizontal ? e.pageX : e.pageY);
                setOffsets(newOffsets);
                prevOffsets.current = newOffsets;
                props.onMoving &&
                    props.onMoving(e, newOffsets.map(function (value) { return value * totalPX + "px"; }), index);
            }
        }
        // 移动结束，解除事件绑定
        function moveEnd() {
            var index = movingIndex.current;
            recordRef.current[index].moving = false;
            setIsMoving(false);
            off(window, 'mousemove', moving);
            off(window, 'touchmove', moving);
            off(window, 'mouseup', moveEnd);
            off(window, 'touchend', moveEnd);
            off(window, 'contextmenu', moveEnd);
            document.body.style.cursor = 'default';
            props.onMovingEnd && props.onMovingEnd(index);
        }
        // 点击快速收缩按钮的回调。
        function handleCollapsed(e, index, status, callback) {
            var next = index + 1;
            var newOffset = __spreadArray$q([], __read$_(offsets), false);
            var currentOffset = offsets[index];
            var nextOffset = offsets[next];
            var totalOffset = currentOffset + nextOffset;
            var totalPX = isHorizontal ? wrapperRef.current.offsetWidth : wrapperRef.current.offsetHeight;
            var _a = getMinAndMax(index), currentMin = _a.currentMin, nextMin = _a.nextMin;
            // 取消收缩时，应该重置为上一个状态。所以从preOffsets里拿值
            var newCurrentOffset = prevOffsets.current[index];
            var newNextOffset = prevOffsets.current[next];
            // 当前面板的收缩状态。
            var collapsed = collapsedStatus[index][status];
            // 点击向上收缩按钮。收缩态是：currentPane = currentMin;
            if (status === 'prev') {
                // 如果下一个面板不是在收缩状态 或者 下一个面板被手动拖拽到收缩状态
                if (nextOffset !== nextMin || newNextOffset === nextMin) {
                    // 当前面板收缩。
                    newCurrentOffset = currentMin;
                    newNextOffset = totalOffset - currentMin;
                    collapsed = true;
                }
                // 点击向下收缩按钮
            }
            else if (currentOffset !== currentMin || newCurrentOffset === currentMin) {
                newCurrentOffset = totalOffset - nextMin;
                newNextOffset = nextMin;
                collapsed = true;
            }
            newOffset[index] = newCurrentOffset;
            newOffset[next] = newNextOffset;
            props.onMoving &&
                props.onMoving(e, newOffset.map(function (value) { return value * totalPX + "px"; }), index);
            props.onMovingEnd && props.onMovingEnd(index);
            setOffsets(newOffset);
            if (isFunction$1(callback)) {
                callback(e, index, status, collapsed);
            }
        }
        React.useEffect(function () {
            var offsets = getInitialOffsets();
            setOffsets(offsets);
            prevOffsets.current = offsets;
        }, [JSON.stringify(panes.map(function (item) { return item.size; }))]);
        React.useImperativeHandle(ref, function () { return wrapperRef.current; }, []);
        React.useEffect(function () {
            var newCollapsedStatus = [];
            offsets.forEach(function (offset, index) {
                var currentCollapsedStatus = { prev: false, next: false };
                var next = index + 1;
                var _a = getMinAndMax(index), currentMin = _a.currentMin, nextMin = _a.nextMin;
                // 当 offsets 变化时，更新各个面板的 collapsed 状态
                if (offset === currentMin) {
                    currentCollapsedStatus.prev = true;
                }
                else if (offsets[next] === nextMin) {
                    currentCollapsedStatus.next = true;
                }
                newCollapsedStatus.push(currentCollapsedStatus);
            });
            setCollapsedStatus(newCollapsedStatus);
        }, [offsets]);
        return (React.createElement(Tag, __assign$1x({}, omit$1(rest, ['onMovingStart', 'onPaneResize', 'onMoving', 'onMovingEnd']), { style: style, className: classNames, ref: wrapperRef }), panes.map(function (pane, index) {
            var content = pane.content, disabled = pane.disabled, trigger = pane.trigger, _a = pane.resizable, resizable = _a === void 0 ? true : _a, _b = pane.collapsible, collapsible = _b === void 0 ? {} : _b;
            var _c = getCollapsedConfig(index), hasPrev = _c.hasPrev, hasNext = _c.hasNext;
            var prevConfig = isObject$1(collapsible) && isObject$1(collapsible.prev) ? collapsible.prev : {};
            var nextConfig = isObject$1(collapsible) && isObject$1(collapsible.next) ? collapsible.next : {};
            return (React.createElement(React.Fragment, { key: index },
                React.createElement("div", { className: prefixCls + "-pane", style: { flexBasis: getPaneSize(index) }, ref: function (el) { return (paneContainers.current[index] = el); } }, content),
                !disabled && index !== panes.length - 1 && (React.createElement(ResizeTrigger, { className: prefixCls + "-trigger", direction: isTriggerHorizontal ? DIRECTION_HORIZONTAL : DIRECTION_VERTICAL$1, icon: icon, onResize: function (e) { return onTriggerResize(e, index); }, onMouseDown: function (e) { return onTriggerMouseDown(e, index); }, collapsible: {
                        prev: hasPrev
                            ? {
                                onClick: function (e) { return handleCollapsed(e, index, 'prev', prevConfig.onClick); },
                                icon: prevConfig.icon,
                                collapsed: collapsedStatus[index].prev,
                            }
                            : undefined,
                        next: hasNext
                            ? {
                                onClick: function (e) { return handleCollapsed(e, index, 'next', nextConfig.onClick); },
                                icon: nextConfig.icon,
                                collapsed: collapsedStatus[index].next,
                            }
                            : undefined,
                    }, resizable: resizable, renderChildren: trigger }))));
        })));
    }
    var SplitGroupComponent = React.forwardRef(SplitGroup);
    SplitGroupComponent.displayName = 'ResizeBoxSplitGroup';
    var SplitGroup$1 = SplitGroupComponent;

    var __assign$1w = (undefined && undefined.__assign) || function () {
        __assign$1w = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1w.apply(this, arguments);
    };
    var __rest$I = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$Z = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var DIRECTION_LEFT = 'left';
    var DIRECTION_RIGHT = 'right';
    var DIRECTION_TOP = 'top';
    var DIRECTION_BOTTOM = 'bottom';
    var allDirections = [
        DIRECTION_LEFT,
        DIRECTION_RIGHT,
        DIRECTION_TOP,
        DIRECTION_BOTTOM,
    ];
    var defaultProps$t = {
        component: 'div',
        directions: ['right'],
        resizeIcons: {},
        resizeTriggers: {},
    };
    var getOppositeDirection = function (direction) {
        switch (direction) {
            case 'left':
                return 'right';
            case 'right':
                return 'left';
            default:
                return direction;
        }
    };
    function ResizeBox(baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$t, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.ResizeBox);
        var style = props.style, className = props.className, component = props.component, directions = props.directions, resizeIcons = props.resizeIcons, children = props.children, resizeTriggers = props.resizeTriggers, propWidth = props.width, propHeight = props.height, rest = __rest$I(props, ["style", "className", "component", "directions", "resizeIcons", "children", "resizeTriggers", "width", "height"]);
        var realDirections = rtl ? directions.map(function (dir) { return getOppositeDirection(dir); }) : directions;
        var prefixCls = getPrefixCls('resizebox');
        var classNames = cs(prefixCls, (_a = {}, _a[prefixCls + "-rtl"] = rtl, _a), className);
        var _c = __read$Z(React.useState({}), 2), paddingStyles = _c[0], setPaddingStyles = _c[1];
        var _d = __read$Z(useMergeValue(undefined, { value: propWidth }), 2), width = _d[0], setWidth = _d[1];
        var _e = __read$Z(useMergeValue(undefined, { value: propHeight }), 2), height = _e[0], setHeight = _e[1];
        var recordRef = React.useRef({
            startX: 0,
            startY: 0,
            startWidth: 0,
            startHeight: 0,
            direction: DIRECTION_RIGHT,
            moving: false,
            padding: {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
            },
        });
        var wrapperRef = React.useRef();
        React.useImperativeHandle(ref, function () { return wrapperRef.current; }, []);
        function getIsHorizontal(direction) {
            return [DIRECTION_TOP, DIRECTION_BOTTOM].indexOf(direction) > -1;
        }
        function getRealSize(clientSize, padding) {
            if (clientSize === 0)
                return 0;
            var res = clientSize - padding;
            return res <= 0 ? 0 : res;
        }
        function onTriggerMouseDown(direction, e) {
            var _a, _b;
            props.onMovingStart && props.onMovingStart();
            recordRef.current.moving = true;
            recordRef.current.startX = e.pageX;
            recordRef.current.startY = e.pageY;
            recordRef.current.direction = direction;
            // 因为 clientWidth 拿到的尺寸包含 padding，而 padding 不应该成为 width 计算的一部分，所以需要去掉。
            var _c = recordRef.current.padding, top = _c.top, left = _c.left, right = _c.right, bottom = _c.bottom;
            recordRef.current.startWidth = getRealSize((_a = wrapperRef.current) === null || _a === void 0 ? void 0 : _a.clientWidth, left + right);
            recordRef.current.startHeight = getRealSize((_b = wrapperRef.current) === null || _b === void 0 ? void 0 : _b.clientHeight, top + bottom);
            on(window, 'mousemove', moving);
            on(window, 'touchmove', moving);
            on(window, 'mouseup', moveEnd);
            on(window, 'touchend', moveEnd);
            on(window, 'contextmenu', moveEnd);
            document.body.style.cursor = getIsHorizontal(direction) ? 'row-resize' : 'col-resize';
        }
        function moving(e) {
            if (!recordRef.current.moving)
                return false;
            var _a = recordRef.current, startX = _a.startX, startY = _a.startY, startWidth = _a.startWidth, startHeight = _a.startHeight;
            var newWidth = startWidth;
            var newHeight = startHeight;
            // 往右移动的距离
            var offsetX = e.pageX - startX;
            // 往下移动的距离
            var offsetY = e.pageY - startY;
            switch (recordRef.current.direction) {
                case DIRECTION_LEFT:
                    newWidth = startWidth - offsetX;
                    setWidth(newWidth);
                    break;
                case DIRECTION_RIGHT:
                    newWidth = startWidth + offsetX;
                    setWidth(newWidth);
                    break;
                case DIRECTION_TOP:
                    newHeight = startHeight - offsetY;
                    setHeight(newHeight);
                    break;
                case DIRECTION_BOTTOM:
                    newHeight = startHeight + offsetY;
                    setHeight(newHeight);
                    break;
            }
            props.onMoving &&
                props.onMoving(e, {
                    width: newWidth,
                    height: newHeight,
                });
        }
        function moveEnd() {
            recordRef.current.moving = false;
            offEvents();
            document.body.style.cursor = 'default';
            props.onMovingEnd && props.onMovingEnd();
        }
        function offEvents() {
            off(window, 'mousemove', moving);
            off(window, 'touchmove', moving);
            off(window, 'mouseup', moveEnd);
            off(window, 'touchend', moveEnd);
            off(window, 'contextmenu', moveEnd);
        }
        function onTriggerResize(direction, e) {
            var isHorizontal = getIsHorizontal(direction);
            var contentRect = e[0].contentRect;
            var styleDirection = "" + direction.slice(0, 1).toUpperCase() + direction.slice(1);
            var size = contentRect[isHorizontal ? 'height' : 'width'];
            // 记录 padding，用于计算 width
            recordRef.current.padding[direction] = size;
            setPaddingStyles(function (pre) {
                var _a;
                return (__assign$1w(__assign$1w({}, pre), (_a = {}, _a["padding" + styleDirection] = size, _a)));
            });
        }
        var wrapperStyles = __assign$1w(__assign$1w(__assign$1w(__assign$1w({}, paddingStyles), (style || {})), (isNumber(width) ? { width: width } : {})), (isNumber(height) ? { height: height } : {}));
        var Tag = component;
        return (React.createElement(Tag, __assign$1w({}, omit$1(rest, ['onMovingStart', 'onMoving', 'onMovingEnd']), { style: wrapperStyles, className: classNames, ref: wrapperRef }),
            children,
            realDirections.map(function (direction) {
                if (allDirections.indexOf(direction) !== -1) {
                    return (React.createElement(ResizeTrigger, { key: direction, className: prefixCls + "-direction-" + direction, direction: getIsHorizontal(direction) ? 'horizontal' : 'vertical', icon: resizeIcons[direction], onMouseDown: function (e) {
                            onTriggerMouseDown(direction, e);
                        }, onResize: function (e) {
                            onTriggerResize(direction, e);
                        } }, resizeTriggers[direction]));
                }
            })));
    }
    var ForwardRefResizeBox = React.forwardRef(ResizeBox);
    var ResizeBoxComponent = ForwardRefResizeBox;
    ResizeBoxComponent.Split = Split$1;
    ResizeBoxComponent.SplitGroup = SplitGroup$1;
    ResizeBoxComponent.displayName = 'ResizeBox';
    var ResizeBox$1 = ResizeBoxComponent;

    // https://github.com/ant-design/ant-design/blob/master/components/_util/responsiveObserve.ts
    var __assign$1v = (undefined && undefined.__assign) || function () {
        __assign$1v = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1v.apply(this, arguments);
    };
    var responsiveArray = ['xxxl', 'xxl', 'xl', 'lg', 'md', 'sm', 'xs'];
    var responsiveMap = {
        xs: '(max-width: 575px)',
        sm: '(min-width: 576px)',
        md: '(min-width: 768px)',
        lg: '(min-width: 992px)',
        xl: '(min-width: 1200px)',
        xxl: '(min-width: 1600px)',
        xxxl: '(min-width: 2000px)',
    };
    var subscribers = [];
    var subUid = -1;
    var screens = {};
    var responsiveObserve = {
        matchHandlers: {},
        dispatch: function (pointMap, breakpointChecked) {
            screens = pointMap;
            if (subscribers.length < 1) {
                return false;
            }
            subscribers.forEach(function (item) {
                item.func(screens, breakpointChecked);
            });
            return true;
        },
        subscribe: function (func) {
            if (subscribers.length === 0) {
                this.register();
            }
            var token = (++subUid).toString();
            subscribers.push({
                token: token,
                func: func,
            });
            func(screens, null);
            return token;
        },
        unsubscribe: function (token) {
            subscribers = subscribers.filter(function (item) { return item.token !== token; });
            if (subscribers.length === 0) {
                this.unregister();
            }
        },
        unregister: function () {
            var _this = this;
            Object.keys(responsiveMap).forEach(function (screen) {
                var matchMediaQuery = responsiveMap[screen];
                var handler = _this.matchHandlers[matchMediaQuery];
                if (handler && handler.mql && handler.listener) {
                    handler.mql.removeListener(handler.listener);
                }
            });
        },
        register: function () {
            var _this = this;
            Object.keys(responsiveMap).forEach(function (screen) {
                var matchMediaQuery = responsiveMap[screen];
                var listener = function (_a) {
                    var _b;
                    var matches = _a.matches;
                    _this.dispatch(__assign$1v(__assign$1v({}, screens), (_b = {}, _b[screen] = matches, _b)), screen);
                };
                var mql = window.matchMedia(matchMediaQuery);
                mql.addListener(listener);
                _this.matchHandlers[matchMediaQuery] = {
                    mql: mql,
                    listener: listener,
                };
                listener(mql);
            });
        },
    };
    var ResponsiveObserve = responsiveObserve;

    var __assign$1u = (undefined && undefined.__assign) || function () {
        __assign$1u = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1u.apply(this, arguments);
    };
    var __read$Y = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var SiderContext = React.createContext({
        siderCollapsed: false,
        collapsedWidth: 64,
    });
    var generateId = (function () {
        var i = 0;
        return function (prefix) {
            if (prefix === void 0) { prefix = ''; }
            i += 1;
            return "" + prefix + i;
        };
    })();
    function Sider(props, ref) {
        var _a;
        var _b;
        var children = props.children, className = props.className, style = props.style, _c = props.theme, theme = _c === void 0 ? 'light' : _c, trigger = props.trigger, reverseArrow = props.reverseArrow, _d = props.collapsedWidth, collapsedWidth = _d === void 0 ? 48 : _d, _e = props.width, width = _e === void 0 ? 200 : _e, collapsible = props.collapsible, resizeDirections = props.resizeDirections, onSiderMount = props.onSiderMount, onSiderUnmount = props.onSiderUnmount, breakpoint = props.breakpoint, onBreakpoint = props.onBreakpoint, onCollapse = props.onCollapse, _f = props.resizeBoxProps, resizeBoxProps = _f === void 0 ? {} : _f;
        var uniqueId = generateId('arco-sider-');
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var prefixCls = getPrefixCls('layout-sider');
        var _g = __read$Y(useMergeValue(false, {
            value: 'collapsed' in props ? props.collapsed : undefined,
            defaultValue: props.defaultCollapsed,
        }), 2), collapsed = _g[0], setCollapsed = _g[1];
        // Parsing props width from number to string, to be used as css property value.
        // Using px as the default unit
        var propsWidth = isNumber(width) ? width + "px" : String(width);
        var _collapsedWidth = isNumber(collapsedWidth) ? "" + collapsedWidth : String(collapsedWidth);
        var _h = __read$Y(React.useState(collapsed ? _collapsedWidth : propsWidth), 2), siderWidth = _h[0], setSiderWidth = _h[1];
        var refResponsiveHandlerToken = React.useRef(null);
        // 提供给 ResponsiveHandler，使得其可以获得最新的 state 值
        var refStateForResponsiveHandler = React.useRef(null);
        refStateForResponsiveHandler.current = {
            breakpoint: breakpoint,
            collapsed: collapsed,
            onCollapse: onCollapse,
            onBreakpoint: onBreakpoint,
        };
        React.useEffect(function () {
            onSiderMount && onSiderMount(uniqueId);
            if (collapsible && breakpoint in responsiveMap) {
                refResponsiveHandlerToken.current = ResponsiveObserve.subscribe(function (screens, breakpointChecked) {
                    var _a = refStateForResponsiveHandler.current, breakpoint = _a.breakpoint, collapsed = _a.collapsed, onCollapse = _a.onCollapse, onBreakpoint = _a.onBreakpoint;
                    if (!breakpointChecked || breakpointChecked === breakpoint) {
                        var nextCollapsed = !screens[breakpoint];
                        if (nextCollapsed !== collapsed) {
                            setCollapsed(nextCollapsed);
                            onCollapse && onCollapse(nextCollapsed, 'responsive');
                        }
                        onBreakpoint && onBreakpoint(nextCollapsed);
                    }
                });
            }
            return function () {
                onSiderUnmount && onSiderUnmount(uniqueId);
                if (refResponsiveHandlerToken.current) {
                    ResponsiveObserve.unsubscribe(refResponsiveHandlerToken.current);
                }
            };
        }, []);
        React.useEffect(function () {
            // Parsing collapsed width from number to string, to be used as css property value.
            // Using px as the default unit
            var _collapsedWidth = isNumber(collapsedWidth)
                ? collapsedWidth + "px"
                : String(collapsedWidth);
            setSiderWidth(collapsed ? _collapsedWidth : propsWidth);
        }, [collapsed, propsWidth, collapsedWidth]);
        var resizable = (resizeDirections && isArray$1(resizeDirections)) || ((_b = resizeBoxProps.directions) === null || _b === void 0 ? void 0 : _b.length);
        var TagName = resizable ? ResizeBox$1 : 'aside';
        var renderTrigger = function () {
            var _a;
            var triggerIcon = trigger ||
                (collapsed ? (reverseArrow ? (React.createElement(IconLeft$1, null)) : (React.createElement(IconRight$1, null))) : reverseArrow ? (React.createElement(IconRight$1, null)) : (React.createElement(IconLeft$1, null)));
            return collapsible && trigger !== null ? (React.createElement("div", { style: { width: siderWidth }, className: cs(prefixCls + "-trigger", (_a = {},
                    _a[prefixCls + "-trigger-light"] = theme === 'light',
                    _a)), onClick: function () {
                    setCollapsed(!collapsed);
                    onCollapse && onCollapse(!collapsed, 'clickTrigger');
                } }, triggerIcon)) : null;
        };
        var resizeProps = React.useMemo(function () {
            if (resizable) {
                return __assign$1u(__assign$1u({ component: 'aside', onMoving: function (_, _a) {
                        var currentWidth = _a.width;
                        setSiderWidth(currentWidth);
                    } }, resizeBoxProps), { width: siderWidth, directions: resizeDirections });
            }
            return {};
        }, [resizable, resizeDirections, siderWidth, resizeBoxProps]);
        return (React.createElement(SiderContext.Provider, { value: {
                siderCollapsed: collapsed,
                collapsedWidth: collapsedWidth,
            } },
            React.createElement(TagName, __assign$1u({ ref: ref, style: __assign$1u({ width: siderWidth }, style), className: cs(prefixCls, (_a = {},
                    _a[prefixCls + "-light"] = theme === 'light',
                    _a[prefixCls + "-has-trigger"] = trigger !== null && collapsible,
                    _a[prefixCls + "-collapsed"] = collapsed,
                    _a), className) }, resizeProps),
                React.createElement("div", { className: prefixCls + "-children" }, children),
                renderTrigger())));
    }
    var ForwardRefSider = React.forwardRef(Sider);
    var SiderComponent = ForwardRefSider;
    SiderComponent.displayName = 'LayoutSider';
    SiderComponent.__ARCO_SIGN__ = 'sider';

    var __assign$1t = (undefined && undefined.__assign) || function () {
        __assign$1t = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1t.apply(this, arguments);
    };
    var __rest$H = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function Header$1(props, ref) {
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var className = props.className, children = props.children, rest = __rest$H(props, ["className", "children"]);
        var prefixCls = getPrefixCls('layout-header');
        var classNames = cs(prefixCls, className);
        return (React.createElement("header", __assign$1t({ ref: ref }, rest, { className: classNames }), children));
    }
    var HeaderComponent = React.forwardRef(Header$1);
    HeaderComponent.displayName = 'LayoutHeader';
    var Header$2 = HeaderComponent;

    var __assign$1s = (undefined && undefined.__assign) || function () {
        __assign$1s = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1s.apply(this, arguments);
    };
    var __rest$G = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function Footer$1(props, ref) {
        var className = props.className, children = props.children, rest = __rest$G(props, ["className", "children"]);
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var prefixCls = getPrefixCls('layout-footer');
        var classNames = cs(prefixCls, className);
        return (React.createElement("footer", __assign$1s({ ref: ref }, rest, { className: classNames }), children));
    }
    var FooterComponent = React.forwardRef(Footer$1);
    FooterComponent.displayName = 'LayoutFooter';
    var Footer$2 = FooterComponent;

    var __assign$1r = (undefined && undefined.__assign) || function () {
        __assign$1r = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1r.apply(this, arguments);
    };
    var __rest$F = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function Content(props, ref) {
        var className = props.className, children = props.children, rest = __rest$F(props, ["className", "children"]);
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var prefixCls = getPrefixCls('layout-content');
        var classNames = cs(prefixCls, className);
        return (React.createElement("main", __assign$1r({ ref: ref }, rest, { className: classNames }), children));
    }
    var contentComponent = React.forwardRef(Content);
    contentComponent.displayName = 'LayoutContent';
    var Content$1 = contentComponent;

    var __assign$1q = (undefined && undefined.__assign) || function () {
        __assign$1q = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1q.apply(this, arguments);
    };
    var __rest$E = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$X = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$p = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    function Layout(baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig;
        var props = useMergeProps(baseProps, {}, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Layout);
        var className = props.className, hasSider = props.hasSider, children = props.children, rest = __rest$E(props, ["className", "hasSider", "children"]);
        var _c = __read$X(React.useState([]), 2), siders = _c[0], setSiders = _c[1];
        var prefixCls = getPrefixCls('layout');
        var classNames = cs(prefixCls, (_a = {},
            _a[prefixCls + "-has-sider"] = typeof hasSider === 'boolean' ? hasSider : siders.length > 0,
            _a), className);
        return (React.createElement("section", __assign$1q({ ref: ref }, rest, { className: classNames }), React.Children.map(children, function (child) {
            // child?.props?.sign: Compatible with custom components
            var sign = get_1(child, 'type.__ARCO_SIGN__') || get_1(child, 'props.sign');
            if (child && sign === 'sider') {
                return React.cloneElement(child, {
                    onSiderMount: function (id) { return setSiders(__spreadArray$p(__spreadArray$p([], __read$X(siders), false), [id], false)); },
                    onSiderUnmount: function (id) { return setSiders(siders.filter(function (currentId) { return currentId !== id; })); },
                });
            }
            return child;
        })));
    }
    var ForwardRefLayout = React.forwardRef(Layout);
    var LayoutComponent = ForwardRefLayout;
    LayoutComponent.displayName = 'Layout';
    LayoutComponent.Sider = SiderComponent;
    LayoutComponent.Header = Header$2;
    LayoutComponent.Footer = Footer$2;
    LayoutComponent.Content = Content$1;

    function ownKeys$x(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$y(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$x(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$x(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconMenuFoldComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$y(_objectSpread$y({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-menu-fold")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M42 11H6M42 24H22M42 37H6M13.66 26.912l-4.82-3.118 4.82-3.118v6.236Z"
      }));
    }

    var IconMenuFold = /*#__PURE__*/React.forwardRef(IconMenuFoldComponent);
    IconMenuFold.defaultProps = {
      isIcon: true
    };
    IconMenuFold.displayName = 'IconMenuFold';
    var IconMenuFold$1 = IconMenuFold;

    function ownKeys$w(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$x(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$w(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$w(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconMenuUnfoldComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$x(_objectSpread$x({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-menu-unfold")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M6 11h36M22 24h20M6 37h36M8 20.882 12.819 24 8 27.118v-6.236Z"
      }));
    }

    var IconMenuUnfold = /*#__PURE__*/React.forwardRef(IconMenuUnfoldComponent);
    IconMenuUnfold.defaultProps = {
      isIcon: true
    };
    IconMenuUnfold.displayName = 'IconMenuUnfold';
    var IconMenuUnfold$1 = IconMenuUnfold;

    var __assign$1p = (undefined && undefined.__assign) || function () {
        __assign$1p = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1p.apply(this, arguments);
    };
    var __rest$D = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$W = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$o = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var DEFAULT_THEME = 'light';
    var defaultProps$s = {
        mode: 'vertical',
        selectable: true,
        ellipsis: true,
    };
    function Menu(baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$s, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Menu);
        var style = props.style, children = props.children, className = props.className, menuPrefixCls = props.prefixCls, mode = props.mode, propTheme = props.theme, icons = props.icons, levelIndent = props.levelIndent, propCollapse = props.collapse, inDropdown = props.inDropdown, selectable = props.selectable, triggerProps = props.triggerProps, tooltipProps = props.tooltipProps, ellipsis = props.ellipsis, accordion = props.accordion, autoOpen = props.autoOpen, autoScrollIntoView = props.autoScrollIntoView, scrollConfig = props.scrollConfig, hasCollapseButton = props.hasCollapseButton, defaultOpenKeys = props.defaultOpenKeys, defaultSelectedKeys = props.defaultSelectedKeys, propOpenKeys = props.openKeys, propSelectedKeys = props.selectedKeys, onClickSubMenu = props.onClickSubMenu, onClickMenuItem = props.onClickMenuItem, onCollapseChange = props.onCollapseChange, rest = __rest$D(props, ["style", "children", "className", "prefixCls", "mode", "theme", "icons", "levelIndent", "collapse", "inDropdown", "selectable", "triggerProps", "tooltipProps", "ellipsis", "accordion", "autoOpen", "autoScrollIntoView", "scrollConfig", "hasCollapseButton", "defaultOpenKeys", "defaultSelectedKeys", "openKeys", "selectedKeys", "onClickSubMenu", "onClickMenuItem", "onCollapseChange"]);
        var _c = __read$W(useMergeValue([], {
            defaultValue: defaultOpenKeys,
            value: propOpenKeys,
        }), 2), openKeys = _c[0], setOpenKeys = _c[1];
        var _d = __read$W(useMergeValue([], {
            defaultValue: defaultSelectedKeys,
            value: propSelectedKeys,
        }), 2), selectedKeys = _d[0], setSelectedKeys = _d[1];
        var _e = __read$W(useMergeValue(false, {
            value: propCollapse,
        }), 2), collapse = _e[0], setCollapse = _e[1];
        var menuContext = React.useContext(MenuContext$1);
        var siderCollapsed = React.useContext(SiderContext).siderCollapsed;
        var prefixCls = menuPrefixCls || getPrefixCls('menu');
        var mergedCollapse = siderCollapsed || collapse || inDropdown || mode === 'popButton';
        var theme = propTheme || menuContext.theme || DEFAULT_THEME;
        var refSubMenuKeys = React.useRef([]);
        var refPrevSubMenuKeys = React.useRef([]);
        var forceUpdate = useForceUpdate();
        var getKeyboardEvents = useKeyboardEvent();
        var menuInfoMap = React.useMemo(function () {
            return generateInfoMap(children);
        }, [children]);
        // Unique ID of this instance
        var _instanceId = useId(prefixCls + "-");
        var instanceId = rest.id || _instanceId;
        // autoOpen 时，初次渲染展开所有的子菜单
        React.useEffect(function () {
            // 从 openKeys 中过滤已经不存在的 subMenuKey
            var validOpenKeys = openKeys.filter(function (key) { return refSubMenuKeys.current.indexOf(key) !== -1; });
            if (autoOpen) {
                var keysAdded = refSubMenuKeys.current.filter(function (key) { return refPrevSubMenuKeys.current.indexOf(key) === -1; });
                validOpenKeys = openKeys.concat(keysAdded);
            }
            setOpenKeys(accordion ? validOpenKeys.slice(0, 1) : validOpenKeys);
            refPrevSubMenuKeys.current = refSubMenuKeys.current.slice();
        }, [refSubMenuKeys.current.toString()]);
        var mergedHasCollapseButton = mode !== 'horizontal' && mode !== 'popButton' && !inDropdown && hasCollapseButton;
        var renderChildren = function () {
            var childrenList = processChildren(children, { level: 1 });
            var collapseIcon = collapse
                ? (icons && icons.collapseActive) || React.createElement(IconMenuUnfold$1, null)
                : (icons && icons.collapseDefault) || React.createElement(IconMenuFold$1, null);
            var collapseButtonClickHandler = function () {
                var newCollapse = !collapse;
                setCollapse(newCollapse);
                onCollapseChange && onCollapseChange(newCollapse);
            };
            return (React.createElement(React.Fragment, null,
                React.createElement("div", { className: prefixCls + "-inner" }, mode === 'horizontal' && ellipsis !== false ? (React.createElement(OverflowWrap$1, { ellipsisText: isObject$1(ellipsis) ? ellipsis.text : '···' }, childrenList)) : (childrenList)),
                mergedHasCollapseButton && (React.createElement("div", __assign$1p({ tabIndex: 0, role: "button", "aria-controls": instanceId, "aria-expanded": !collapse, className: prefixCls + "-collapse-button", onClick: collapseButtonClickHandler }, getKeyboardEvents({ onPressEnter: collapseButtonClickHandler })), collapseIcon))));
        };
        var usedStyle = __assign$1p({}, style);
        if (mergedCollapse && !inDropdown) {
            delete usedStyle.width;
        }
        return (React.createElement("div", __assign$1p({ id: mergedHasCollapseButton ? instanceId : undefined, role: "menu" }, omit$1(rest, ['isMenu']), { ref: ref, style: usedStyle, className: cs(prefixCls, prefixCls + "-" + theme, prefixCls + "-" + (mode === 'horizontal' ? 'horizontal' : 'vertical'), (_a = {},
                _a[prefixCls + "-collapse"] = mergedCollapse,
                // 缩起状态自动变成 pop 模式
                _a[prefixCls + "-pop"] = mode === 'pop' || mergedCollapse,
                _a[prefixCls + "-pop-button"] = mode === 'popButton',
                _a[prefixCls + "-rtl"] = rtl,
                _a), className) }),
            React.createElement(MenuContext$1.Provider, { value: {
                    mode: mode,
                    theme: theme,
                    collapse: mergedCollapse,
                    levelIndent: levelIndent,
                    inDropdown: inDropdown,
                    selectedKeys: selectedKeys,
                    openKeys: openKeys,
                    icons: icons,
                    triggerProps: triggerProps,
                    tooltipProps: tooltipProps,
                    autoScrollIntoView: autoScrollIntoView,
                    scrollConfig: scrollConfig,
                    // pass props directly
                    id: instanceId,
                    prefixCls: prefixCls,
                    collectInlineMenuKeys: function (key, unmount) {
                        if (unmount) {
                            refSubMenuKeys.current = refSubMenuKeys.current.filter(function (x) { return x !== key; });
                        }
                        else {
                            refSubMenuKeys.current.push(key);
                        }
                        forceUpdate();
                    },
                    onClickMenuItem: function (key, event) {
                        var _a;
                        selectable && setSelectedKeys([key]);
                        onClickMenuItem && onClickMenuItem(key, event, (_a = menuInfoMap[key]) === null || _a === void 0 ? void 0 : _a.keyPath);
                    },
                    onClickSubMenu: function (key, level, type) {
                        var _a;
                        var newOpenKeys = __spreadArray$o([], __read$W(openKeys), false);
                        if (type === 'inline') {
                            if ((openKeys === null || openKeys === void 0 ? void 0 : openKeys.indexOf(key)) > -1) {
                                if (accordion && level === 1) {
                                    newOpenKeys = [];
                                }
                                else {
                                    newOpenKeys = openKeys.filter(function (item) { return item !== key; });
                                }
                            }
                            else if (accordion && level === 1) {
                                newOpenKeys = [key];
                            }
                            else {
                                newOpenKeys = openKeys.concat([key]);
                            }
                        }
                        setOpenKeys(newOpenKeys);
                        onClickSubMenu && onClickSubMenu(key, newOpenKeys, (_a = menuInfoMap[key]) === null || _a === void 0 ? void 0 : _a.keyPath);
                    },
                } }, renderChildren())));
    }
    var ForwardRefMenu = React.forwardRef(Menu);
    var MenuComponent = ForwardRefMenu;
    MenuComponent.displayName = 'Menu';
    MenuComponent.Item = Item$4;
    MenuComponent.SubMenu = SubMenu$1;
    MenuComponent.ItemGroup = ItemGroup$1;
    MenuComponent.__ARCO_MENU__ = true;
    var Menu$1 = MenuComponent;

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new _ListCache;
      this.size = 0;
    }

    var _stackClear = stackClear;

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    var _stackDelete = stackDelete;

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    var _stackGet = stackGet;

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    var _stackHas = stackHas;

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof _ListCache) {
        var pairs = data.__data__;
        if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new _MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    var _stackSet = stackSet;

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new _ListCache(entries);
      this.size = data.size;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = _stackClear;
    Stack.prototype['delete'] = _stackDelete;
    Stack.prototype.get = _stackGet;
    Stack.prototype.has = _stackHas;
    Stack.prototype.set = _stackSet;

    var _Stack = Stack;

    var defineProperty = (function() {
      try {
        var func = _getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    var _defineProperty$1 = defineProperty;

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && _defineProperty$1) {
        _defineProperty$1(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    var _baseAssignValue = baseAssignValue;

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq_1(object[key], value)) ||
          (value === undefined && !(key in object))) {
        _baseAssignValue(object, key, value);
      }
    }

    var _assignMergeValue = assignMergeValue;

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    var _createBaseFor = createBaseFor;

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = _createBaseFor();

    var _baseFor = baseFor;

    var _cloneBuffer = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer = moduleExports ? _root.Buffer : undefined,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    module.exports = cloneBuffer;
    });

    /** Built-in value references. */
    var Uint8Array = _root.Uint8Array;

    var _Uint8Array = Uint8Array;

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
      return result;
    }

    var _cloneArrayBuffer = cloneArrayBuffer;

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    var _cloneTypedArray = cloneTypedArray;

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    var _copyArray = copyArray;

    /** Built-in value references. */
    var objectCreate = Object.create;

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject_1(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    var _baseCreate = baseCreate;

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    var _overArg = overArg;

    /** Built-in value references. */
    var getPrototype = _overArg(Object.getPrototypeOf, Object);

    var _getPrototype = getPrototype;

    /** Used for built-in method references. */
    var objectProto$9 = Object.prototype;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$9;

      return value === proto;
    }

    var _isPrototype = isPrototype;

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !_isPrototype(object))
        ? _baseCreate(_getPrototype(object))
        : {};
    }

    var _initCloneObject = initCloneObject;

    /** `Object#toString` result references. */
    var argsTag$2 = '[object Arguments]';

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike_1(value) && _baseGetTag(value) == argsTag$2;
    }

    var _baseIsArguments = baseIsArguments;

    /** Used for built-in method references. */
    var objectProto$8 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

    /** Built-in value references. */
    var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
      return isObjectLike_1(value) && hasOwnProperty$7.call(value, 'callee') &&
        !propertyIsEnumerable$1.call(value, 'callee');
    };

    var isArguments_1 = isArguments;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
    }

    var isLength_1 = isLength;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength_1(value.length) && !isFunction_1(value);
    }

    var isArrayLike_1 = isArrayLike;

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike_1(value) && isArrayLike_1(value);
    }

    var isArrayLikeObject_1 = isArrayLikeObject;

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    var stubFalse_1 = stubFalse;

    var isBuffer_1 = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer = moduleExports ? _root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse_1;

    module.exports = isBuffer;
    });

    /** `Object#toString` result references. */
    var objectTag$3 = '[object Object]';

    /** Used for built-in method references. */
    var funcProto = Function.prototype,
        objectProto$7 = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag$3) {
        return false;
      }
      var proto = _getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$6.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    var isPlainObject_1 = isPlainObject;

    /** `Object#toString` result references. */
    var argsTag$1 = '[object Arguments]',
        arrayTag$1 = '[object Array]',
        boolTag$1 = '[object Boolean]',
        dateTag$1 = '[object Date]',
        errorTag$1 = '[object Error]',
        funcTag = '[object Function]',
        mapTag$2 = '[object Map]',
        numberTag$1 = '[object Number]',
        objectTag$2 = '[object Object]',
        regexpTag$1 = '[object RegExp]',
        setTag$2 = '[object Set]',
        stringTag$1 = '[object String]',
        weakMapTag$1 = '[object WeakMap]';

    var arrayBufferTag$1 = '[object ArrayBuffer]',
        dataViewTag$2 = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
    typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] =
    typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] =
    typedArrayTags[errorTag$1] = typedArrayTags[funcTag] =
    typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] =
    typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] =
    typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] =
    typedArrayTags[weakMapTag$1] = false;

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike_1(value) &&
        isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
    }

    var _baseIsTypedArray = baseIsTypedArray;

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }

    var _baseUnary = baseUnary;

    var _nodeUtil = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && _freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function() {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        }

        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }());

    module.exports = nodeUtil;
    });

    /* Node.js helper references. */
    var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

    var isTypedArray_1 = isTypedArray;

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    var _safeGet = safeGet;

    /** Used for built-in method references. */
    var objectProto$6 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty$5.call(object, key) && eq_1(objValue, value)) ||
          (value === undefined && !(key in object))) {
        _baseAssignValue(object, key, value);
      }
    }

    var _assignValue = assignValue;

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          _baseAssignValue(object, key, newValue);
        } else {
          _assignValue(object, key, newValue);
        }
      }
      return object;
    }

    var _copyObject = copyObject;

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    var _baseTimes = baseTimes;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    var _isIndex = isIndex;

    /** Used for built-in method references. */
    var objectProto$5 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray_1(value),
          isArg = !isArr && isArguments_1(value),
          isBuff = !isArr && !isArg && isBuffer_1(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? _baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$4.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               _isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    var _arrayLikeKeys = arrayLikeKeys;

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    var _nativeKeysIn = nativeKeysIn;

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject_1(object)) {
        return _nativeKeysIn(object);
      }
      var isProto = _isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty$3.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    var _baseKeysIn = baseKeysIn;

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
    }

    var keysIn_1 = keysIn;

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return _copyObject(value, keysIn_1(value));
    }

    var toPlainObject_1 = toPlainObject;

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = _safeGet(object, key),
          srcValue = _safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        _assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray_1(srcValue),
            isBuff = !isArr && isBuffer_1(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray_1(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject_1(objValue)) {
            newValue = _copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = _cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = _cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {
          newValue = objValue;
          if (isArguments_1(objValue)) {
            newValue = toPlainObject_1(objValue);
          }
          else if (!isObject_1(objValue) || isFunction_1(objValue)) {
            newValue = _initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      _assignMergeValue(object, key, newValue);
    }

    var _baseMergeDeep = baseMergeDeep;

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      _baseFor(source, function(srcValue, key) {
        stack || (stack = new _Stack);
        if (isObject_1(srcValue)) {
          _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(_safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          _assignMergeValue(object, key, newValue);
        }
      }, keysIn_1);
    }

    var _baseMerge = baseMerge;

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    var identity_1 = identity;

    /**
     * A faster alternative to `Function#apply`, this function invokes `func`
     * with the `this` binding of `thisArg` and the arguments of `args`.
     *
     * @private
     * @param {Function} func The function to invoke.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} args The arguments to invoke `func` with.
     * @returns {*} Returns the result of `func`.
     */
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0: return func.call(thisArg);
        case 1: return func.call(thisArg, args[0]);
        case 2: return func.call(thisArg, args[0], args[1]);
        case 3: return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }

    var _apply = apply;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max;

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return _apply(func, this, otherArgs);
      };
    }

    var _overRest = overRest;

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    var constant_1 = constant;

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !_defineProperty$1 ? identity_1 : function(func, string) {
      return _defineProperty$1(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant_1(string),
        'writable': true
      });
    };

    var _baseSetToString = baseSetToString;

    /** Used to detect hot functions by number of calls within a span of milliseconds. */
    var HOT_COUNT = 800,
        HOT_SPAN = 16;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeNow = Date.now;

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    var _shortOut = shortOut;

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = _shortOut(_baseSetToString);

    var _setToString = setToString;

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return _setToString(_overRest(func, start, identity_1), func + '');
    }

    var _baseRest = baseRest;

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject_1(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike_1(object) && _isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq_1(object[index], value);
      }
      return false;
    }

    var _isIterateeCall = isIterateeCall;

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return _baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    var _createAssigner = createAssigner;

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = _createAssigner(function(object, source, srcIndex) {
      _baseMerge(object, source, srcIndex);
    });

    var merge_1 = merge;

    var customParseFormat = createCommonjsModule(function (module, exports) {
    !function(e,t){module.exports=t();}(commonjsGlobal,(function(){var e={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},t=/(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,n=/\d\d/,r=/\d\d?/,i=/\d*[^-_:/,()\s\d]+/,o={},s=function(e){return (e=+e)+(e>68?1900:2e3)};var a=function(e){return function(t){this[e]=+t;}},f=[/[+-]\d\d:?(\d\d)?|Z/,function(e){(this.zone||(this.zone={})).offset=function(e){if(!e)return 0;if("Z"===e)return 0;var t=e.match(/([+-]|\d\d)/g),n=60*t[1]+(+t[2]||0);return 0===n?0:"+"===t[0]?-n:n}(e);}],h=function(e){var t=o[e];return t&&(t.indexOf?t:t.s.concat(t.f))},u=function(e,t){var n,r=o.meridiem;if(r){for(var i=1;i<=24;i+=1)if(e.indexOf(r(i,0,t))>-1){n=i>12;break}}else n=e===(t?"pm":"PM");return n},d={A:[i,function(e){this.afternoon=u(e,!1);}],a:[i,function(e){this.afternoon=u(e,!0);}],S:[/\d/,function(e){this.milliseconds=100*+e;}],SS:[n,function(e){this.milliseconds=10*+e;}],SSS:[/\d{3}/,function(e){this.milliseconds=+e;}],s:[r,a("seconds")],ss:[r,a("seconds")],m:[r,a("minutes")],mm:[r,a("minutes")],H:[r,a("hours")],h:[r,a("hours")],HH:[r,a("hours")],hh:[r,a("hours")],D:[r,a("day")],DD:[n,a("day")],Do:[i,function(e){var t=o.ordinal,n=e.match(/\d+/);if(this.day=n[0],t)for(var r=1;r<=31;r+=1)t(r).replace(/\[|\]/g,"")===e&&(this.day=r);}],M:[r,a("month")],MM:[n,a("month")],MMM:[i,function(e){var t=h("months"),n=(h("monthsShort")||t.map((function(e){return e.slice(0,3)}))).indexOf(e)+1;if(n<1)throw new Error;this.month=n%12||n;}],MMMM:[i,function(e){var t=h("months").indexOf(e)+1;if(t<1)throw new Error;this.month=t%12||t;}],Y:[/[+-]?\d+/,a("year")],YY:[n,function(e){this.year=s(e);}],YYYY:[/\d{4}/,a("year")],Z:f,ZZ:f};function c(n){var r,i;r=n,i=o&&o.formats;for(var s=(n=r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(t,n,r){var o=r&&r.toUpperCase();return n||i[r]||e[r]||i[o].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(e,t,n){return t||n.slice(1)}))}))).match(t),a=s.length,f=0;f<a;f+=1){var h=s[f],u=d[h],c=u&&u[0],l=u&&u[1];s[f]=l?{regex:c,parser:l}:h.replace(/^\[|\]$/g,"");}return function(e){for(var t={},n=0,r=0;n<a;n+=1){var i=s[n];if("string"==typeof i)r+=i.length;else {var o=i.regex,f=i.parser,h=e.slice(r),u=o.exec(h)[0];f.call(t,u),e=e.replace(u,"");}}return function(e){var t=e.afternoon;if(void 0!==t){var n=e.hours;t?n<12&&(e.hours+=12):12===n&&(e.hours=0),delete e.afternoon;}}(t),t}}return function(e,t,n){n.p.customParseFormat=!0,e&&e.parseTwoDigitYear&&(s=e.parseTwoDigitYear);var r=t.prototype,i=r.parse;r.parse=function(e){var t=e.date,r=e.utc,s=e.args;this.$u=r;var a=s[1];if("string"==typeof a){var f=!0===s[2],h=!0===s[3],u=f||h,d=s[2];h&&(d=s[2]),o=this.$locale(),!f&&d&&(o=n.Ls[d]),this.$d=function(e,t,n){try{if(["x","X"].indexOf(t)>-1)return new Date(("X"===t?1e3:1)*e);var r=c(t)(e),i=r.year,o=r.month,s=r.day,a=r.hours,f=r.minutes,h=r.seconds,u=r.milliseconds,d=r.zone,l=new Date,m=s||(i||o?1:l.getDate()),M=i||l.getFullYear(),Y=0;i&&!o||(Y=o>0?o-1:l.getMonth());var p=a||0,v=f||0,D=h||0,g=u||0;return d?new Date(Date.UTC(M,Y,m,p,v,D,g+60*d.offset*1e3)):n?new Date(Date.UTC(M,Y,m,p,v,D,g)):new Date(M,Y,m,p,v,D,g)}catch(e){return new Date("")}}(t,a,r),this.init(),d&&!0!==d&&(this.$L=this.locale(d).$L),u&&t!=this.format(a)&&(this.$d=new Date("")),o={};}else if(a instanceof Array)for(var l=a.length,m=1;m<=l;m+=1){s[1]=a[m-1];var M=n.apply(this,s);if(M.isValid()){this.$d=M.$d,this.$L=M.$L,this.init();break}m===l&&(this.$d=new Date(""));}else i.call(this,e);};}}));
    });

    var isBetween = createCommonjsModule(function (module, exports) {
    !function(e,i){module.exports=i();}(commonjsGlobal,(function(){return function(e,i,t){i.prototype.isBetween=function(e,i,s,f){var n=t(e),o=t(i),r="("===(f=f||"()")[0],u=")"===f[1];return (r?this.isAfter(n,s):!this.isBefore(n,s))&&(u?this.isBefore(o,s):!this.isAfter(o,s))||(r?this.isBefore(n,s):!this.isAfter(n,s))&&(u?this.isAfter(o,s):!this.isBefore(o,s))};}}));
    });

    var weekOfYear = createCommonjsModule(function (module, exports) {
    !function(e,t){module.exports=t();}(commonjsGlobal,(function(){var e="week",t="year";return function(i,n,r){var f=n.prototype;f.week=function(i){if(void 0===i&&(i=null),null!==i)return this.add(7*(i-this.week()),"day");var n=this.$locale().yearStart||1;if(11===this.month()&&this.date()>25){var f=r(this).startOf(t).add(1,t).date(n),s=r(this).endOf(e);if(f.isBefore(s))return 1}var a=r(this).startOf(t).date(n).startOf(e).subtract(1,"millisecond"),o=this.diff(a,e,!0);return o<0?r(this).startOf("week").week():Math.ceil(o)},f.weeks=function(e){return void 0===e&&(e=null),this.week(e)};}}));
    });

    var advancedFormat = createCommonjsModule(function (module, exports) {
    !function(e,t){module.exports=t();}(commonjsGlobal,(function(){return function(e,t){var r=t.prototype,n=r.format;r.format=function(e){var t=this,r=this.$locale();if(!this.isValid())return n.bind(this)(e);var s=this.$utils(),a=(e||"YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,(function(e){switch(e){case"Q":return Math.ceil((t.$M+1)/3);case"Do":return r.ordinal(t.$D);case"gggg":return t.weekYear();case"GGGG":return t.isoWeekYear();case"wo":return r.ordinal(t.week(),"W");case"w":case"ww":return s.s(t.week(),"w"===e?1:2,"0");case"W":case"WW":return s.s(t.isoWeek(),"W"===e?1:2,"0");case"k":case"kk":return s.s(String(0===t.$H?24:t.$H),"k"===e?1:2,"0");case"X":return Math.floor(t.$d.getTime()/1e3);case"x":return t.$d.getTime();case"z":return "["+t.offsetName()+"]";case"zzz":return "["+t.offsetName("long")+"]";default:return e}}));return n.bind(this)(a)};}}));
    });

    var weekYear = createCommonjsModule(function (module, exports) {
    !function(e,t){module.exports=t();}(commonjsGlobal,(function(){return function(e,t){t.prototype.weekYear=function(){var e=this.month(),t=this.week(),n=this.year();return 1===t&&11===e?n+1:0===e&&t>=52?n-1:n};}}));
    });

    var quarterOfYear = createCommonjsModule(function (module, exports) {
    !function(t,n){module.exports=n();}(commonjsGlobal,(function(){var t="month",n="quarter";return function(e,i){var r=i.prototype;r.quarter=function(t){return this.$utils().u(t)?Math.ceil((this.month()+1)/3):this.month(this.month()%3+3*(t-1))};var s=r.add;r.add=function(e,i){return e=Number(e),this.$utils().p(i)===n?this.add(3*e,t):s.bind(this)(e,i)};var u=r.startOf;r.startOf=function(e,i){var r=this.$utils(),s=!!r.u(i)||i;if(r.p(e)===n){var o=this.quarter()-1;return s?this.month(3*o).startOf(t).startOf("day"):this.month(3*o+2).endOf(t).endOf("day")}return u.bind(this)(e,i)};}}));
    });

    var __assign$1o = (undefined && undefined.__assign) || function () {
        __assign$1o = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1o.apply(this, arguments);
    };
    var __read$V = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$n = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var isMoment = dayjs_min()._isAMomentObject;
    if (isMoment) {
        dayjs_min.extend = function () { };
    }
    var overwriteIsDayjs = function (_, Dayjs, dayjs) {
        dayjs = function (date, c) {
            if (isDayjs(date)) {
                return date.clone();
            }
            var cfg = typeof c === 'object' ? c : {};
            cfg.date = date;
            cfg.args = arguments; // eslint-disable-line prefer-rest-params
            return new Dayjs(cfg);
        };
        var proto = Dayjs.prototype;
        var old$Utils = proto.$utils;
        proto.$utils = function () {
            var newUtils = old$Utils();
            newUtils.i = isDayjs;
            return newUtils;
        };
        dayjs.isDayjs = isDayjs;
    };
    dayjs_min.extend(overwriteIsDayjs);
    dayjs_min.extend(customParseFormat);
    dayjs_min.extend(isBetween);
    dayjs_min.extend(weekOfYear);
    dayjs_min.extend(advancedFormat);
    dayjs_min.extend(weekYear);
    dayjs_min.extend(quarterOfYear);
    var dayjs = dayjs_min;
    function startOfWeekTimestamp(date, weekStart) {
        // 计算 date 与前一个 weekStart 日期的间隔
        var diff = (date.day() - weekStart + 7) % 7;
        var startOfWeek = date.clone().startOf('day').subtract(diff, 'day');
        return startOfWeek.valueOf();
    }
    function isSameWeekMoment(date1, date2, weekStart) {
        return startOfWeekTimestamp(date1, weekStart) === startOfWeekTimestamp(date2, weekStart);
    }
    // 兼容 moment
    var methods = {
        add: function (time, value, unit) {
            return isMoment ? time.clone().add(value, unit) : time.add(value, unit);
        },
        subtract: function (time, value, unit) {
            return isMoment ? time.clone().subtract(value, unit) : time.subtract(value, unit);
        },
        startOf: function (time, unit) {
            return isMoment ? time.clone().startOf(unit) : time.startOf(unit);
        },
        endOf: function (time, unit) {
            return isMoment ? time.clone().endOf(unit) : time.endOf(unit);
        },
        set: function (time, unit, value) {
            return isMoment ? time.clone().set(unit, value) : time.set(unit, value);
        },
        isSameWeek: function (date1, date2, weekStart, localeName) {
            return isMoment
                ? isSameWeekMoment(date1, date2, weekStart)
                : date1.locale(__assign$1o(__assign$1o({}, dayjs.Ls[localeName]), { weekStart: weekStart })).isSame(date2, 'week');
        },
    };
    // convert timezone to utcOffset
    // https://github.com/iamkun/dayjs/blob/dev/src/plugin/timezone/index.js#L3
    var typeToPos = {
        year: 0,
        month: 1,
        day: 2,
        hour: 3,
        minute: 4,
        second: 5,
    };
    // Cache time-zone lookups from Intl.DateTimeFormat,
    // as it is a *very* slow method.
    var dtfCache = {};
    var getDateTimeFormat = function (timezone, timeZoneName) {
        var key = timezone + "|" + (timeZoneName || 'short');
        var dtf = dtfCache[key];
        if (!dtf) {
            dtf = new Intl.DateTimeFormat('en-US', {
                hour12: false,
                timeZone: timezone,
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
            });
            dtfCache[key] = dtf;
        }
        return dtf;
    };
    var makeFormatParts = function (timestamp, timezone) {
        var date = new Date(timestamp);
        var dtf = getDateTimeFormat(timezone);
        return dtf.formatToParts(date);
    };
    var tzOffset = function (timestamp, timezone) {
        var formatResult = makeFormatParts(timestamp, timezone);
        var filled = [];
        for (var i = 0; i < formatResult.length; i += 1) {
            var _a = formatResult[i], type = _a.type, value = _a.value;
            var pos = typeToPos[type];
            if (pos >= 0) {
                filled[pos] = parseInt(value, 10);
            }
        }
        var hour = filled[3];
        // Workaround for the same behavior in different node version
        // https://github.com/nodejs/node/issues/33027
        /* istanbul ignore next */
        var fixedHour = hour === 24 ? 0 : hour;
        var utcTs = Date.UTC(filled[0], filled[1] - 1, filled[2], fixedHour, filled[4], filled[5], 0);
        var asTS = +timestamp;
        var over = asTS % 1000;
        asTS -= over;
        return (utcTs - asTS) / (60 * 1000);
    };
    // find the right offset a given local time. The o input is our guess, which determines which
    // offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)
    // https://github.com/moment/luxon/blob/master/src/datetime.js#L76
    var fixOffset = function (localTS, o0, tz) {
        // Our UTC time is just a guess because our offset is just a guess
        var utcGuess = localTS - o0 * 60 * 1000;
        // Test whether the zone matches the offset for this ts
        var o2 = tzOffset(utcGuess, tz);
        // If so, offset didn't change and we're done
        if (o0 === o2) {
            return [utcGuess, o0];
        }
        // If not, change the ts by the difference in the offset
        utcGuess -= (o2 - o0) * 60 * 1000;
        // If that gives us the local time we want, we're done
        var o3 = tzOffset(utcGuess, tz);
        if (o2 === o3) {
            return [utcGuess, o2];
        }
        // If it's different, we're in a hole time.
        // The offset has changed, but the we don't adjust the time
        return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];
    };
    function timezoneToOffset(inputTs, timezone) {
        return fixOffset(inputTs, tzOffset(new Date().getTime(), timezone), timezone)[1];
    }
    // get local now time
    function getNow(utcOffset, timezone) {
        return isUndefined(utcOffset) && !timezone ? dayjs() : toTimezone(dayjs(), utcOffset, timezone);
    }
    // convert local date to specify timezone date
    function toTimezone(time, utcOffset, timezone, local) {
        if (!time || (isUndefined(utcOffset) && !timezone)) {
            return time;
        }
        var localOffset = -time.toDate().getTimezoneOffset();
        var uOffset = isUndefined(utcOffset)
            ? !timezone
                ? localOffset
                : timezoneToOffset(time.valueOf(), timezone)
            : utcOffset;
        var timezoneOffset = Math.abs(uOffset) <= 16 ? uOffset * 60 : uOffset;
        var diffOffset = local ? localOffset - timezoneOffset : timezoneOffset - localOffset;
        return dayjs(dayjs(time).valueOf() + diffOffset * 60 * 1000);
    }
    // convert specify timezone date to local date
    function toLocal(time, utcOffset, timezone) {
        return toTimezone(time, utcOffset, timezone, true);
    }
    function getTimeFormat(format) {
        var units = ['H', 'h', 'm', 's', 'A', 'a'];
        var timeFormat = '';
        units.some(function (unit) {
            if (format.indexOf(unit) !== -1) {
                timeFormat = "" + unit + format.split(" " + unit)[1];
                return true;
            }
            return false;
        });
        return timeFormat || 'HH:mm:ss';
    }
    function getDayjsValue(time, format, utcOffset, timezone) {
        if (!time) {
            return undefined;
        }
        var formatValue = function (value) {
            if (isDayjs(value)) {
                return dayjs(value.valueOf());
            }
            if (typeof value === 'string') {
                var dv = dayjs(value, format);
                return dv.isValid() ? dv : dayjs(value, 'YYYY-MM-DD');
            }
            return dayjs(value);
        };
        // if set a timezone, convert to timezone date
        var getRealTime = function (t) {
            return utcOffset !== undefined || timezone
                ? toTimezone(formatValue(t), utcOffset, timezone)
                : formatValue(t);
        };
        if (isArray$1(time)) {
            return time.map(function (t) { return (t ? getRealTime(t) : undefined); });
        }
        return getRealTime(time);
    }
    function getValueWithTime(date, time) {
        var y = date.year();
        var m = date.month();
        var d = date.date();
        if (time) {
            var returnTime = time;
            returnTime = methods.set(returnTime, 'year', y);
            returnTime = methods.set(returnTime, 'month', m);
            returnTime = methods.set(returnTime, 'date', d);
            return returnTime;
        }
        return date;
    }
    function getSortedDayjsArray(values) {
        if (!values || !values[0] || !values[1]) {
            return values;
        }
        var newValues = __spreadArray$n([], __read$V(values), false);
        newValues.sort(function (a, b) { return a.valueOf() - b.valueOf(); });
        return newValues;
    }
    function isDayjsChange(prevValue, currentValue) {
        if (currentValue === undefined && prevValue === undefined) {
            return false;
        }
        return ((currentValue && !prevValue) ||
            (!currentValue && prevValue) ||
            dayjs(currentValue).valueOf() !== dayjs(prevValue).valueOf());
    }
    function isDayjsArrayChange(prevValue, currentValue) {
        if (currentValue === undefined && prevValue === undefined) {
            return false;
        }
        return ((currentValue && !prevValue) ||
            (!currentValue && prevValue) ||
            (isArray$1(currentValue) &&
                isArray$1(prevValue) &&
                dayjs(currentValue[0]).valueOf() !== dayjs(prevValue[0]).valueOf()) ||
            dayjs(currentValue[1]).valueOf() !== dayjs(prevValue[1]).valueOf());
    }
    function isValidTimeString(str, format) {
        return typeof str === 'string' && dayjs(str, format).format(format) === str;
    }

    function padStart(string, length, char) {
        if (char === void 0) { char = ' '; }
        var s = String(string);
        if (!length) {
            return s;
        }
        var newString = s.length < length ? "" + char + s : s;
        return newString.length < length ? padStart(newString, length, char) : newString;
    }

    var __assign$1n = (undefined && undefined.__assign) || function () {
        __assign$1n = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1n.apply(this, arguments);
    };
    var __read$U = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var defaultContextValue = {
        type: 'radio',
    };
    var defaultProps$r = {
        type: 'radio',
        mode: 'outline',
        direction: 'horizontal',
    };
    var RadioGroupContext = React.createContext(defaultContextValue);
    function Group(baseProps) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, ctxSize = _b.size, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$r, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig['Radio.Group']);
        var style = props.style, className = props.className, name = props.name, children = props.children, direction = props.direction, type = props.type, mode = props.mode, options = props.options, disabled = props.disabled;
        var _c = __read$U(useMergeValue(undefined, {
            defaultValue: props.defaultValue,
            value: props.value,
        }), 2), value = _c[0], setValue = _c[1];
        var size = props.size || ctxSize;
        var prefixCls = getPrefixCls('radio');
        var classNames = cs(prefixCls + "-group", (_a = {},
            _a[prefixCls + "-group-type-button"] = type !== 'radio',
            _a[prefixCls + "-size-" + size] = !!size,
            _a[prefixCls + "-mode-" + mode] = !!mode,
            _a[prefixCls + "-group-disabled"] = disabled,
            _a[prefixCls + "-group-direction-vertical"] = direction === 'vertical',
            _a[prefixCls + "-group-rtl"] = rtl,
            _a), className);
        var onChangeValue = function (v, event) {
            var onChange = props.onChange;
            if (v !== value) {
                if (!('value' in props)) {
                    setValue(v);
                }
                onChange && onChange(v, event);
            }
        };
        var contextProp = {
            onChangeValue: onChangeValue,
            type: type,
            value: value,
            disabled: disabled,
            group: true,
            name: name,
        };
        return (React.createElement(RadioGroupContext.Provider, { value: contextProp },
            React.createElement("div", __assign$1n({ className: classNames, role: "radiogroup", style: style }, pickTriggerPropsFromRest(props), pickDataAttributes(props)), options && isArray$1(options)
                ? options.map(function (option, index) {
                    if (isObject$1(option)) {
                        return (React.createElement(Radio$1, { key: option.value, disabled: disabled || option.disabled, value: option.value }, option.label));
                    }
                    return (React.createElement(Radio$1, { key: index, value: option, disabled: disabled }, option));
                })
                : children)));
    }
    Group.displayName = 'RadioGroup';

    var __assign$1m = (undefined && undefined.__assign) || function () {
        __assign$1m = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1m.apply(this, arguments);
    };
    var __rest$C = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$T = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    function Radio$1(baseProps) {
        var _a;
        var inputRef = React.useRef(null);
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, {}, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Radio);
        var context = React.useContext(RadioGroupContext);
        var prefixCls = getPrefixCls('radio');
        var mergeProps = __assign$1m({}, props);
        if (context.group) {
            mergeProps.checked = context.value === props.value;
            mergeProps.disabled = !!(context.disabled || props.disabled);
        }
        var disabled = mergeProps.disabled, children = mergeProps.children, value = mergeProps.value, style = mergeProps.style, className = mergeProps.className, rest = __rest$C(mergeProps, ["disabled", "children", "value", "style", "className"]);
        var _c = __read$T(useMergeValue(false, {
            value: mergeProps.checked,
            defaultValue: mergeProps.defaultChecked,
        }), 2), checked = _c[0], setChecked = _c[1];
        var classNames = cs("" + prefixCls + (context.type === 'button' ? '-button' : ''), (_a = {},
            _a[prefixCls + "-checked"] = checked,
            _a[prefixCls + "-disabled"] = disabled,
            _a[prefixCls + "-rtl"] = rtl,
            _a), className);
        var onChange = function (event) {
            var onChange = mergeProps.onChange, value = mergeProps.value;
            if (disabled) {
                return;
            }
            if (context.group) {
                context.onChangeValue && context.onChangeValue(value, event);
            }
            else if (!('checked' in props) && !checked) {
                setChecked(true);
            }
            !checked && onChange && onChange(true, event);
        };
        var onLabelClick = React.useCallback(function (e) {
            if (isFunction$1(props.children)) {
                // 避免children中含有表单元素造成label无法触发input的onchange的情况
                e.preventDefault();
                inputRef.current && inputRef.current.click();
            }
            rest.onClick && rest.onClick(e);
        }, [props.children, rest.onClick]);
        return (React.createElement("label", __assign$1m({}, omit$1(rest, ['checked', 'onChange']), { onClick: onLabelClick, style: style, className: classNames }),
            React.createElement("input", __assign$1m({ ref: inputRef, disabled: disabled, value: value || '', type: "radio" }, (context.name ? { name: context.name } : {}), { checked: checked, onChange: function (event) {
                    event.persist();
                    onChange(event);
                }, onClick: function (e) {
                    e.stopPropagation();
                } })),
            isFunction$1(children) ? (children({ checked: checked })) : context.type === 'radio' ? (React.createElement(React.Fragment, null,
                React.createElement(IconHover, { prefix: prefixCls, className: prefixCls + "-mask-wrapper", disabled: checked || disabled },
                    React.createElement("div", { className: prefixCls + "-mask" })),
                children && React.createElement("span", { className: prefixCls + "-text" }, children))) : (context.type === 'button' && React.createElement("span", { className: prefixCls + "-button-inner" }, children))));
    }
    Radio$1.__BYTE_RADIO = true;
    Radio$1.displayName = 'Radio';
    Radio$1.Group = Group;
    Radio$1.GroupContext = RadioGroupContext;

    function ownKeys$v(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$w(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$v(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$v(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconDoubleLeftComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$w(_objectSpread$w({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-double-left")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M36.857 9.9 22.715 24.042l14.142 14.142M25.544 9.9 11.402 24.042l14.142 14.142"
      }));
    }

    var IconDoubleLeft = /*#__PURE__*/React.forwardRef(IconDoubleLeftComponent);
    IconDoubleLeft.defaultProps = {
      isIcon: true
    };
    IconDoubleLeft.displayName = 'IconDoubleLeft';
    var IconDoubleLeft$1 = IconDoubleLeft;

    function ownKeys$u(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$v(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$u(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$u(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconDoubleRightComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$v(_objectSpread$v({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-double-right")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "m11.143 38.1 14.142-14.142L11.143 9.816M22.456 38.1l14.142-14.142L22.456 9.816"
      }));
    }

    var IconDoubleRight = /*#__PURE__*/React.forwardRef(IconDoubleRightComponent);
    IconDoubleRight.defaultProps = {
      isIcon: true
    };
    IconDoubleRight.displayName = 'IconDoubleRight';
    var IconDoubleRight$1 = IconDoubleRight;

    var __assign$1l = (undefined && undefined.__assign) || function () {
        __assign$1l = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1l.apply(this, arguments);
    };
    var __rest$B = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function Meta$2(props, ref) {
        var _a;
        var className = props.className, title = props.title, avatar = props.avatar, description = props.description, actionList = props.actionList, others = __rest$B(props, ["className", "title", "avatar", "description", "actionList"]);
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var prefixCls = getPrefixCls('card-meta');
        var classNames = cs(prefixCls, className);
        return (React.createElement("div", __assign$1l({}, others, { ref: ref, className: classNames }),
            title || description ? (React.createElement("div", { className: prefixCls + "-content" },
                title && React.createElement("div", { className: prefixCls + "-title" }, title),
                description && React.createElement("div", { className: prefixCls + "-description" }, description))) : null,
            avatar || actionList ? (React.createElement("div", { className: cs(prefixCls + "-footer ", (_a = {}, _a[prefixCls + "-footer-only-actions"] = !avatar, _a)) },
                avatar ? React.createElement("div", { className: prefixCls + "-avatar" }, avatar) : null,
                actionList)) : null));
    }
    var MetaComponent$1 = React.forwardRef(Meta$2);
    MetaComponent$1.displayName = 'CardMeta';
    var Meta$3 = MetaComponent$1;

    function Grid(props, ref) {
        var _a;
        var children = props.children, style = props.style, className = props.className, hoverable = props.hoverable;
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var prefixCls = getPrefixCls('card-grid');
        return (React.createElement("div", { ref: ref, style: style, className: cs(prefixCls, (_a = {}, _a[prefixCls + "-hoverable"] = hoverable, _a), className) }, children));
    }
    var CardComponent$1 = React.forwardRef(Grid);
    CardComponent$1.displayName = 'CardGrid';
    var Grid$1 = CardComponent$1;

    var __read$S = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$m = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    function DotLoading(props) {
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var prefixCls = getPrefixCls('spin') + "-dot";
        var dotStyle = {
            width: props.size,
            height: props.size,
        };
        var sizeNumber = props.size ? parseInt(String(props.size)) : 0;
        return (React.createElement("div", { className: prefixCls + "-list", style: {
                height: props.size,
                width: isNumber(sizeNumber) && sizeNumber > 0 ? sizeNumber * 7 : '',
            } }, __spreadArray$m([], __read$S(new Array(5)), false).map(function (_, index) {
            return React.createElement("div", { key: index, className: prefixCls, style: dotStyle });
        })));
    }

    var __assign$1k = (undefined && undefined.__assign) || function () {
        __assign$1k = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1k.apply(this, arguments);
    };
    var __rest$A = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$R = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    function Spin(baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig;
        var props = useMergeProps(baseProps, {}, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Spin);
        var style = props.style, className = props.className, children = props.children, propLoading = props.loading, size = props.size, icon = props.icon, element = props.element, tip = props.tip, dot = props.dot, delay = props.delay, _c = props.block, block = _c === void 0 ? false : _c, rest = __rest$A(props, ["style", "className", "children", "loading", "size", "icon", "element", "tip", "dot", "delay", "block"]);
        var _d = __read$R(React.useState(delay ? false : propLoading), 2), loading = _d[0], setLoading = _d[1];
        var debouncedSetLoading = React.useCallback(debounce_1(setLoading, delay), [delay]);
        var _usedLoading = delay ? loading : propLoading;
        var prefixCls = getPrefixCls('spin');
        React.useEffect(function () {
            delay && debouncedSetLoading(propLoading);
            return function () {
                debouncedSetLoading && debouncedSetLoading.cancel();
            };
        }, [propLoading]);
        var loadingIcon = (React.createElement("span", { className: prefixCls + "-icon" }, icon
            ? React.cloneElement(icon, {
                className: cs(prefixCls.replace('-spin', '-icon') + "-loading"),
                style: {
                    fontSize: size,
                },
            })
            : element ||
                (dot ? React.createElement(DotLoading, { size: size }) : React.createElement(IconLoading$1, { style: { fontSize: size } }))));
        return (React.createElement("div", __assign$1k({ ref: ref, className: cs(prefixCls, (_a = {},
                _a[prefixCls + "-block"] = block,
                _a[prefixCls + "-loading"] = _usedLoading,
                _a[prefixCls + "-with-tip"] = tip && !children,
                _a), className), style: style }, rest), children ? (React.createElement(React.Fragment, null,
            React.createElement("div", { className: prefixCls + "-children" }, children),
            _usedLoading && (React.createElement("div", { className: prefixCls + "-loading-layer", style: { fontSize: size } },
                React.createElement("span", { className: prefixCls + "-loading-layer-inner" },
                    loadingIcon,
                    tip ? React.createElement("div", { className: prefixCls + "-tip" }, tip) : null))))) : (React.createElement(React.Fragment, null,
            loadingIcon,
            tip ? React.createElement("div", { className: prefixCls + "-tip" }, tip) : null))));
    }
    var SpinComponent = React.forwardRef(Spin);
    SpinComponent.displayName = 'Spin';
    var Spin$1 = SpinComponent;

    var __assign$1j = (undefined && undefined.__assign) || function () {
        __assign$1j = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1j.apply(this, arguments);
    };
    var __rest$z = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var defaultProps$q = {
        size: 'default',
        bordered: true,
    };
    function Card(baseProps, ref) {
        var _a, _b;
        var _c = React.useContext(ConfigContext), getPrefixCls = _c.getPrefixCls, loadingElement = _c.loadingElement, componentConfig = _c.componentConfig, rtl = _c.rtl;
        var props = useMergeProps(baseProps, defaultProps$q, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Card);
        var className = props.className, children = props.children, bordered = props.bordered, loading = props.loading, hoverable = props.hoverable, size = props.size, title = props.title, extra = props.extra, cover = props.cover, actions = props.actions, headerStyle = props.headerStyle, bodyStyle = props.bodyStyle, rest = __rest$z(props, ["className", "children", "bordered", "loading", "hoverable", "size", "title", "extra", "cover", "actions", "headerStyle", "bodyStyle"]);
        var prefixCls = getPrefixCls('card');
        var actionList = actions && actions.length ? (React.createElement("div", { className: prefixCls + "-actions" },
            React.createElement("div", { className: prefixCls + "-actions-right" }, actions.map(function (action, index) { return (React.createElement("span", { key: "action-" + index, className: prefixCls + "-actions-item" }, action)); })))) : null;
        var isContainGrid = false;
        var isContainMeta = false;
        var handledChildren = React.Children.map(children, function (element) {
            if (element && element.type) {
                if (element.type === Grid$1) {
                    isContainGrid = true;
                }
                else if (element.type === Meta$3) {
                    isContainMeta = true;
                    return React.cloneElement(element, { actionList: actionList });
                }
            }
            return element;
        });
        return (React.createElement("div", __assign$1j({}, rest, { ref: ref, className: cs(prefixCls, prefixCls + "-size-" + size, (_a = {},
                _a[prefixCls + "-loading"] = loading,
                _a[prefixCls + "-bordered"] = bordered,
                _a[prefixCls + "-hoverable"] = hoverable,
                _a[prefixCls + "-contain-grid"] = isContainGrid,
                _a[prefixCls + "-rtl"] = rtl,
                _a), className) }),
            title || extra ? (React.createElement("div", { className: cs(prefixCls + "-header", (_b = {}, _b[prefixCls + "-header-no-title"] = !title, _b)), style: headerStyle },
                title && React.createElement("div", { className: prefixCls + "-header-title" }, title),
                extra && React.createElement("div", { className: prefixCls + "-header-extra" }, extra))) : null,
            cover ? React.createElement("div", { className: prefixCls + "-cover" }, cover) : null,
            React.createElement("div", { className: prefixCls + "-body", style: bodyStyle },
                loading ? loadingElement || React.createElement(Spin$1, null) : handledChildren,
                isContainMeta ? null : actionList)));
    }
    var ForwardRefCard = React.forwardRef(Card);
    var CardComponent = ForwardRefCard;
    CardComponent.Meta = Meta$3;
    CardComponent.Grid = Grid$1;
    CardComponent.displayName = 'Card';
    var Card$1 = CardComponent;

    function ownKeys$t(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$u(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$t(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$t(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconUpComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$u(_objectSpread$u({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-up")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M39.6 30.557 24.043 15 8.487 30.557"
      }));
    }

    var IconUp = /*#__PURE__*/React.forwardRef(IconUpComponent);
    IconUp.defaultProps = {
      isIcon: true
    };
    IconUp.displayName = 'IconUp';
    var IconUp$1 = IconUp;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    var _setCacheAdd = setCacheAdd;

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    var _setCacheHas = setCacheHas;

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new _MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
    SetCache.prototype.has = _setCacheHas;

    var _SetCache = SetCache;

    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    var _arraySome = arraySome;

    /**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function cacheHas(cache, key) {
      return cache.has(key);
    }

    var _cacheHas = cacheHas;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$3 = 1,
        COMPARE_UNORDERED_FLAG$1 = 2;

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG$1) ? new _SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!_arraySome(other, function(othValue, othIndex) {
                if (!_cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    var _equalArrays = equalArrays;

    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */
    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);

      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }

    var _mapToArray = mapToArray;

    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */
    function setToArray(set) {
      var index = -1,
          result = Array(set.size);

      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }

    var _setToArray = setToArray;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$2 = 1,
        COMPARE_UNORDERED_FLAG = 2;

    /** `Object#toString` result references. */
    var boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        mapTag$1 = '[object Map]',
        numberTag = '[object Number]',
        regexpTag = '[object RegExp]',
        setTag$1 = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]';

    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag$1 = '[object DataView]';

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = _Symbol ? _Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag$1:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq_1(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag$1:
          var convert = _mapToArray;

        case setTag$1:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
          convert || (convert = _setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    var _equalByTag = equalByTag;

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    var _arrayPush = arrayPush;

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
    }

    var _baseGetAllKeys = baseGetAllKeys;

    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    var _arrayFilter = arrayFilter;

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    var stubArray_1 = stubArray;

    /** Used for built-in method references. */
    var objectProto$3 = Object.prototype;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols = Object.getOwnPropertySymbols;

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return _arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    var _getSymbols = getSymbols;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = _overArg(Object.keys, Object);

    var _nativeKeys = nativeKeys;

    /** Used for built-in method references. */
    var objectProto$2 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!_isPrototype(object)) {
        return _nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$2.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    var _baseKeys = baseKeys;

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
    }

    var keys_1 = keys;

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return _baseGetAllKeys(object, keys_1, _getSymbols);
    }

    var _getAllKeys = getAllKeys;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$1 = 1;

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1,
          objProps = _getAllKeys(object),
          objLength = objProps.length,
          othProps = _getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    var _equalObjects = equalObjects;

    /* Built-in method references that are verified to be native. */
    var DataView = _getNative(_root, 'DataView');

    var _DataView = DataView;

    /* Built-in method references that are verified to be native. */
    var Promise$1 = _getNative(_root, 'Promise');

    var _Promise = Promise$1;

    /* Built-in method references that are verified to be native. */
    var Set$1 = _getNative(_root, 'Set');

    var _Set = Set$1;

    /* Built-in method references that are verified to be native. */
    var WeakMap$1 = _getNative(_root, 'WeakMap');

    var _WeakMap = WeakMap$1;

    /** `Object#toString` result references. */
    var mapTag = '[object Map]',
        objectTag$1 = '[object Object]',
        promiseTag = '[object Promise]',
        setTag = '[object Set]',
        weakMapTag = '[object WeakMap]';

    var dataViewTag = '[object DataView]';

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = _toSource(_DataView),
        mapCtorString = _toSource(_Map),
        promiseCtorString = _toSource(_Promise),
        setCtorString = _toSource(_Set),
        weakMapCtorString = _toSource(_WeakMap);

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = _baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (_Map && getTag(new _Map) != mapTag) ||
        (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
        (_Set && getTag(new _Set) != setTag) ||
        (_WeakMap && getTag(new _WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = _baseGetTag(value),
            Ctor = result == objectTag$1 ? value.constructor : undefined,
            ctorString = Ctor ? _toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    var _getTag = getTag;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG = 1;

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        objectTag = '[object Object]';

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray_1(object),
          othIsArr = isArray_1(other),
          objTag = objIsArr ? arrayTag : _getTag(object),
          othTag = othIsArr ? arrayTag : _getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer_1(object)) {
        if (!isBuffer_1(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new _Stack);
        return (objIsArr || isTypedArray_1(object))
          ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new _Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new _Stack);
      return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    var _baseIsEqualDeep = baseIsEqualDeep;

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike_1(value) && !isObjectLike_1(other))) {
        return value !== value && other !== other;
      }
      return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    var _baseIsEqual = baseIsEqual;

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? _baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    var isEqualWith_1 = isEqualWith;

    function ownKeys$s(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$t(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$s(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$s(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconCheckComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$t(_objectSpread$t({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-check")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M41.678 11.05 19.05 33.678 6.322 20.95"
      }));
    }

    var IconCheck = /*#__PURE__*/React.forwardRef(IconCheckComponent);
    IconCheck.defaultProps = {
      isIcon: true
    };
    IconCheck.displayName = 'IconCheck';
    var IconCheck$1 = IconCheck;

    var Option$1 = function (props) {
        var prefixCls = props.prefixCls, multiple = props.multiple, option = props.option, renderOption = props.renderOption, selected = props.selected, rtl = props.rtl;
        var checkboxDisabled = option.disabled || (multiple && option.disableCheckbox);
        return (React.createElement(React.Fragment, null,
            multiple ? (React.createElement(Checkbox$2, { disabled: checkboxDisabled, checked: option._checked, indeterminate: option._halfChecked, onChange: props.onMultipleChecked, value: option.value })) : (''),
            React.createElement("div", { className: prefixCls + "-list-item-label", onClick: option.disabled ? undefined : props.onClickOption, onMouseEnter: props.onMouseEnter, onDoubleClick: checkboxDisabled ? undefined : props.onDoubleClickOption },
                renderOption ? renderOption() : option.label,
                option.isLeaf ? (selected && React.createElement(IconCheck$1, null)) : option.loading ? (React.createElement(IconLoading$1, null)) : rtl ? (React.createElement(IconLeft$1, null)) : (React.createElement(IconRight$1, null)))));
    };
    var Option$2 = Option$1;

    // 保存一个ref列表

    function useRefs(defaultValue) {
        if (defaultValue === void 0) { defaultValue = []; }
        var listRef = React.useRef(defaultValue);
        var setListRef = function (element, index) {
            if (index !== undefined) {
                listRef.current[index] = element;
            }
            else {
                listRef.current.push(element);
            }
        };
        return [listRef.current, setListRef];
    }

    var __read$Q = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$l = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };

    function useUpdate(fn, deps) {
        if (deps === void 0) { deps = []; }
        var isDidMount = React.useRef(false);
        React.useEffect(function () {
            if (isDidMount.current) {
                fn();
            }
            else {
                isDidMount.current = true;
            }
        }, __spreadArray$l([], __read$Q(deps), false));
    }

    var __assign$1i = (undefined && undefined.__assign) || function () {
        __assign$1i = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1i.apply(this, arguments);
    };
    var __read$P = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$k = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var Node$2 = /** @class */ (function () {
        function Node(data, config, parent) {
            var _this = this;
            /** 当前选项节点路径的所有节点的值 */
            this.pathValue = [];
            this.pathLabel = [];
            this.config = {};
            this._initNode = function (option, parent) {
                if (parent === void 0) { parent = null; }
                var _a = _this.config, showEmptyChildren = _a.showEmptyChildren, lazyload = _a.lazyload;
                var fieldNames = __assign$1i(__assign$1i({}, DefaultFieldNames$2), _this.config.fieldNames);
                var children = option[fieldNames.children];
                var isLeaf = Array.isArray(children)
                    ? showEmptyChildren
                        ? false
                        : children.length === 0
                    : true;
                if (lazyload) {
                    if (fieldNames.isLeaf in option) {
                        isLeaf = !!option[fieldNames.isLeaf];
                    }
                    else {
                        isLeaf = false;
                    }
                }
                var nodeValue = option[fieldNames.value];
                var nodeLabel = option[fieldNames.label];
                var newOption = __assign$1i(__assign$1i({}, option), { value: nodeValue, label: nodeLabel, isLeaf: isLeaf, loading: false, loaded: false, disabled: (parent && parent.disabled) || option[fieldNames.disabled], parent: parent, pathValue: parent ? __spreadArray$k(__spreadArray$k([], __read$P(parent.pathValue), false), [nodeValue], false) : [nodeValue], pathLabel: parent ? __spreadArray$k(__spreadArray$k([], __read$P(parent.pathLabel), false), [nodeLabel], false) : [nodeLabel], _level: parent ? parent._level + 1 : 0, _checked: false, _halfChecked: false });
                _this._data = __assign$1i(__assign$1i({}, newOption), { parent: newOption.parent && newOption.parent._data });
                Object.keys(newOption).forEach(function (key) {
                    _this[key] = newOption[key];
                });
                if (children && children.length) {
                    _this.children = children.map(function (data, index) {
                        return new Node(__assign$1i(__assign$1i({}, data), { _index: index }), _this.config, _this);
                    });
                    _this._data.children = _this.children.map(function (node) { return node._data; });
                }
            };
            /**
             * 根据this.children 计算是否当前node半选状态
             * 假设半选是 0.5，全选是1，不选是0。
             * 那么只有当前节点的所有children加起来等于children.length，才是全选，否则和大于0，就是半选。
             */
            this._isHalfChecked = function () {
                var checkedLen = _this.children.reduce(function (total, prev) {
                    var num = prev._halfChecked ? 0.5 : prev._checked ? 1 : 0;
                    return total + num;
                }, 0);
                return checkedLen !== _this.children.length && checkedLen > 0;
            };
            /**
             *
             * @param checked 选中状态
             * @param ignoreDisabled 是否忽略节点禁用设置选中状态，一般在初始化设置选中状态时传参为true
             */
            this._setNodeChildrenChecked = function (checked, ignoreDisabled) {
                if (!ignoreDisabled && _this.disabled) {
                    return;
                }
                if (_this.children && _this.children.length) {
                    _this.children.forEach(function (item) {
                        if (item.disabled) {
                            if (ignoreDisabled) {
                                item.setCheckedStateIgnoreDisabled(checked);
                            }
                        }
                        else {
                            item.setCheckedState(checked);
                        }
                    });
                    _this.updateHalfState(checked);
                }
            };
            this.getSelfChildrenValue = function () {
                var result = [];
                var join = function (pathValue, nodes) {
                    if (!nodes || !nodes.length) {
                        result.push(pathValue);
                        return;
                    }
                    (nodes || []).forEach(function (node) {
                        join(node.pathValue, node.children);
                    });
                };
                join(_this.pathValue, _this.children);
                return result;
            };
            this.updateHalfState = function (checked) {
                _this._halfChecked = _this._isHalfChecked();
                _this._checked = _this._halfChecked ? false : checked;
            };
            // 直接设置选中状态
            this.setCheckedProperty = function (checked) {
                _this._checked = checked;
                _this._halfChecked = false;
            };
            // 设置当前节点选中状态
            this.setCheckedState = function (checked) {
                var noNeedToUpdate = checked ? _this._checked : !_this._checked && !_this._halfChecked;
                if (_this.disabled || noNeedToUpdate) {
                    return;
                }
                _this.setCheckedProperty(checked);
                // 父子节点关联
                if (!_this.config.changeOnSelect) {
                    _this._setNodeChildrenChecked(checked);
                    var parent_1 = _this.parent;
                    while (parent_1 && !parent_1.disabled) {
                        // 当半选状态时，设置_checked为false。保证点击半选状态的节点时，执行选中操作。
                        parent_1.updateHalfState(checked);
                        parent_1 = parent_1.parent;
                    }
                }
            };
            // 忽略禁用设置选中状态
            this.setCheckedStateIgnoreDisabled = function (checked) {
                if (checked === Boolean(_this._checked)) {
                    return;
                }
                _this.setCheckedProperty(checked);
                if (!_this.config.changeOnSelect) {
                    _this._setNodeChildrenChecked(checked, true);
                    var parent_2 = _this.parent;
                    while (parent_2) {
                        // 当半选状态时，设置_checked为false。保证点击半选状态的节点时，执行选中操作。
                        parent_2.updateHalfState(checked);
                        parent_2 = parent_2.parent;
                    }
                }
            };
            /**
             * 遍历节点的parent，获取当前节点的路径节点。
             * node: { label: '1-1-1', parent: { label: '1-1', parent: { label: '1' }, ... }, ...}
             * @return [node.parent.parent, node.parent, node]
             * @memberof Store
             */
            this.getPathNodes = function () {
                var nodes = [_this];
                var parent = _this.parent;
                while (parent) {
                    nodes.unshift(parent);
                    parent = parent.parent;
                }
                return nodes;
            };
            this.getChildren = function () {
                return _this.children;
            };
            this.setLoading = function (loading) {
                _this.loading = loading;
                if (loading || loading === undefined) {
                    _this.loaded = false;
                }
                if (loading === false) {
                    _this.loaded = true;
                }
            };
            this.config = config || {};
            this._initNode(data, parent || null);
        }
        return Node;
    }());
    var Node$3 = Node$2;

    var __assign$1h = (undefined && undefined.__assign) || function () {
        __assign$1h = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1h.apply(this, arguments);
    };
    var Store = /** @class */ (function () {
        function Store(options, value, config) {
            var _this = this;
            this.nodes = [];
            this.flatNodes = [];
            this.config = {};
            // 初始化节点状态，附加状态信息字段： _checked,_halfChecked,parent,disabled
            this._calcNodes = function (options, parent) {
                if (!options) {
                    return [];
                }
                return options.map(function (option, index) {
                    return new Node$3(__assign$1h(__assign$1h({}, option), { _index: index }), _this.config, parent);
                });
            };
            // this.flatNodes 保存所有可能的选中项
            this._updateFlatNodes = function () {
                var leafOnly = !_this.config.changeOnSelect;
                _this.flatNodes = [];
                var traversal = function (option) {
                    if (!option)
                        return;
                    if (!leafOnly || option.isLeaf) {
                        _this.flatNodes.push(option);
                    }
                    if (isArray$1(option.children)) {
                        option.children.forEach(function (x) {
                            traversal(x);
                        });
                    }
                };
                _this.nodes.forEach(function (node) {
                    traversal(node);
                });
            };
            /**
             * values: 全部的选中值
             * 根据values更新节点状态。不包含在values的节点都设置为未选中状态
             * @memberof Store
             */
            this.setNodeCheckedByValue = function (initValues) {
                var valuesSet = transformValuesToSet(initValues);
                // 根据value设置节点初始选中状态
                _this.flatNodes.forEach(function (node) {
                    var checked = false;
                    if (_this.config.showParent) {
                        if (node.pathValue.some(function (_, index, arr) { return valueInSet(valuesSet, arr.slice(0, index + 1)); })) {
                            checked = true;
                        }
                    }
                    else if (valueInSet(valuesSet, node.pathValue)) {
                        checked = true;
                    }
                    node.setCheckedStateIgnoreDisabled(checked);
                });
            };
            /**
             * 为当前节点插入子节点。动态加载时候用到
             */
            this.appendOptionChildren = function (node, children) {
                if (children && node) {
                    // const checked = node._checked;
                    // node.setCheckedProperty(false);
                    var options = _this._calcNodes(children, node);
                    node.children = options;
                    _this._updateFlatNodes();
                    if (_this.config.changeOnSelect) ;
                    else {
                        node.setCheckedState(false);
                    }
                }
            };
            /**
             * 通过 value 查找对应的node节点。
             * value: 是路径节点的value组成的数组
             */
            this.findNodeByValue = function (value) {
                var targetNode = null;
                if (!value || !value.length) {
                    return targetNode;
                }
                _this.flatNodes.some(function (node) {
                    if (isEqualWith_1(node.pathValue, value)) {
                        targetNode = node;
                    }
                });
                return targetNode;
            };
            /**
             * 搜索所有label含有关键字的节点
             */
            this.searchNodeByLabel = function (inputStr) {
                if (!inputStr) {
                    return _this.flatNodes;
                }
                var filterOption = _this.config.filterOption;
                var filterMethod = isFunction$1(filterOption)
                    ? filterOption
                    : function (inputValue, node) {
                        return isString(node.label) && node.label.indexOf(inputValue) > -1;
                    };
                return _this.flatNodes.filter(function (item) {
                    var pathNodes = item.getPathNodes();
                    return pathNodes.some(function (node) {
                        return filterMethod(inputStr, node._data);
                    });
                });
            };
            /** 获取所有节点 */
            this.getOptions = function () {
                return _this.nodes;
            };
            /** 获取所有选中状态的节点。 aggregation: 是否聚合节点 */
            this.getCheckedNodes = function () {
                if (_this.config.showParent) {
                    return _this.getCheckedParentNodes();
                }
                return _this.flatNodes.filter(function (node) {
                    return node._checked;
                });
            };
            // 按照父节点纬度聚合当前所有选中节点。
            this.getCheckedParentNodes = function () {
                var result = new Set();
                _this.flatNodes.forEach(function (node) {
                    if (node._checked) {
                        var pathnodes = node.getPathNodes();
                        pathnodes.some(function (node) {
                            if (node._checked) {
                                if (!result.has(node)) {
                                    result.add(node);
                                }
                                return true;
                            }
                        });
                    }
                });
                return Array.from(result);
            };
            this.config = __assign$1h({}, config);
            var values = Array.isArray(value) ? value : [];
            this.nodes = this._calcNodes(options, null);
            // 根据nodes获取选中值
            this._updateFlatNodes();
            this.setNodeCheckedByValue(values);
        }
        return Store;
    }());
    var Store$1 = Store;

    var ValueSeparator = '__arco_cascader__';
    var SHOW_PARENT = 'parent';
    var SHOW_CHILD = 'child';
    var PANEL_MODE = {
        cascader: 'cascader',
        select: 'select',
    };
    function isEmptyValue$1(value) {
        return !value || (isArray$1(value) && value.length === 0);
    }
    function getConfig(props) {
        return {
            showEmptyChildren: props.showEmptyChildren,
            changeOnSelect: props.changeOnSelect,
            lazyload: !!props.loadMore,
            fieldNames: props.fieldNames,
            filterOption: props.filterOption,
            showParent: props.mode === 'multiple' && !props.changeOnSelect && props.checkedStrategy === SHOW_PARENT,
        };
    }
    function getStore(props, value) {
        var tmp = value ? (Array.isArray(value[0]) ? value : [value]) : [];
        return new Store$1(props.options || [], tmp, getConfig(props));
    }
    var transformValuesToSet = function (values) {
        var _values = values || [];
        var valuesSet = _values.reduce(function (set, next) {
            // 'next' could be a string.
            set.add([].concat(next).join(ValueSeparator));
            return set;
        }, new Set());
        return valuesSet;
    };
    var valueInSet = function (set, value) {
        var _value = value || [];
        return set.has(_value.join(ValueSeparator));
    };
    var removeValueFromSet = function (set, value) {
        var _value = value || [];
        return set.delete(_value.join(ValueSeparator));
    };
    var formatValue = function (value, isMultiple, store) {
        var _value = [];
        if (value === undefined) {
            _value = [];
        }
        else if (isMultiple) {
            _value = value;
        }
        else {
            _value = [value];
        }
        if (store && store.config.showParent) {
            var checkedNodes = store.getCheckedNodes();
            var valuesSet_1 = transformValuesToSet(checkedNodes.map(function (node) { return node.pathValue; }));
            var result_1 = [];
            var temp_1 = {};
            _value.map(function (v) {
                v.some(function (_, index, arr) {
                    var curVal = arr.slice(0, index + 1);
                    var pass = valueInSet(valuesSet_1, curVal);
                    if (pass && !temp_1[curVal.join(ValueSeparator)]) {
                        result_1.push(curVal);
                        temp_1[curVal.join(ValueSeparator)] = 1;
                    }
                    return pass;
                });
            });
            return result_1;
        }
        return _value;
    };
    // change check status to false
    var deny2Checked = function (option) {
        var deny = function (options) {
            return !Array.isArray(options)
                ? false
                : options.every(function (item) {
                    if (item._checked || item.disabled) {
                        return true;
                    }
                    return deny(item.children);
                });
        };
        return option._halfChecked && deny(option === null || option === void 0 ? void 0 : option.children);
    };
    var getMultipleCheckValue = function (propsValue, store, option, _checked) {
        var checked = _checked && deny2Checked(option) ? false : _checked;
        var beforeValueSet = store.getCheckedNodes().reduce(function (set, node) {
            set.add(node.pathValue.join(ValueSeparator));
            return set;
        }, new Set());
        option.setCheckedState(checked);
        var checkedNodes = store.getCheckedNodes();
        var currentValue = checkedNodes.map(function (node) { return node.pathValue; });
        var currentValueSet = transformValuesToSet(currentValue);
        var newValueSet = new Set();
        return propsValue
            .filter(function (v) {
            // v 不在 beforeValueSet 中，说明 v 不包含对应的option。直接返回true，不应该清除掉。
            if (!valueInSet(beforeValueSet, v) || valueInSet(currentValueSet, v)) {
                newValueSet.add(v.join(ValueSeparator));
                return true;
            }
        })
            .concat(currentValue.filter(function (v) {
            return !valueInSet(newValueSet, v);
        }));
    };

    var __assign$1g = (undefined && undefined.__assign) || function () {
        __assign$1g = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1g.apply(this, arguments);
    };
    var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$4 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __read$O = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var getLegalActiveNode = function (options) {
        for (var index = 0; index < options.length; index++) {
            if (!options[index].disabled) {
                return options[index];
            }
        }
    };
    var getBaseActiveNode = function (currentNode) {
        if (currentNode && currentNode.disabled) {
            var node = currentNode;
            while (node.parent) {
                if (node.parent.disabled) {
                    node = node.parent;
                }
                else {
                    break;
                }
            }
            return node;
        }
        return currentNode;
    };
    var getLegalIndex$1 = function (currentIndex, maxIndex) {
        if (currentIndex < 0) {
            return maxIndex;
        }
        if (currentIndex > maxIndex) {
            return 0;
        }
        return currentIndex;
    };
    var ListPanel = function (props) {
        var _a;
        var _b = __read$O(useRefs(), 2), refWrapper = _b[0], setRefWrapper = _b[1];
        var forceUpdate = useForceUpdate();
        var store = props.store, prefixCls = props.prefixCls, value = props.value, multiple = props.multiple, renderFooter = props.renderFooter, renderOption = props.renderOption, showEmptyChildren = props.showEmptyChildren, loadMore = props.loadMore, renderEmpty = props.renderEmpty, rtl = props.rtl;
        var _c = __read$O(React.useState(store.findNodeByValue(value && value[value.length - 1]) || null), 2), activeNode = _c[0], setActiveNode = _c[1];
        var options = store.getOptions();
        var triggerChange = function (newValue) {
            props.onChange && props.onChange(newValue);
        };
        var loadData = function (option) { return __awaiter$4(void 0, void 0, void 0, function () {
            var options_1, e_1;
            return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!option.isLeaf && isFunction$1(loadMore) && !option.children)) return [3 /*break*/, 5];
                        option.setLoading(true);
                        forceUpdate();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, loadMore(option.pathValue, option.pathValue.length)];
                    case 2:
                        options_1 = _a.sent();
                        store.appendOptionChildren(option, options_1);
                        store.setNodeCheckedByValue(props.value);
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        console.error(e_1);
                        return [3 /*break*/, 4];
                    case 4:
                        option.setLoading(false);
                        forceUpdate();
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        }); };
        var onClickOption = function (option, isEnterClick) {
            if (isEnterClick === void 0) { isEnterClick = true; }
            return __awaiter$4(void 0, void 0, void 0, function () {
                return __generator$4(this, function (_a) {
                    if (!option || option.disabled) {
                        return [2 /*return*/];
                    }
                    setActiveNode(option);
                    loadData(option);
                    // 在键盘上下左右键操作时,isEnterClick 是false，不触发triggerChange
                    if (!multiple && isEnterClick) {
                        if (props.changeOnSelect || option.isLeaf) {
                            triggerChange([option.pathValue]);
                        }
                    }
                    return [2 /*return*/];
                });
            });
        };
        var onMultipleChecked = function (option, checked) {
            var newValue = getMultipleCheckValue(props.value, store, option, checked);
            if (option === activeNode) {
                // setActiveNode 不会执行rerender，需要forceupdate
                forceUpdate();
            }
            setActiveNode(option);
            if (!props.changeOnSelect) {
                // 父子节点关联，选中复选框时执行loadMore，否则直接选中父节点
                loadData(option);
            }
            triggerChange(newValue);
        };
        var scrollToActiveNode = React.useCallback(function (targetNode) {
            var _a;
            if (targetNode === void 0) { targetNode = activeNode; }
            var current = targetNode;
            while (current) {
                (_a = refWrapper[current._level]) === null || _a === void 0 ? void 0 : _a.scrollTo({
                    index: current._index,
                    options: { block: 'nearest' },
                });
                current = current._level < 1 ? null : current.parent;
            }
        }, [activeNode]);
        var handleKeyDown = React.useCallback(function (e) {
            e.stopPropagation();
            // 使用keycode，避免中文输入法输入时，触发enter,space等事件。
            // p.s 中文输入时，keycode 都是229
            var keyCode = e.keyCode || e.which;
            var nextActiveNode;
            switch (keyCode) {
                case Esc.code: {
                    e.preventDefault();
                    props.onEsc();
                    break;
                }
                case ArrowDown.code:
                case ArrowUp.code: {
                    if (!activeNode) {
                        nextActiveNode = getLegalActiveNode(options);
                    }
                    else {
                        var baseActiveNode = getBaseActiveNode(activeNode);
                        var list = (baseActiveNode.parent && baseActiveNode.parent.children) || options;
                        var diff = keyCode === ArrowDown.code ? 1 : -1;
                        var nextIndex = getLegalIndex$1(baseActiveNode._index + diff, list.length - 1);
                        while (nextIndex !== baseActiveNode._index) {
                            nextActiveNode = list[nextIndex];
                            if (nextActiveNode.disabled) {
                                nextIndex = getLegalIndex$1(nextIndex + diff, list.length - 1);
                            }
                            else {
                                break;
                            }
                        }
                    }
                    scrollToActiveNode(nextActiveNode);
                    onClickOption(nextActiveNode, false);
                    e.preventDefault();
                    return false;
                }
                case ArrowRight.code: {
                    if (activeNode && !activeNode.disabled) {
                        var list = activeNode.children || [];
                        nextActiveNode = list[0] || activeNode;
                        onClickOption(nextActiveNode, false);
                    }
                    e.preventDefault();
                    return false;
                }
                case ArrowLeft.code: {
                    if (activeNode) {
                        var baseActiveNode = getBaseActiveNode(activeNode);
                        nextActiveNode = baseActiveNode.parent || baseActiveNode;
                    }
                    onClickOption(nextActiveNode, false);
                    e.preventDefault();
                    return false;
                }
                case Enter.code:
                    if (activeNode) {
                        if (multiple) {
                            onMultipleChecked(activeNode, !activeNode._checked);
                        }
                        else {
                            onClickOption(activeNode);
                        }
                    }
                    e.preventDefault();
                    return false;
            }
        }, [activeNode]);
        useUpdate(function () {
            setActiveNode(function (activeNode) {
                // store 改变时候，更新下activeNode.如果当前activeNode不存在于store里了，就设置为null
                var newActiveNode;
                if (activeNode && activeNode.pathValue && activeNode.pathValue.length) {
                    var values = activeNode.pathValue;
                    var parent_1 = { children: options };
                    values.map(function (value) {
                        var list = parent_1.children || [];
                        var item = list.find(function (x) { return x.value === value; });
                        if (item) {
                            parent_1 = item;
                            newActiveNode = item;
                        }
                    });
                }
                return newActiveNode;
            });
        }, [store]);
        React.useEffect(function () {
            if (props.popupVisible && options.length) {
                setTimeout(scrollToActiveNode);
            }
        }, [props.popupVisible]);
        React.useEffect(function () {
            var target = props.getTriggerElement();
            if (!target) {
                return;
            }
            if (props.popupVisible) {
                on(target, 'keydown', handleKeyDown);
            }
            else {
                off(target, 'keydown', handleKeyDown);
            }
            return function () {
                off(target, 'keydown', handleKeyDown);
            };
        }, [props.popupVisible, handleKeyDown]);
        var menus = (function () {
            var list = [options];
            var pathNodes = activeNode ? activeNode.getPathNodes() : [];
            pathNodes.forEach(function (option) {
                option && option.children && list.push(option.children);
            });
            return list;
        })();
        var dropdownColumnRender = isFunction$1(props.dropdownColumnRender)
            ? props.dropdownColumnRender
            : function (menu) { return menu; };
        return !menus.length || !((_a = menus[0]) === null || _a === void 0 ? void 0 : _a.length) ? (React.createElement(React.Fragment, null, renderEmpty())) : (React.createElement(TransitionGroup$1, { component: React.Fragment }, menus.map(function (list, level) {
            var _a, _b, _c;
            var footer = renderFooter ? renderFooter(level, activeNode || null) : null;
            return list.length === 0 && !showEmptyChildren ? null : (React.createElement(CSSTransition$1, { key: level, timeout: {
                    enter: 300,
                    exit: 0,
                }, classNames: "cascaderSlide", onEnter: function (e) {
                    e.style.marginLeft = "-" + e.scrollWidth + "px";
                }, onEntering: function (e) {
                    e.style.marginLeft = "0px";
                }, onEntered: function (e) {
                    e.style.marginLeft = '';
                } },
                React.createElement("div", { className: cs(prefixCls + "-list-column", (_a = {},
                        _a[prefixCls + "-list-column-virtual"] = props.virtualListProps && props.virtualListProps.threshold !== null,
                        _a[prefixCls + "-list-column-rtl"] = rtl,
                        _a)), style: __assign$1g({ zIndex: menus.length - level }, props.dropdownMenuColumnStyle) }, dropdownColumnRender(React.createElement("div", { className: cs(prefixCls + "-list-wrapper", (_b = {},
                        _b[prefixCls + "-list-wrapper-with-footer"] = footer !== null,
                        _b)) },
                    list.length === 0 ? (renderEmpty && renderEmpty(props.virtualListProps ? '100%' : 120)) : (React.createElement(VirtualList$1, __assign$1g({ needFiller: false, threshold: props.virtualListProps ? 100 : null, data: list, isStaticItemHeight: true, itemKey: "value" }, (isObject$1(props.virtualListProps) ? props.virtualListProps : {}), { wrapper: "ul", role: "menu", ref: function (node) { return setRefWrapper(node, level); }, className: cs(prefixCls + "-list", prefixCls + "-list-select", (_c = {},
                            _c[prefixCls + "-list-multiple"] = multiple,
                            _c[prefixCls + "-list-rtl"] = rtl,
                            _c)) }), function (option) {
                        var _a;
                        var isActive = false;
                        if (activeNode) {
                            isActive = activeNode.pathValue[level] === option.value;
                        }
                        return (React.createElement("li", { tabIndex: 0, role: "menuitem", "aria-haspopup": !option.isLeaf, "aria-expanded": isActive && !option.isLeaf, "aria-disabled": option.disabled, key: option.value, title: isString(option.label) ? option.label : undefined, className: cs(prefixCls + "-list-item", (_a = {},
                                _a[prefixCls + "-list-item-active"] = isActive,
                                _a[prefixCls + "-list-item-disabled"] = option.disabled,
                                _a)) },
                            React.createElement(Option$2, { prefixCls: prefixCls, rtl: rtl, multiple: multiple, option: option, 
                                // 叶子节点被选中
                                selected: !multiple &&
                                    option.isLeaf &&
                                    isEqualWith_1(props.value, option.pathValue), onMouseEnter: function () {
                                    if (option.disabled) {
                                        return;
                                    }
                                    if (props.expandTrigger === 'hover') {
                                        setActiveNode(option);
                                        !option.isLeaf && loadData(option);
                                    }
                                }, renderOption: renderOption &&
                                    (function () {
                                        return renderOption(option._data, level);
                                    }), onClickOption: function () {
                                    if (option.isLeaf && multiple && !option.disableCheckbox) {
                                        onMultipleChecked(option, !option._checked);
                                    }
                                    else {
                                        onClickOption(option);
                                    }
                                }, onMultipleChecked: function (checked) {
                                    onMultipleChecked(option, checked);
                                }, onDoubleClickOption: props.onDoubleClickOption })));
                    })),
                    footer && (React.createElement("div", { className: prefixCls + "-list-footer", onMouseDown: function (e) {
                            // 这里是为了阻止冒泡到面板节点的onMousedown事件。因为弹出层会阻止默认行为，避免选择框失去焦点
                            // 如果这里不阻止冒泡，footer里如果渲染了input标签，将无法被focus
                            e.stopPropagation();
                        } }, footer))), level))));
        })));
    };
    var CascaderPanel = ListPanel;

    var __assign$1f = (undefined && undefined.__assign) || function () {
        __assign$1f = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1f.apply(this, arguments);
    };
    var __read$N = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var getLegalIndex = function (currentIndex, maxIndex) {
        if (currentIndex < 0) {
            return maxIndex;
        }
        if (currentIndex > maxIndex) {
            return 0;
        }
        return currentIndex;
    };
    var formatLabel = function (inputValue, label, prefixCls) {
        var dom = label;
        if (isString(label)) {
            var index = label.toUpperCase().indexOf(inputValue.toUpperCase());
            if (index > -1) {
                var prefix = label.substr(0, index);
                var suffix = label.substr(index + inputValue.length);
                dom = (React.createElement(React.Fragment, null,
                    prefix,
                    React.createElement("span", { className: prefixCls + "-highlight" }, label.substr(index, inputValue.length)),
                    suffix));
            }
        }
        return dom;
    };
    var SearchPanel = function (props) {
        var _a;
        var store = props.store, prefixCls = props.prefixCls, multiple = props.multiple, onChange = props.onChange, inputValue = props.inputValue, renderEmpty = props.renderEmpty, style = props.style, defaultActiveFirstOption = props.defaultActiveFirstOption, rtl = props.rtl;
        var value = props.value || [];
        var _b = __read$N(React.useState(store.searchNodeByLabel(inputValue) || []), 2), options = _b[0], setOptions = _b[1];
        var refActiveItem = React.useRef();
        // 用来标示是否需要scrollIntoView。如果是鼠标hover，不需要滚动。
        var isKeyboardHover = React.useRef();
        var isFirstRender = useIsFirstRender();
        // 保存键盘操作的目标节点
        var _c = __read$N(React.useState(defaultActiveFirstOption ? 0 : -1), 2), currentHoverIndex = _c[0], setCurrentHoverIndex = _c[1];
        var handleSearchOptionClick = function (option, checked, e) {
            e.stopPropagation();
            if (option.disabled) {
                return;
            }
            if (multiple) {
                var checkedValues = getMultipleCheckValue(props.value, store, option, checked);
                onChange && onChange(checkedValues);
            }
            else {
                onChange && onChange([option.pathValue]);
            }
        };
        useUpdate(function () {
            setOptions(store.searchNodeByLabel(inputValue));
        }, [inputValue, store]);
        useUpdate(function () {
            setCurrentHoverIndex(function (currentIndex) {
                if (currentIndex > options.length - 1) {
                    return defaultActiveFirstOption ? 0 : -1;
                }
                return currentIndex;
            });
        }, [options]);
        React.useEffect(function () {
            var target = props.getTriggerElement();
            if (!target) {
                return;
            }
            var handleKeyDown = function (e) {
                e.stopPropagation();
                // 使用keycode，避免中文输入法输入时，触发enter,space等事件。
                // p.s 中文输入时，keycode 都是229
                var keyCode = e.keyCode || e.which;
                switch (keyCode) {
                    case Esc.code: {
                        props.onEsc();
                        return false;
                    }
                    case ArrowDown.code:
                    case ArrowUp.code: {
                        isKeyboardHover.current = true;
                        var diff = ArrowDown.code === keyCode ? 1 : -1;
                        var nextIndex = getLegalIndex(currentHoverIndex + diff, options.length - 1);
                        while (nextIndex !== currentHoverIndex) {
                            var item_1 = options[nextIndex];
                            if (item_1.disabled) {
                                nextIndex = getLegalIndex(nextIndex + diff, options.length - 1);
                            }
                            else {
                                break;
                            }
                        }
                        setCurrentHoverIndex(nextIndex);
                        return false;
                    }
                    case Enter.code:
                        var item_2 = options[currentHoverIndex];
                        if (item_2) {
                            var isChecked = value.some(function (x) {
                                return isEqualWith_1(x, item_2.pathValue);
                            });
                            handleSearchOptionClick(item_2, !isChecked, e);
                        }
                        return false;
                }
            };
            on(target, 'keydown', handleKeyDown);
            return function () {
                off(target, 'keydown', handleKeyDown);
            };
        }, [options, currentHoverIndex, value]);
        React.useEffect(function () {
            var _a;
            var target = refActiveItem.current;
            if (target && (isKeyboardHover.current || isFirstRender)) {
                scrollIntoView(target, {
                    behavior: 'instant',
                    block: 'nearest',
                    scrollMode: 'if-needed',
                    boundary: (_a = target.parentNode) === null || _a === void 0 ? void 0 : _a.parentNode,
                });
            }
        }, [currentHoverIndex, options]);
        refActiveItem.current = null;
        return options.length ? (React.createElement("div", { className: prefixCls + "-list-wrapper" },
            React.createElement(VirtualList$1, __assign$1f({ needFiller: false, wrapper: "ul", role: "menu", style: style, data: options, isStaticItemHeight: true, threshold: props.virtualListProps ? 100 : null }, (isObject$1(props.virtualListProps) ? props.virtualListProps : {}), { onMouseMove: function () {
                    isKeyboardHover.current = false;
                }, className: cs(prefixCls + "-list", prefixCls + "-list-search", (_a = {},
                    _a[prefixCls + "-list-multiple"] = multiple,
                    _a[prefixCls + "-list-rtl"] = rtl,
                    _a)) }), function (item, i) {
                var _a;
                var pathNodes = item.getPathNodes();
                var pathLabel = pathNodes.map(function (x) { return x.label; }).join(' / ');
                var label = isFunction$1(props.renderOption)
                    ? props.renderOption(inputValue, item._data)
                    : formatLabel(inputValue, pathLabel, prefixCls);
                var isChecked = item._checked;
                return (React.createElement("li", { title: isString(label) ? label : isString(pathLabel) ? pathLabel : undefined, role: "menuitem", "aria-disabled": item.disabled, ref: function (node) {
                        if (i === currentHoverIndex) {
                            refActiveItem.current = node;
                        }
                        if (isChecked && !refActiveItem.current) {
                            refActiveItem.current = node;
                        }
                    }, className: cs(prefixCls + "-list-search-item", (_a = {},
                        _a[prefixCls + "-list-search-item-active"] = isChecked,
                        _a[prefixCls + "-list-search-item-hover"] = i === currentHoverIndex,
                        _a[prefixCls + "-list-search-item-disabled"] = item.disabled,
                        _a)), onClick: function (e) {
                        handleSearchOptionClick(item, !isChecked, e);
                    }, key: i, onMouseEnter: function () {
                        if (!isKeyboardHover.current && !item.disabled) {
                            setCurrentHoverIndex(i);
                        }
                    }, onMouseLeave: function () {
                        if (!isKeyboardHover.current && !item.disabled) {
                            setCurrentHoverIndex(defaultActiveFirstOption ? 0 : -1);
                        }
                    } },
                    React.createElement("div", { className: prefixCls + "-list-item-label" }, isFunction$1(props.renderOption) ? (label) : multiple ? (React.createElement(Checkbox$2, { checked: isChecked, disabled: item.disabled }, label)) : (React.createElement(React.Fragment, null,
                        label,
                        isChecked && (React.createElement("span", { className: prefixCls + "-check-icon" },
                            React.createElement(IconCheck$1, null))))))));
            }))) : (React.createElement(React.Fragment, null, renderEmpty && renderEmpty()));
    };
    var SearchPanel$1 = SearchPanel;

    var __read$M = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$j = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    function useCurrentRef(initFunc, deps) {
        var ref = React.useRef(null);
        var forceUdpate = useForceUpdate();
        if (!ref.current) {
            ref.current = initFunc();
        }
        useUpdate(function () {
            ref.current = initFunc();
            forceUdpate();
        }, __spreadArray$j([], __read$M(deps), false));
        return ref.current;
    }

    var __assign$1e = (undefined && undefined.__assign) || function () {
        __assign$1e = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1e.apply(this, arguments);
    };
    var __read$L = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var DefaultFieldNames$2 = {
        label: 'label',
        value: 'value',
        isLeaf: 'isLeaf',
        children: 'children',
        disabled: 'disabled',
    };
    var defaultProps$p = {
        options: [],
        bordered: true,
        fieldNames: DefaultFieldNames$2,
        trigger: 'click',
        expandTrigger: 'click',
        checkedStrategy: SHOW_CHILD,
        defaultActiveFirstOption: true,
    };
    function Cascader$2(baseProps, ref) {
        var _a = React.useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, renderEmpty = _a.renderEmpty, componentConfig = _a.componentConfig, rtl = _a.rtl;
        var props = useMergeProps(baseProps, defaultProps$p, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Cascader);
        var disabled = props.disabled, renderFormat = props.renderFormat, getPopupContainer = props.getPopupContainer, children = props.children, triggerProps = props.triggerProps, expandTrigger = props.expandTrigger;
        var prefixCls = getPrefixCls('cascader');
        var isMultiple = props.mode === 'multiple';
        var timerRef = React.useRef(null);
        var forceUpdate = useForceUpdate();
        var store = useCurrentRef(function () {
            return getStore(props, formatValue('value' in props ? props.value : props.defaultValue, isMultiple));
        }, [JSON.stringify(getConfig(props)), props.options]);
        var _b = __read$L(React.useState(function () {
            return 'value' in props
                ? formatValue(props.value, isMultiple, store)
                : 'defaultValue' in props
                    ? formatValue(props.defaultValue, isMultiple, store)
                    : [];
        }), 2), stateValue = _b[0], setValue = _b[1];
        var mergeValue = 'value' in props ? formatValue(props.value, isMultiple, store) : stateValue;
        var _c = __read$L(useMergeValue(false, {
            value: props.popupVisible,
            defaultValue: props.defaultPopupVisible,
        }), 2), popupVisible = _c[0], setPopupVisible = _c[1];
        var _d = __read$L(useMergeValue('', {
            value: 'inputValue' in props ? props.inputValue || '' : undefined,
        }), 3), inputValue = _d[0], setInputValue = _d[1], stateInputValue = _d[2];
        // 触发 onInputValueChange 回调的值
        var refOnInputChangeCallbackValue = React.useRef(inputValue);
        // 触发 onInputValueChange 回调的原因
        var refOnInputChangeCallbackReason = React.useRef(null);
        var selectRef = React.useRef(null);
        // 暂存被选中的值对应的节点。仅在onSearch的时候用到
        // 避免出现下拉列表改变，之前选中的option找不到对应的节点，展示上会出问题。
        var stashNodes = React.useRef((store === null || store === void 0 ? void 0 : store.getCheckedNodes()) || []);
        // Unique ID of this instance
        var instancePopupID = useId(prefixCls + "-popup-");
        // 尝试更新 inputValue，触发 onInputValueChange
        var tryUpdateInputValue = function (value, reason) {
            if (value !== refOnInputChangeCallbackValue.current) {
                setInputValue(value);
                refOnInputChangeCallbackValue.current = value;
                refOnInputChangeCallbackReason.current = reason;
                props.onInputValueChange && props.onInputValueChange(value, reason);
            }
        };
        // 在 inputValue 变化时，适时触发 onSearch
        React.useEffect(function () {
            var reason = refOnInputChangeCallbackReason.current;
            if (stateInputValue === inputValue && (reason === 'manual' || reason === 'optionListHide')) {
                props.onSearch && props.onSearch(inputValue, reason);
            }
            if (inputValue !== refOnInputChangeCallbackValue.current) {
                refOnInputChangeCallbackValue.current = inputValue;
            }
        }, [inputValue]);
        React.useEffect(function () {
            var clearTimer = function () {
                clearTimeout(timerRef.current);
                timerRef.current = null;
            };
            if (!popupVisible && inputValue) {
                if (timerRef.current) {
                    clearTimer();
                }
                timerRef.current = setTimeout(function () {
                    tryUpdateInputValue('', 'optionListHide');
                    timerRef.current = null;
                }, 200);
            }
            return function () {
                clearTimer();
            };
        }, [popupVisible]);
        useUpdate(function () {
            if ('value' in props && props.value !== stateValue) {
                // don't to use formatValue(x, y, store)
                // we just need to get the value in a valid format, and update it to store nodes
                var newValue = formatValue(props.value, isMultiple);
                store.setNodeCheckedByValue(newValue);
                setValue(newValue);
            }
        }, [props.value, isMultiple]);
        React.useImperativeHandle(ref, function () { return selectRef.current; }, []);
        var updateStashNodes = function (nodes) {
            stashNodes.current = Array.from(new Set([].concat(nodes, stashNodes.current)));
        };
        var getSelectedOptionsByValue = function (values) {
            var result = [];
            var valuesSet = transformValuesToSet(values);
            var findValue = function (nodes) {
                nodes.some(function (node) {
                    if (valueInSet(valuesSet, node.pathValue)) {
                        result.push(node.getPathNodes().map(function (x) { return x._data; }));
                        removeValueFromSet(valuesSet, node.pathValue);
                    }
                    if (!valuesSet.size) {
                        return true;
                    }
                });
            };
            findValue(store.getCheckedNodes());
            if (valuesSet.size) {
                findValue(stashNodes.current);
            }
            return result;
        };
        var handleVisibleChange = React.useCallback(function (newVisible) {
            if (newVisible !== popupVisible) {
                props.onVisibleChange && props.onVisibleChange(newVisible);
                if (!('popupVisible' in props)) {
                    setPopupVisible(newVisible);
                }
            }
        }, [props.onVisibleChange, popupVisible]);
        var renderText = React.useCallback(function (value) {
            var _a;
            // store 中不存在时，从stashNodes.current中找一下对应节点
            var options = getSelectedOptionsByValue([value])[0] || [];
            var text;
            var valueShow = isArray$1(value) ? value.map(function (x) { return String(x); }) : [];
            if (options.length) {
                valueShow = options.map(function (x) { return x.label; });
            }
            if (isFunction$1(renderFormat)) {
                text = renderFormat(valueShow);
            }
            else if (valueShow.every(function (v) { return isString(v); })) {
                text = valueShow.join(' / ');
            }
            else {
                text = valueShow.reduce(function (total, item, index) {
                    return total.concat(index === 0 ? [item] : [' / ', item]);
                }, []);
            }
            return {
                text: text || '',
                disabled: (_a = options[options.length - 1]) === null || _a === void 0 ? void 0 : _a.disabled,
            };
        }, [store, renderFormat]);
        var handleChange = function (newValue, trigger) {
            var _a;
            if (trigger === 'panel' &&
                isObject$1(props.showSearch) &&
                !props.showSearch.retainInputValueWhileSelect &&
                isMultiple) {
                tryUpdateInputValue('', 'optionChecked');
            }
            var onChange = props.onChange, changeOnSelect = props.changeOnSelect, expandTrigger = props.expandTrigger;
            var isSame = mergeValue === newValue;
            if (isSame) {
                return;
            }
            if (!isMultiple) {
                store.setNodeCheckedByValue(newValue);
            }
            updateStashNodes(store.getCheckedNodes());
            var selectedOptions = getSelectedOptionsByValue(newValue);
            var _value = isMultiple ? newValue : newValue[0];
            var _selectedOptions = isMultiple ? selectedOptions : selectedOptions[0];
            if (!isMultiple) {
                if (inputValue) {
                    // 单选时选择搜索项，直接关闭面板
                    handleVisibleChange(false);
                }
                else if ((selectedOptions[0] && ((_a = selectedOptions[0][selectedOptions[0].length - 1]) === null || _a === void 0 ? void 0 : _a.isLeaf)) ||
                    (changeOnSelect && expandTrigger === 'hover')) {
                    handleVisibleChange(false);
                }
            }
            if ('value' in props) {
                store.setNodeCheckedByValue(mergeValue);
                // 受控触发更新，回到选中前的状态。
                forceUpdate();
            }
            else {
                setValue(newValue);
            }
            onChange &&
                onChange(_value, _selectedOptions, {
                    dropdownVisible: popupVisible,
                });
        };
        var onRemoveCheckedItem = function (item, index, e) {
            e.stopPropagation();
            if (item.disabled) {
                return;
            }
            var newValue = mergeValue.filter(function (_, i) { return i !== index; });
            store.setNodeCheckedByValue(newValue);
            handleChange(newValue);
        };
        var renderEmptyEle = function (width) {
            var wd = width || (selectRef.current && selectRef.current.getWidth());
            return (React.createElement("div", { className: prefixCls + "-list-empty", style: { width: wd } }, props.notFoundContent || renderEmpty('Cascader')));
        };
        var renderPopup = function () {
            var _a;
            // 远程搜索时是否以搜索面板展示搜索结果
            var panelMode = isObject$1(props.showSearch) ? props.showSearch.panelMode : undefined;
            var showSearchPanel = panelMode === PANEL_MODE.select
                ? true
                : panelMode === PANEL_MODE.cascader
                    ? false
                    : !isFunction$1(props.onSearch) && !!inputValue;
            var width = selectRef.current && selectRef.current.getWidth();
            var dropdownRender = isFunction$1(props.dropdownRender) ? props.dropdownRender : function (menu) { return menu; };
            return (React.createElement("div", { id: instancePopupID, className: cs(prefixCls + "-popup", props.dropdownMenuClassName, (_a = {},
                    _a[prefixCls + "-popup-trigger-hover"] = props.expandTrigger === 'hover',
                    _a)) }, dropdownRender(React.createElement("div", { className: prefixCls + "-popup-inner", onMouseDown: function (e) { return e.preventDefault(); } }, showSearchPanel ? (React.createElement(SearchPanel$1, { style: { minWidth: width }, store: store, inputValue: inputValue, renderEmpty: function () { return renderEmptyEle(width); }, multiple: isMultiple, onChange: function (value) {
                    handleChange(value, 'panel');
                }, prefixCls: prefixCls, rtl: rtl, onEsc: function () {
                    handleVisibleChange(false);
                }, renderOption: (isObject$1(props.showSearch) && props.showSearch.renderOption) || undefined, 
                // TODO 组件重构，解耦面板选择和输入框，面板可独立使用
                getTriggerElement: function () { var _a; return (_a = selectRef.current) === null || _a === void 0 ? void 0 : _a.dom; }, value: mergeValue, virtualListProps: props.virtualListProps, defaultActiveFirstOption: props.defaultActiveFirstOption })) : (React.createElement(CascaderPanel, { dropdownMenuColumnStyle: props.dropdownMenuColumnStyle, virtualListProps: props.virtualListProps, expandTrigger: expandTrigger, store: store, dropdownColumnRender: props.dropdownColumnRender, renderOption: props.renderOption, changeOnSelect: props.changeOnSelect, showEmptyChildren: props.showEmptyChildren || !!props.loadMore, multiple: isMultiple, onChange: function (value) {
                    handleChange(value, 'panel');
                }, loadMore: props.loadMore, prefixCls: prefixCls, rtl: rtl, getTriggerElement: function () { var _a; return (_a = selectRef.current) === null || _a === void 0 ? void 0 : _a.dom; }, renderEmpty: renderEmptyEle, popupVisible: popupVisible, value: mergeValue, renderFooter: props.renderFooter, onEsc: function () {
                    handleVisibleChange(false);
                }, onDoubleClickOption: function () {
                    if (props.changeOnSelect && !isMultiple) {
                        handleVisibleChange(false);
                    }
                } }))))));
        };
        var updateSelectedValues = function (value) {
            setValue(value);
        };
        var renderView = function (eleView) {
            return (React.createElement(Trigger$1, __assign$1e({ popup: renderPopup, trigger: props.trigger, disabled: disabled, getPopupContainer: getPopupContainer, position: rtl ? 'br' : 'bl', classNames: "slideDynamicOrigin", popupAlign: { bottom: 4 }, 
                // 动态加载时，unmountOnExit 默认为false。
                unmountOnExit: 'unmountOnExit' in props ? props.unmountOnExit : !isFunction$1(props.loadMore), popupVisible: popupVisible }, triggerProps, { onVisibleChange: handleVisibleChange }), eleView));
        };
        return children ? (renderView(children)) : (React.createElement(SelectView$1, __assign$1e({}, props, { ref: selectRef, ariaControls: instancePopupID, popupVisible: popupVisible, value: isMultiple ? mergeValue : mergeValue && mergeValue[0], inputValue: inputValue, rtl: rtl, 
            // other
            isEmptyValue: isEmptyValue$1(mergeValue), prefixCls: prefixCls, isMultiple: isMultiple, renderText: renderText, onRemoveCheckedItem: onRemoveCheckedItem, onSort: updateSelectedValues, renderView: renderView, onClear: function (e) {
                var _a;
                e.stopPropagation();
                if (!isMultiple) {
                    handleChange([]);
                }
                else {
                    var nodes = store.getCheckedNodes();
                    var newValue = nodes.filter(function (x) { return x.disabled; }).map(function (x) { return x.pathValue; });
                    store.setNodeCheckedByValue(newValue);
                    handleChange(newValue);
                }
                (_a = props.onClear) === null || _a === void 0 ? void 0 : _a.call(props, !!popupVisible);
            }, onKeyDown: function (e) {
                var _a;
                if (disabled) {
                    return;
                }
                e.stopPropagation();
                var keyCode = e.keyCode || e.which;
                if (keyCode === Enter.code && !popupVisible) {
                    handleVisibleChange(true);
                    e.preventDefault();
                }
                if (keyCode === Tab.code && popupVisible) {
                    handleVisibleChange(false);
                }
                (_a = props.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(props, e);
            }, 
            // onFocus={this.onFocusInput}
            onChangeInputValue: function (v) {
                tryUpdateInputValue(v, 'manual');
                // tab键 focus 到输入框，此时下拉框未显示。如果输入值，展示下拉框
                if (!popupVisible) {
                    handleVisibleChange(true);
                }
            } })));
    }
    var CascaderComponent = React.forwardRef(Cascader$2);
    CascaderComponent.displayName = 'Cascader';
    var Cascader$3 = CascaderComponent;

    var __assign$1d = (undefined && undefined.__assign) || function () {
        __assign$1d = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1d.apply(this, arguments);
    };
    var __rest$y = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function Item$2(props, ref) {
        var _a, _b, _c, _d, _e;
        var _f;
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var ctx = React.useContext(CollapseContext);
        var getEventListeners = useKeyboardEvent();
        var children = props.children, name = props.name, header = props.header, className = props.className, style = props.style, contentStyle = props.contentStyle, extra = props.extra, disabled = props.disabled, destroyOnHide = props.destroyOnHide, expandIcon = props.expandIcon, _g = props.showExpandIcon, showExpandIcon = _g === void 0 ? true : _g, rest = __rest$y(props, ["children", "name", "header", "className", "style", "contentStyle", "extra", "disabled", "destroyOnHide", "expandIcon", "showExpandIcon"]);
        var prefixCls = getPrefixCls('collapse-item');
        var isExpanded = ((_f = ctx.activeKeys) === null || _f === void 0 ? void 0 : _f.indexOf(name)) > -1;
        var icon = showExpandIcon ? ('expandIcon' in props ? expandIcon : ctx.expandIcon) : null;
        var clickEventHandler = function (e, regionLevel) {
            if (disabled)
                return;
            var triggerRegion = ctx.triggerRegion;
            var triggerRegionLevel = triggerRegion === 'icon' ? 0 : triggerRegion === 'header' ? 1 : 2;
            if (regionLevel <= triggerRegionLevel) {
                ctx.onToggle(name, e);
                e.stopPropagation();
            }
        };
        return (React.createElement("div", __assign$1d({ ref: ref }, rest, { className: cs(prefixCls, (_a = {},
                _a[prefixCls + "-active"] = isExpanded,
                _a[prefixCls + "-no-icon"] = !icon,
                _a[prefixCls + "-disabled"] = disabled,
                _a), className), style: style }),
            React.createElement("div", __assign$1d({ role: "button", "aria-disabled": disabled, "aria-expanded": isExpanded, "data-active-region": ctx.triggerRegion, tabIndex: disabled ? -1 : 0, className: cs(prefixCls + "-header", prefixCls + "-header-" + ctx.expandIconPosition, (_b = {},
                    _b[prefixCls + "-header-disabled"] = disabled,
                    _b)), onClick: function (e) { return clickEventHandler(e, 2); } }, getEventListeners({
                onPressEnter: function (e) {
                    !disabled && ctx.onToggle(name, e);
                },
            })),
                icon && (React.createElement(IconHover, { prefix: prefixCls, disabled: disabled, className: cs((_c = {},
                        _c[prefixCls + "-icon-hover-right"] = ctx.expandIconPosition === 'right',
                        _c[prefixCls + "-header-icon-right"] = ctx.expandIconPosition === 'right',
                        _c)), onClick: function (e) { return clickEventHandler(e, 0); } },
                    React.createElement("span", { className: cs(prefixCls + "-header-icon", (_d = {},
                            _d[prefixCls + "-header-icon-down"] = isExpanded,
                            _d)) }, icon))),
                React.createElement("div", { className: prefixCls + "-header-title", onClick: function (e) { return clickEventHandler(e, 1); } }, header),
                extra && (React.createElement("div", { className: prefixCls + "-header-extra", onClick: function (e) {
                        e.stopPropagation();
                    } }, extra))),
            React.createElement(Transition$1, { in: isExpanded, addEndListener: function (node, done) {
                    node.addEventListener('transitionend', done, false);
                }, mountOnEnter: 'destroyOnHide' in props ? destroyOnHide : ctx.destroyOnHide || ctx.lazyload, unmountOnExit: 'destroyOnHide' in props ? destroyOnHide : ctx.destroyOnHide, onEnter: function (e) {
                    e.style.height = 0;
                    e.style.display = 'block';
                }, onEntering: function (e) {
                    e.style.height = e.scrollHeight + "px";
                }, onEntered: function (e) {
                    e.style.height = 'auto';
                }, onExit: function (e) {
                    e.style.display = 'block';
                    e.style.height = e.offsetHeight + "px";
                    // have to trigger reflow to get animation effect on exit
                    e.offsetHeight; // eslint-disable-line
                }, onExiting: function (e) {
                    e.style.height = 0;
                }, onExited: function (e) {
                    e.style.display = 'none';
                    e.style.height = 'auto';
                } },
                React.createElement("div", { role: "region", className: cs(prefixCls + "-content", (_e = {},
                        _e[prefixCls + "-content-expanded"] = isExpanded,
                        _e)) },
                    React.createElement("div", { style: contentStyle, className: prefixCls + "-content-box" }, children)))));
    }
    var ItemRef = React.forwardRef(Item$2);
    ItemRef.displayName = 'CollapseItem';
    var CollapseItem = ItemRef;

    var __assign$1c = (undefined && undefined.__assign) || function () {
        __assign$1c = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1c.apply(this, arguments);
    };
    var __rest$x = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$K = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$i = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var getActiveKeys = function (keys, accordion) {
        var res = [].concat(keys);
        if (accordion) {
            return res.slice(0, 1);
        }
        return res;
    };
    var defaultProps$o = {
        bordered: true,
        lazyload: true,
        expandIconPosition: 'left',
    };
    var CollapseContext = React.createContext({
        expandIconPosition: 'left',
        expandIcon: React.createElement(IconCaretRight$1, null),
        activeKeys: [],
        onToggle: function () { },
    });
    function Collapse(baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$o, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Collapse);
        var _c = __read$K(useMergeValue([], {
            defaultValue: 'defaultActiveKey' in props
                ? getActiveKeys(props.defaultActiveKey, props.accordion)
                : undefined,
            value: 'activeKey' in props ? getActiveKeys(props.activeKey, props.accordion) : undefined,
        }), 2), activeKeys = _c[0], setActiveKeys = _c[1];
        var children = props.children, className = props.className, style = props.style, bordered = props.bordered, lazyload = props.lazyload, expandIcon = props.expandIcon, expandIconPosition = props.expandIconPosition, destroyOnHide = props.destroyOnHide, accordion = props.accordion, triggerRegion = props.triggerRegion, onChange = props.onChange, rest = __rest$x(props, ["children", "className", "style", "bordered", "lazyload", "expandIcon", "expandIconPosition", "destroyOnHide", "accordion", "triggerRegion", "onChange"]);
        var prefixCls = getPrefixCls('collapse');
        var onItemClick = function (key, e) {
            var newActiveKeys = __spreadArray$i([], __read$K((activeKeys || [])), false);
            var index = activeKeys === null || activeKeys === void 0 ? void 0 : activeKeys.indexOf(key);
            if (index > -1) {
                newActiveKeys.splice(index, 1);
            }
            else if (accordion) {
                newActiveKeys = [key];
            }
            else {
                newActiveKeys.push(key);
            }
            if (!('activeKey' in props)) {
                setActiveKeys(newActiveKeys);
            }
            isFunction$1(onChange) && onChange(key, newActiveKeys, e);
        };
        return (React.createElement(CollapseContext.Provider, { value: {
                activeKeys: activeKeys,
                triggerRegion: triggerRegion,
                lazyload: lazyload,
                destroyOnHide: destroyOnHide,
                expandIconPosition: expandIconPosition,
                onToggle: onItemClick,
                expandIcon: 'expandIcon' in props ? (expandIcon) : expandIconPosition === 'right' ? (React.createElement(IconCaretLeft$1, null)) : (React.createElement(IconCaretRight$1, null)),
            } },
            React.createElement("div", __assign$1c({ ref: ref }, omit$1(rest, ['activeKey', 'defaultActiveKey']), { className: cs(prefixCls, prefixCls + "-" + (bordered ? 'border' : 'borderless'), (_a = {}, _a[prefixCls + "-rtl"] = rtl, _a), className), style: style }), children)));
    }
    var ForwardRefCollapse = React.forwardRef(Collapse);
    var CollapseComponent = ForwardRefCollapse;
    CollapseComponent.displayName = 'Collapse';
    CollapseComponent.Item = CollapseItem;
    var Collapse$1 = CollapseComponent;

    var __assign$1b = (undefined && undefined.__assign) || function () {
        __assign$1b = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1b.apply(this, arguments);
    };
    var __rest$w = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function DateInput$1(_a, ref) {
        var _b, _c;
        var style = _a.style, className = _a.className, propPrefixCls = _a.prefixCls, allowClear = _a.allowClear, error = _a.error, disabled = _a.disabled, placeholder = _a.placeholder, format = _a.format, propSize = _a.size, onClear = _a.onClear, editable = _a.editable, value = _a.value, inputValue = _a.inputValue, onPressEnter = _a.onPressEnter, suffixIcon = _a.suffixIcon, prefix = _a.prefix, onChange = _a.onChange, popupVisible = _a.popupVisible, isPlaceholder = _a.isPlaceholder, rest = __rest$w(_a, ["style", "className", "prefixCls", "allowClear", "error", "disabled", "placeholder", "format", "size", "onClear", "editable", "value", "inputValue", "onPressEnter", "suffixIcon", "prefix", "onChange", "popupVisible", "isPlaceholder"]);
        var _d = React.useContext(ConfigContext), getPrefixCls = _d.getPrefixCls, ctxSize = _d.size, locale = _d.locale, rtl = _d.rtl;
        var input = React.useRef(null);
        var size = propSize || ctxSize;
        React.useImperativeHandle(ref, function () { return ({
            focus: function () {
                input.current && input.current.focus && input.current.focus();
            },
            blur: function () {
                input.current && input.current.blur && input.current.blur();
            },
        }); });
        function onKeyDown(e) {
            var keyCode = e.keyCode || e.which;
            if (keyCode === Enter.code) {
                onPressEnter && onPressEnter();
            }
        }
        var showValue = '';
        if (inputValue !== undefined) {
            showValue = inputValue;
        }
        else if (value && !isArray$1(value)) {
            showValue =
                typeof format === 'function'
                    ? format(value)
                    : value.locale(locale.dayjsLocale).format(format);
        }
        var readOnlyProps = editable ? {} : { readOnly: true };
        var prefixCls = propPrefixCls || getPrefixCls('picker');
        var classNames = cs(prefixCls, prefixCls + "-size-" + size, (_b = {},
            _b[prefixCls + "-focused"] = !!popupVisible,
            _b[prefixCls + "-disabled"] = disabled,
            _b[prefixCls + "-has-prefix"] = prefix,
            _b[prefixCls + "-error"] = error,
            _b[prefixCls + "-rtl"] = rtl,
            _b), className);
        return (React.createElement("div", __assign$1b({ style: style, className: classNames }, omit$1(rest, ['onChange', 'onPressEnter'])),
            prefix && React.createElement("div", { className: prefixCls + "-prefix" }, prefix),
            React.createElement("div", { className: cs(prefixCls + "-input", (_c = {}, _c[prefixCls + "-input-placeholder"] = isPlaceholder, _c)) },
                React.createElement("input", __assign$1b({ ref: input, disabled: disabled, placeholder: placeholder, className: prefixCls + "-start-time", value: showValue, onKeyDown: onKeyDown, onChange: onChange }, readOnlyProps))),
            React.createElement("div", { className: prefixCls + "-suffix" },
                allowClear && showValue && (React.createElement(IconHover, { prefix: prefixCls, onClick: onClear, className: prefixCls + "-clear-icon" },
                    React.createElement(IconClose$1, null))),
                React.createElement("span", { className: prefixCls + "-suffix-icon" }, suffixIcon))));
    }
    var Input$2 = React.forwardRef(DateInput$1);

    function ownKeys$r(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$s(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$r(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$r(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconCalendarComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$s(_objectSpread$s({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-calendar")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M7 22h34M14 5v8m20-8v8M8 41h32a1 1 0 0 0 1-1V10a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1Z"
      }));
    }

    var IconCalendar = /*#__PURE__*/React.forwardRef(IconCalendarComponent);
    IconCalendar.defaultProps = {
      isIcon: true
    };
    IconCalendar.displayName = 'IconCalendar';
    var IconCalendar$1 = IconCalendar;

    function ownKeys$q(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$r(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$q(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$q(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconCalendarClockComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$r(_objectSpread$r({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-calendar-clock")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M7 22h34V10a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v30a1 1 0 0 0 1 1h18M34 5v8M14 5v8"
      }), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        fillRule: "evenodd",
        stroke: "none",
        d: "M36 44a9 9 0 1 0 0-18 9 9 0 0 0 0 18Zm1.5-9.75V29h-3v8.25H42v-3h-4.5Z",
        clipRule: "evenodd"
      }));
    }

    var IconCalendarClock = /*#__PURE__*/React.forwardRef(IconCalendarClockComponent);
    IconCalendarClock.defaultProps = {
      isIcon: true
    };
    IconCalendarClock.displayName = 'IconCalendarClock';
    var IconCalendarClock$1 = IconCalendarClock;

    function Shortcuts(props, ref) {
        var prefixCls = props.prefixCls, _a = props.shortcuts, shortcuts = _a === void 0 ? [] : _a, onSelectNow = props.onSelectNow, nowText = props.nowText, showNowBtn = props.showNowBtn, showTime = props.showTime, onMouseEnterShortcut = props.onMouseEnterShortcut, onMouseLeaveShortcut = props.onMouseLeaveShortcut;
        function onMouseEnter(shortcut) {
            onMouseEnterShortcut && onMouseEnterShortcut(shortcut);
        }
        function onMouseLeave(shortcut) {
            onMouseLeaveShortcut && onMouseLeaveShortcut(shortcut);
        }
        function onClick(shortcut, e) {
            var onSelectShortcut = props.onSelectShortcut;
            onSelectShortcut && onSelectShortcut(shortcut, e);
        }
        var hasShortcuts = isArray$1(shortcuts) && shortcuts.length > 0;
        var shouldShowNowBtn = showNowBtn && showTime && !hasShortcuts;
        return (React.createElement("div", { ref: ref, className: prefixCls + "-shortcuts" },
            shouldShowNowBtn && (React.createElement(Button$3, { size: "mini", onClick: onSelectNow }, nowText)),
            hasShortcuts &&
                shortcuts.map(function (shortcut, index) {
                    return (React.createElement(Button$3, { key: index, size: "mini", onMouseEnter: function () { return onMouseEnter(shortcut); }, onMouseLeave: function () { return onMouseLeave(shortcut); }, onClick: function (e) { return onClick(shortcut, e); } }, shortcut.text));
                })));
    }
    var Shortcuts$1 = React.forwardRef(Shortcuts);

    function ownKeys$p(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$q(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$p(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$p(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconLinkComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$q(_objectSpread$q({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-link")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "m14.1 25.414-4.95 4.95a6 6 0 0 0 8.486 8.485l8.485-8.485a6 6 0 0 0 0-8.485m7.779.707 4.95-4.95a6 6 0 1 0-8.486-8.485l-8.485 8.485a6 6 0 0 0 0 8.485"
      }));
    }

    var IconLink = /*#__PURE__*/React.forwardRef(IconLinkComponent);
    IconLink.defaultProps = {
      isIcon: true
    };
    IconLink.displayName = 'IconLink';
    var IconLink$1 = IconLink;

    var __assign$1a = (undefined && undefined.__assign) || function () {
        __assign$1a = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1a.apply(this, arguments);
    };
    var __rest$v = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var defaultProps$n = {
        hoverable: true,
    };
    function Link(baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$n, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Link);
        var className = props.className, style = props.style, children = props.children, icon = props.icon, status = props.status, disabled = props.disabled, hoverable = props.hoverable, rest = __rest$v(props, ["className", "style", "children", "icon", "status", "disabled", "hoverable"]);
        var getKeyboardEvents = useKeyboardEvent({ onKeyDown: props.onKeyDown });
        var prefixCls = getPrefixCls('link');
        var TagWrapper = 'href' in props ? 'a' : 'span';
        var handleClick = function (e) {
            if (disabled) {
                e.preventDefault();
                e.stopPropagation();
            }
            else {
                props.onClick && props.onClick(e);
            }
        };
        return (React.createElement(TagWrapper, __assign$1a({ className: cs(prefixCls, (_a = {},
                _a[prefixCls + "-disabled"] = disabled,
                _a[prefixCls + "-is-" + status] = status,
                _a[prefixCls + "-with-icon"] = icon,
                _a[prefixCls + "-hoverless"] = !hoverable,
                _a[prefixCls + "-rtl"] = rtl,
                _a), className), ref: ref, tabIndex: disabled ? -1 : undefined }, rest, { style: style, onClick: handleClick }, getKeyboardEvents({
            onPressEnter: handleClick,
        })),
            icon ? (React.createElement("span", { className: prefixCls + "-icon" }, icon === true ? React.createElement(IconLink$1, null) : icon)) : null,
            children));
    }
    var LinkRef = React.forwardRef(Link);
    LinkRef.displayName = 'Link';
    var Link$1 = LinkRef;

    function Footer(props) {
        var showTime = props.showTime, prefixCls = props.prefixCls, DATEPICKER_LOCALE = props.DATEPICKER_LOCALE, disabled = props.disabled, onClickConfirmBtn = props.onClickConfirmBtn, onClickSelectTimeBtn = props.onClickSelectTimeBtn, isTimePanel = props.isTimePanel, onSelectNow = props.onSelectNow, showNowBtn = props.showNowBtn, shortcuts = props.shortcuts, onMouseEnterShortcut = props.onMouseEnterShortcut, onMouseLeaveShortcut = props.onMouseLeaveShortcut, onSelectShortcut = props.onSelectShortcut, extra = props.extra, mode = props.mode, shortcutsPlacementLeft = props.shortcutsPlacementLeft;
        var hasShortcuts = isArray$1(shortcuts) && shortcuts.length > 0;
        var shouldShowNowBtn = showNowBtn && showTime && !hasShortcuts;
        var shouldShouldShortcuts = shouldShowNowBtn || (hasShortcuts && !shortcutsPlacementLeft);
        return (React.createElement("div", { className: prefixCls + "-footer" },
            extra && React.createElement("div", { className: prefixCls + "-footer-extra-wrapper" }, extra),
            !showTime && showNowBtn && mode === 'date' && (React.createElement("div", { className: prefixCls + "-footer-now-wrapper" },
                React.createElement(Link$1, { onClick: onSelectNow }, DATEPICKER_LOCALE.today))),
            shouldShouldShortcuts || showTime ? (React.createElement("div", { className: prefixCls + "-footer-btn-wrapper" },
                !shortcutsPlacementLeft ? (React.createElement(Shortcuts$1, { shortcuts: shortcuts, prefixCls: prefixCls, onSelectNow: onSelectNow, nowText: DATEPICKER_LOCALE.now, showNowBtn: showNowBtn, onMouseEnterShortcut: onMouseEnterShortcut, onMouseLeaveShortcut: onMouseLeaveShortcut, onSelectShortcut: onSelectShortcut, showTime: showTime })) : (React.createElement("div", null)),
                showTime && (React.createElement(React.Fragment, null,
                    React.createElement(Button$3, { type: "text", size: "mini", onClick: onClickSelectTimeBtn, className: isTimePanel ? prefixCls + "-btn-select-date" : prefixCls + "-btn-select-time" }, isTimePanel ? DATEPICKER_LOCALE.selectDate : DATEPICKER_LOCALE.selectTime),
                    React.createElement(Button$3, { className: prefixCls + "-btn-confirm", type: "primary", size: "mini", disabled: disabled, onClick: onClickConfirmBtn }, DATEPICKER_LOCALE.ok))))) : null));
    }

    var PickerContext$1 = React.createContext({});

    function getAvailableDayjsLength(value) {
        if (!value) {
            return 0;
        }
        if (isArray$1(value)) {
            if (isDayjs(value[0]) && isDayjs(value[1])) {
                return 2;
            }
            if (!isDayjs(value[0]) && !isDayjs(value[1])) {
                return 0;
            }
            return 1;
        }
        return 0;
    }
    function isDisabledDate(date, disabledDate, mode, originMode) {
        if (typeof disabledDate !== 'function') {
            return false;
        }
        if (!originMode || originMode === mode) {
            return disabledDate(date);
        }
        return disabledDate(date.startOf(mode)) && disabledDate(date.endOf(mode));
    }
    function getDefaultWeekStart(dayjsLocale) {
        var _a, _b;
        return ((_b = (_a = dayjs_min.Ls) === null || _a === void 0 ? void 0 : _a[dayjsLocale]) === null || _b === void 0 ? void 0 : _b.weekStart) || 0;
    }
    function getLocaleDayjsValue(date, dayjsLocale) {
        return date ? date.locale(dayjsLocale) : date;
    }

    var __assign$19 = (undefined && undefined.__assign) || function () {
        __assign$19 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$19.apply(this, arguments);
    };
    var __read$J = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    function getFormat$2(props) {
        var format = props.format, picker = props.picker, showTime = props.showTime;
        var valueFormat;
        var mode = props.mode || picker.props.pickerType;
        switch (mode) {
            case 'date':
                valueFormat = showTime ? 'YYYY-MM-DD HH:mm:ss' : 'YYYY-MM-DD';
                break;
            case 'month':
                valueFormat = 'YYYY-MM';
                break;
            case 'year':
                valueFormat = 'YYYY';
                break;
            case 'week':
                valueFormat = 'gggg-wo';
                break;
            case 'quarter':
                valueFormat = 'YYYY-[Q]Q';
                break;
            default:
                valueFormat = 'YYYY-MM-DD';
        }
        if (format) {
            valueFormat = format;
        }
        return valueFormat;
    }
    var defaultProps$m = {
        allowClear: true,
        unmountOnExit: true,
        position: 'bl',
        editable: true,
        showNowBtn: true,
    };
    var Picker$3 = function (baseProps) {
        var _a = React.useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, locale = _a.locale, ctxSize = _a.size, componentConfig = _a.componentConfig, rtl = _a.rtl;
        if (rtl) {
            defaultProps$m.position = 'br';
        }
        var props = useMergeProps(baseProps, defaultProps$m, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.DatePicker);
        var allowClear = props.allowClear, className = props.className, style = props.style, placeholder = props.placeholder, getPopupContainer = props.getPopupContainer, disabled = props.disabled, position = props.position, error = props.error, unmountOnExit = props.unmountOnExit, editable = props.editable, triggerProps = props.triggerProps, picker = props.picker, shortcuts = props.shortcuts, onSelect = props.onSelect, onVisibleChange = props.onVisibleChange, propsValue = props.value, onChange = props.onChange, icons = props.icons, disabledDate = props.disabledDate, showTime = props.showTime, showNowBtn = props.showNowBtn, onSelectShortcut = props.onSelectShortcut, extra = props.extra, shortcutsPlacementLeft = props.shortcutsPlacementLeft, onOk = props.onOk, defaultPickerValue = props.defaultPickerValue, pickerValue = props.pickerValue, onPickerValueChange = props.onPickerValueChange, triggerElement = props.triggerElement, utcOffset = props.utcOffset, timezone = props.timezone, panelRender = props.panelRender;
        var prefixCls = getPrefixCls('picker');
        var DATEPICKER_LOCALE = locale.DatePicker;
        var weekStart = isUndefined(props.dayStartOfWeek)
            ? getDefaultWeekStart(locale.dayjsLocale)
            : props.dayStartOfWeek;
        // picker.props.pickerType: Compatible with defaultProps
        var mode = props.mode || picker.props.pickerType;
        var refInput = React.useRef(null);
        var refPanel = React.useRef(null);
        var refShortcuts = React.useRef(null);
        var realFormat = getFormat$2(props);
        var format = realFormat;
        if (typeof format === 'function') {
            format = showTime ? 'YYYY-MM-DD HH:mm:ss' : 'YYYY-MM-DD';
        }
        function getDefaultValue() {
            var value;
            if (props.value) {
                value = getDayjsValue(props.value, format, utcOffset, timezone);
            }
            else {
                value = getDayjsValue(props.defaultValue, format, utcOffset, timezone);
            }
            return value;
        }
        var _b = __read$J(React.useState(getDefaultValue()), 2), value = _b[0], setValue = _b[1];
        var _c = __read$J(React.useState(props.popupVisible), 2), popupVisible = _c[0], setPopupVisible = _c[1];
        var _d = __read$J(React.useState(false), 2), isTimePanel = _d[0], setIsTimePanel = _d[1];
        var _e = __read$J(React.useState(), 2), hoverPlaceholderValue = _e[0], setHoverPlaceholderValue = _e[1];
        var mergedPopupVisible = 'popupVisible' in props ? props.popupVisible : popupVisible;
        var mergedValue = 'value' in props ? getDayjsValue(propsValue, format, utcOffset, timezone) : value;
        var defaultPageShowDate = mergedValue || getDayjsValue(defaultPickerValue, format) || getNow();
        var _f = __read$J(React.useState(), 2), inputValue = _f[0], setInputValue = _f[1];
        var _g = __read$J(React.useState(), 2), valueShow = _g[0], setValueShow = _g[1];
        var _h = __read$J(React.useState(), 2), shortcutValue = _h[0], setShortcutValue = _h[1];
        var _j = __read$J(React.useState(defaultPageShowDate), 2), pageShowDate = _j[0], setPageShowDate = _j[1];
        var mergedPageShowDate = getDayjsValue(pickerValue, format) || pageShowDate;
        var panelValue = shortcutValue || valueShow || mergedValue;
        var _k = __read$J(React.useState(mode), 2), panelMode = _k[0], setPanelMode = _k[1];
        var defaultTimeValue = (isObject$1(showTime) &&
            getDayjsValue(showTime.defaultValue, showTime.format || 'HH:mm:ss', utcOffset, timezone)) ||
            getNow(utcOffset, timezone);
        var timeValue = panelValue || defaultTimeValue;
        function focusInput() {
            refInput.current && refInput.current.blur && refInput.current.focus();
        }
        function blurInput() {
            refInput.current && refInput.current.blur && refInput.current.blur();
        }
        var previousUtcOffset = usePrevious(utcOffset);
        var previousTimezone = usePrevious(timezone);
        // when timezone or utcOffset change changed
        useUpdate(function () {
            if (value && (previousUtcOffset !== utcOffset || timezone !== previousTimezone)) {
                var localValue = toLocal(value, previousUtcOffset, previousTimezone);
                setValue(toTimezone(localValue, utcOffset, timezone));
            }
        }, [utcOffset, previousUtcOffset, timezone, previousTimezone]);
        React.useEffect(function () {
            setInputValue(undefined);
            setHoverPlaceholderValue(undefined);
            if (mergedPopupVisible) {
                setPageShowDate(defaultPageShowDate);
                if (shortcutsPlacementLeft) {
                    refShortcuts.current.style.maxHeight = refPanel.current.clientHeight + "px";
                }
            }
            else {
                setValueShow(undefined);
                setShortcutValue(undefined);
                setTimeout(function () {
                    setIsTimePanel(false);
                    setPanelMode(mode);
                    blurInput();
                }, 100);
            }
        }, [mergedPopupVisible]);
        function visibleChange(visible) {
            if (visible) {
                setOpen(visible, function () {
                    focusInput();
                });
            }
            else {
                setOpen(false);
            }
        }
        function handlePickerValueChange(v) {
            onPickerValueChange && onPickerValueChange(v.format(format), v);
        }
        function setOpen(visible, callback) {
            setPopupVisible(visible);
            onVisibleChange && onVisibleChange(visible);
            callback && callback();
        }
        function onClear(e) {
            e.stopPropagation();
            setValue(undefined);
            setValueShow(undefined);
            onHandleChange(undefined);
            props.onClear && props.onClear();
        }
        function onClickConfirmBtn() {
            var pv = getLocaleDayjsValue(panelValue, locale.dayjsLocale);
            onConfirmValue();
            onOk && onOk(pv && pv.format(format), pv);
        }
        function onConfirmValue() {
            setValue(panelValue);
            onHandleChange(panelValue);
            setOpen(false);
        }
        function onHandleSelect(_, date, now) {
            setInputValue(undefined);
            setHoverPlaceholderValue(undefined);
            if (showTime) {
                var newTime = now ? date : getValueWithTime(date, timeValue);
                setValueShow(newTime);
                setPageShowDate(newTime);
                var localTime = getLocaleDayjsValue(toLocal(newTime, utcOffset, timezone), locale.dayjsLocale);
                onSelect && onSelect(localTime.format(format), localTime);
            }
            else {
                var localTime = getLocaleDayjsValue(toLocal(date, utcOffset, timezone).locale(locale.dayjsLocale), locale.dayjsLocale);
                onSelect && onSelect(localTime ? localTime.format(format) : undefined, localTime);
                setValue(date);
                onHandleChange(date);
                setOpen(false);
            }
        }
        function onHandleChange(newValue) {
            if (isDayjsChange(newValue, mergedValue)) {
                var localValue = getLocaleDayjsValue(toLocal(newValue, utcOffset, timezone), locale.dayjsLocale);
                onChange && onChange(localValue ? localValue.format(format) : undefined, localValue);
            }
        }
        function onTimePickerSelect(_, time) {
            var _valueShow = panelValue || getNow(utcOffset, timezone);
            var newValueShow = getValueWithTime(_valueShow, time);
            setValueShow(newValueShow);
            var localNewValueShow = getLocaleDayjsValue(toLocal(newValueShow, utcOffset, timezone), locale.dayjsLocale);
            onSelect && onSelect(localNewValueShow.format(format), localNewValueShow);
        }
        function isValid(time) {
            return (typeof time === 'string' &&
                dayjs(time, format).format(format) === time &&
                (typeof disabledDate === 'function' ? !disabledDate(dayjs(time, format)) : true));
        }
        function onChangeInput(e) {
            var niv = e.target.value;
            setInputValue(niv);
            if (!mergedPopupVisible) {
                setOpen(true);
            }
            if (isValid(niv)) {
                var newValue = getDayjsValue(niv, format, utcOffset, timezone);
                setValueShow(newValue);
                setPageShowDate(newValue);
                setInputValue(undefined);
            }
        }
        function onPressEnter() {
            if (panelValue) {
                onConfirmValue();
                blurInput();
            }
            else if (mergedPopupVisible) {
                setOpen(false);
            }
        }
        function changePageShowDate(type, unit, num) {
            if (num === void 0) { num = 1; }
            var newPageShowDate;
            if (type === 'prev') {
                newPageShowDate = methods.subtract(mergedPageShowDate, num, unit);
            }
            if (type === 'next') {
                newPageShowDate = methods.add(mergedPageShowDate, num, unit);
            }
            handlePickerValueChange(newPageShowDate);
            setPageShowDate(newPageShowDate);
        }
        function getHeaderOperations(pickMode) {
            if (pickMode === void 0) { pickMode = mode; }
            if (pickMode === 'date' || pickMode === 'week') {
                return {
                    onPrev: function () { return changePageShowDate('prev', 'month'); },
                    onNext: function () { return changePageShowDate('next', 'month'); },
                    onSuperPrev: function () { return changePageShowDate('prev', 'year'); },
                    onSuperNext: function () { return changePageShowDate('next', 'year'); },
                };
            }
            if (pickMode === 'month' || pickMode === 'quarter') {
                return {
                    onSuperPrev: function () { return changePageShowDate('prev', 'year'); },
                    onSuperNext: function () { return changePageShowDate('next', 'year'); },
                };
            }
            if (pickMode === 'year') {
                return {
                    onSuperPrev: function () { return changePageShowDate('prev', 'year', 10); },
                    onSuperNext: function () { return changePageShowDate('next', 'year', 10); },
                };
            }
        }
        function onSelectNow() {
            var now = getLocaleDayjsValue(getNow(utcOffset, timezone), locale.dayjsLocale);
            handlePickerValueChange(now);
            onHandleSelect(now.format(format), now, true);
        }
        function onMouseEnterCell(value, disabled) {
            if (!disabled) {
                var placeHolderValue = showTime ? getValueWithTime(value, timeValue) : value;
                setHoverPlaceholderValue(typeof realFormat === 'function'
                    ? realFormat(value)
                    : placeHolderValue.locale(locale.dayjsLocale).format(format));
            }
        }
        function onMouseLeaveCell() {
            setHoverPlaceholderValue(undefined);
        }
        function onMouseEnterShortcut(shortcut) {
            if (typeof shortcut.value === 'function' && isDayjs(shortcut.value())) {
                var sv = getDayjsValue(shortcut.value(), format, utcOffset, timezone);
                setPageShowDate(sv);
                handlePickerValueChange(sv);
                setShortcutValue(sv);
            }
        }
        function onMouseLeaveShortcut() {
            var newValue = valueShow || mergedValue || getNow(utcOffset, timezone);
            setShortcutValue(undefined);
            setPageShowDate(newValue);
            handlePickerValueChange(newValue);
        }
        function onHandleSelectShortcut(shortcut) {
            onSelectShortcut && onSelectShortcut(shortcut);
            if (typeof shortcut.value === 'function' && isDayjs(shortcut.value())) {
                var time = getDayjsValue(shortcut.value(), format, utcOffset, timezone);
                setValue(time);
                onHandleChange(time);
                setOpen(false);
            }
        }
        function onClickSelectTimeBtn() {
            setIsTimePanel(!isTimePanel);
        }
        function renderPopup(panelOnly) {
            var _a;
            var classNames = cs(prefixCls + "-container", (_a = {},
                _a[prefixCls + "-panel-only"] = panelOnly,
                _a[prefixCls + "-container-shortcuts-placement-left"] = isArray$1(shortcuts) && shortcutsPlacementLeft,
                _a[prefixCls + "-container-rtl"] = rtl,
                _a), panelOnly ? className : '');
            var shortcutsProps = {
                prefixCls: prefixCls,
                showTime: showTime,
                shortcuts: shortcuts,
                onSelectNow: onSelectNow,
                showNowBtn: showNowBtn,
                onMouseEnterShortcut: onMouseEnterShortcut,
                onMouseLeaveShortcut: onMouseLeaveShortcut,
                onSelectShortcut: onHandleSelectShortcut,
            };
            var shouldShowFooter = (showTime && panelMode === 'date') ||
                extra ||
                (isArray$1(shortcuts) && shortcuts.length && !shortcutsPlacementLeft) ||
                (!showTime && panelMode === 'date' && showNowBtn);
            var content = (React.createElement(React.Fragment, null,
                React.cloneElement(picker, __assign$19(__assign$19(__assign$19({}, omit$1(props, ['style'])), getHeaderOperations()), { getHeaderOperations: getHeaderOperations, onSelect: onHandleSelect, onTimePickerSelect: onTimePickerSelect, onSelectNow: onSelectNow, popupVisible: mergedPopupVisible, format: format, value: panelValue, pageShowDate: mergedPageShowDate, localeName: locale.dayjsLocale, setPageShowDate: function (v) {
                        setPageShowDate(v);
                        handlePickerValueChange(v);
                    }, timeValue: timeValue, isTimePanel: isTimePanel, panelMode: panelMode, setPanelMode: setPanelMode, onMouseEnterCell: onMouseEnterCell, onMouseLeaveCell: onMouseLeaveCell })),
                shouldShowFooter && (React.createElement(Footer, __assign$19({}, shortcutsProps, { DATEPICKER_LOCALE: DATEPICKER_LOCALE, disabled: !panelValue, onClickConfirmBtn: onClickConfirmBtn, extra: extra, mode: panelMode, shortcutsPlacementLeft: shortcutsPlacementLeft, onClickSelectTimeBtn: onClickSelectTimeBtn, isTimePanel: isTimePanel })))));
            var contentWithShortcuts = shortcutsPlacementLeft ? (React.createElement(React.Fragment, null,
                React.createElement(Shortcuts$1, __assign$19({ ref: refShortcuts }, shortcutsProps)),
                React.createElement("div", { ref: refPanel, className: prefixCls + "-panel-wrapper" }, content))) : (content);
            var panelNode = typeof panelRender === 'function' ? panelRender(contentWithShortcuts) : contentWithShortcuts;
            return (React.createElement("div", { className: classNames, onClick: function () {
                    refInput.current && refInput.current.focus && refInput.current.focus();
                }, style: panelOnly ? style : {} }, panelNode));
        }
        var size = props.size || ctxSize;
        var suffixIcon = icons && icons.inputSuffix === null
            ? null
            : (icons && icons.inputSuffix) || (showTime ? React.createElement(IconCalendarClock$1, null) : React.createElement(IconCalendar$1, null));
        var baseInputProps = {
            style: style,
            className: className,
            popupVisible: mergedPopupVisible,
            format: realFormat,
            disabled: disabled,
            error: error,
            size: size,
            onPressEnter: onPressEnter,
            onClear: onClear,
            prefix: props.prefix,
            suffixIcon: suffixIcon,
            editable: editable && typeof realFormat !== 'function',
            allowClear: allowClear,
        };
        return (React.createElement(PickerContext$1.Provider, { value: { utcOffset: utcOffset, timezone: timezone, weekStart: weekStart } }, triggerElement === null ? (renderPopup(true)) : (React.createElement(Trigger$1, __assign$19({ popup: renderPopup, trigger: "click", clickToClose: false, position: position, disabled: disabled, popupAlign: { bottom: 4 }, getPopupContainer: getPopupContainer, onVisibleChange: visibleChange, popupVisible: mergedPopupVisible, classNames: "slideDynamicOrigin", unmountOnExit: unmountOnExit }, triggerProps), triggerElement || (React.createElement(Input$2, __assign$19({}, pickDataAttributes(props), baseInputProps, { ref: refInput, placeholder: placeholder || DATEPICKER_LOCALE.placeholder[mode], popupVisible: mergedPopupVisible, value: valueShow || mergedValue, inputValue: hoverPlaceholderValue || inputValue, prefixCls: prefixCls, onChange: onChangeInput, isPlaceholder: !!hoverPlaceholderValue })))))));
    };
    var Picker$4 = Picker$3;

    var __assign$18 = (undefined && undefined.__assign) || function () {
        __assign$18 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$18.apply(this, arguments);
    };
    var __rest$u = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function DateInput(_a, ref) {
        var _b;
        var allowClear = _a.allowClear, error = _a.error, style = _a.style, className = _a.className, disabled = _a.disabled, _c = _a.placeholder, placeholder = _c === void 0 ? [] : _c, _d = _a.value, value = _d === void 0 ? [] : _d, popupVisible = _a.popupVisible, format = _a.format, propSize = _a.size, onClear = _a.onClear, editable = _a.editable, inputValue = _a.inputValue, onPressEnter = _a.onPressEnter, onPressTab = _a.onPressTab, onChange = _a.onChange, separator = _a.separator, suffixIcon = _a.suffixIcon, changeFocusedInputIndex = _a.changeFocusedInputIndex, focusedInputIndex = _a.focusedInputIndex, isPlaceholder = _a.isPlaceholder, prefix = _a.prefix, rest = __rest$u(_a, ["allowClear", "error", "style", "className", "disabled", "placeholder", "value", "popupVisible", "format", "size", "onClear", "editable", "inputValue", "onPressEnter", "onPressTab", "onChange", "separator", "suffixIcon", "changeFocusedInputIndex", "focusedInputIndex", "isPlaceholder", "prefix"]);
        var _e = React.useContext(ConfigContext), getPrefixCls = _e.getPrefixCls, ctxSize = _e.size, locale = _e.locale, rtl = _e.rtl;
        var input0 = React.useRef(null);
        var input1 = React.useRef(null);
        var disabled1 = isArray$1(disabled) ? disabled[0] : disabled;
        var disabled2 = isArray$1(disabled) ? disabled[1] : disabled;
        React.useImperativeHandle(ref, function () { return ({
            focus: function (index) {
                var focusedIndex = typeof index === 'number' ? index : focusedInputIndex;
                var focusElement = focusedIndex === 0 ? input0 : input1;
                if ((focusedInputIndex === 0 && !disabled1) || (focusedInputIndex === 1 && !disabled2)) {
                    focusElement.current && focusElement.current.focus && focusElement.current.focus();
                }
            },
            blur: function () {
                if (focusedInputIndex === 0) {
                    input0.current && input0.current.blur && input0.current.blur();
                }
                if (focusedInputIndex === 1) {
                    input1.current && input1.current.blur && input1.current.blur();
                }
            },
        }); });
        function changeFocusedInput(index) {
            if (focusedInputIndex !== index) {
                changeFocusedInputIndex(index);
            }
        }
        function onKeyDown(e) {
            var keyCode = e.keyCode || e.which;
            if (keyCode === Enter.code) {
                onPressEnter && onPressEnter();
            }
            if (keyCode === Tab.code) {
                onPressTab && onPressTab(e);
            }
        }
        function onChangeInput(e) {
            e.stopPropagation();
            onChange && onChange(e);
        }
        var prefixCls = getPrefixCls('picker');
        var size = propSize || ctxSize;
        var inputClassNames = cs(prefixCls, prefixCls + "-range", prefixCls + "-size-" + size, (_b = {},
            _b[prefixCls + "-focused"] = !!popupVisible,
            _b[prefixCls + "-disabled"] = disabled1 && disabled2,
            _b[prefixCls + "-error"] = error,
            _b[prefixCls + "-rtl"] = rtl,
            _b[prefixCls + "-has-prefix"] = prefix,
            _b), className);
        var getInputValue = function (index) {
            var valueText = value[index] ? value[index].locale(locale.dayjsLocale).format(format) : '';
            if (inputValue) {
                return index === focusedInputIndex ? inputValue : valueText;
            }
            return valueText;
        };
        var readOnlyProps = editable ? {} : { readOnly: true };
        function getFocusInputClassName(index) {
            var _a;
            return cs(prefixCls + "-input", (_a = {},
                _a[prefixCls + "-input-active"] = focusedInputIndex === index,
                _a[prefixCls + "-input-placeholder"] = isPlaceholder && focusedInputIndex === index,
                _a));
        }
        return (React.createElement("div", __assign$18({ style: style, className: inputClassNames }, omit$1(rest, ['onChange', 'onPressEnter'])),
            prefix && React.createElement("div", { className: prefixCls + "-prefix" }, prefix),
            React.createElement("div", { className: getFocusInputClassName(0) },
                React.createElement("input", __assign$18({ ref: input0, disabled: disabled1, placeholder: placeholder[0], value: getInputValue(0), onChange: onChangeInput, onKeyDown: onKeyDown, onClick: function () { return changeFocusedInput(0); } }, readOnlyProps))),
            React.createElement("span", { className: prefixCls + "-separator" }, separator || '-'),
            React.createElement("div", { className: getFocusInputClassName(1) },
                React.createElement("input", __assign$18({ ref: input1, disabled: disabled2, placeholder: placeholder[1], value: getInputValue(1), onChange: onChangeInput, onKeyDown: onKeyDown, onClick: function () { return changeFocusedInput(1); } }, readOnlyProps))),
            React.createElement("div", { className: prefixCls + "-suffix" },
                allowClear && value.length === 2 && (React.createElement(IconHover, { prefix: prefixCls, onClick: onClear, className: prefixCls + "-clear-icon" },
                    React.createElement(IconClose$1, null))),
                React.createElement("span", { className: prefixCls + "-suffix-icon" }, suffixIcon))));
    }
    var InputRange = React.forwardRef(DateInput);

    function getColumnsFromFormat(format) {
        var units = ['H', 'h', 'm', 's', 'a', 'A'];
        var list = [];
        var use12Hours = false;
        units.forEach(function (unit) {
            if (format.indexOf(unit) !== -1) {
                list.push(unit);
                if (unit === 'a' || unit === 'A') {
                    use12Hours = true;
                }
            }
        });
        return {
            list: list,
            use12Hours: use12Hours,
        };
    }
    var scrollIds = new Map();
    function scrollTo(element, to, duration) {
        if (scrollIds.get(element)) {
            cancelAnimationFrame(scrollIds.get(element));
        }
        if (duration <= 0) {
            element.scrollTop = to;
        }
        scrollIds.set(element, requestAnimationFrame(function () {
            var tween = new Tween({
                from: { scrollTop: element.scrollTop },
                to: { scrollTop: to },
                duration: duration,
                onUpdate: function (keys) {
                    element.scrollTop = keys.scrollTop;
                },
                easing: 'quartInOut',
            });
            tween.start();
        }));
    }
    function getFormatTime(time) {
        var today = dayjs();
        var y = today.year();
        var m = today.month();
        var d = today.date();
        if (isDayjs(time)) {
            var returnTime = time;
            returnTime = methods.set(returnTime, 'year', y);
            returnTime = methods.set(returnTime, 'month', m);
            returnTime = methods.set(returnTime, 'date', d);
            return returnTime;
        }
        return time;
    }

    function TimeColumn(props) {
        var prefixCls = props.prefixCls, list = props.list, value = props.value, onHandleSelect = props.onHandleSelect, unit = props.unit, popupVisible = props.popupVisible, scrollSticky = props.scrollSticky;
        var lis = React.useRef(new Map());
        var wrapper = React.useRef();
        var ul = React.useRef();
        var listItemHeight = React.useRef(0);
        var prevPopupVisible = usePrevious(popupVisible);
        var prevScrollTop = React.useRef(wrapper.current && wrapper.current.scrollTop);
        React.useEffect(function () {
            var li = lis.current.get(value);
            if (li && popupVisible && prevPopupVisible) {
                scrollTo(wrapper.current, li.offsetTop, 150);
                prevScrollTop.current = li.offsetTop;
            }
        }, [value]);
        React.useEffect(function () {
            if (popupVisible && popupVisible !== prevPopupVisible) {
                var li = lis.current.get(value);
                if (li) {
                    scrollTo(wrapper.current, li.offsetTop, 0);
                    prevScrollTop.current = li.offsetTop;
                }
            }
        }, [popupVisible, prevPopupVisible]);
        React.useEffect(function () {
            if (list.length <= 1) {
                return;
            }
            listItemHeight.current =
                (ul.current.clientHeight - wrapper.current.clientHeight) / (list.length - 1);
        }, [list.length]);
        var onScrollList = React.useCallback(debounce_1(function () {
            var mathFunc = wrapper.current.scrollTop - prevScrollTop.current > 0 ? Math.ceil : Math.floor;
            var index = mathFunc(wrapper.current.scrollTop / listItemHeight.current);
            if (index !== value && list[index] && !list[index].disabled) {
                onHandleSelect(list[index].value, unit);
            }
        }, 100), [onHandleSelect]);
        return (React.createElement("div", { className: cs(prefixCls + "-list"), ref: wrapper, onWheel: scrollSticky && onScrollList },
            React.createElement("ul", { ref: ul }, list.map(function (item) {
                var _a;
                return (React.createElement("li", { key: item.value, className: cs(prefixCls + "-cell", (_a = {},
                        _a[prefixCls + "-cell-disabled"] = item.disabled,
                        _a[prefixCls + "-cell-selected"] = item.selected,
                        _a)), onClick: function () { return !item.disabled && onHandleSelect(item.value, unit); }, ref: function (element) {
                        lis.current.set(item.value, element);
                    } },
                    React.createElement("div", { className: prefixCls + "-cell-inner" }, item.label)));
            }))));
    }

    var PickerContext = React.createContext({});

    var __assign$17 = (undefined && undefined.__assign) || function () {
        __assign$17 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$17.apply(this, arguments);
    };
    var AMPM = ['am', 'pm'];
    function isUse12Hours(props) {
        return props.use12Hours || getColumnsFromFormat(props.format).use12Hours;
    }
    function TimePicker$3(props) {
        var _a = props.format, format = _a === void 0 ? 'HH:mm:ss' : _a, onSelect = props.onSelect, popupVisible = props.popupVisible, _b = props.step, step = _b === void 0 ? {} : _b, disabledHours = props.disabledHours, disabledMinutes = props.disabledMinutes, disabledSeconds = props.disabledSeconds, hideDisabledOptions = props.hideDisabledOptions, onConfirmValue = props.onConfirmValue, isRangePicker = props.isRangePicker, confirmBtnDisabled = props.confirmBtnDisabled, propsValueShow = props.valueShow, setValueShow = props.setValueShow, extra = props.extra, disableConfirm = props.disableConfirm, hideFooter = props.hideFooter, _c = props.showNowBtn, showNowBtn = _c === void 0 ? true : _c, scrollSticky = props.scrollSticky;
        var _d = React.useContext(ConfigContext), getPrefixCls = _d.getPrefixCls, locale = _d.locale;
        var prefixCls = getPrefixCls('timepicker');
        var _e = React.useContext(PickerContext), utcOffset = _e.utcOffset, timezone = _e.timezone;
        var valueShow = getDayjsValue(propsValueShow, format);
        var ampm = valueShow && valueShow.hour() >= 12 ? 'pm' : 'am';
        var use12Hours = isUse12Hours(props);
        var getShowList = React.useCallback(function (type) {
            var stepHour = step.hour || 1;
            var stepMinute = step.minute || 1;
            var stepSecond = step.second || 1;
            var list = [];
            if (type === 'hour') {
                for (var i = 0; i < (use12Hours ? 12 : 24); i += stepHour) {
                    list.push(i);
                }
                if (use12Hours) {
                    list[0] = 12;
                }
            }
            if (type === 'minute') {
                for (var i = 0; i < 60; i += stepMinute) {
                    list.push(i);
                }
            }
            if (type === 'second') {
                for (var i = 0; i < 60; i += stepSecond) {
                    list.push(i);
                }
            }
            return list;
        }, [step.hour, step.minute, step.second, use12Hours]);
        var HOURS = getShowList('hour');
        var MINUTES = getShowList('minute');
        var SECONDS = getShowList('second');
        var selectedHour = valueShow && valueShow.hour();
        selectedHour = use12Hours ? (selectedHour > 12 ? selectedHour - 12 : selectedHour) : selectedHour;
        if (use12Hours && selectedHour === 0 && ampm === 'am') {
            selectedHour += 12;
        }
        var selectedMinute = valueShow && valueShow.minute();
        var selectedSecond = valueShow && valueShow.second();
        var getDefaultStr = React.useCallback(function (type) {
            switch (type) {
                case 'hour':
                    return typeof disabledHours === 'function'
                        ? padStart(HOURS.find(function (h) { return disabledHours().indexOf(h) === -1; }) || 0, 2, '0')
                        : padStart(HOURS[0], 2, '0');
                case 'minute':
                    return typeof disabledMinutes === 'function'
                        ? padStart(MINUTES.find(function (m) { return disabledMinutes(selectedHour).indexOf(m) === -1; }) || 0, 2, '0')
                        : padStart(MINUTES[0], 2, '0');
                case 'second':
                    return typeof disabledSeconds === 'function'
                        ? padStart(SECONDS.find(function (s) { return disabledSeconds(selectedHour, selectedMinute).indexOf(s) === -1; }) || 0, 2, '0')
                        : padStart(SECONDS[0], 2, '0');
                default:
                    return '00';
            }
        }, [
            HOURS,
            MINUTES,
            SECONDS,
            disabledHours,
            disabledMinutes,
            disabledSeconds,
            selectedHour,
            selectedMinute,
        ]);
        function onHandleSelect(selectedValue, unit) {
            var isUpperCase = getColumnsFromFormat(format).list.indexOf('A') !== -1;
            var _valueShow = valueShow ||
                dayjs(getDefaultStr('hour') + ":" + getDefaultStr('minute') + ":" + getDefaultStr('second'), 'HH:mm:ss');
            var hour = _valueShow.hour();
            var minute = _valueShow.minute();
            var second = _valueShow.second();
            var selectedAmpm = isUpperCase ? ampm.toUpperCase() : ampm;
            var valueFormat = 'HH:mm:ss';
            var newValue;
            if (use12Hours) {
                if (isUpperCase) {
                    valueFormat = valueFormat + " A";
                }
                else {
                    valueFormat = valueFormat + " a";
                }
            }
            if (use12Hours) {
                hour = hour > 12 ? hour - 12 : hour;
            }
            if (unit === 'hour') {
                newValue = dayjs(selectedValue + ":" + minute + ":" + second + " " + selectedAmpm, valueFormat, 'en');
            }
            if (unit === 'minute') {
                newValue = dayjs(hour + ":" + selectedValue + ":" + second + " " + selectedAmpm, valueFormat, 'en');
            }
            if (unit === 'second') {
                newValue = dayjs(hour + ":" + minute + ":" + selectedValue + " " + selectedAmpm, valueFormat, 'en');
            }
            if (unit === 'ampm') {
                newValue = dayjs(hour + ":" + minute + ":" + second + " " + (isUpperCase ? selectedValue.toUpperCase() : selectedValue), valueFormat, 'en');
            }
            newValue = dayjs(newValue, valueFormat).locale(dayjs.locale());
            onSelect &&
                onSelect(toLocal(newValue, utcOffset, timezone).format(format), toLocal(newValue, utcOffset, timezone));
            if (!isRangePicker) {
                setValueShow && setValueShow(newValue);
                if (disableConfirm) {
                    onConfirmValue(newValue);
                }
            }
        }
        function onConfirmTime() {
            if (valueShow) {
                onConfirmValue(valueShow);
            }
        }
        function onSelectNow() {
            var now = getNow();
            var zoneNow = getNow(utcOffset, timezone);
            onSelect && onSelect(now.format(format), now);
            if (disableConfirm) {
                onConfirmValue(zoneNow);
            }
            else {
                setValueShow && setValueShow(zoneNow);
            }
        }
        var baseTimeColumnProps = {
            prefixCls: prefixCls,
            onHandleSelect: onHandleSelect,
            popupVisible: popupVisible,
            scrollSticky: scrollSticky,
        };
        function renderHours() {
            var hours = hideDisabledOptions && typeof disabledHours === 'function'
                ? HOURS.filter(function (h) { return disabledHours().indexOf(h) === -1; })
                : HOURS;
            var list = hours.map(function (h) { return ({
                label: padStart("" + h, 2, '0'),
                value: h,
                selected: selectedHour !== undefined && selectedHour === h,
                disabled: typeof disabledHours === 'function' && disabledHours().indexOf(h) !== -1,
            }); });
            return React.createElement(TimeColumn, __assign$17({}, baseTimeColumnProps, { list: list, value: selectedHour, unit: "hour" }));
        }
        function renderMinutes() {
            var minutes = hideDisabledOptions && typeof disabledMinutes === 'function'
                ? MINUTES.filter(function (h) { return disabledMinutes(selectedHour).indexOf(h) === -1; })
                : MINUTES;
            var list = minutes.map(function (m) { return ({
                label: padStart("" + m, 2, '0'),
                value: m,
                selected: selectedHour !== undefined && selectedMinute === m,
                disabled: typeof disabledMinutes === 'function' && disabledMinutes(selectedHour).indexOf(m) !== -1,
            }); });
            return React.createElement(TimeColumn, __assign$17({}, baseTimeColumnProps, { list: list, value: selectedMinute, unit: "minute" }));
        }
        function renderSeconds() {
            var seconds = hideDisabledOptions && typeof disabledSeconds === 'function'
                ? SECONDS.filter(function (h) { return disabledSeconds(selectedHour, selectedMinute).indexOf(h) === -1; })
                : SECONDS;
            var list = seconds.map(function (s) { return ({
                label: padStart("" + s, 2, '0'),
                value: s,
                selected: selectedHour !== undefined && selectedSecond === s,
                disabled: typeof disabledSeconds === 'function' &&
                    disabledSeconds(selectedHour, selectedMinute).indexOf(s) !== -1,
            }); });
            return React.createElement(TimeColumn, __assign$17({}, baseTimeColumnProps, { list: list, value: selectedSecond, unit: "second" }));
        }
        function renderAmPm() {
            var isUpperCase = getColumnsFromFormat(format).list.indexOf('A') !== -1;
            var list = AMPM.map(function (a) { return ({
                label: isUpperCase ? a.toUpperCase() : a,
                value: a,
                selected: ampm === a,
            }); });
            return React.createElement(TimeColumn, __assign$17({}, baseTimeColumnProps, { list: list, value: ampm, unit: "ampm" }));
        }
        var list = getColumnsFromFormat(format).list;
        var classNames = cs(prefixCls);
        var _hideFooter = hideFooter ||
            (disableConfirm && isRangePicker) ||
            (!isRangePicker && disableConfirm && !showNowBtn);
        return (React.createElement(React.Fragment, null,
            React.createElement("div", { className: classNames },
                (list.indexOf('H') !== -1 || list.indexOf('h') !== -1) && renderHours(),
                list.indexOf('m') !== -1 && renderMinutes(),
                list.indexOf('s') !== -1 && renderSeconds(),
                use12Hours && renderAmPm()),
            extra && React.createElement("div", { className: prefixCls + "-footer-extra-wrapper" }, extra),
            !_hideFooter && (React.createElement("div", { className: prefixCls + "-footer-btn-wrapper" },
                !isRangePicker && showNowBtn ? (React.createElement(Button$3, { size: "mini", onClick: onSelectNow }, locale.TimePicker.now)) : (React.createElement("div", null)),
                !disableConfirm && (React.createElement(Button$3, { type: "primary", size: "mini", onClick: onConfirmTime, disabled: confirmBtnDisabled || !valueShow }, locale.TimePicker.ok))))));
    }

    function Header(props) {
        var prefixCls = props.prefixCls, title = props.title, onPrev = props.onPrev, onNext = props.onNext, onSuperPrev = props.onSuperPrev, onSuperNext = props.onSuperNext, mode = props.mode, value = props.value, onChangePanel = props.onChangePanel, _a = props.icons, icons = _a === void 0 ? {} : _a, rtl = props.rtl;
        var showPrev = typeof onPrev === 'function';
        var showSuperPrev = typeof onSuperPrev === 'function';
        var showNext = typeof onNext === 'function';
        var showSuperNext = typeof onSuperNext === 'function';
        var getIconClassName = function (isShow) {
            var _a;
            return cs(prefixCls + "-header-icon", (_a = {}, _a[prefixCls + "-header-icon-hidden"] = !isShow, _a));
        };
        function renderHeaderLabel() {
            if (title) {
                return title;
            }
            if (mode === 'date' || mode === 'week') {
                return (React.createElement(React.Fragment, null,
                    React.createElement("span", { className: prefixCls + "-header-label", onClick: function () { return onChangePanel('year'); } }, value.format('YYYY')),
                    "-",
                    React.createElement("span", { className: prefixCls + "-header-label", onClick: function () { return onChangePanel('month'); } }, value.format('MM'))));
            }
            if (mode === 'month' || mode === 'quarter') {
                return (React.createElement("span", { className: prefixCls + "-header-label", onClick: function () { return onChangePanel('year'); } }, value.format('YYYY')));
            }
        }
        var prevDoubleNull = icons.prevDouble === null;
        var prevNull = icons.prev === null;
        var nextNull = icons.next === null;
        var nextDoubleNull = icons.nextDouble === null;
        return (React.createElement("div", { className: prefixCls + "-header" },
            !prevDoubleNull && (React.createElement("div", { className: getIconClassName(showSuperPrev), onClick: onSuperPrev }, showSuperPrev &&
                (prevDoubleNull
                    ? null
                    : icons.prevDouble || (rtl ? React.createElement(IconDoubleRight$1, null) : React.createElement(IconDoubleLeft$1, null))))),
            !prevNull && (React.createElement("div", { className: getIconClassName(showPrev), onClick: onPrev }, showPrev && (prevNull ? null : icons.prev || (rtl ? React.createElement(IconRight$1, null) : React.createElement(IconLeft$1, null))))),
            React.createElement("div", { className: prefixCls + "-header-value" }, renderHeaderLabel()),
            !nextNull && (React.createElement("div", { className: getIconClassName(showNext), onClick: onNext }, showNext && (nextNull ? null : icons.next || (rtl ? React.createElement(IconLeft$1, null) : React.createElement(IconRight$1, null))))),
            !nextDoubleNull && (React.createElement("div", { className: getIconClassName(showSuperNext), onClick: onSuperNext }, showSuperNext &&
                (nextDoubleNull
                    ? null
                    : icons.nextDouble || (rtl ? React.createElement(IconDoubleLeft$1, null) : React.createElement(IconDoubleRight$1, null)))))));
    }

    function WeekList(props) {
        var prefixCls = props.prefixCls, weekStart = props.weekStart, isWeek = props.isWeek, CALENDAR_LOCALE = props.CALENDAR_LOCALE;
        var weekList = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
        weekList = weekList.slice(weekStart).concat(weekList.slice(0, weekStart));
        if (isWeek) {
            weekList.unshift('');
        }
        var weekLocale = CALENDAR_LOCALE.week.short;
        return (React.createElement("div", { className: prefixCls + "-week-list" }, weekList.map(function (w) { return (React.createElement("div", { className: prefixCls + "-week-list-item", key: w }, w && weekLocale[w])); })));
    }

    function getDateValue(date, index) {
        if (!date) {
            return undefined;
        }
        if (isArray$1(date)) {
            return date[index];
        }
    }
    function useClassName(props) {
        var prefixCls = props.prefixCls, value = props.value, rangeValues = props.rangeValues, valueShowHover = props.valueShowHover, isSameTime = props.isSameTime, mode = props.mode, hideNotInViewDates = props.hideNotInViewDates;
        var selectedLength = getAvailableDayjsLength(rangeValues);
        var hoverLength = getAvailableDayjsLength(valueShowHover);
        var sortedRangeValues = selectedLength !== 2 && hoverLength === 2 ? getSortedDayjsArray(valueShowHover) : rangeValues;
        var sortedHoverRangeValues = selectedLength === 2 ? getSortedDayjsArray(valueShowHover) : [];
        function isInRange(current, startDate, endDate) {
            // show placeholder range
            // if (!startDate || !endDate) {
            //   if (startDate) {
            //     return isSameTime(current, startDate) || current.isAfter(startDate);
            //   }
            //   if (endDate) {
            //     return isSameTime(current, endDate) || current.isBefore(endDate);
            //   }
            //   return false;
            // }
            if (startDate && endDate) {
                return (isSameTime(current, startDate) ||
                    isSameTime(current, endDate) ||
                    current.isBetween(startDate, endDate, null));
            }
        }
        return function getCellClassName(cellDateObj, disabled, utcOffset, timezone) {
            var _a;
            var rangeStart = getDateValue(sortedRangeValues, 0);
            var rangeEnd = getDateValue(sortedRangeValues, 1);
            var hoverRangeStart = getDateValue(sortedHoverRangeValues, 0);
            var hoverRangeEnd = getDateValue(sortedHoverRangeValues, 1);
            var isInView = !cellDateObj.isPrev && !cellDateObj.isNext;
            var selected = value && isSameTime(cellDateObj.time, value);
            var isToday = isSameTime(cellDateObj.time, getNow(utcOffset, timezone));
            var checkIsInView = mode !== 'week' ? isInView : true;
            if (mode === 'week') {
                isToday = getNow(utcOffset, timezone).isSame(cellDateObj.time, 'date');
            }
            if (mode === 'quarter') {
                isToday = getNow(utcOffset, timezone).isSame(cellDateObj.time, 'quarter');
            }
            function getIsRangeStartOrEnd(v) {
                return checkIsInView && !disabled && v && isSameTime(cellDateObj.time, v);
            }
            var isRangeStart = getIsRangeStartOrEnd(rangeStart);
            var isRangeEnd = getIsRangeStartOrEnd(rangeEnd);
            var isRangeStartSelected = getIsRangeStartOrEnd(getDateValue(rangeValues, 0));
            var isRangeEndSelected = getIsRangeStartOrEnd(getDateValue(rangeValues, 1));
            var isHoverRangeStart = getIsRangeStartOrEnd(hoverRangeStart);
            var isHoverRangeEnd = getIsRangeStartOrEnd(hoverRangeEnd);
            var isRangeEdgeInHoverRange = false;
            if (isRangeStart) {
                isRangeEdgeInHoverRange =
                    hoverRangeStart &&
                        rangeStart &&
                        hoverRangeStart.isBefore(rangeStart) &&
                        isInRange(rangeStart, hoverRangeStart, hoverRangeEnd);
            }
            else if (isRangeEnd) {
                isRangeEdgeInHoverRange =
                    hoverRangeEnd &&
                        rangeEnd &&
                        hoverRangeEnd.isAfter(rangeEnd) &&
                        isInRange(rangeEnd, hoverRangeStart, hoverRangeEnd);
            }
            var isHoverRangeEdgeInRange = false;
            if (isHoverRangeStart) {
                isHoverRangeEdgeInRange =
                    hoverRangeStart &&
                        rangeStart &&
                        rangeStart.isBefore(hoverRangeStart) &&
                        isInRange(hoverRangeStart, rangeStart, rangeEnd);
            }
            else if (isHoverRangeEnd) {
                isHoverRangeEdgeInRange =
                    hoverRangeEnd &&
                        rangeEnd &&
                        rangeEnd.isAfter(hoverRangeEnd) &&
                        isInRange(hoverRangeEnd, rangeStart, rangeEnd);
            }
            return cs(prefixCls + "-cell", (_a = {},
                _a[prefixCls + "-cell-disabled"] = disabled,
                _a[prefixCls + "-cell-hidden"] = hideNotInViewDates && !isInView,
                _a[prefixCls + "-cell-in-view"] = isInView,
                _a[prefixCls + "-cell-today"] = isToday && isInView,
                _a[prefixCls + "-cell-selected"] = selected || isRangeStartSelected || isRangeEndSelected,
                _a[prefixCls + "-cell-range-start"] = isRangeStart,
                _a[prefixCls + "-cell-range-end"] = isRangeEnd,
                _a[prefixCls + "-cell-in-range"] = checkIsInView && !disabled && isInRange(cellDateObj.time, rangeStart, rangeEnd),
                _a[prefixCls + "-cell-hover-range-start"] = isHoverRangeStart,
                _a[prefixCls + "-cell-hover-range-end"] = isHoverRangeEnd,
                _a[prefixCls + "-cell-hover-in-range"] = checkIsInView && !disabled && isInRange(cellDateObj.time, hoverRangeStart, hoverRangeEnd),
                _a[prefixCls + "-cell-range-edge-in-hover-range"] = isRangeEdgeInHoverRange,
                _a[prefixCls + "-cell-hover-range-edge-in-range"] = isHoverRangeEdgeInRange,
                _a));
        };
    }

    var __assign$16 = (undefined && undefined.__assign) || function () {
        __assign$16 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$16.apply(this, arguments);
    };
    function Body(props) {
        var prefixCls = props.prefixCls, isWeek = props.isWeek, disabledDate = props.disabledDate, onSelectDate = props.onSelectDate, dateRender = props.dateRender, onMouseEnterCell = props.onMouseEnterCell, onMouseLeaveCell = props.onMouseLeaveCell, CALENDAR_LOCALE = props.CALENDAR_LOCALE, rows = props.rows, showWeekList = props.showWeekList, isSameTime = props.isSameTime, format = props.format, mode = props.mode, originMode = props.originMode;
        var _a = React.useContext(PickerContext$1), utcOffset = _a.utcOffset, timezone = _a.timezone, weekStart = _a.weekStart;
        var getCellClassName = useClassName(__assign$16(__assign$16({}, props), { isSameTime: isSameTime }));
        function renderRow(row) {
            return row.map(function (col, index) {
                if (col.time) {
                    var disabled_1 = isDisabledDate(col.time, disabledDate, mode, originMode);
                    var onClickHandler = function () { return !disabled_1 && onSelectDate(col.time.format(format), col.time); };
                    return (React.createElement("div", { key: index, className: getCellClassName(col, disabled_1, utcOffset, timezone), onMouseEnter: function () { return onMouseEnterCell && onMouseEnterCell(col.time, disabled_1); }, onMouseLeave: function () { return onMouseLeaveCell && onMouseLeaveCell(col.time, disabled_1); }, onClick: onClickHandler }, dateRender ? (React.cloneElement(dateRender(col.time))) : (React.createElement("div", { className: prefixCls + "-date" },
                        React.createElement("div", { className: prefixCls + "-date-value" }, col.name)))));
                }
                if ('weekOfYear' in col) {
                    return (React.createElement("div", { key: index, className: cs(prefixCls + "-cell", prefixCls + "-cell-week") },
                        React.createElement("div", { className: prefixCls + "-date" },
                            React.createElement("div", { className: prefixCls + "-date-value" }, col.weekOfYear))));
                }
            });
        }
        return (React.createElement(React.Fragment, null,
            showWeekList && (React.createElement(WeekList, { prefixCls: prefixCls, weekStart: weekStart, isWeek: isWeek, CALENDAR_LOCALE: CALENDAR_LOCALE })),
            React.createElement("div", { className: prefixCls + "-body" }, rows.map(function (row, index) {
                var _a;
                return (React.createElement("div", { key: index, className: cs(prefixCls + "-row", (_a = {}, _a[prefixCls + "-row-week"] = isWeek, _a)) }, renderRow(row)));
            }))));
    }

    var __assign$15 = (undefined && undefined.__assign) || function () {
        __assign$15 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$15.apply(this, arguments);
    };
    var __rest$t = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function YearPicker$1(props) {
        var pageShowDate = props.pageShowDate, style = props.style, onMouseEnterCell = props.onMouseEnterCell, onMouseLeaveCell = props.onMouseLeaveCell, dateRender = props.dateRender, disabledDate = props.disabledDate, value = props.value, locale = props.locale, isRangePicker = props.isRangePicker, onSelect = props.onSelect, rangeValues = props.rangeValues, onSuperPrev = props.onSuperPrev, onSuperNext = props.onSuperNext, format = props.format, icons = props.icons, originMode = props.originMode, rest = __rest$t(props, ["pageShowDate", "style", "onMouseEnterCell", "onMouseLeaveCell", "dateRender", "disabledDate", "value", "locale", "isRangePicker", "onSelect", "rangeValues", "onSuperPrev", "onSuperNext", "format", "icons", "originMode"]);
        var _a = React.useContext(ConfigContext), globalLocale = _a.locale, getPrefixCls = _a.getPrefixCls, rtl = _a.rtl;
        var DATEPICKER_LOCALE = merge_1(globalLocale.DatePicker, locale);
        var CALENDAR_LOCALE = DATEPICKER_LOCALE.Calendar;
        var _b = React.useContext(PickerContext$1), utcOffset = _b.utcOffset, timezone = _b.timezone;
        var prefixCls = getPrefixCls('panel-year');
        var classNames = cs(prefixCls);
        var bodyProps = isRangePicker ? { rangeValues: rangeValues } : { value: value };
        var showYear = pageShowDate ? pageShowDate.year() : getNow(utcOffset, timezone).year();
        var startYear = Math.floor(showYear / 10) * 10 - 1;
        var groupRow = newArray(3).map(function (_) { return ''; });
        var rows = newArray(4)
            .map(function (_) { return groupRow; })
            .map(function (arr, i) {
            return arr.map(function (_, j) {
                return {
                    name: startYear + i * 3 + j,
                    time: dayjs("" + (startYear + i * 3 + j), 'YYYY').endOf('year'),
                    isPrev: i === 0 && j === 0,
                    isNext: i === 3 && j === 2,
                };
            });
        });
        function renderCalendar() {
            return (React.createElement(Body, __assign$15({}, rest, bodyProps, { prefixCls: getPrefixCls('picker'), rows: rows, onSelectDate: onSelect, isSameTime: function (current, target) { return current.isSame(target, 'year'); }, onMouseEnterCell: onMouseEnterCell, onMouseLeaveCell: onMouseLeaveCell, dateRender: dateRender, disabledDate: disabledDate, CALENDAR_LOCALE: CALENDAR_LOCALE, mode: "year", originMode: originMode, format: format })));
        }
        var headerOperations = { onSuperPrev: onSuperPrev, onSuperNext: onSuperNext };
        return (React.createElement("div", { className: classNames, style: style },
            React.createElement(Header, __assign$15({ prefixCls: getPrefixCls('picker'), icons: icons, title: rows[0][1].name + " - " + rows[3][2].name, rtl: rtl }, headerOperations)),
            renderCalendar()));
    }

    var __assign$14 = (undefined && undefined.__assign) || function () {
        __assign$14 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$14.apply(this, arguments);
    };
    var __rest$s = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function MonthPicker$1(props) {
        var pageShowDate = props.pageShowDate, style = props.style, onMouseEnterCell = props.onMouseEnterCell, onMouseLeaveCell = props.onMouseLeaveCell, dateRender = props.dateRender, disabledDate = props.disabledDate, value = props.value, locale = props.locale, isRangePicker = props.isRangePicker, onSelect = props.onSelect, rangeValues = props.rangeValues, onSuperPrev = props.onSuperPrev, onSuperNext = props.onSuperNext, format = props.format, getHeaderOperations = props.getHeaderOperations, setPageShowDate = props.setPageShowDate, icons = props.icons, panelMode = props.panelMode, originMode = props.originMode, setPanelMode = props.setPanelMode, rest = __rest$s(props, ["pageShowDate", "style", "onMouseEnterCell", "onMouseLeaveCell", "dateRender", "disabledDate", "value", "locale", "isRangePicker", "onSelect", "rangeValues", "onSuperPrev", "onSuperNext", "format", "getHeaderOperations", "setPageShowDate", "icons", "panelMode", "originMode", "setPanelMode"]);
        var _a = React.useContext(ConfigContext), globalLocale = _a.locale, getPrefixCls = _a.getPrefixCls, rtl = _a.rtl;
        var DATEPICKER_LOCALE = merge_1(globalLocale.DatePicker, locale);
        var CALENDAR_LOCALE = DATEPICKER_LOCALE.Calendar;
        var prefixCls = getPrefixCls('panel-month');
        var classNames = cs(prefixCls);
        var bodyProps = isRangePicker ? { rangeValues: rangeValues } : { value: value };
        var showYear = pageShowDate.year();
        var rows = React.useMemo(function () {
            var MONTHS = [
                'January',
                'February',
                'March',
                'April',
                'May',
                'June',
                'July',
                'August',
                'September',
                'October',
                'November',
                'December',
            ].map(function (month, index) {
                return {
                    name: CALENDAR_LOCALE.month.short[month],
                    time: dayjs(showYear + "-" + padStart(index + 1, 2, '0'), 'YYYY-MM').endOf('month'),
                };
            });
            var monthGroup = Array(4);
            for (var i = 0; i < 4; i++) {
                monthGroup[i] = MONTHS.slice(i * 3, 3 * (i + 1));
            }
            return monthGroup;
        }, [showYear, CALENDAR_LOCALE]);
        function renderCalendar() {
            return (React.createElement(Body, __assign$14({}, rest, bodyProps, { prefixCls: getPrefixCls('picker'), rows: rows, onSelectDate: onSelect, isSameTime: function (current, target) { return current.isSame(target, 'month'); }, onMouseEnterCell: onMouseEnterCell, onMouseLeaveCell: onMouseLeaveCell, dateRender: dateRender, disabledDate: disabledDate, CALENDAR_LOCALE: CALENDAR_LOCALE, mode: "month", originMode: originMode, format: format })));
        }
        var headerOperations = { onSuperPrev: onSuperPrev, onSuperNext: onSuperNext };
        function onChangePanel(mode) {
            setPanelMode(mode);
        }
        if (panelMode === 'year') {
            return (React.createElement(YearPicker$1, __assign$14({}, getHeaderOperations(panelMode), { pageShowDate: pageShowDate, onSelect: function (_, date) {
                    setPanelMode('month');
                    setPageShowDate(date);
                }, disabledDate: disabledDate })));
        }
        return (React.createElement("div", { className: classNames, style: style },
            React.createElement(Header, __assign$14({}, headerOperations, { icons: icons, prefixCls: getPrefixCls('picker'), value: pageShowDate, mode: panelMode, onChangePanel: onChangePanel, rtl: rtl })),
            renderCalendar()));
    }

    var __assign$13 = (undefined && undefined.__assign) || function () {
        __assign$13 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$13.apply(this, arguments);
    };
    var __rest$r = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$I = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$h = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var allDaysInOnePage = 6 * 7;
    var getReturn = function (time) {
        return {
            year: time.year(),
            month: time.month() + 1,
            day: time.day(),
            name: time.date(),
            time: time,
        };
    };
    var getTimeObj = function (time) {
        return __assign$13(__assign$13({}, getReturn(methods.startOf(time, 'month'))), { days: time.daysInMonth() });
    };
    function getAllDaysByTime(props, time) {
        var dayStartOfWeek = props.dayStartOfWeek, isWeek = props.isWeek;
        var current = getTimeObj(time);
        var flatRows = newArray(allDaysInOnePage).map(function () { return ({}); });
        var startIndex = current.day - dayStartOfWeek < 0
            ? 7 + (current.day - dayStartOfWeek)
            : current.day - dayStartOfWeek;
        flatRows[startIndex] = __assign$13({}, current);
        // pre
        for (var i = 0; i < startIndex; i++) {
            flatRows[startIndex - i - 1] = __assign$13(__assign$13({}, getReturn(methods.subtract(current.time, i + 1, 'day'))), { isPrev: true });
        }
        // next
        for (var i = 0; i < allDaysInOnePage - startIndex - 1; i++) {
            flatRows[startIndex + i + 1] = __assign$13(__assign$13({}, getReturn(methods.add(current.time, i + 1, 'day'))), { isNext: i >= current.days - 1 });
        }
        var rows = newArray(6).map(function () { return []; });
        for (var i = 0; i < 6; i++) {
            rows[i] = flatRows.slice(i * 7, 7 * (i + 1));
            if (isWeek) {
                var weekTime = rows[i][0].time;
                var weekRows = __spreadArray$h([], __read$I(rows[i]), false);
                rows[i].unshift({
                    weekRows: weekRows,
                    weekOfYear: weekTime.week(),
                });
            }
        }
        return rows;
    }
    function DatePicker$3(props) {
        var isWeek = props.isWeek, popupVisible = props.popupVisible, format = props.format, pageShowDate = props.pageShowDate, showTime = props.showTime, style = props.style, timepickerProps = props.timepickerProps, onMouseEnterCell = props.onMouseEnterCell, onMouseLeaveCell = props.onMouseLeaveCell, dateRender = props.dateRender, disabledDate = props.disabledDate, disabledTime = props.disabledTime, value = props.value, rangeValues = props.rangeValues, locale = props.locale, isRangePicker = props.isRangePicker, onSelect = props.onSelect, onTimePickerSelect = props.onTimePickerSelect, onPrev = props.onPrev, onNext = props.onNext, onSuperPrev = props.onSuperPrev, onSuperNext = props.onSuperNext, isSameTime = props.isSameTime, index = props.index, getHeaderOperations = props.getHeaderOperations, setPageShowDate = props.setPageShowDate, timeValue = props.timeValue, hideNotInViewDates = props.hideNotInViewDates, icons = props.icons, isTimePanel = props.isTimePanel, panelMode = props.panelMode, setPanelMode = props.setPanelMode, rest = __rest$r(props, ["isWeek", "popupVisible", "format", "pageShowDate", "showTime", "style", "timepickerProps", "onMouseEnterCell", "onMouseLeaveCell", "dateRender", "disabledDate", "disabledTime", "value", "rangeValues", "locale", "isRangePicker", "onSelect", "onTimePickerSelect", "onPrev", "onNext", "onSuperPrev", "onSuperNext", "isSameTime", "index", "getHeaderOperations", "setPageShowDate", "timeValue", "hideNotInViewDates", "icons", "isTimePanel", "panelMode", "setPanelMode"]);
        var _a = React.useContext(ConfigContext), globalLocale = _a.locale, getPrefixCls = _a.getPrefixCls, rtl = _a.rtl;
        var _b = React.useContext(PickerContext$1), utcOffset = _b.utcOffset, timezone = _b.timezone, weekStart = _b.weekStart;
        var DATEPICKER_LOCALE = merge_1(globalLocale.DatePicker, locale);
        var prefixCls = getPrefixCls(isWeek ? 'panel-week' : 'panel-date');
        var classNames = cs(prefixCls);
        var bodyProps = isRangePicker ? { rangeValues: rangeValues } : { value: value };
        var timeFormat = (isObject$1(showTime) && showTime.format) || getTimeFormat(format);
        var dayjsLocale = globalLocale.dayjsLocale;
        // page data list
        var rows = React.useMemo(function () {
            return getAllDaysByTime(__assign$13(__assign$13({}, props), { dayStartOfWeek: weekStart }), pageShowDate.locale(dayjsLocale));
        }, [pageShowDate.toString(), weekStart, dayjsLocale]);
        var disabledTimeProps;
        if (isRangePicker) {
            disabledTimeProps =
                typeof disabledTime === 'function'
                    ? disabledTime(rangeValues[index], index === 0 ? 'start' : 'end')
                    : {};
        }
        else {
            disabledTimeProps =
                typeof disabledTime === 'function' ? disabledTime(getDayjsValue(value, format)) : {};
        }
        function renderCalendar() {
            return (React.createElement(Body, __assign$13({}, rest, bodyProps, { showWeekList: true, isWeek: isWeek, prefixCls: getPrefixCls('picker'), rows: rows, isSameTime: isSameTime || (function (current, target) { return current.isSame(target, 'day'); }), onSelectDate: onSelect, onMouseEnterCell: onMouseEnterCell, onMouseLeaveCell: onMouseLeaveCell, dateRender: dateRender, disabledDate: disabledDate, CALENDAR_LOCALE: DATEPICKER_LOCALE.Calendar, mode: isWeek ? 'week' : 'date', format: format, hideNotInViewDates: hideNotInViewDates })));
        }
        function renderTimePicker() {
            var showTimeProps = isObject$1(showTime) ? showTime : {};
            return (React.createElement("div", { className: prefixCls + "-timepicker" },
                React.createElement("header", { className: prefixCls + "-timepicker-title" }, DATEPICKER_LOCALE.selectTime),
                React.createElement(TimePicker$3, __assign$13({}, omit$1(timepickerProps, ['disableConfirm']), showTimeProps, disabledTimeProps, { hideFooter: true, format: timeFormat, valueShow: timeValue.format(timeFormat), onSelect: onTimePickerSelect, popupVisible: popupVisible, utcOffset: utcOffset, timezone: timezone }))));
        }
        var headerOperations = { onPrev: onPrev, onSuperPrev: onSuperPrev, onNext: onNext, onSuperNext: onSuperNext };
        function onChangePanel(mode) {
            setPanelMode(mode);
        }
        if (panelMode === 'year') {
            return (React.createElement(YearPicker$1, __assign$13({}, getHeaderOperations(panelMode), { pageShowDate: pageShowDate, onSelect: function (_, date) {
                    setPanelMode('month');
                    setPageShowDate(date);
                }, disabledDate: disabledDate, originMode: "date" })));
        }
        if (panelMode === 'month') {
            return (React.createElement(MonthPicker$1, __assign$13({}, getHeaderOperations(panelMode), { setPageShowDate: setPageShowDate, pageShowDate: pageShowDate, panelMode: panelMode, getHeaderOperations: getHeaderOperations, onSelect: function (_, date) {
                    setPanelMode('date');
                    setPageShowDate(date);
                }, disabledDate: disabledDate, originMode: "date", setPanelMode: setPanelMode })));
        }
        return (React.createElement("div", { className: classNames, style: style }, showTime && isTimePanel ? (renderTimePicker()) : (React.createElement("div", { className: prefixCls + "-inner" },
            React.createElement(Header, __assign$13({}, headerOperations, { icons: icons, prefixCls: getPrefixCls('picker'), value: pageShowDate, mode: panelMode, onChangePanel: onChangePanel, rtl: rtl })),
            renderCalendar()))));
    }

    var __assign$12 = (undefined && undefined.__assign) || function () {
        __assign$12 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$12.apply(this, arguments);
    };
    var __rest$q = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function WeekPicker$1(props) {
        var value = props.value, isRangePicker = props.isRangePicker, rangeValues = props.rangeValues, onPrev = props.onPrev, onNext = props.onNext, onSuperPrev = props.onSuperPrev, onSuperNext = props.onSuperNext, localeName = props.localeName, rest = __rest$q(props, ["value", "isRangePicker", "rangeValues", "onPrev", "onNext", "onSuperPrev", "onSuperNext", "localeName"]);
        var weekStart = React.useContext(PickerContext$1).weekStart;
        var bodyProps = isRangePicker ? { rangeValues: rangeValues } : { value: value };
        var headerOperations = { onPrev: onPrev, onNext: onNext, onSuperPrev: onSuperPrev, onSuperNext: onSuperNext };
        function isSameTime(current, target) {
            return methods.isSameWeek(current, target, weekStart, localeName);
        }
        return (React.createElement(DatePicker$3, __assign$12({}, rest, bodyProps, headerOperations, { isWeek: true, isSameTime: isSameTime, isRangePicker: isRangePicker })));
    }

    var __assign$11 = (undefined && undefined.__assign) || function () {
        __assign$11 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$11.apply(this, arguments);
    };
    var __rest$p = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function QuarterPicker$1(props) {
        var pageShowDate = props.pageShowDate, style = props.style, onMouseEnterCell = props.onMouseEnterCell, onMouseLeaveCell = props.onMouseLeaveCell, dateRender = props.dateRender, disabledDate = props.disabledDate, value = props.value, locale = props.locale, isRangePicker = props.isRangePicker, onSelect = props.onSelect, rangeValues = props.rangeValues, onSuperPrev = props.onSuperPrev, onSuperNext = props.onSuperNext, format = props.format, getHeaderOperations = props.getHeaderOperations, setPageShowDate = props.setPageShowDate, icons = props.icons, panelMode = props.panelMode, setPanelMode = props.setPanelMode, rest = __rest$p(props, ["pageShowDate", "style", "onMouseEnterCell", "onMouseLeaveCell", "dateRender", "disabledDate", "value", "locale", "isRangePicker", "onSelect", "rangeValues", "onSuperPrev", "onSuperNext", "format", "getHeaderOperations", "setPageShowDate", "icons", "panelMode", "setPanelMode"]);
        var _a = React.useContext(ConfigContext), globalLocale = _a.locale, getPrefixCls = _a.getPrefixCls, rtl = _a.rtl;
        var DATEPICKER_LOCALE = merge_1(globalLocale.DatePicker, locale);
        var CALENDAR_LOCALE = DATEPICKER_LOCALE.Calendar;
        var prefixCls = getPrefixCls('panel-quarter');
        var classNames = cs(prefixCls);
        var bodyProps = isRangePicker ? { rangeValues: rangeValues } : { value: value };
        var showYear = pageShowDate.year();
        var rows = [
            [1, 2, 3, 4].map(function (q) { return ({
                name: "Q" + q,
                time: dayjs(showYear + "-" + padStart((q - 1) * 3 + 1, 2, '0') + "-01"),
            }); }),
        ];
        function renderCalendar() {
            return (React.createElement(Body, __assign$11({}, rest, bodyProps, { prefixCls: getPrefixCls('picker'), rows: rows, onSelectDate: onSelect, isSameTime: function (current, target) { return current.isSame(target, 'month'); }, onMouseEnterCell: onMouseEnterCell, onMouseLeaveCell: onMouseLeaveCell, dateRender: dateRender, disabledDate: disabledDate, CALENDAR_LOCALE: CALENDAR_LOCALE, mode: "quarter", format: format })));
        }
        var headerOperations = { onSuperPrev: onSuperPrev, onSuperNext: onSuperNext };
        function onChangePanel(mode) {
            setPanelMode(mode);
        }
        if (panelMode === 'year') {
            return (React.createElement(YearPicker$1, __assign$11({}, getHeaderOperations(panelMode), { pageShowDate: pageShowDate, onSelect: function (_, date) {
                    setPanelMode('quarter');
                    setPageShowDate(date);
                }, disabledDate: disabledDate, originMode: "quarter" })));
        }
        return (React.createElement("div", { className: classNames, style: style },
            React.createElement(Header, __assign$11({}, headerOperations, { icons: icons, prefixCls: getPrefixCls('picker'), value: pageShowDate, mode: panelMode, onChangePanel: onChangePanel, rtl: rtl })),
            React.createElement("div", { className: prefixCls + "-wrapper" }, renderCalendar())));
    }

    var __assign$10 = (undefined && undefined.__assign) || function () {
        __assign$10 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$10.apply(this, arguments);
    };
    function range$1(start, end) {
        var result = [];
        for (var i = start; i < end; i++) {
            result.push(i);
        }
        return result;
    }
    function RangePicker$3(props) {
        var _a = props.mode, mode = _a === void 0 ? 'date' : _a, showTime = props.showTime, disabledDate = props.disabledDate, disabledTime = props.disabledTime, format = props.format, dateRender = props.dateRender, propsValue = props.value, timeValues = props.timeValues, icons = props.icons, locale = props.locale, pageShowDates = props.pageShowDates, onMouseEnterCell = props.onMouseEnterCell, onMouseLeaveCell = props.onMouseLeaveCell, onSelectTime = props.onTimePickerSelect, onSelectPanel = props.onSelectPanel, onPrev = props.onPrev, onSuperPrev = props.onSuperPrev, onNext = props.onNext, onSuperNext = props.onSuperNext, localeName = props.localeName, popupVisible = props.popupVisible, timepickerProps = props.timepickerProps, getHeaderOperations = props.getHeaderOperations, setRangePageShowDates = props.setRangePageShowDates, disabledTimePickerIndex = props.disabledTimePickerIndex, hideNotInViewDates = props.hideNotInViewDates, isTimePanel = props.isTimePanel, valueShowHover = props.valueShowHover, panelModes = props.panelModes, setPanelModes = props.setPanelModes;
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var prefixCls = getPrefixCls('picker-range');
        var _b = React.useContext(PickerContext$1), utcOffset = _b.utcOffset, timezone = _b.timezone;
        var startShowDate = pageShowDates[0] || getNow(utcOffset, timezone);
        var endShowDate = pageShowDates[1] || getNow(utcOffset, timezone);
        var value = getDayjsValue(propsValue, format);
        var basePickerProps = {
            isRangePicker: true,
            rangeValues: value,
            onMouseEnterCell: onMouseEnterCell,
            onMouseLeaveCell: onMouseLeaveCell,
            format: format,
            locale: locale,
            disabledDate: disabledDate,
            onSelect: onSelectPanel,
            dateRender: dateRender,
            getHeaderOperations: getHeaderOperations,
            icons: icons,
            valueShowHover: valueShowHover,
        };
        var startPickerProps = {
            pageShowDate: startShowDate,
            panelMode: panelModes[0],
            setPanelMode: function (m) { return setPanelModes([m, panelModes[1]]); },
        };
        var endPickerProps = {
            pageShowDate: endShowDate,
            panelMode: panelModes[1],
            setPanelMode: function (m) { return setPanelModes([panelModes[0], m]); },
        };
        function renderDate() {
            var startOperations = {
                onPrev: onPrev,
                onSuperPrev: onSuperPrev,
            };
            var endOperations = {
                onNext: onNext,
                onSuperNext: onSuperNext,
            };
            var pickerProps = __assign$10(__assign$10({}, basePickerProps), { localeName: localeName, popupVisible: popupVisible, timepickerProps: timepickerProps, getHeaderOperations: getHeaderOperations, hideNotInViewDates: hideNotInViewDates, isTimePanel: isTimePanel });
            if (mode === 'week') {
                return (React.createElement(React.Fragment, null,
                    React.createElement(WeekPicker$1, __assign$10({ setPageShowDate: function (d) { return setRangePageShowDates([d, d], 0); } }, startOperations, pickerProps, startPickerProps)),
                    React.createElement(WeekPicker$1, __assign$10({ setPageShowDate: function (d) { return setRangePageShowDates([d, d], 1); } }, endOperations, pickerProps, endPickerProps))));
            }
            var showTimeProps = {
                disabledTime: disabledTime,
                showTime: showTime,
            };
            var disabledTimePickerProps = {};
            // 禁用面板时，TimePicker 被整体禁用同时关闭 hideDisabledOptions 防止用户传 true 导致空白
            if (typeof disabledTimePickerIndex === 'number') {
                disabledTimePickerProps.disabledTime = function () { return ({
                    disabledHours: function () { return range$1(0, 24); },
                    disabledMinutes: function () { return range$1(0, 60); },
                    disabledSeconds: function () { return range$1(0, 60); },
                }); };
                if (isObject$1(showTime)) {
                    var st = __assign$10(__assign$10({}, showTime), { defaultValue: undefined });
                    disabledTimePickerProps.showTime = __assign$10(__assign$10({}, st), { hideDisabledOptions: false });
                }
            }
            return (React.createElement(React.Fragment, null,
                React.createElement(DatePicker$3, __assign$10({}, startOperations, pickerProps, showTimeProps, (disabledTimePickerIndex === 0 ? disabledTimePickerProps : {}), { onTimePickerSelect: function (timeString, time) {
                        onSelectTime(0, timeString, time);
                    }, index: 0, setPageShowDate: function (d) { return setRangePageShowDates([d, d], 0); }, timeValue: timeValues[0] }, startPickerProps)),
                React.createElement(DatePicker$3, __assign$10({}, endOperations, pickerProps, showTimeProps, (disabledTimePickerIndex === 1 ? disabledTimePickerProps : {}), { onTimePickerSelect: function (timeString, time) {
                        onSelectTime(1, timeString, time);
                    }, index: 1, setPageShowDate: function (d) { return setRangePageShowDates([d, d], 1); }, timeValue: timeValues[1] }, endPickerProps))));
        }
        function renderMonth() {
            var startOperations = {
                onSuperPrev: onSuperPrev,
            };
            var endOperations = {
                onSuperNext: onSuperNext,
            };
            var pickerProps = basePickerProps;
            return (React.createElement(React.Fragment, null,
                React.createElement(MonthPicker$1, __assign$10({ setPageShowDate: function (d) { return setRangePageShowDates([d, d], 0); } }, startOperations, pickerProps, startPickerProps)),
                React.createElement(MonthPicker$1, __assign$10({ setPageShowDate: function (d) { return setRangePageShowDates([d, d], 1); } }, endOperations, pickerProps, endPickerProps))));
        }
        function renderYear() {
            var startOperations = {
                onSuperPrev: onSuperPrev,
            };
            var endOperations = {
                onSuperNext: onSuperNext,
            };
            var pickerProps = basePickerProps;
            return (React.createElement(React.Fragment, null,
                React.createElement(YearPicker$1, __assign$10({}, startOperations, pickerProps, { pageShowDate: startShowDate })),
                React.createElement(YearPicker$1, __assign$10({}, endOperations, pickerProps, { pageShowDate: endShowDate }))));
        }
        function renderQuarter() {
            var startOperations = {
                onSuperPrev: onSuperPrev,
            };
            var endOperations = {
                onSuperNext: onSuperNext,
            };
            var pickerProps = basePickerProps;
            return (React.createElement(React.Fragment, null,
                React.createElement(QuarterPicker$1, __assign$10({ setPageShowDate: function (d) { return setRangePageShowDates([d, d], 0); } }, startOperations, pickerProps, startPickerProps)),
                React.createElement(QuarterPicker$1, __assign$10({ setPageShowDate: function (d) { return setRangePageShowDates([d, d], 1); } }, endOperations, pickerProps, endPickerProps))));
        }
        return (React.createElement("div", { className: prefixCls },
            React.createElement("div", { className: prefixCls + "-wrapper" },
                (mode === 'date' || mode === 'week') && renderDate(),
                mode === 'month' && renderMonth(),
                mode === 'year' && renderYear(),
                mode === 'quarter' && renderQuarter())));
    }

    var __assign$$ = (undefined && undefined.__assign) || function () {
        __assign$$ = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$$.apply(this, arguments);
    };
    var __read$H = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$g = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    // get default format by mode
    function getFormat$1(props) {
        var format = props.format, showTime = props.showTime, mode = props.mode;
        var valueFormat;
        switch (mode) {
            case 'date':
                valueFormat = showTime ? 'YYYY-MM-DD HH:mm:ss' : 'YYYY-MM-DD';
                break;
            case 'month':
                valueFormat = 'YYYY-MM';
                break;
            case 'year':
                valueFormat = 'YYYY';
                break;
            case 'week':
                valueFormat = 'YYYY-wo';
                break;
            case 'quarter':
                valueFormat = 'YYYY-[Q]Q';
                break;
            default:
                valueFormat = 'YYYY-MM-DD';
        }
        if (format) {
            valueFormat = format;
        }
        return valueFormat;
    }
    var defaultProps$l = {
        allowClear: true,
        unmountOnExit: true,
        position: 'bl',
        editable: true,
        mode: 'date',
    };
    var Picker$2 = function (baseProps) {
        var _a, _b;
        var _c = React.useContext(ConfigContext), getPrefixCls = _c.getPrefixCls, locale = _c.locale, ctxSize = _c.size, componentConfig = _c.componentConfig, rtl = _c.rtl;
        if (rtl) {
            defaultProps$l.position = 'br';
        }
        var props = useMergeProps(baseProps, defaultProps$l, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.DatePicker);
        var allowClear = props.allowClear, className = props.className, style = props.style, placeholder = props.placeholder, getPopupContainer = props.getPopupContainer, disabled = props.disabled, position = props.position, error = props.error, unmountOnExit = props.unmountOnExit, editable = props.editable, triggerProps = props.triggerProps, shortcuts = props.shortcuts, onSelect = props.onSelect, onVisibleChange = props.onVisibleChange, propsValue = props.value, onChange = props.onChange, icons = props.icons, disabledDate = props.disabledDate, disabledTime = props.disabledTime, mode = props.mode, showTime = props.showTime, onSelectShortcut = props.onSelectShortcut, extra = props.extra, shortcutsPlacementLeft = props.shortcutsPlacementLeft, onOk = props.onOk, defaultPickerValue = props.defaultPickerValue, pickerValue = props.pickerValue, panelRender = props.panelRender, onPickerValueChange = props.onPickerValueChange, triggerElement = props.triggerElement, clearRangeOnReselect = props.clearRangeOnReselect, separator = props.separator, utcOffset = props.utcOffset, timezone = props.timezone;
        var prefixCls = getPrefixCls('picker-range');
        var weekStart = isUndefined(props.dayStartOfWeek)
            ? getDefaultWeekStart(locale.dayjsLocale)
            : props.dayStartOfWeek;
        var refInput = React.useRef(null);
        var refPanel = React.useRef(null);
        var refShortcuts = React.useRef(null);
        var shortcutEnterTimer = React.useRef(null);
        var shortcutLeaveTimer = React.useRef(null);
        var format = getFormat$1(props);
        // get input index when half disabled
        function getAvailableInputIndex() {
            if (isArray$1(disabled)) {
                if (disabled[0] && !disabled[1]) {
                    return 1;
                }
                if (disabled[1] && !disabled[0]) {
                    return 0;
                }
            }
        }
        var availableInputIndex = getAvailableInputIndex();
        var isHalfAvailable = typeof availableInputIndex === 'number';
        var disabledTimePickerIndex = isHalfAvailable ? 1 ^ availableInputIndex : undefined;
        // current focus index
        var _d = __read$H(React.useState(isHalfAvailable ? availableInputIndex : 0), 2), focusedInputIndex = _d[0], setFocusedInputIndex = _d[1];
        React.useEffect(function () {
            if (isHalfAvailable) {
                setFocusedInputIndex(availableInputIndex);
            }
        }, [disabled]);
        var nextFocusedInputIndex = 1 ^ focusedInputIndex;
        var _e = __read$H(React.useState(), 2), inputValue = _e[0], setInputValue = _e[1];
        var _f = __read$H(React.useState(), 2), hoverPlaceholderValue = _f[0], setHoverPlaceholderValue = _f[1];
        var _g = __read$H(React.useState(getDefaultValue()), 2), value = _g[0], setValue = _g[1];
        var _h = __read$H(React.useState(), 2), valueShow = _h[0], setValueShow = _h[1];
        var _j = __read$H(React.useState(), 2), valueShowHover = _j[0], setValueShowHover = _j[1];
        var _k = __read$H(React.useState(), 2), shortcutsValue = _k[0], setShortcutsValue = _k[1];
        var _l = __read$H(React.useState(props.popupVisible), 2), popupVisible = _l[0], setPopupVisible = _l[1];
        var _m = __read$H(React.useState([mode, mode]), 2), panelModes = _m[0], setPanelModes = _m[1];
        var _o = __read$H(React.useState(false), 2), isTimePanel = _o[0], setIsTimePanel = _o[1];
        var mergedPopupVisible = 'popupVisible' in props ? props.popupVisible : popupVisible;
        var propsValueDayjs = getDayjsValue(propsValue, format, utcOffset, timezone);
        var mergedValue = 'value' in props ? propsValueDayjs : value;
        var panelValue = shortcutsValue || valueShow || mergedValue || [];
        var selectedLength = getAvailableDayjsLength(valueShow || mergedValue);
        // the first time we select a range after open
        var firstRange = React.useRef(true);
        var now = getNow();
        var zoneNow = toTimezone(now, utcOffset, timezone);
        function getTimeValues() {
            var timeValues = [];
            var defaultTimeValue = isObject$1(showTime) && showTime.defaultValue
                ? getDayjsValue(showTime.defaultValue, showTime.format || 'HH:mm:ss', utcOffset, timezone)
                : [];
            timeValues[0] = panelValue[0] || defaultTimeValue[0] || zoneNow;
            timeValues[1] = panelValue[1] || defaultTimeValue[1] || zoneNow;
            return timeValues;
        }
        var timeValues = getTimeValues();
        var selectedDisabledDate = isHalfAvailable
            ? function (current) {
                return availableInputIndex === 0
                    ? current.isAfter(panelValue[1], mode)
                    : current.isBefore(panelValue[0], mode);
            }
            : undefined;
        // if triggerElement !== undefined, we should activate clearRangeOnReselect by default
        var customTriggerElement = triggerElement !== undefined;
        var resetRange = customTriggerElement || clearRangeOnReselect;
        function getDefaultValue() {
            var value;
            if (props.value) {
                value = getDayjsValue(props.value, format, utcOffset, timezone);
            }
            else {
                value = getDayjsValue(props.defaultValue, format, utcOffset, timezone);
            }
            if (isHalfAvailable && (!value || (value && !value[nextFocusedInputIndex]))) {
                var nv = [];
                nv[nextFocusedInputIndex] = getNow(utcOffset, timezone);
                return nv;
            }
            return value;
        }
        var defaultPageShowDates = mergedValue ||
            getDayjsValue(defaultPickerValue, format) || [now, now];
        // show date at two panels
        var _p = __read$H(React.useState(getShowDatesFromFocused(defaultPageShowDates)), 2), pageShowDates = _p[0], setPageShowDates = _p[1];
        var mergedPageShowDate = getShowDatesFromFocused(getDayjsValue(pickerValue, format, utcOffset, timezone)) ||
            pageShowDates;
        var previousUtcOffset = usePrevious(utcOffset);
        var previousTimezone = usePrevious(timezone);
        // when timezone or utcOffset change changed
        useUpdate(function () {
            if (isArray$1(value) && (previousUtcOffset !== utcOffset || timezone !== previousTimezone)) {
                var localValue = value.map(function (v) { return toLocal(v, previousUtcOffset, previousTimezone); });
                var zoneValue = localValue.map(function (v) { return toTimezone(v, utcOffset, timezone); });
                setValue(zoneValue);
            }
        }, [utcOffset, previousUtcOffset, timezone, previousTimezone]);
        // panel open and change mode
        useUpdate(function () {
            setPageShowDates(getShowDatesFromFocused(mergedPageShowDate));
        }, [mode]);
        React.useEffect(function () {
            setPanelModes([mode, mode]);
        }, [mode]);
        React.useEffect(function () {
            setHoverPlaceholderValue(undefined);
            setInputValue(undefined);
            if (mergedPopupVisible) {
                setIsTimePanel(false);
                setPanelModes([mode, mode]);
                setPageShowDates(getShowDatesFromFocused(defaultPageShowDates));
                setValueShow(mergedValue);
                if (shortcutsPlacementLeft) {
                    refShortcuts.current.style.maxHeight = refPanel.current.clientHeight + "px";
                }
            }
            else {
                setValueShow(undefined);
                setValueShowHover(undefined);
                setShortcutsValue(undefined);
                blurInput();
            }
            firstRange.current = mergedPopupVisible;
        }, [mergedPopupVisible]);
        var startStr = (_a = propsValueDayjs === null || propsValueDayjs === void 0 ? void 0 : propsValueDayjs[0]) === null || _a === void 0 ? void 0 : _a.format(format);
        var endStr = (_b = propsValueDayjs === null || propsValueDayjs === void 0 ? void 0 : propsValueDayjs[1]) === null || _b === void 0 ? void 0 : _b.format(format);
        React.useEffect(function () {
            setValueShow(undefined);
            setValueShowHover(undefined);
        }, [startStr, endStr]);
        function setFixedPageShowDates(innerValue, index) {
            if (index === void 0) { index = focusedInputIndex; }
            var newPageShowDates = getShowDatesFromFocused(innerValue, index);
            setPageShowDates(newPageShowDates);
            handlePickerValueChange(newPageShowDates);
        }
        function handlePickerValueChange(v) {
            if (!isSamePanel([v[0], pageShowDates[0]], mode)) {
                onPickerValueChange &&
                    onPickerValueChange(isArray$1(v) ? v.map(function (v) { return v && v.format(format); }) : undefined, v);
            }
        }
        function getShowDatesFromFocused(dates, index) {
            if (index === void 0) { index = focusedInputIndex; }
            var prev = index === 0 || isSamePanel(dates, mode);
            if (isArray$1(dates) && dates.length < 2) {
                return getPageShowDatesByValue(dates[0] || getNow(utcOffset, timezone), mode, 'prev');
            }
            if (isArray$1(dates) && dates.length === 2) {
                if (dates[index]) {
                    return getPageShowDatesByValue(dates[index], mode, prev ? 'prev' : 'next');
                }
                return getPageShowDatesByValue(dates[index === 0 ? 1 : 0] || getNow(utcOffset, timezone), mode, prev && !dates[index === 0 ? 1 : 0] ? 'prev' : 'next');
            }
        }
        function isSamePanel(innerValue, pickerMode) {
            if (innerValue && innerValue.length === 2 && isValidDayjsArray(innerValue)) {
                return (((pickerMode === 'date' || pickerMode === 'week') &&
                    innerValue[0].isSame(innerValue[1], 'month')) ||
                    ((pickerMode === 'month' || pickerMode === 'quarter') &&
                        innerValue[0].isSame(innerValue[1], 'year')) ||
                    (pickerMode === 'year' &&
                        Math.floor(innerValue[0].year() / 10) === Math.floor(innerValue[1].year() / 10)));
            }
        }
        // get page show date by specify value
        function getPageShowDatesByValue(value, pickerMode, type) {
            if (value === void 0) { value = getNow(utcOffset, timezone); }
            if (pickerMode === void 0) { pickerMode = mode; }
            if (type === void 0) { type = 'prev'; }
            var prev = type === 'prev';
            switch (pickerMode) {
                case 'date':
                case 'week':
                    return prev
                        ? [value, methods.add(value, 1, 'month')]
                        : [methods.subtract(value, 1, 'month'), value];
                case 'month':
                case 'quarter':
                    return prev
                        ? [value, methods.add(value, 1, 'year')]
                        : [methods.subtract(value, 1, 'year'), value];
                case 'year':
                    return prev
                        ? [value, methods.add(value, 10, 'year')]
                        : [methods.subtract(value, 10, 'year'), value];
                default:
                    return [];
            }
        }
        function focusInput(index) {
            refInput.current &&
                refInput.current.focus &&
                refInput.current.focus(isHalfAvailable ? availableInputIndex : index);
        }
        function blurInput() {
            refInput.current && refInput.current.blur && refInput.current.blur();
        }
        function visibleChange(visible) {
            if (visible) {
                setTimeout(function () { return focusInput(); });
                setOpen(visible);
            }
            else {
                setOpen(false);
            }
        }
        // open or close popup
        function setOpen(visible) {
            onVisibleChange && onVisibleChange(visible);
            setPopupVisible(visible);
        }
        function onClear(e) {
            e.stopPropagation();
            var newValueShow = __spreadArray$g([], __read$H(panelValue), false);
            if (isHalfAvailable) {
                newValueShow[availableInputIndex] = undefined;
            }
            else {
                newValueShow = undefined;
            }
            setValue(newValueShow);
            setValueShow(newValueShow);
            onHandleChange(newValueShow);
            props.onClear && props.onClear();
        }
        function changeFocusedInputIndex(index, silent) {
            setInputValue(undefined);
            setFocusedInputIndex(index);
            if (panelValue && panelValue.length && !silent) {
                var newPageShowDates = getShowDatesFromFocused(panelValue, index);
                setPageShowDates(newPageShowDates);
                handlePickerValueChange(newPageShowDates);
            }
        }
        function isDisabledDate(date) {
            var selectedDisabled = typeof selectedDisabledDate === 'function' ? selectedDisabledDate(date) : false;
            var originDisabledDate = typeof disabledDate === 'function' ? disabledDate(date) : false;
            return originDisabledDate || selectedDisabled;
        }
        // Determine whether the input date is in the correct format
        function isValid(time) {
            return (isValidTimeString(time, format) && !isDisabledDate(getDayjsValue(time, format))
            // (panelValue[nextFocusedInputIndex]
            //   ? nextFocusedInputIndex === 0
            //     ? panelValue[nextFocusedInputIndex].isBefore(dayjs(time, format))
            //     : panelValue[nextFocusedInputIndex].isAfter(dayjs(time, format))
            //   : true)
            );
        }
        function onChangeInput(e) {
            var newValueShow = __spreadArray$g([], __read$H((panelValue || [])), false);
            var niv = e.target.value;
            setInputValue(niv);
            if (!mergedPopupVisible) {
                setOpen(true);
            }
            if (isValid(niv)) {
                newValueShow[focusedInputIndex] = getDayjsValue(niv, format);
                setValueShow(newValueShow);
                setFixedPageShowDates(newValueShow);
                setInputValue(undefined);
            }
        }
        // Compare with the last value, trigger onChange only if the value changes
        function onHandleChange(newValue) {
            if (isDayjsArrayChange(mergedValue, newValue)) {
                var localValue = isArray$1(newValue)
                    ? newValue.map(function (v) {
                        return getLocaleDayjsValue(toLocal(v, utcOffset, timezone), locale.dayjsLocale);
                    })
                    : undefined;
                onChange &&
                    onChange(isArray$1(localValue) ? localValue.map(function (v) { return v && v.format(format); }) : undefined, localValue);
            }
        }
        function onPressEnter() {
            if (isArray$1(valueShow) && valueShow.length) {
                if (inputValue && !isValid(inputValue)) {
                    setInputValue(undefined);
                }
                else if (selectedLength !== 2) {
                    switchFocusedInput();
                }
                else if (selectedLength === 2) {
                    onConfirmValue(valueShow);
                }
            }
            else if (mergedPopupVisible) {
                setOpen(false);
            }
        }
        // Confirm and update component value
        function onConfirmValue(date, keepOpen) {
            var confirmValue = date || panelValue;
            if (!confirmValue || !confirmValue[0] || !confirmValue[1]) {
                return;
            }
            var sortedValues = getSortedDayjsArray(confirmValue);
            setValue(sortedValues);
            onHandleChange(sortedValues);
            if (triggerElement !== null && !keepOpen) {
                setOpen(false);
            }
        }
        // Callback when click the confirm button
        function onClickConfirmBtn() {
            onConfirmValue();
            var localePanelValue = panelValue.map(function (v) { return getLocaleDayjsValue(v, locale.dayjsLocale); });
            onOk &&
                onOk(localePanelValue.map(function (v) { return v && v.format(format); }), localePanelValue);
        }
        function getUnit() {
            switch (mode) {
                case 'date':
                case 'week':
                    return 'date';
                case 'month':
                    return 'month';
                case 'year':
                    return 'year';
                default:
                    return undefined;
            }
        }
        function outOfRange(date) {
            if (selectedLength !== 2) {
                return false;
            }
            var v = valueShow || mergedValue;
            if (focusedInputIndex === 0 && date.isAfter(v[1], getUnit())) {
                return true;
            }
            if (focusedInputIndex === 1 && date.isBefore(v[0], getUnit())) {
                return true;
            }
            return false;
        }
        // Callback when click the panel date cell
        function onSelectPanel(_, date) {
            var isOutOfRange = outOfRange(date) && firstRange.current;
            var newValueShow = resetRange && selectedLength === 2 && !isHalfAvailable ? [] : __spreadArray$g([], __read$H(panelValue), false);
            // if custom triggerElement, focused input index always 0 -> 1
            var focusedIndex = customTriggerElement
                ? selectedLength === 0 || selectedLength === 2
                    ? 0
                    : 1
                : focusedInputIndex;
            var newDate = showTime ? getValueWithTime(date, timeValues[focusedIndex]) : date;
            if (isOutOfRange) {
                newValueShow[focusedIndex] = newDate;
                newValueShow[1 ^ focusedIndex] = undefined;
            }
            else {
                newValueShow[focusedIndex] = newDate;
            }
            var sortedValueShow = getSortedDayjsArray(newValueShow);
            onSelectValueShow(sortedValueShow);
            setFixedPageShowDates(sortedValueShow);
            setInputValue(undefined);
            setHoverPlaceholderValue(undefined);
            var newSelectedLength = getAvailableDayjsLength(newValueShow);
            if (resetRange) {
                if (selectedLength === 0 || (selectedLength === 2 && !isHalfAvailable)) {
                    customTriggerElement ? setFocusedInputIndex(1) : switchFocusedInput(true);
                }
                else if (!showTime) {
                    onConfirmValue(newValueShow);
                }
            }
            else if (newSelectedLength <= 1) {
                switchFocusedInput(true);
            }
            else if (selectedLength === 2 && firstRange.current && !isHalfAvailable) {
                firstRange.current = false;
                switchFocusedInput(true);
                if (!showTime && !isOutOfRange) {
                    onConfirmValue(newValueShow, true);
                }
            }
            else {
                firstRange.current = false;
                if (!showTime && !isOutOfRange) {
                    onConfirmValue(newValueShow);
                }
            }
        }
        // Callback when click TimePicker
        function onTimePickerSelect(index, _, time) {
            var newValueShow = isArray$1(panelValue) ? __spreadArray$g([], __read$H(panelValue), false) : [];
            var newTimeValue = getValueWithTime(newValueShow[index] || getNow(utcOffset, timezone), time);
            newValueShow[index] = newTimeValue;
            onSelectValueShow(newValueShow);
        }
        function onSelectValueShow(newValueShow) {
            setValueShow(newValueShow);
            setValueShowHover(undefined);
            var sortedValues = getSortedDayjsArray(newValueShow);
            var zoneValues = sortedValues.map(function (v) {
                return getLocaleDayjsValue(toLocal(v, utcOffset, timezone), locale.dayjsLocale);
            });
            onSelect &&
                onSelect(zoneValues.map(function (v) { return v && v.format(format); }), zoneValues, { type: focusedInputIndex === 1 ? 'end' : 'start' });
        }
        // Switch to next focused input
        function switchFocusedInput(silent) {
            changeFocusedInputIndex(nextFocusedInputIndex, silent);
            setTimeout(function () { return focusInput(nextFocusedInputIndex); });
        }
        // Callback when mouse entered the date cell
        function onMouseEnterCell(date, disabled) {
            var newValueShowHover = __spreadArray$g([], __read$H((panelValue || [])), false);
            var needShowHover = resetRange ? selectedLength === 1 : selectedLength !== 0;
            if (!disabled && needShowHover && !outOfRange(date)) {
                newValueShowHover[focusedInputIndex] = getValueWithTime(date, timeValues[focusedInputIndex]);
                setValueShowHover(newValueShowHover);
                setInputValue(undefined);
            }
            if (!disabled) {
                var placeHolderValue = showTime
                    ? getValueWithTime(date, timeValues[focusedInputIndex])
                    : date;
                setHoverPlaceholderValue(placeHolderValue.locale(locale.dayjsLocale).format(format));
            }
        }
        function onMouseLeaveCell() {
            setValueShowHover(undefined);
            setHoverPlaceholderValue(undefined);
        }
        function isValidDayjsArray(sv) {
            return sv && isArray$1(sv) && sv.length === 2 && isDayjs(sv[0]) && isDayjs(sv[1]);
        }
        // Determine whether the value entered in the shortcut is in the correct format
        function isValidShortcut(shortcut) {
            var sv = typeof shortcut.value === 'function' && shortcut.value();
            return isValidDayjsArray(sv);
        }
        function clearShortcutsTimer() {
            clearTimeout(shortcutEnterTimer.current);
            clearTimeout(shortcutLeaveTimer.current);
            shortcutEnterTimer.current = null;
            shortcutLeaveTimer.current = null;
        }
        // Callback when mouse entered the shortcuts
        function onMouseEnterShortcut(shortcut) {
            clearShortcutsTimer();
            shortcutEnterTimer.current = setTimeout(function () {
                if (isValidShortcut(shortcut)) {
                    var nv = getDayjsValue(shortcut.value(), format, utcOffset, timezone);
                    setShortcutsValue(nv);
                    setFixedPageShowDates(nv);
                }
            }, 50);
        }
        // Callback when mouse leaved the shortcuts
        function onMouseLeaveShortcut() {
            clearShortcutsTimer();
            shortcutLeaveTimer.current = setTimeout(function () {
                setShortcutsValue(undefined);
                setFixedPageShowDates(valueShow || mergedValue || [getNow(utcOffset, timezone), getNow(utcOffset, timezone)]);
            }, 50);
        }
        // Callback when click the shortcuts button
        function onHandleSelectShortcut(shortcut) {
            onSelectShortcut && onSelectShortcut(shortcut);
            if (isValidShortcut(shortcut)) {
                var time = getDayjsValue(shortcut.value(), format, utcOffset, timezone);
                onConfirmValue(time);
            }
        }
        // Modify panel date (the value of the panel itself, not the component value)
        function changePageShowDates(type, unit, num) {
            if (num === void 0) { num = 1; }
            var index = type === 'prev' ? 0 : 1;
            var newPageShowDates = __spreadArray$g([], __read$H(mergedPageShowDate), false);
            if (type === 'prev') {
                newPageShowDates[index] = methods.subtract(mergedPageShowDate[index], num, unit);
            }
            if (type === 'next') {
                newPageShowDates[index] = methods.add(mergedPageShowDate[index], num, unit);
            }
            newPageShowDates = getPageShowDatesByValue(newPageShowDates[index], mode, type);
            setFixedPageShowDates(newPageShowDates);
        }
        // Callback when click the prev or next button
        function getHeaderOperations(pickerMode) {
            if (pickerMode === void 0) { pickerMode = mode; }
            if (pickerMode === 'date' || pickerMode === 'week') {
                return {
                    onPrev: function () { return changePageShowDates('prev', 'month'); },
                    onNext: function () { return changePageShowDates('next', 'month'); },
                    onSuperPrev: function () { return changePageShowDates('prev', 'year'); },
                    onSuperNext: function () { return changePageShowDates('next', 'year'); },
                };
            }
            if (pickerMode === 'month' || pickerMode === 'quarter') {
                return {
                    onSuperPrev: function () { return changePageShowDates('prev', 'year'); },
                    onSuperNext: function () { return changePageShowDates('next', 'year'); },
                };
            }
            if (pickerMode === 'year') {
                return {
                    onSuperPrev: function () { return changePageShowDates('prev', 'year', 10); },
                    onSuperNext: function () { return changePageShowDates('next', 'year', 10); },
                };
            }
        }
        function onClickSelectTimeBtn() {
            setIsTimePanel(!isTimePanel);
        }
        function renderPopup(panelOnly) {
            var _a;
            var classNames = cs(prefixCls + "-container", (_a = {},
                _a[prefixCls + "-panel-only"] = panelOnly,
                _a[prefixCls + "-container-shortcuts-placement-left"] = isArray$1(shortcuts) && shortcutsPlacementLeft,
                _a[prefixCls + "-container-rtl"] = rtl,
                _a), panelOnly ? className : '');
            var shortcutsProps = {
                prefixCls: getPrefixCls('picker'),
                showTime: showTime,
                shortcuts: shortcuts,
                onMouseEnterShortcut: onMouseEnterShortcut,
                onMouseLeaveShortcut: onMouseLeaveShortcut,
                onSelectShortcut: onHandleSelectShortcut,
            };
            var shouldShowFooter = (showTime && panelModes[0] === 'date' && panelModes[1] === 'date') ||
                extra ||
                (isArray$1(shortcuts) && shortcuts.length && !shortcutsPlacementLeft);
            var content = (React.createElement(React.Fragment, null,
                React.createElement(RangePicker$3, __assign$$({}, props, getHeaderOperations(), { getHeaderOperations: getHeaderOperations, setRangePageShowDates: setFixedPageShowDates, pageShowDates: mergedPageShowDate, value: panelValue, format: format, onSelectPanel: onSelectPanel, onMouseEnterCell: onMouseEnterCell, onMouseLeaveCell: onMouseLeaveCell, disabledDate: function (current) { return isDisabledDate(current); }, disabledTime: disabledTime, mode: mode, localeName: locale.dayjsLocale, showTime: showTime, timeValues: shortcutsValue || timeValues, onTimePickerSelect: onTimePickerSelect, popupVisible: mergedPopupVisible, disabledTimePickerIndex: disabledTimePickerIndex, isTimePanel: isTimePanel, valueShowHover: valueShowHover, panelModes: panelModes, setPanelModes: setPanelModes })),
                shouldShowFooter && (React.createElement(Footer, __assign$$({}, shortcutsProps, { DATEPICKER_LOCALE: locale.DatePicker, disabled: !(isArray$1(panelValue) && panelValue[0] && panelValue[1]), onClickConfirmBtn: onClickConfirmBtn, extra: extra, shortcutsPlacementLeft: shortcutsPlacementLeft, onClickSelectTimeBtn: onClickSelectTimeBtn, isTimePanel: isTimePanel })))));
            var contentWithShortcuts = shortcutsPlacementLeft ? (React.createElement(React.Fragment, null,
                React.createElement(Shortcuts$1, __assign$$({ ref: refShortcuts }, shortcutsProps)),
                React.createElement("div", { ref: refPanel, className: prefixCls + "-panel-wrapper" }, content))) : (content);
            var panelNode = typeof panelRender === 'function' ? panelRender(contentWithShortcuts) : contentWithShortcuts;
            return (React.createElement("div", { className: classNames, onClick: function () { return focusInput(); }, style: panelOnly ? style : {} }, panelNode));
        }
        var size = props.size || ctxSize;
        var placeholders = isArray$1(placeholder) ? placeholder : locale.DatePicker.placeholders[mode];
        var suffixIcon = icons && icons.inputSuffix === null
            ? null
            : (icons && icons.inputSuffix) || (showTime ? React.createElement(IconCalendarClock$1, null) : React.createElement(IconCalendar$1, null));
        var baseInputProps = {
            style: style,
            className: className,
            popupVisible: mergedPopupVisible,
            format: format,
            disabled: disabled,
            error: error,
            size: size,
            onPressEnter: onPressEnter,
            onClear: onClear,
            suffixIcon: suffixIcon,
            editable: editable,
            allowClear: allowClear,
            prefix: props.prefix,
        };
        var triggerDisabled = isArray$1(disabled) ? disabled[0] && disabled[1] : disabled;
        return (React.createElement(PickerContext$1.Provider, { value: { utcOffset: utcOffset, timezone: timezone, weekStart: weekStart } }, triggerElement === null ? (renderPopup(true)) : (React.createElement(Trigger$1, __assign$$({ popup: renderPopup, trigger: "click", clickToClose: false, position: position, disabled: triggerDisabled, popupAlign: { bottom: 4 }, getPopupContainer: getPopupContainer, onVisibleChange: visibleChange, popupVisible: mergedPopupVisible, classNames: "slideDynamicOrigin", unmountOnExit: unmountOnExit }, triggerProps), triggerElement || (React.createElement(InputRange, __assign$$({}, pickDataAttributes(props), baseInputProps, { ref: refInput, placeholder: placeholders, value: valueShow || mergedValue, onChange: onChangeInput, inputValue: hoverPlaceholderValue || inputValue, changeFocusedInputIndex: changeFocusedInputIndex, focusedInputIndex: focusedInputIndex, isPlaceholder: !!hoverPlaceholderValue, separator: separator })))))));
    };
    Picker$2.displayName = 'RangePicker';
    var PickerRange = Picker$2;

    var __extends$5 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$_ = (undefined && undefined.__assign) || function () {
        __assign$_ = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$_.apply(this, arguments);
    };
    function wrapper$1(picker, options) {
        var _a;
        return _a = /** @class */ (function (_super) {
                __extends$5(PickerWrapper, _super);
                function PickerWrapper() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                PickerWrapper.prototype.render = function () {
                    return React.createElement(Picker$4, __assign$_({}, this.props, { picker: picker, mode: options.mode }));
                };
                return PickerWrapper;
            }(React.Component)),
            _a.displayName = options.displayName,
            _a;
    }
    var DatePicker$2 = wrapper$1(React.createElement(DatePicker$3, null), {
        displayName: 'DatePicker',
        mode: 'date',
    });
    var MonthPicker = wrapper$1(React.createElement(MonthPicker$1, null), {
        displayName: 'MonthPicker',
        mode: 'month',
    });
    var YearPicker = wrapper$1(React.createElement(YearPicker$1, null), {
        displayName: 'YearPicker',
        mode: 'year',
    });
    var WeekPicker = wrapper$1(React.createElement(WeekPicker$1, null), {
        displayName: 'WeekPicker',
        mode: 'week',
    });
    var QuarterPicker = wrapper$1(React.createElement(QuarterPicker$1, null), {
        displayName: 'QuarterPicker',
        mode: 'quarter',
    });
    var RangePicker$2 = PickerRange;
    Object.assign(DatePicker$2, { MonthPicker: MonthPicker, YearPicker: YearPicker, WeekPicker: WeekPicker, QuarterPicker: QuarterPicker, RangePicker: RangePicker$2 });
    var ArcoDatePicker = DatePicker$2;

    /**
     * defines a focus group
     */
    var FOCUS_GROUP = 'data-focus-lock';
    /**
     * disables element discovery inside a group marked by key
     */
    var FOCUS_DISABLED = 'data-focus-lock-disabled';
    /**
     * allows uncontrolled focus within the marked area, effectively disabling focus lock for it's content
     */
    var FOCUS_ALLOW = 'data-no-focus-lock';
    /**
     * instructs autofocus engine to pick default autofocus inside a given node
     * can be set on the element or container
     */
    var FOCUS_AUTO = 'data-autofocus-inside';
    /**
     * instructs autofocus to ignore elements within a given node
     * can be set on the element or container
     */
    var FOCUS_NO_AUTOFOCUS = 'data-no-autofocus';

    /**
     * Assigns a value for a given ref, no matter of the ref format
     * @param {RefObject} ref - a callback function or ref object
     * @param value - a new value
     *
     * @see https://github.com/theKashey/use-callback-ref#assignref
     * @example
     * const refObject = useRef();
     * const refFn = (ref) => {....}
     *
     * assignRef(refObject, "refValue");
     * assignRef(refFn, "refValue");
     */
    function assignRef(ref, value) {
        if (typeof ref === 'function') {
            ref(value);
        }
        else if (ref) {
            ref.current = value;
        }
        return ref;
    }

    /**
     * creates a MutableRef with ref change callback
     * @param initialValue - initial ref value
     * @param {Function} callback - a callback to run when value changes
     *
     * @example
     * const ref = useCallbackRef(0, (newValue, oldValue) => console.log(oldValue, '->', newValue);
     * ref.current = 1;
     * // prints 0 -> 1
     *
     * @see https://reactjs.org/docs/hooks-reference.html#useref
     * @see https://github.com/theKashey/use-callback-ref#usecallbackref---to-replace-reactuseref
     * @returns {MutableRefObject}
     */
    function useCallbackRef(initialValue, callback) {
        var ref = React.useState(function () { return ({
            // value
            value: initialValue,
            // last callback
            callback: callback,
            // "memoized" public interface
            facade: {
                get current() {
                    return ref.value;
                },
                set current(value) {
                    var last = ref.value;
                    if (last !== value) {
                        ref.value = value;
                        ref.callback(value, last);
                    }
                },
            },
        }); })[0];
        // update callback
        ref.callback = callback;
        return ref.facade;
    }

    /**
     * Merges two or more refs together providing a single interface to set their value
     * @param {RefObject|Ref} refs
     * @returns {MutableRefObject} - a new ref, which translates all changes to {refs}
     *
     * @see {@link mergeRefs} a version without buit-in memoization
     * @see https://github.com/theKashey/use-callback-ref#usemergerefs
     * @example
     * const Component = React.forwardRef((props, ref) => {
     *   const ownRef = useRef();
     *   const domRef = useMergeRefs([ref, ownRef]); // 👈 merge together
     *   return <div ref={domRef}>...</div>
     * }
     */
    function useMergeRefs(refs, defaultValue) {
        return useCallbackRef(defaultValue || null, function (newValue) { return refs.forEach(function (ref) { return assignRef(ref, newValue); }); });
    }

    var hiddenGuard = {
      width: '1px',
      height: '0px',
      padding: 0,
      overflow: 'hidden',
      position: 'fixed',
      top: '1px',
      left: '1px'
    };

    process.env.NODE_ENV !== "production" ? {
      children: PropTypes.node
    } : {};

    function ItoI(a) {
        return a;
    }
    function innerCreateMedium(defaults, middleware) {
        if (middleware === void 0) { middleware = ItoI; }
        var buffer = [];
        var assigned = false;
        var medium = {
            read: function () {
                if (assigned) {
                    throw new Error('Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.');
                }
                if (buffer.length) {
                    return buffer[buffer.length - 1];
                }
                return defaults;
            },
            useMedium: function (data) {
                var item = middleware(data, assigned);
                buffer.push(item);
                return function () {
                    buffer = buffer.filter(function (x) { return x !== item; });
                };
            },
            assignSyncMedium: function (cb) {
                assigned = true;
                while (buffer.length) {
                    var cbs = buffer;
                    buffer = [];
                    cbs.forEach(cb);
                }
                buffer = {
                    push: function (x) { return cb(x); },
                    filter: function () { return buffer; },
                };
            },
            assignMedium: function (cb) {
                assigned = true;
                var pendingQueue = [];
                if (buffer.length) {
                    var cbs = buffer;
                    buffer = [];
                    cbs.forEach(cb);
                    pendingQueue = buffer;
                }
                var executeQueue = function () {
                    var cbs = pendingQueue;
                    pendingQueue = [];
                    cbs.forEach(cb);
                };
                var cycle = function () { return Promise.resolve().then(executeQueue); };
                cycle();
                buffer = {
                    push: function (x) {
                        pendingQueue.push(x);
                        cycle();
                    },
                    filter: function (filter) {
                        pendingQueue = pendingQueue.filter(filter);
                        return buffer;
                    },
                };
            },
        };
        return medium;
    }
    function createMedium(defaults, middleware) {
        if (middleware === void 0) { middleware = ItoI; }
        return innerCreateMedium(defaults, middleware);
    }
    // eslint-disable-next-line @typescript-eslint/ban-types
    function createSidecarMedium(options) {
        if (options === void 0) { options = {}; }
        var medium = innerCreateMedium(null);
        medium.options = __assign$2e({ async: true, ssr: false }, options);
        return medium;
    }

    var mediumFocus = createMedium({}, function (_ref) {
      var target = _ref.target,
          currentTarget = _ref.currentTarget;
      return {
        target: target,
        currentTarget: currentTarget
      };
    });
    var mediumBlur = createMedium();
    var mediumEffect = createMedium();
    var mediumSidecar = createSidecarMedium({
      async: true // focus-lock sidecar is not required on the server
      // however, it might be required for JSDOM tests
      // ssr: true,

    });

    var emptyArray = [];
    var FocusLock$1 = /*#__PURE__*/React.forwardRef(function FocusLockUI(props, parentRef) {
      var _extends2;

      var _React$useState = React.useState(),
          realObserved = _React$useState[0],
          setObserved = _React$useState[1];

      var observed = React.useRef();
      var isActive = React.useRef(false);
      var originalFocusedElement = React.useRef(null);
      var children = props.children,
          disabled = props.disabled,
          noFocusGuards = props.noFocusGuards,
          persistentFocus = props.persistentFocus,
          crossFrame = props.crossFrame,
          autoFocus = props.autoFocus,
          allowTextSelection = props.allowTextSelection,
          group = props.group,
          className = props.className,
          whiteList = props.whiteList,
          hasPositiveIndices = props.hasPositiveIndices,
          _props$shards = props.shards,
          shards = _props$shards === void 0 ? emptyArray : _props$shards,
          _props$as = props.as,
          Container = _props$as === void 0 ? 'div' : _props$as,
          _props$lockProps = props.lockProps,
          containerProps = _props$lockProps === void 0 ? {} : _props$lockProps,
          SideCar = props.sideCar,
          shouldReturnFocus = props.returnFocus,
          focusOptions = props.focusOptions,
          onActivationCallback = props.onActivation,
          onDeactivationCallback = props.onDeactivation;

      var _React$useState2 = React.useState({}),
          id = _React$useState2[0]; // SIDE EFFECT CALLBACKS


      var onActivation = React.useCallback(function () {
        originalFocusedElement.current = originalFocusedElement.current || document && document.activeElement;

        if (observed.current && onActivationCallback) {
          onActivationCallback(observed.current);
        }

        isActive.current = true;
      }, [onActivationCallback]);
      var onDeactivation = React.useCallback(function () {
        isActive.current = false;

        if (onDeactivationCallback) {
          onDeactivationCallback(observed.current);
        }
      }, [onDeactivationCallback]);
      React.useEffect(function () {
        if (!disabled) {
          // cleanup return focus on trap deactivation
          // sideEffect/returnFocus should happen by this time
          originalFocusedElement.current = null;
        }
      }, []);
      var returnFocus = React.useCallback(function (allowDefer) {
        var returnFocusTo = originalFocusedElement.current;

        if (returnFocusTo && returnFocusTo.focus) {
          var howToReturnFocus = typeof shouldReturnFocus === 'function' ? shouldReturnFocus(returnFocusTo) : shouldReturnFocus;

          if (howToReturnFocus) {
            var returnFocusOptions = typeof howToReturnFocus === 'object' ? howToReturnFocus : undefined;
            originalFocusedElement.current = null;

            if (allowDefer) {
              // React might return focus after update
              // it's safer to defer the action
              Promise.resolve().then(function () {
                return returnFocusTo.focus(returnFocusOptions);
              });
            } else {
              returnFocusTo.focus(returnFocusOptions);
            }
          }
        }
      }, [shouldReturnFocus]); // MEDIUM CALLBACKS

      var onFocus = React.useCallback(function (event) {
        if (isActive.current) {
          mediumFocus.useMedium(event);
        }
      }, []);
      var onBlur = mediumBlur.useMedium; // REF PROPAGATION
      // not using real refs due to race conditions

      var setObserveNode = React.useCallback(function (newObserved) {
        if (observed.current !== newObserved) {
          observed.current = newObserved;
          setObserved(newObserved);
        }
      }, []);

      if (process.env.NODE_ENV !== 'production') {
        if (typeof allowTextSelection !== 'undefined') {
          // eslint-disable-next-line no-console
          console.warn('React-Focus-Lock: allowTextSelection is deprecated and enabled by default');
        }

        React.useEffect(function () {
          // report incorrect integration - https://github.com/theKashey/react-focus-lock/issues/123
          if (!observed.current && typeof Container !== 'string') {
            // eslint-disable-next-line no-console
            console.error('FocusLock: could not obtain ref to internal node');
          }
        }, []);
      }

      var lockProps = _extends$1((_extends2 = {}, _extends2[FOCUS_DISABLED] = disabled && 'disabled', _extends2[FOCUS_GROUP] = group, _extends2), containerProps);

      var hasLeadingGuards = noFocusGuards !== true;
      var hasTailingGuards = hasLeadingGuards && noFocusGuards !== 'tail';
      var mergedRef = useMergeRefs([parentRef, setObserveNode]);
      return /*#__PURE__*/React.createElement(React.Fragment, null, hasLeadingGuards && [
      /*#__PURE__*/
      // nearest focus guard
      React.createElement("div", {
        key: "guard-first",
        "data-focus-guard": true,
        tabIndex: disabled ? -1 : 0,
        style: hiddenGuard
      }), // first tabbed element guard
      hasPositiveIndices ? /*#__PURE__*/React.createElement("div", {
        key: "guard-nearest",
        "data-focus-guard": true,
        tabIndex: disabled ? -1 : 1,
        style: hiddenGuard
      }) : null], !disabled && /*#__PURE__*/React.createElement(SideCar, {
        id: id,
        sideCar: mediumSidecar,
        observed: realObserved,
        disabled: disabled,
        persistentFocus: persistentFocus,
        crossFrame: crossFrame,
        autoFocus: autoFocus,
        whiteList: whiteList,
        shards: shards,
        onActivation: onActivation,
        onDeactivation: onDeactivation,
        returnFocus: returnFocus,
        focusOptions: focusOptions
      }), /*#__PURE__*/React.createElement(Container, _extends$1({
        ref: mergedRef
      }, lockProps, {
        className: className,
        onBlur: onBlur,
        onFocus: onFocus
      }), children), hasTailingGuards && /*#__PURE__*/React.createElement("div", {
        "data-focus-guard": true,
        tabIndex: disabled ? -1 : 0,
        style: hiddenGuard
      }));
    });
    FocusLock$1.propTypes = process.env.NODE_ENV !== "production" ? {
      children: propTypes$3.node,
      disabled: propTypes$3.bool,
      returnFocus: propTypes$3.oneOfType([propTypes$3.bool, propTypes$3.object, propTypes$3.func]),
      focusOptions: propTypes$3.object,
      noFocusGuards: propTypes$3.bool,
      hasPositiveIndices: propTypes$3.bool,
      allowTextSelection: propTypes$3.bool,
      autoFocus: propTypes$3.bool,
      persistentFocus: propTypes$3.bool,
      crossFrame: propTypes$3.bool,
      group: propTypes$3.string,
      className: propTypes$3.string,
      whiteList: propTypes$3.func,
      shards: propTypes$3.arrayOf(propTypes$3.any),
      as: propTypes$3.oneOfType([propTypes$3.string, propTypes$3.func, propTypes$3.object]),
      lockProps: propTypes$3.object,
      onActivation: propTypes$3.func,
      onDeactivation: propTypes$3.func,
      sideCar: propTypes$3.any.isRequired
    } : {};
    FocusLock$1.defaultProps = {
      children: undefined,
      disabled: false,
      returnFocus: false,
      focusOptions: undefined,
      noFocusGuards: false,
      autoFocus: true,
      persistentFocus: false,
      crossFrame: true,
      hasPositiveIndices: undefined,
      allowTextSelection: undefined,
      group: undefined,
      className: undefined,
      whiteList: undefined,
      shards: undefined,
      as: 'div',
      lockProps: {},
      onActivation: undefined,
      onDeactivation: undefined
    };
    var FocusLockUI = FocusLock$1;

    function _typeof(obj) {
      "@babel/helpers - typeof";

      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      }, _typeof(obj);
    }

    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }

    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }

    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }

    function withSideEffect(reducePropsToState, handleStateChangeOnClient) {
      if (process.env.NODE_ENV !== "production") {
        if (typeof reducePropsToState !== 'function') {
          throw new Error('Expected reducePropsToState to be a function.');
        }

        if (typeof handleStateChangeOnClient !== 'function') {
          throw new Error('Expected handleStateChangeOnClient to be a function.');
        }
      }

      function getDisplayName(WrappedComponent) {
        return WrappedComponent.displayName || WrappedComponent.name || 'Component';
      }

      return function wrap(WrappedComponent) {
        if (process.env.NODE_ENV !== "production") {
          if (typeof WrappedComponent !== 'function') {
            throw new Error('Expected WrappedComponent to be a React component.');
          }
        }

        var mountedInstances = [];
        var state;

        function emitChange() {
          state = reducePropsToState(mountedInstances.map(function (instance) {
            return instance.props;
          }));
          handleStateChangeOnClient(state);
        }

        var SideEffect = /*#__PURE__*/function (_PureComponent) {
          _inheritsLoose(SideEffect, _PureComponent);

          function SideEffect() {
            return _PureComponent.apply(this, arguments) || this;
          }

          // Try to use displayName of wrapped component
          SideEffect.peek = function peek() {
            return state;
          };

          var _proto = SideEffect.prototype;

          _proto.componentDidMount = function componentDidMount() {
            mountedInstances.push(this);
            emitChange();
          };

          _proto.componentDidUpdate = function componentDidUpdate() {
            emitChange();
          };

          _proto.componentWillUnmount = function componentWillUnmount() {
            var index = mountedInstances.indexOf(this);
            mountedInstances.splice(index, 1);
            emitChange();
          };

          _proto.render = function render() {
            return /*#__PURE__*/React.createElement(WrappedComponent, this.props);
          };

          return SideEffect;
        }(React.PureComponent);

        _defineProperty(SideEffect, "displayName", "SideEffect(" + getDisplayName(WrappedComponent) + ")");

        return SideEffect;
      };
    }

    /*
    IE11 support
     */
    var toArray = function (a) {
        var ret = Array(a.length);
        for (var i = 0; i < a.length; ++i) {
            ret[i] = a[i];
        }
        return ret;
    };
    var asArray = function (a) { return (Array.isArray(a) ? a : [a]); };
    var getFirst = function (a) { return (Array.isArray(a) ? a[0] : a); };

    var isElementHidden = function (node) {
        // we can measure only "elements"
        // consider others as "visible"
        if (node.nodeType !== Node.ELEMENT_NODE) {
            return false;
        }
        var computedStyle = window.getComputedStyle(node, null);
        if (!computedStyle || !computedStyle.getPropertyValue) {
            return false;
        }
        return (computedStyle.getPropertyValue('display') === 'none' || computedStyle.getPropertyValue('visibility') === 'hidden');
    };
    var getParentNode$1 = function (node) {
        // DOCUMENT_FRAGMENT_NODE can also point on ShadowRoot. In this case .host will point on the next node
        return node.parentNode && node.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE
            ? // eslint-disable-next-line @typescript-eslint/no-explicit-any
                node.parentNode.host
            : node.parentNode;
    };
    var isTopNode = function (node) {
        // @ts-ignore
        return node === document || (node && node.nodeType === Node.DOCUMENT_NODE);
    };
    var isVisibleUncached = function (node, checkParent) {
        return !node || isTopNode(node) || (!isElementHidden(node) && checkParent(getParentNode$1(node)));
    };
    var isVisibleCached = function (visibilityCache, node) {
        var cached = visibilityCache.get(node);
        if (cached !== undefined) {
            return cached;
        }
        var result = isVisibleUncached(node, isVisibleCached.bind(undefined, visibilityCache));
        visibilityCache.set(node, result);
        return result;
    };
    var isAutoFocusAllowedUncached = function (node, checkParent) {
        return node && !isTopNode(node) ? (isAutoFocusAllowed(node) ? checkParent(getParentNode$1(node)) : false) : true;
    };
    var isAutoFocusAllowedCached = function (cache, node) {
        var cached = cache.get(node);
        if (cached !== undefined) {
            return cached;
        }
        var result = isAutoFocusAllowedUncached(node, isAutoFocusAllowedCached.bind(undefined, cache));
        cache.set(node, result);
        return result;
    };
    var getDataset = function (node) {
        // @ts-ignore
        return node.dataset;
    };
    var isHTMLButtonElement = function (node) { return node.tagName === 'BUTTON'; };
    var isHTMLInputElement = function (node) { return node.tagName === 'INPUT'; };
    var isRadioElement = function (node) {
        return isHTMLInputElement(node) && node.type === 'radio';
    };
    var notHiddenInput = function (node) {
        return !((isHTMLInputElement(node) || isHTMLButtonElement(node)) && (node.type === 'hidden' || node.disabled));
    };
    var isAutoFocusAllowed = function (node) {
        var attribute = node.getAttribute(FOCUS_NO_AUTOFOCUS);
        return ![true, 'true', ''].includes(attribute);
    };
    var isGuard = function (node) { var _a; return Boolean(node && ((_a = getDataset(node)) === null || _a === void 0 ? void 0 : _a.focusGuard)); };
    var isNotAGuard = function (node) { return !isGuard(node); };
    var isDefined = function (x) { return Boolean(x); };

    var tabSort = function (a, b) {
        var tabDiff = a.tabIndex - b.tabIndex;
        var indexDiff = a.index - b.index;
        if (tabDiff) {
            if (!a.tabIndex) {
                return 1;
            }
            if (!b.tabIndex) {
                return -1;
            }
        }
        return tabDiff || indexDiff;
    };
    var orderByTabIndex = function (nodes, filterNegative, keepGuards) {
        return toArray(nodes)
            .map(function (node, index) { return ({
            node: node,
            index: index,
            tabIndex: keepGuards && node.tabIndex === -1 ? ((node.dataset || {}).focusGuard ? 0 : -1) : node.tabIndex,
        }); })
            .filter(function (data) { return !filterNegative || data.tabIndex >= 0; })
            .sort(tabSort);
    };

    /**
     * list of the object to be considered as focusable
     */
    var tabbables = [
        'button:enabled',
        'select:enabled',
        'textarea:enabled',
        'input:enabled',
        // elements with explicit roles will also use explicit tabindex
        // '[role="button"]',
        'a[href]',
        'area[href]',
        'summary',
        'iframe',
        'object',
        'embed',
        'audio[controls]',
        'video[controls]',
        '[tabindex]',
        '[contenteditable]',
        '[autofocus]',
    ];

    var queryTabbables = tabbables.join(',');
    var queryGuardTabbables = "".concat(queryTabbables, ", [data-focus-guard]");
    var getFocusablesWithShadowDom = function (parent, withGuards) {
        var _a;
        return toArray(((_a = parent.shadowRoot) === null || _a === void 0 ? void 0 : _a.children) || parent.children).reduce(function (acc, child) {
            return acc.concat(child.matches(withGuards ? queryGuardTabbables : queryTabbables) ? [child] : [], getFocusablesWithShadowDom(child));
        }, []);
    };
    var getFocusablesWithIFrame = function (parent, withGuards) {
        if (parent instanceof HTMLIFrameElement && parent.contentDocument) {
            return getFocusables([parent.contentDocument.body], withGuards);
        }
        return [parent];
    };
    var getFocusables = function (parents, withGuards) {
        return parents.reduce(function (acc, parent) {
            var _a;
            var focusableWithShadowDom = getFocusablesWithShadowDom(parent, withGuards);
            var focusableWithIframes = (_a = []).concat.apply(_a, focusableWithShadowDom.map(function (node) { return getFocusablesWithIFrame(node, withGuards); }));
            return acc.concat(
            // add all tabbables inside and within shadow DOMs in DOM order
            focusableWithIframes, 
            // add if node is tabbable itself
            parent.parentNode
                ? toArray(parent.parentNode.querySelectorAll(queryTabbables)).filter(function (node) { return node === parent; })
                : []);
        }, []);
    };
    /**
     * return a list of focusable nodes within an area marked as "auto-focusable"
     * @param parent
     */
    var getParentAutofocusables = function (parent) {
        var parentFocus = parent.querySelectorAll("[".concat(FOCUS_AUTO, "]"));
        return toArray(parentFocus)
            .map(function (node) { return getFocusables([node]); })
            .reduce(function (acc, nodes) { return acc.concat(nodes); }, []);
    };

    /**
     * given list of focusable elements keeps the ones user can interact with
     * @param nodes
     * @param visibilityCache
     */
    var filterFocusable = function (nodes, visibilityCache) {
        return toArray(nodes)
            .filter(function (node) { return isVisibleCached(visibilityCache, node); })
            .filter(function (node) { return notHiddenInput(node); });
    };
    var filterAutoFocusable = function (nodes, cache) {
        if (cache === void 0) { cache = new Map(); }
        return toArray(nodes).filter(function (node) { return isAutoFocusAllowedCached(cache, node); });
    };
    /**
     * only tabbable ones
     * (but with guards which would be ignored)
     */
    var getTabbableNodes = function (topNodes, visibilityCache, withGuards) {
        return orderByTabIndex(filterFocusable(getFocusables(topNodes, withGuards), visibilityCache), true, withGuards);
    };
    /**
     * actually anything "focusable", not only tabbable
     * (without guards, as long as they are not expected to be focused)
     */
    var getAllTabbableNodes = function (topNodes, visibilityCache) {
        return orderByTabIndex(filterFocusable(getFocusables(topNodes), visibilityCache), false);
    };
    /**
     * return list of nodes which are expected to be auto-focused
     * @param topNode
     * @param visibilityCache
     */
    var parentAutofocusables = function (topNode, visibilityCache) {
        return filterFocusable(getParentAutofocusables(topNode), visibilityCache);
    };
    /*
     * Determines if element is contained in scope, including nested shadow DOMs
     */
    var contains = function (scope, element) {
        if (scope.shadowRoot) {
            return contains(scope.shadowRoot, element);
        }
        else {
            if (Object.getPrototypeOf(scope).contains !== undefined &&
                Object.getPrototypeOf(scope).contains.call(scope, element)) {
                return true;
            }
            return toArray(scope.children).some(function (child) {
                var _a;
                if (child instanceof HTMLIFrameElement) {
                    var iframeBody = (_a = child.contentDocument) === null || _a === void 0 ? void 0 : _a.body;
                    if (iframeBody) {
                        return contains(iframeBody, element);
                    }
                    return false;
                }
                return contains(child, element);
            });
        }
    };

    /**
     * in case of multiple nodes nested inside each other
     * keeps only top ones
     * this is O(nlogn)
     * @param nodes
     * @returns {*}
     */
    var filterNested = function (nodes) {
        var contained = new Set();
        var l = nodes.length;
        for (var i = 0; i < l; i += 1) {
            for (var j = i + 1; j < l; j += 1) {
                var position = nodes[i].compareDocumentPosition(nodes[j]);
                /* eslint-disable no-bitwise */
                if ((position & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0) {
                    contained.add(j);
                }
                if ((position & Node.DOCUMENT_POSITION_CONTAINS) > 0) {
                    contained.add(i);
                }
                /* eslint-enable */
            }
        }
        return nodes.filter(function (_, index) { return !contained.has(index); });
    };
    /**
     * finds top most parent for a node
     * @param node
     * @returns {*}
     */
    var getTopParent = function (node) {
        return node.parentNode ? getTopParent(node.parentNode) : node;
    };
    /**
     * returns all "focus containers" inside a given node
     * @param node
     * @returns {T}
     */
    var getAllAffectedNodes = function (node) {
        var nodes = asArray(node);
        return nodes.filter(Boolean).reduce(function (acc, currentNode) {
            var group = currentNode.getAttribute(FOCUS_GROUP);
            acc.push.apply(acc, (group
                ? filterNested(toArray(getTopParent(currentNode).querySelectorAll("[".concat(FOCUS_GROUP, "=\"").concat(group, "\"]:not([").concat(FOCUS_DISABLED, "=\"disabled\"])"))))
                : [currentNode]));
            return acc;
        }, []);
    };

    /**
     * returns active element from document or from nested shadowdoms
     */
    var getActiveElement = function (inDocument) {
        var _a;
        if (inDocument === void 0) { inDocument = document; }
        if (!inDocument || !inDocument.activeElement) {
            return undefined;
        }
        var activeElement = inDocument.activeElement;
        return (activeElement.shadowRoot
            ? getActiveElement(activeElement.shadowRoot)
            : activeElement instanceof HTMLIFrameElement && ((_a = activeElement.contentWindow) === null || _a === void 0 ? void 0 : _a.document)
                ? getActiveElement(activeElement.contentWindow.document)
                : activeElement);
    };

    var focusInFrame = function (frame, activeElement) { return frame === activeElement; };
    var focusInsideIframe = function (topNode, activeElement) {
        return Boolean(toArray(topNode.querySelectorAll('iframe')).some(function (node) { return focusInFrame(node, activeElement); }));
    };
    /**
     * @returns {Boolean} true, if the current focus is inside given node or nodes
     */
    var focusInside = function (topNode, activeElement) {
        // const activeElement = document && getActiveElement();
        if (activeElement === void 0) { activeElement = getActiveElement(getFirst(topNode).ownerDocument); }
        if (!activeElement || (activeElement.dataset && activeElement.dataset.focusGuard)) {
            return false;
        }
        return getAllAffectedNodes(topNode).some(function (node) {
            return contains(node, activeElement) || focusInsideIframe(node, activeElement);
        });
    };

    /**
     * focus is hidden FROM the focus-lock
     * ie contained inside a node focus-lock shall ignore
     * @returns {boolean} focus is currently is in "allow" area
     */
    var focusIsHidden = function (inDocument) {
        if (inDocument === void 0) { inDocument = document; }
        var activeElement = getActiveElement(inDocument);
        if (!activeElement) {
            return false;
        }
        // this does not support setting FOCUS_ALLOW within shadow dom
        return toArray(inDocument.querySelectorAll("[".concat(FOCUS_ALLOW, "]"))).some(function (node) { return contains(node, activeElement); });
    };

    var findSelectedRadio = function (node, nodes) {
        return nodes
            .filter(isRadioElement)
            .filter(function (el) { return el.name === node.name; })
            .filter(function (el) { return el.checked; })[0] || node;
    };
    var correctNode = function (node, nodes) {
        if (isRadioElement(node) && node.name) {
            return findSelectedRadio(node, nodes);
        }
        return node;
    };
    /**
     * giving a set of radio inputs keeps only selected (tabbable) ones
     * @param nodes
     */
    var correctNodes = function (nodes) {
        // IE11 has no Set(array) constructor
        var resultSet = new Set();
        nodes.forEach(function (node) { return resultSet.add(correctNode(node, nodes)); });
        // using filter to support IE11
        return nodes.filter(function (node) { return resultSet.has(node); });
    };

    var pickFirstFocus = function (nodes) {
        if (nodes[0] && nodes.length > 1) {
            return correctNode(nodes[0], nodes);
        }
        return nodes[0];
    };
    var pickFocusable = function (nodes, index) {
        if (nodes.length > 1) {
            return nodes.indexOf(correctNode(nodes[index], nodes));
        }
        return index;
    };

    var NEW_FOCUS = 'NEW_FOCUS';
    /**
     * Main solver for the "find next focus" question
     * @param innerNodes
     * @param outerNodes
     * @param activeElement
     * @param lastNode
     * @returns {number|string|undefined|*}
     */
    var newFocus = function (innerNodes, outerNodes, activeElement, lastNode) {
        var cnt = innerNodes.length;
        var firstFocus = innerNodes[0];
        var lastFocus = innerNodes[cnt - 1];
        var isOnGuard = isGuard(activeElement);
        // focus is inside
        if (activeElement && innerNodes.indexOf(activeElement) >= 0) {
            return undefined;
        }
        var activeIndex = activeElement !== undefined ? outerNodes.indexOf(activeElement) : -1;
        var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;
        var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;
        var indexDiff = activeIndex - lastIndex;
        var firstNodeIndex = outerNodes.indexOf(firstFocus);
        var lastNodeIndex = outerNodes.indexOf(lastFocus);
        var correctedNodes = correctNodes(outerNodes);
        var correctedIndex = activeElement !== undefined ? correctedNodes.indexOf(activeElement) : -1;
        var correctedIndexDiff = correctedIndex - (lastNode ? correctedNodes.indexOf(lastNode) : activeIndex);
        var returnFirstNode = pickFocusable(innerNodes, 0);
        var returnLastNode = pickFocusable(innerNodes, cnt - 1);
        // new focus
        if (activeIndex === -1 || lastNodeInside === -1) {
            return NEW_FOCUS;
        }
        // old focus
        if (!indexDiff && lastNodeInside >= 0) {
            return lastNodeInside;
        }
        // first element
        if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
            return returnLastNode;
        }
        // last element
        if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
            return returnFirstNode;
        }
        // jump out, but not on the guard
        if (indexDiff && Math.abs(correctedIndexDiff) > 1) {
            return lastNodeInside;
        }
        // focus above lock
        if (activeIndex <= firstNodeIndex) {
            return returnLastNode;
        }
        // focus below lock
        if (activeIndex > lastNodeIndex) {
            return returnFirstNode;
        }
        // index is inside tab order, but outside Lock
        if (indexDiff) {
            if (Math.abs(indexDiff) > 1) {
                return lastNodeInside;
            }
            return (cnt + lastNodeInside + indexDiff) % cnt;
        }
        // do nothing
        return undefined;
    };

    var findAutoFocused = function (autoFocusables) {
        return function (node) {
            var _a;
            var autofocus = (_a = getDataset(node)) === null || _a === void 0 ? void 0 : _a.autofocus;
            return (
            // @ts-expect-error
            node.autofocus ||
                //
                (autofocus !== undefined && autofocus !== 'false') ||
                //
                autoFocusables.indexOf(node) >= 0);
        };
    };
    var pickAutofocus = function (nodesIndexes, orderedNodes, groups) {
        var nodes = nodesIndexes.map(function (_a) {
            var node = _a.node;
            return node;
        });
        var autoFocusable = filterAutoFocusable(nodes.filter(findAutoFocused(groups)));
        if (autoFocusable && autoFocusable.length) {
            return pickFirstFocus(autoFocusable);
        }
        return pickFirstFocus(filterAutoFocusable(orderedNodes));
    };

    var getParents = function (node, parents) {
        if (parents === void 0) { parents = []; }
        parents.push(node);
        if (node.parentNode) {
            getParents(node.parentNode.host || node.parentNode, parents);
        }
        return parents;
    };
    /**
     * finds a parent for both nodeA and nodeB
     * @param nodeA
     * @param nodeB
     * @returns {boolean|*}
     */
    var getCommonParent = function (nodeA, nodeB) {
        var parentsA = getParents(nodeA);
        var parentsB = getParents(nodeB);
        // tslint:disable-next-line:prefer-for-of
        for (var i = 0; i < parentsA.length; i += 1) {
            var currentParent = parentsA[i];
            if (parentsB.indexOf(currentParent) >= 0) {
                return currentParent;
            }
        }
        return false;
    };
    var getTopCommonParent = function (baseActiveElement, leftEntry, rightEntries) {
        var activeElements = asArray(baseActiveElement);
        var leftEntries = asArray(leftEntry);
        var activeElement = activeElements[0];
        var topCommon = false;
        leftEntries.filter(Boolean).forEach(function (entry) {
            topCommon = getCommonParent(topCommon || entry, entry) || topCommon;
            rightEntries.filter(Boolean).forEach(function (subEntry) {
                var common = getCommonParent(activeElement, subEntry);
                if (common) {
                    if (!topCommon || contains(common, topCommon)) {
                        topCommon = common;
                    }
                    else {
                        topCommon = getCommonParent(common, topCommon);
                    }
                }
            });
        });
        // TODO: add assert here?
        return topCommon;
    };
    /**
     * return list of nodes which are expected to be autofocused inside a given top nodes
     * @param entries
     * @param visibilityCache
     */
    var allParentAutofocusables = function (entries, visibilityCache) {
        return entries.reduce(function (acc, node) { return acc.concat(parentAutofocusables(node, visibilityCache)); }, []);
    };

    var reorderNodes = function (srcNodes, dstNodes) {
        var remap = new Map();
        // no Set(dstNodes) for IE11 :(
        dstNodes.forEach(function (entity) { return remap.set(entity.node, entity); });
        // remap to dstNodes
        return srcNodes.map(function (node) { return remap.get(node); }).filter(isDefined);
    };
    /**
     * given top node(s) and the last active element return the element to be focused next
     * @param topNode
     * @param lastNode
     */
    var getFocusMerge = function (topNode, lastNode) {
        var activeElement = getActiveElement(asArray(topNode).length > 0 ? document : getFirst(topNode).ownerDocument);
        var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);
        var commonParent = getTopCommonParent(activeElement || topNode, topNode, entries);
        var visibilityCache = new Map();
        var anyFocusable = getAllTabbableNodes(entries, visibilityCache);
        var innerElements = getTabbableNodes(entries, visibilityCache).filter(function (_a) {
            var node = _a.node;
            return isNotAGuard(node);
        });
        if (!innerElements[0]) {
            innerElements = anyFocusable;
            if (!innerElements[0]) {
                return undefined;
            }
        }
        var outerNodes = getAllTabbableNodes([commonParent], visibilityCache).map(function (_a) {
            var node = _a.node;
            return node;
        });
        var orderedInnerElements = reorderNodes(outerNodes, innerElements);
        var innerNodes = orderedInnerElements.map(function (_a) {
            var node = _a.node;
            return node;
        });
        var newId = newFocus(innerNodes, outerNodes, activeElement, lastNode);
        if (newId === NEW_FOCUS) {
            var focusNode = pickAutofocus(anyFocusable, innerNodes, allParentAutofocusables(entries, visibilityCache));
            if (focusNode) {
                return { node: focusNode };
            }
            else {
                console.warn('focus-lock: cannot find any node to move focus into');
                return undefined;
            }
        }
        if (newId === undefined) {
            return newId;
        }
        return orderedInnerElements[newId];
    };

    /**
     * return list of focusable elements inside a given top node
     * @deprecated use {@link getFocusableIn}. Yep, there is typo in the function name
     */
    var getFocusabledIn = function (topNode) {
        var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);
        var commonParent = getTopCommonParent(topNode, topNode, entries);
        var visibilityCache = new Map();
        var outerNodes = getTabbableNodes([commonParent], visibilityCache, true);
        var innerElements = getTabbableNodes(entries, visibilityCache)
            .filter(function (_a) {
            var node = _a.node;
            return isNotAGuard(node);
        })
            .map(function (_a) {
            var node = _a.node;
            return node;
        });
        return outerNodes.map(function (_a) {
            var node = _a.node, index = _a.index;
            return ({
                node: node,
                index: index,
                lockItem: innerElements.indexOf(node) >= 0,
                guard: isGuard(node),
            });
        });
    };

    var focusOn = function (target, focusOptions) {
        if ('focus' in target) {
            target.focus(focusOptions);
        }
        if ('contentWindow' in target && target.contentWindow) {
            target.contentWindow.focus();
        }
    };
    var guardCount = 0;
    var lockDisabled = false;
    /**
     * Sets focus at a given node. The last focused element will help to determine which element(first or last) should be focused.
     * HTML markers (see {@link import('./constants').FOCUS_AUTO} constants) can control autofocus
     * @param topNode
     * @param lastNode
     * @param options
     */
    var setFocus = function (topNode, lastNode, options) {
        if (options === void 0) { options = {}; }
        var focusable = getFocusMerge(topNode, lastNode);
        if (lockDisabled) {
            return;
        }
        if (focusable) {
            if (guardCount > 2) {
                // tslint:disable-next-line:no-console
                console.error('FocusLock: focus-fighting detected. Only one focus management system could be active. ' +
                    'See https://github.com/theKashey/focus-lock/#focus-fighting');
                lockDisabled = true;
                setTimeout(function () {
                    lockDisabled = false;
                }, 1);
                return;
            }
            guardCount++;
            focusOn(focusable.node, options.focusOptions);
            guardCount--;
        }
    };

    var moveFocusInside = setFocus;
    //

    function deferAction(action) {
      // Hidding setImmediate from Webpack to avoid inserting polyfill
      var _window = window,
          setImmediate = _window.setImmediate;

      if (typeof setImmediate !== 'undefined') {
        setImmediate(action);
      } else {
        setTimeout(action, 1);
      }
    }

    var focusOnBody = function focusOnBody() {
      return document && document.activeElement === document.body;
    };

    var isFreeFocus = function isFreeFocus() {
      return focusOnBody() || focusIsHidden();
    };

    var lastActiveTrap = null;
    var lastActiveFocus = null;
    var lastPortaledElement = null;
    var focusWasOutsideWindow = false;

    var defaultWhitelist = function defaultWhitelist() {
      return true;
    };

    var focusWhitelisted = function focusWhitelisted(activeElement) {
      return (lastActiveTrap.whiteList || defaultWhitelist)(activeElement);
    };

    var recordPortal = function recordPortal(observerNode, portaledElement) {
      lastPortaledElement = {
        observerNode: observerNode,
        portaledElement: portaledElement
      };
    };

    var focusIsPortaledPair = function focusIsPortaledPair(element) {
      return lastPortaledElement && lastPortaledElement.portaledElement === element;
    };

    function autoGuard(startIndex, end, step, allNodes) {
      var lastGuard = null;
      var i = startIndex;

      do {
        var item = allNodes[i];

        if (item.guard) {
          if (item.node.dataset.focusAutoGuard) {
            lastGuard = item;
          }
        } else if (item.lockItem) {
          if (i !== startIndex) {
            // we will tab to the next element
            return;
          }

          lastGuard = null;
        } else {
          break;
        }
      } while ((i += step) !== end);

      if (lastGuard) {
        lastGuard.node.tabIndex = 0;
      }
    }

    var extractRef = function extractRef(ref) {
      return ref && 'current' in ref ? ref.current : ref;
    };

    var focusWasOutside = function focusWasOutside(crossFrameOption) {
      if (crossFrameOption) {
        // with cross frame return true for any value
        return Boolean(focusWasOutsideWindow);
      } // in other case return only of focus went a while aho


      return focusWasOutsideWindow === 'meanwhile';
    };

    var checkInHost = function checkInHost(check, el, boundary) {
      return el && ( // find host equal to active element and check nested active element
      el.host === check && (!el.activeElement || boundary.contains(el.activeElement)) // dive up
      || el.parentNode && checkInHost(check, el.parentNode, boundary));
    };

    var withinHost = function withinHost(activeElement, workingArea) {
      return workingArea.some(function (area) {
        return checkInHost(activeElement, area, area);
      });
    };

    var activateTrap = function activateTrap() {
      var result = false;

      if (lastActiveTrap) {
        var _lastActiveTrap = lastActiveTrap,
            observed = _lastActiveTrap.observed,
            persistentFocus = _lastActiveTrap.persistentFocus,
            autoFocus = _lastActiveTrap.autoFocus,
            shards = _lastActiveTrap.shards,
            crossFrame = _lastActiveTrap.crossFrame,
            focusOptions = _lastActiveTrap.focusOptions;
        var workingNode = observed || lastPortaledElement && lastPortaledElement.portaledElement;
        var activeElement = document && document.activeElement;

        if (workingNode) {
          var workingArea = [workingNode].concat(shards.map(extractRef).filter(Boolean));

          if (!activeElement || focusWhitelisted(activeElement)) {
            if (persistentFocus || focusWasOutside(crossFrame) || !isFreeFocus() || !lastActiveFocus && autoFocus) {
              if (workingNode && !( // active element is "inside" working area
              focusInside(workingArea) || // check for shadow-dom contained elements
              activeElement && withinHost(activeElement, workingArea) || focusIsPortaledPair(activeElement))) {
                if (document && !lastActiveFocus && activeElement && !autoFocus) {
                  // Check if blur() exists, which is missing on certain elements on IE
                  if (activeElement.blur) {
                    activeElement.blur();
                  }

                  document.body.focus();
                } else {
                  result = moveFocusInside(workingArea, lastActiveFocus, {
                    focusOptions: focusOptions
                  });
                  lastPortaledElement = {};
                }
              }

              focusWasOutsideWindow = false;
              lastActiveFocus = document && document.activeElement;
            }
          }

          if (document) {
            var newActiveElement = document && document.activeElement;
            var allNodes = getFocusabledIn(workingArea);
            var focusedIndex = allNodes.map(function (_ref) {
              var node = _ref.node;
              return node;
            }).indexOf(newActiveElement);

            if (focusedIndex > -1) {
              // remove old focus
              allNodes.filter(function (_ref2) {
                var guard = _ref2.guard,
                    node = _ref2.node;
                return guard && node.dataset.focusAutoGuard;
              }).forEach(function (_ref3) {
                var node = _ref3.node;
                return node.removeAttribute('tabIndex');
              });
              autoGuard(focusedIndex, allNodes.length, +1, allNodes);
              autoGuard(focusedIndex, -1, -1, allNodes);
            }
          }
        }
      }

      return result;
    };

    var onTrap = function onTrap(event) {
      if (activateTrap() && event) {
        // prevent scroll jump
        event.stopPropagation();
        event.preventDefault();
      }
    };

    var onBlur = function onBlur() {
      return deferAction(activateTrap);
    };

    var onFocus = function onFocus(event) {
      // detect portal
      var source = event.target;
      var currentNode = event.currentTarget;

      if (!currentNode.contains(source)) {
        recordPortal(currentNode, source);
      }
    };

    var FocusWatcher = function FocusWatcher() {
      return null;
    };

    process.env.NODE_ENV !== "production" ? {
      children: PropTypes.node.isRequired
    } : {};

    var onWindowBlur = function onWindowBlur() {
      focusWasOutsideWindow = 'just'; // using setTimeout to set  this variable after React/sidecar reaction

      setTimeout(function () {
        focusWasOutsideWindow = 'meanwhile';
      }, 0);
    };

    var attachHandler = function attachHandler() {
      document.addEventListener('focusin', onTrap);
      document.addEventListener('focusout', onBlur);
      window.addEventListener('blur', onWindowBlur);
    };

    var detachHandler = function detachHandler() {
      document.removeEventListener('focusin', onTrap);
      document.removeEventListener('focusout', onBlur);
      window.removeEventListener('blur', onWindowBlur);
    };

    function reducePropsToState(propsList) {
      return propsList.filter(function (_ref5) {
        var disabled = _ref5.disabled;
        return !disabled;
      });
    }

    function handleStateChangeOnClient(traps) {
      var trap = traps.slice(-1)[0];

      if (trap && !lastActiveTrap) {
        attachHandler();
      }

      var lastTrap = lastActiveTrap;
      var sameTrap = lastTrap && trap && trap.id === lastTrap.id;
      lastActiveTrap = trap;

      if (lastTrap && !sameTrap) {
        lastTrap.onDeactivation(); // return focus only of last trap was removed

        if (!traps.filter(function (_ref6) {
          var id = _ref6.id;
          return id === lastTrap.id;
        }).length) {
          // allow defer is no other trap is awaiting restore
          lastTrap.returnFocus(!trap);
        }
      }

      if (trap) {
        lastActiveFocus = null;

        if (!sameTrap || lastTrap.observed !== trap.observed) {
          trap.onActivation();
        }

        activateTrap();
        deferAction(activateTrap);
      } else {
        detachHandler();
        lastActiveFocus = null;
      }
    } // bind medium


    mediumFocus.assignSyncMedium(onFocus);
    mediumBlur.assignMedium(onBlur);
    mediumEffect.assignMedium(function (cb) {
      return cb({
        moveFocusInside: moveFocusInside,
        focusInside: focusInside
      });
    });
    var FocusTrap = withSideEffect(reducePropsToState, handleStateChangeOnClient)(FocusWatcher);

    /* that would be a BREAKING CHANGE!
    // delaying sidecar execution till the first usage
    const RequireSideCar = (props) => {
      // eslint-disable-next-line global-require
      const SideCar = require('./Trap').default;
      return <SideCar {...props} />;
    };
    */

    var FocusLockCombination = /*#__PURE__*/React.forwardRef(function FocusLockUICombination(props, ref) {
      return /*#__PURE__*/React.createElement(FocusLockUI, _extends$1({
        sideCar: FocusTrap,
        ref: ref
      }, props));
    });

    var _ref = FocusLockUI.propTypes || {};
        _ref.sideCar;
        var propTypes$2 = _objectWithoutPropertiesLoose(_ref, ["sideCar"]);

    FocusLockCombination.propTypes = process.env.NODE_ENV !== "production" ? propTypes$2 : {};
    var FocusLock = FocusLockCombination;

    var __extends$4 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();


    var Portal$1 = /** @class */ (function (_super) {
        __extends$4(Portal, _super);
        function Portal() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.container = null;
            return _this;
        }
        // constructor(props) {
        //   super(props);
        //   const { getContainer } = this.props;
        //   this.container = getContainer && getContainer();
        // }
        Portal.prototype.componentDidMount = function () {
            var _this = this;
            this.createContainer();
            this.timer = setTimeout(function () {
                // getContainer 返回ref时，子组件首先执行 componentDidMount,此时ref还未赋值
                if (!_this.container) {
                    _this.createContainer();
                }
            });
        };
        Portal.prototype.componentWillUnmount = function () {
            clearTimeout(this.timer);
        };
        Portal.prototype.createContainer = function () {
            var getContainer = this.props.getContainer;
            this.container = getContainer && getContainer();
            this.forceUpdate();
        };
        Portal.prototype.render = function () {
            var children = this.props.children;
            if (this.container) {
                return ReactDOM.createPortal(children, this.container);
            }
            return null;
        };
        return Portal;
    }(React.Component));
    var Portal$2 = Portal$1;

    var __extends$3 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$Z = (undefined && undefined.__assign) || function () {
        __assign$Z = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$Z.apply(this, arguments);
    };
    var PortalWrapper = /** @class */ (function (_super) {
        __extends$3(PortalWrapper, _super);
        function PortalWrapper() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PortalWrapper.prototype.componentWillUnmount = function () {
            this.instance = null;
        };
        PortalWrapper.prototype.render = function () {
            var _this = this;
            var _a = this.props, forceRender = _a.forceRender, visible = _a.visible;
            return forceRender || visible || this.instance ? (React.createElement(Portal$2, __assign$Z({ ref: function (ref) { return (_this.instance = ref); } }, this.props))) : null;
        };
        PortalWrapper.displayName = 'Portal';
        PortalWrapper.defaultProps = {
            getContainer: function () { return document.body; },
        };
        return PortalWrapper;
    }(React.Component));
    var Portal = PortalWrapper;

    function useOverflowHidden(getContainer, _a) {
        var hidden = _a.hidden;
        var needResetContainerStyle = React.useRef(false);
        var originContainerStyle = React.useRef({});
        var getScrollBarWidth = function (element) {
            return element.tagName === 'BODY'
                ? window.innerWidth - (document.body.clientWidth || document.documentElement.clientWidth)
                : element.offsetWidth - element.clientWidth;
        };
        var setContainerStyle = function () {
            var container = getContainer();
            if (container && container.style.overflow !== 'hidden') {
                var originStyle = container.style;
                needResetContainerStyle.current = true;
                // 记录并设置宽度
                var containerScrollBarWidth = getScrollBarWidth(container);
                if (containerScrollBarWidth) {
                    originContainerStyle.current.width = originStyle.width;
                    container.style.width = "calc(" + (container.style.width || '100%') + " - " + containerScrollBarWidth + "px)";
                }
                // 记录并设置overflow
                originContainerStyle.current.overflow = originStyle.overflow;
                container.style.overflow = 'hidden';
            }
        };
        var resetContainerStyle = function () {
            if (needResetContainerStyle.current && getContainer()) {
                var container_1 = getContainer();
                var originStyle_1 = originContainerStyle.current;
                Object.keys(originStyle_1).forEach(function (i) { return (container_1.style[i] = originStyle_1[i]); });
            }
            needResetContainerStyle.current = false;
            originContainerStyle.current = {};
        };
        React.useEffect(function () {
            hidden ? setContainerStyle() : resetContainerStyle();
            return function () {
                resetContainerStyle();
            };
        }, [getContainer, hidden]);
        return [resetContainerStyle, setContainerStyle];
    }

    var __assign$Y = (undefined && undefined.__assign) || function () {
        __assign$Y = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$Y.apply(this, arguments);
    };
    var __rest$o = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$G = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var defaultProps$k = {
        placement: 'right',
        width: 250,
        height: 250,
        escToExit: true,
        mask: true,
        closable: true,
        maskClosable: true,
        mountOnEnter: true,
        getPopupContainer: function () { return document.body; },
    };
    function Drawer(baseProps, ref) {
        var _a, _b, _c, _d;
        var context = React.useContext(ConfigContext);
        var locale = context.locale, getPrefixCls = context.getPrefixCls, componentConfig = context.componentConfig, rtl = context.rtl;
        var props = useMergeProps(baseProps, defaultProps$k, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Drawer);
        var style = props.style, className = props.className, children = props.children, wrapClassName = props.wrapClassName, maskStyle = props.maskStyle, headerStyle = props.headerStyle, bodyStyle = props.bodyStyle, title = props.title, footer = props.footer, okText = props.okText, cancelText = props.cancelText, width = props.width, height = props.height, placement = props.placement, mask = props.mask, visible = props.visible, closable = props.closable, maskClosable = props.maskClosable, confirmLoading = props.confirmLoading, mountOnEnter = props.mountOnEnter, unmountOnExit = props.unmountOnExit, afterOpen = props.afterOpen, afterClose = props.afterClose, getPopupContainer = props.getPopupContainer, escToExit = props.escToExit, propGetChildrenPopupContainer = props.getChildrenPopupContainer, focusLock = props.focusLock, autoFocus = props.autoFocus, okButtonProps = props.okButtonProps, cancelButtonProps = props.cancelButtonProps, zIndex = props.zIndex, rest = __rest$o(props, ["style", "className", "children", "wrapClassName", "maskStyle", "headerStyle", "bodyStyle", "title", "footer", "okText", "cancelText", "width", "height", "placement", "mask", "visible", "closable", "maskClosable", "confirmLoading", "mountOnEnter", "unmountOnExit", "afterOpen", "afterClose", "getPopupContainer", "escToExit", "getChildrenPopupContainer", "focusLock", "autoFocus", "okButtonProps", "cancelButtonProps", "zIndex"]);
        var drawerWrapperRef = React.useRef(null);
        var contentWrapperRef = React.useRef(null);
        var _e = __read$G(React.useState(false), 2), shouldReComputeFixed = _e[0], setShouldReComputeFixed = _e[1];
        var _f = __read$G(React.useState(), 2), popupZIndex = _f[0], setPopupZIndex = _f[1];
        var prefixCls = getPrefixCls('drawer');
        // Record whether is exiting, to prevent `onCancel` being unnecessarily triggered when mask is clicked during the period.
        var inExit = React.useRef(false);
        // Record whether it's opened to avoid element shaking during animation caused by focus lock.
        var _g = __read$G(React.useState(false), 2), isOpened = _g[0], setIsOpened = _g[1];
        var getContainer = React.useCallback(function () {
            var container = getPopupContainer && getPopupContainer();
            return (ReactDOM.findDOMNode(container) || document.body);
        }, [getPopupContainer]);
        var isFixed = React.useMemo(function () {
            return !isServerRendering && getContainer() === document.body;
        }, [shouldReComputeFixed, getContainer]);
        useOverflowHidden(getContainer, { hidden: visible && mask });
        React.useImperativeHandle(ref, function () { return drawerWrapperRef.current; });
        React.useEffect(function () {
            // 初始就是展示，且设置了 getPopupContainer 时，组件挂载后重新执行下 isFixed 的计算逻辑，避免 getPopupContainer 返回的节点还未挂载，导致 isFixed 为true，样式表现错误的问题。
            if (visible && props.getPopupContainer) {
                // Recompute `isFixed` to avoid style error resulting from truthy `isFixed` value due to the custom container dom is not mounted yet.
                setShouldReComputeFixed(true);
            }
        }, []);
        React.useEffect(function () {
            var _a;
            if (visible && popupZIndex === undefined) {
                if (drawerWrapperRef.current) {
                    // Set zIndex for nested drawer components based on zIndex of wrapper
                    var zIndex_1 = +((_a = window.getComputedStyle(drawerWrapperRef.current, null)) === null || _a === void 0 ? void 0 : _a.zIndex);
                    if (!isNaN(zIndex_1)) {
                        setPopupZIndex(zIndex_1 + 1);
                    }
                }
            }
        }, [visible, popupZIndex]);
        React.useEffect(function () {
            var onKeyDown = function (e) {
                if (escToExit && e && e.key === Esc.key && props.onCancel) {
                    props.onCancel(e);
                }
            };
            if (visible) {
                on(document, 'keydown', onKeyDown);
            }
            return function () {
                off(document, 'keydown', onKeyDown);
            };
        }, [visible, escToExit]);
        var element = (React.createElement("div", { className: prefixCls + "-scroll" },
            title !== null && (React.createElement("div", { className: prefixCls + "-header", style: headerStyle },
                React.createElement("div", { className: prefixCls + "-header-title" }, title))),
            closable && (React.createElement(IconHover, { onClick: props.onCancel, className: prefixCls + "-close-icon" },
                React.createElement(IconClose$1, null))),
            React.createElement("div", { ref: contentWrapperRef, style: bodyStyle, className: cs(prefixCls + "-content", (_a = {},
                    _a[prefixCls + "-content-nofooter"] = footer === null,
                    _a[prefixCls + "-content-noheader"] = title === null,
                    _a)) },
                React.createElement(ConfigProvider, __assign$Y({}, context, { zIndex: popupZIndex || 1050, getPopupContainer: function (node) {
                        return typeof propGetChildrenPopupContainer === 'function'
                            ? propGetChildrenPopupContainer(node)
                            : contentWrapperRef.current;
                    } }), children)),
            footer !== null &&
                (footer ? (React.createElement("div", { className: prefixCls + "-footer" }, footer)) : (React.createElement("div", { className: prefixCls + "-footer" },
                    React.createElement(Button$3, __assign$Y({ onClick: props.onCancel }, cancelButtonProps), cancelText || locale.Drawer.cancelText),
                    React.createElement(Button$3, __assign$Y({ type: "primary", loading: confirmLoading, onClick: props.onOk }, okButtonProps), okText || locale.Drawer.okText))))));
        var globalFocusLockConfig = context.focusLock.drawer;
        var globalFocusLock = !!globalFocusLockConfig;
        var globalAutoFocus = isObject$1(globalFocusLockConfig) && globalFocusLockConfig.autoFocus;
        var innerFocusLock = focusLock !== undefined ? focusLock : globalFocusLock;
        var innerAutoFocus = autoFocus !== undefined ? autoFocus : globalAutoFocus;
        // Only enable FocusLock when drawer is fully opened, to avoid element shaking.
        var dom = innerFocusLock ? (React.createElement(FocusLock, { as: "span", disabled: !isOpened, crossFrame: false, autoFocus: innerAutoFocus }, element)) : (element);
        return (React.createElement(Portal, { forceRender: !mountOnEnter, visible: visible, getContainer: getPopupContainer },
            React.createElement("div", __assign$Y({}, omit$1(rest, ['onCancel', 'onOk']), { ref: drawerWrapperRef, className: cs(prefixCls + "-wrapper", (_b = {},
                    _b[prefixCls + "-no-mask"] = !mask,
                    _b[prefixCls + "-wrapper-hide"] = !visible,
                    _b), wrapClassName), style: isFixed
                    ? { position: 'fixed', zIndex: zIndex }
                    : { zIndex: zIndex || 'inherit', position: 'absolute' } }),
                mask ? (React.createElement(CSSTransition$1, { in: visible, appear: true, timeout: 300, classNames: "fadeInStandard", mountOnEnter: mountOnEnter, unmountOnExit: unmountOnExit },
                    React.createElement("div", { className: prefixCls + "-mask", style: maskStyle, onClick: function (e) {
                            if (!inExit.current && maskClosable) {
                                props.onCancel && props.onCancel(e);
                            }
                        } }))) : null,
                React.createElement(CSSTransition$1, { in: visible, appear: true, timeout: 300, classNames: {
                        top: 'slideTop',
                        bottom: 'slideBottom',
                        left: 'slideLeft',
                        right: 'slideRight',
                    }[placement], mountOnEnter: mountOnEnter, unmountOnExit: unmountOnExit, onEnter: function (e) {
                        e.parentNode.style.display = 'block';
                        inExit.current = false;
                    }, onEntered: function () {
                        setIsOpened(true);
                        afterOpen && afterOpen();
                    }, onExit: function () {
                        setIsOpened(false);
                        inExit.current = true;
                    }, onExited: function (e) {
                        inExit.current = false;
                        e.parentNode.style.display = ''; // don't set display='none'
                        afterClose && afterClose();
                    } },
                    React.createElement("div", { className: cs(prefixCls, className, (_c = {}, _c[prefixCls + "-rtl"] = rtl, _c)), style: Object.assign(placement === 'left' || placement === 'right' ? { width: width } : { height: height }, (_d = {}, _d[placement] = 0, _d), style) },
                        React.createElement("div", { className: prefixCls + "-inner" },
                            React.createElement(ConfigProvider, __assign$Y({}, context, { zIndex: popupZIndex || 1050 }), dom)))))));
    }
    var DrawerComponent = React.forwardRef(Drawer);
    DrawerComponent.displayName = 'Drawer';
    var Drawer$1 = DrawerComponent;

    var RowContext = React.createContext({});

    var __assign$X = (undefined && undefined.__assign) || function () {
        __assign$X = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$X.apply(this, arguments);
    };
    var __rest$n = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var defaultProps$j = {
        span: 24,
    };
    function getFlexString(flex) {
        if (typeof flex === 'string' && /\d+[px|%|em|rem|]{1}/.test(flex)) {
            return "0 0 " + flex;
        }
        return flex;
    }
    function Col(baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$j, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig['Grid.Col']);
        var _c = React.useContext(RowContext), gutter = _c.gutter, div = _c.div;
        var className = props.className, style = props.style, children = props.children, span = props.span, offset = props.offset, order = props.order, pull = props.pull, push = props.push, xs = props.xs, sm = props.sm, md = props.md, lg = props.lg, xl = props.xl, xxl = props.xxl, xxxl = props.xxxl, flex = props.flex, rest = __rest$n(props, ["className", "style", "children", "span", "offset", "order", "pull", "push", "xs", "sm", "md", "lg", "xl", "xxl", "xxxl", "flex"]);
        function adaptationGrid(prefixCls, mergeClassName) {
            var screenList = { xs: xs, sm: sm, md: md, lg: lg, xl: xl, xxl: xxl, xxxl: xxxl };
            Object.keys(screenList).forEach(function (screen) {
                var screenValue = screenList[screen];
                if (isNumber(screenValue)) {
                    if (screenValue >= 0) {
                        mergeClassName[prefixCls + "-" + screen + "-" + screenValue] = true;
                    }
                }
                else if (isObject$1(screenValue)) {
                    mergeClassName[prefixCls + "-" + screen + "-" + screenValue.span] = screenValue.span;
                    mergeClassName[prefixCls + "-" + screen + "-offset-" + screenValue.offset] = screenValue.offset;
                    mergeClassName[prefixCls + "-" + screen + "-order-" + screenValue.order] = screenValue.order;
                    mergeClassName[prefixCls + "-" + screen + "-pull-" + screenValue.pull] = screenValue.pull;
                    mergeClassName[prefixCls + "-" + screen + "-push-" + screenValue.push] = screenValue.push;
                }
            });
            return mergeClassName;
        }
        var prefixCls = getPrefixCls('col');
        var mergeClassName = (_a = {},
            _a["" + prefixCls] = !div,
            _a[prefixCls + "-order-" + order] = order,
            _a[prefixCls + "-" + span] = !div && !xs && !sm && !md && !lg && !xl && !xxl && !xxxl,
            _a[prefixCls + "-offset-" + offset] = offset,
            _a[prefixCls + "-pull-" + pull] = pull,
            _a[prefixCls + "-push-" + push] = push,
            _a[prefixCls + "-rtl"] = rtl,
            _a);
        mergeClassName = adaptationGrid(prefixCls, mergeClassName);
        var classNames = cs(flex ? prefixCls : mergeClassName, className);
        var paddingStyle = {};
        if (Array.isArray(gutter) && !div) {
            var paddingHorizontal = (gutter[0] && gutter[0] / 2) || 0;
            var paddingVertical = (gutter[1] && gutter[1] / 2) || 0;
            if (paddingHorizontal) {
                paddingStyle.paddingLeft = paddingHorizontal;
                paddingStyle.paddingRight = paddingHorizontal;
            }
            if (paddingVertical) {
                paddingStyle.paddingTop = paddingVertical;
                paddingStyle.paddingBottom = paddingVertical;
            }
        }
        var flexStyle = React.useMemo(function () { return (getFlexString(flex) ? { flex: getFlexString(flex) } : {}); }, [flex]);
        return (React.createElement("div", __assign$X({ ref: ref }, rest, { style: __assign$X(__assign$X(__assign$X({}, style), paddingStyle), flexStyle), className: classNames }), children));
    }
    var ColComponent = React.forwardRef(Col);
    ColComponent.displayName = 'Col';
    var Col$1 = ColComponent;

    var __assign$W = (undefined && undefined.__assign) || function () {
        __assign$W = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$W.apply(this, arguments);
    };
    var __rest$m = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$F = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var defaultProps$i = {
        gutter: 0,
        align: 'start',
        justify: 'start',
    };
    function Row$1(baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$i, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig['Grid.Row']);
        var className = props.className, style = props.style, children = props.children, div = props.div, align = props.align, justify = props.justify, gutter = props.gutter, rest = __rest$m(props, ["className", "style", "children", "div", "align", "justify", "gutter"]);
        var _c = __read$F(React.useState({
            xs: true,
            sm: true,
            md: true,
            lg: true,
            xl: true,
            xxl: true,
            xxxl: true,
        }), 2), screens = _c[0], setScreens = _c[1];
        var token = React.useRef();
        React.useEffect(function () {
            token.current = ResponsiveObserve.subscribe(function (screens) {
                // Responsive Gutter
                if ((!Array.isArray(gutter) && typeof gutter === 'object') ||
                    (Array.isArray(gutter) && (typeof gutter[0] === 'object' || typeof gutter[1] === 'object'))) {
                    setScreens(screens);
                }
            });
            return function () {
                ResponsiveObserve.unsubscribe(token.current);
            };
        }, []);
        function getGutter(gutter) {
            var result = 0;
            if (typeof gutter === 'object') {
                for (var i = 0; i < responsiveArray.length; i++) {
                    var breakpoint = responsiveArray[i];
                    if (screens[breakpoint] && gutter[breakpoint] !== undefined) {
                        result = gutter[breakpoint];
                        break;
                    }
                }
            }
            else {
                result = gutter;
            }
            return result;
        }
        var prefixCls = getPrefixCls('row');
        var classNames = cs((_a = {},
            _a["" + prefixCls] = !div,
            _a[prefixCls + "-align-" + align] = align,
            _a[prefixCls + "-justify-" + justify] = justify,
            _a[prefixCls + "-rtl"] = rtl,
            _a), className);
        var marginStyle = {};
        var gutterHorizontal = getGutter(Array.isArray(gutter) ? gutter[0] : gutter);
        var gutterVertical = getGutter(Array.isArray(gutter) ? gutter[1] : 0);
        if ((gutterHorizontal || gutterVertical) && !div) {
            var marginHorizontal = -gutterHorizontal / 2;
            var marginVertical = -gutterVertical / 2;
            if (marginHorizontal) {
                marginStyle.marginLeft = marginHorizontal;
                marginStyle.marginRight = marginHorizontal;
            }
            if (marginVertical) {
                marginStyle.marginTop = marginVertical;
                marginStyle.marginBottom = marginVertical;
            }
        }
        return (React.createElement("div", __assign$W({ ref: ref }, omit$1(rest, ['gutter']), { style: __assign$W(__assign$W({}, style), marginStyle), className: classNames }),
            React.createElement(RowContext.Provider, { value: { gutter: [gutterHorizontal, gutterVertical], div: div } }, children)));
    }
    var RowComponent = React.forwardRef(Row$1);
    RowComponent.displayName = 'Row';
    var Row$2 = RowComponent;

    function ownKeys$o(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$p(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$o(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$o(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconQuestionCircleComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$p(_objectSpread$p({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-question-circle")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M42 24c0 9.941-8.059 18-18 18S6 33.941 6 24 14.059 6 24 6s18 8.059 18 18Z"
      }), /*#__PURE__*/React.createElement("path", {
        d: "M24.006 31v4.008m0-6.008L24 28c0-3 3-4 4.78-6.402C30.558 19.195 28.288 15 23.987 15c-4.014 0-5.382 2.548-5.388 4.514v.465"
      }));
    }

    var IconQuestionCircle = /*#__PURE__*/React.forwardRef(IconQuestionCircleComponent);
    IconQuestionCircle.defaultProps = {
      isIcon: true
    };
    IconQuestionCircle.displayName = 'IconQuestionCircle';
    var IconQuestionCircle$1 = IconQuestionCircle;

    function ownKeys$n(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$o(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$n(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$n(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconPlusComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$o(_objectSpread$o({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-plus")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M5 24h38M24 5v38"
      }));
    }

    var IconPlus = /*#__PURE__*/React.forwardRef(IconPlusComponent);
    IconPlus.defaultProps = {
      isIcon: true
    };
    IconPlus.displayName = 'IconPlus';
    var IconPlus$1 = IconPlus;

    function ownKeys$m(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$n(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$m(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$m(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconMinusComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$n(_objectSpread$n({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-minus")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M5 24h38"
      }));
    }

    var IconMinus = /*#__PURE__*/React.forwardRef(IconMinusComponent);
    IconMinus.defaultProps = {
      isIcon: true
    };
    IconMinus.displayName = 'IconMinus';
    var IconMinus$1 = IconMinus;

    function useSelectionRange(_a) {
        var inputElement = _a.inputElement, inputValue = _a.inputValue;
        // Selection position from the tail (e.g. 1234|56, this value will be 2)
        var refSelectionPosition = React.useRef(null);
        useIsomorphicLayoutEffect$1(function () {
            try {
                var position = refSelectionPosition.current;
                if (inputElement && inputValue && isNumber(position)) {
                    var start = Math.max(0, inputValue.length - position);
                    inputElement.setSelectionRange(start, start);
                }
            }
            catch (err) {
                console.warn('Failed to reset input selection range position', err);
            }
        }, [inputValue]);
        return function (event) {
            var _a = event.target, end = _a.selectionEnd, value = _a.value;
            if (isNumber(end)) {
                refSelectionPosition.current = value.length - end;
            }
        };
    }

    var __read$E = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    /**
     * Judge whether a number is scientific notation
     */
    function isE(number) {
        return !Number.isNaN(Number(number)) && String(number).includes('e');
    }
    /**
     * Get precision of a number, include scientific notation like 1e-10
     */
    function getNumberPrecision(number) {
        var numStr = String(number);
        if (isE(number)) {
            var precision_1 = Number(numStr.slice(numStr.indexOf('e-') + 2));
            numStr.replace(/\.(\d+)/, function (_, $1) {
                precision_1 += $1.length;
                return _;
            });
            return precision_1;
        }
        return numStr.includes('.') && validateNumber(numStr)
            ? numStr.length - numStr.indexOf('.') - 1
            : 0;
    }
    /**
     * Convert number to non-scientific notation
     */
    function toSafeString(number) {
        var nativeNumberStr = String(number);
        if (isE(number)) {
            if (number < Number.MIN_SAFE_INTEGER || number > Number.MAX_SAFE_INTEGER) {
                return BigInt(number).toString();
            }
            // This may lose precision, but foFixed must accept argument in the range 0-100
            var precision = getNumberPrecision(nativeNumberStr);
            nativeNumberStr = Number(number).toFixed(Math.min(100, precision));
        }
        return trimNumber(nativeNumberStr).fullStr;
    }
    /**
     * Judge whether a number is valid
     */
    function validateNumber(num) {
        if (typeof num === 'number') {
            return !Number.isNaN(num);
        }
        if (!num) {
            return false;
        }
        return (
        // 1.1
        /^\s*-?\d+(\.\d+)?\s*$/.test(num) ||
            // 1.
            /^\s*-?\d+\.\s*$/.test(num) ||
            // .1
            /^\s*-?\.\d+\s*$/.test(num));
    }
    function trimNumber(numStr) {
        var str = numStr.trim();
        var negative = false;
        str = str
            // Remove negative-label(-) at head.
            .replace(/^-/, function () {
            negative = true;
            return '';
        })
            // Remove useless 0 at decimal end. `1.00100` => `1.001`
            .replace(/(\.\d*[^0])0*$/, '$1')
            // Remove useless decimal.
            .replace(/\.0*$/, '')
            // Remove useless 0 at head.
            .replace(/^0+/, '')
            // Add 0 before empty dot. `.1` => `0.1`
            .replace(/^\./, '0.');
        var trimStr = str || '0';
        var _a = __read$E(trimStr.split('.'), 2), _b = _a[0], integerStr = _b === void 0 ? '0' : _b, _c = _a[1], decimalStr = _c === void 0 ? '0' : _c;
        if (integerStr === '0' && decimalStr === '0') {
            negative = false;
        }
        var negativeStr = negative ? '-' : '';
        return {
            negative: negative,
            negativeStr: negativeStr,
            trimStr: trimStr,
            integerStr: integerStr,
            decimalStr: decimalStr,
            fullStr: "" + negativeStr + trimStr,
        };
    }

    var __read$D = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var Decimal = /** @class */ (function () {
        function Decimal(value) {
            this.origin = '';
            this.origin = String(value);
            if ((!value && value !== 0) || !this.origin.trim()) {
                this.isEmpty = true;
                return;
            }
            if (value === '-') {
                this.isNaN = true;
                return;
            }
            var safeValueString = toSafeString(value);
            if (validateNumber(safeValueString)) {
                var _a = trimNumber(safeValueString), negative = _a.negative, trimStr = _a.trimStr;
                var _b = __read$D(trimStr.split('.'), 2), integerStr = _b[0], _c = _b[1], decimalStr = _c === void 0 ? '0' : _c;
                this.isNegative = negative;
                this.integer = BigInt(integerStr);
                this.decimal = BigInt(decimalStr);
                this.decimalLen = decimalStr.length;
            }
            else {
                this.isNaN = true;
            }
        }
        Decimal.from = function (value) {
            return new Decimal(value);
        };
        Object.defineProperty(Decimal.prototype, "isInvalid", {
            get: function () {
                return this.isEmpty || this.isNaN;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Decimal.prototype, "mark", {
            get: function () {
                return this.isNegative ? '-' : '';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Decimal.prototype, "integerStr", {
            get: function () {
                return this.integer.toString();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Decimal.prototype, "decimalStr", {
            get: function () {
                return this.decimal.toString().padStart(this.decimalLen, '0');
            },
            enumerable: false,
            configurable: true
        });
        Decimal.prototype.alignDecimal = function (decimalLength) {
            return BigInt("" + this.mark + this.integerStr + this.decimalStr.padEnd(decimalLength, '0'));
        };
        Decimal.prototype.negate = function () {
            var clone = new Decimal(this.toString());
            clone.isNegative = !clone.isNegative;
            return clone;
        };
        Decimal.prototype.add = function (value) {
            var offset = new Decimal(value);
            if (offset.isInvalid) {
                return this;
            }
            if (this.isInvalid) {
                return offset;
            }
            var maxDecimalLength = Math.max(this.decimalLen, offset.decimalLen);
            var thisAlignedDecimal = this.alignDecimal(maxDecimalLength);
            var offsetAlignedDecimal = offset.alignDecimal(maxDecimalLength);
            var valueStr = (thisAlignedDecimal + offsetAlignedDecimal).toString();
            var _a = trimNumber(valueStr), negativeStr = _a.negativeStr, trimStr = _a.trimStr;
            var hydrateValueStr = "" + negativeStr + trimStr.padStart(maxDecimalLength + 1, '0');
            return new Decimal(hydrateValueStr.slice(0, -maxDecimalLength) + "." + hydrateValueStr.slice(-maxDecimalLength));
        };
        Decimal.prototype.equals = function (target) {
            return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());
        };
        Decimal.prototype.less = function (target) {
            return this.isInvalid || target.isInvalid
                ? false
                : this.add(target.negate().toString()).toNumber() < 0;
        };
        Decimal.prototype.toNumber = function () {
            return this.isNaN ? NaN : Number(this.toString());
        };
        Decimal.prototype.toString = function (options) {
            if (options === void 0) { options = { safe: true }; }
            var safe = options.safe, precision = options.precision;
            var result = safe
                ? this.isInvalid
                    ? ''
                    : trimNumber("" + this.mark + this.integerStr + "." + this.decimalStr).fullStr
                : this.origin;
            return typeof precision === 'number' ? Decimal.toFixed(result, precision) : result;
        };
        /**
         * Replace String.prototype.toFixed like Math.round
         * If cutOnly is true, just slice the tail
         * e.g. Decimal.toFixed(0.15) will return 0.2, not 0.1
         */
        Decimal.toFixed = function (numStr, precision, cutOnly) {
            if (cutOnly === void 0) { cutOnly = false; }
            if (numStr === '') {
                return '';
            }
            var separator = '.';
            var _a = trimNumber(numStr), negativeStr = _a.negativeStr, integerStr = _a.integerStr, decimalStr = _a.decimalStr;
            var precisionDecimalStr = "" + separator + decimalStr;
            var numberWithoutDecimal = "" + negativeStr + integerStr;
            if (precision >= 0) {
                var advancedNum = Number(decimalStr[precision]);
                if (advancedNum >= 5 && !cutOnly) {
                    var advancedDecimal = Decimal.from(numStr).add(negativeStr + "0." + '0'.repeat(precision) + (10 - advancedNum));
                    return Decimal.toFixed(advancedDecimal.toString(), precision, cutOnly);
                }
                return precision === 0
                    ? numberWithoutDecimal
                    : "" + numberWithoutDecimal + separator + decimalStr
                        .padEnd(precision, '0')
                        .slice(0, precision);
            }
            return "" + numberWithoutDecimal + (precisionDecimalStr === '.0' ? '' : precisionDecimalStr);
        };
        return Decimal;
    }());

    var __assign$V = (undefined && undefined.__assign) || function () {
        __assign$V = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$V.apply(this, arguments);
    };
    var __rest$l = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$C = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    // Value's auto change speed when user holds on plus or minus
    var AUTO_CHANGE_INTERVAL = 200;
    // Delay to auto change value when user holds on plus or minus
    var AUTO_CHANGE_START_DELAY = 1000;
    var defaultProps$h = {
        max: Infinity,
        min: -Infinity,
        step: 1,
        mode: 'embed',
        parser: function (input) { return input.replace(/[^\w\.-]+/g, ''); },
    };
    function InputNumber$1(baseProps, ref) {
        var _a;
        var _b;
        var _c = React.useContext(ConfigContext), getPrefixCls = _c.getPrefixCls, ctxSize = _c.size, componentConfig = _c.componentConfig;
        var props = useMergeProps(baseProps, defaultProps$h, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.InputNumber);
        var className = props.className, style = props.style, defaultValue = props.defaultValue, disabled = props.disabled, error = props.error, readOnly = props.readOnly, strictMode = props.strictMode, placeholder = props.placeholder, hideControl = props.hideControl, suffix = props.suffix, prefix = props.prefix, icons = props.icons, mode = props.mode, size = props.size, step = props.step, precision = props.precision, min = props.min, max = props.max, parser = props.parser, formatter = props.formatter, onBlur = props.onBlur, onFocus = props.onFocus, onChange = props.onChange, onKeyDown = props.onKeyDown, rest = __rest$l(props, ["className", "style", "defaultValue", "disabled", "error", "readOnly", "strictMode", "placeholder", "hideControl", "suffix", "prefix", "icons", "mode", "size", "step", "precision", "min", "max", "parser", "formatter", "onBlur", "onFocus", "onChange", "onKeyDown"]);
        var prefixCls = getPrefixCls('input-number');
        var mergedSize = size || ctxSize;
        var mergedPrecision = (function () {
            if (isNumber(precision)) {
                var decimal = ("" + step).split('.')[1];
                var stepPrecision = (decimal && decimal.length) || 0;
                return Math.max(stepPrecision, precision);
            }
            return null;
        })();
        var _d = __read$C(React.useState(function () {
            return Decimal.from('value' in props ? props.value : 'defaultValue' in props ? defaultValue : undefined);
        }), 2), innerValue = _d[0], setInnerValue = _d[1];
        var _e = __read$C(React.useState(''), 2), inputValue = _e[0], setInputValue = _e[1];
        var _f = __read$C(React.useState(false), 2), isOutOfRange = _f[0], setIsOutOfRange = _f[1];
        var _g = __read$C(React.useState(false), 2), isUserTyping = _g[0], setIsUserTyping = _g[1];
        var refAutoTimer = React.useRef(null);
        var refInput = React.useRef(null);
        // Ref to keep track of whether user has taken operations since the last change of prop value
        var refHasOperateSincePropValueChanged = React.useRef(false);
        var value = React.useMemo(function () {
            return 'value' in props ? Decimal.from(props.value) : innerValue;
        }, [props.value, innerValue]);
        var _h = __read$C(React.useMemo(function () {
            return [Decimal.from(max), Decimal.from(min)];
        }, [max, min]), 2), maxDecimal = _h[0], minDecimal = _h[1];
        React.useImperativeHandle(ref, function () { return refInput.current; }, []);
        var setValue = function (newValue) {
            setInnerValue(newValue);
            if (!newValue.equals(value) && onChange) {
                var newValueStr = newValue.toString({ safe: true, precision: mergedPrecision });
                onChange(newValue.isEmpty
                    ? undefined
                    : strictMode
                        ? newValueStr
                        : newValue.isNaN
                            ? NaN
                            : Number(newValueStr));
            }
        };
        var stop = function () {
            refAutoTimer.current && clearTimeout(refAutoTimer.current);
            refAutoTimer.current = null;
        };
        var getLegalValue = React.useCallback(function (changedValue) {
            var finalValue = changedValue;
            if (finalValue.less(minDecimal)) {
                finalValue = minDecimal;
            }
            else if (maxDecimal.less(finalValue)) {
                finalValue = maxDecimal;
            }
            return finalValue;
        }, [minDecimal, maxDecimal]);
        React.useEffect(function () {
            return function () { return stop(); };
        }, []);
        React.useEffect(function () {
            refHasOperateSincePropValueChanged.current = false;
        }, [props.value]);
        React.useEffect(function () {
            var _isOutOfRange = value.less(minDecimal) || maxDecimal.less(value);
            // Don't correct the illegal value caused by prop value. Wait for user to take actions.
            if (_isOutOfRange && refHasOperateSincePropValueChanged.current) {
                setValue(getLegalValue(value));
            }
            setIsOutOfRange(_isOutOfRange);
        }, [minDecimal, maxDecimal, value, getLegalValue]);
        var handleArrowKey = function (event, method, needRepeat) {
            if (needRepeat === void 0) { needRepeat = false; }
            event.persist();
            event.preventDefault();
            setIsUserTyping(false);
            if (disabled || readOnly) {
                return;
            }
            var finalValue = value.isInvalid
                ? Decimal.from(min === -Infinity ? 0 : min)
                : value.add(method === 'plus' ? step : -step);
            setValue(getLegalValue(finalValue));
            refInput.current && refInput.current.focus();
            // auto change while holding
            if (needRepeat) {
                var isFirstRepeat = refAutoTimer.current === null;
                refAutoTimer.current = setTimeout(function () { return event.target.dispatchEvent(event.nativeEvent); }, isFirstRepeat ? AUTO_CHANGE_START_DELAY : AUTO_CHANGE_INTERVAL);
            }
        };
        var displayedInputValue = React.useMemo(function () {
            var _value;
            if (isUserTyping) {
                _value = parser ? "" + parser(inputValue) : inputValue;
            }
            else if (isNumber(mergedPrecision)) {
                _value = value.toString({ safe: true, precision: mergedPrecision });
            }
            else if (value.isInvalid) {
                _value = '';
            }
            else {
                _value = value.toString();
            }
            return formatter ? formatter(_value, { userTyping: isUserTyping, input: inputValue }) : _value;
        }, [value, inputValue, isUserTyping, mergedPrecision, parser, formatter]);
        var updateSelectionRangePosition = useSelectionRange({
            inputElement: (_b = refInput.current) === null || _b === void 0 ? void 0 : _b.dom,
            inputValue: displayedInputValue,
        });
        var inputEventHandlers = {
            onChange: function (rawText, event) {
                setIsUserTyping(true);
                rawText = rawText.trim().replace(/。/g, '.');
                var parsedValue = parser ? parser(rawText) : rawText;
                if (isNumber(+parsedValue) || parsedValue === '-' || !parsedValue || parsedValue === '.') {
                    setInputValue(rawText);
                    setValue(getLegalValue(Decimal.from(parsedValue)));
                    updateSelectionRangePosition(event);
                }
            },
            onKeyDown: function (e) {
                e.stopPropagation();
                var key = e.key;
                if (key === ArrowDown.key) {
                    handleArrowKey(e, 'minus');
                }
                else if (key === ArrowUp.key) {
                    handleArrowKey(e, 'plus');
                }
                stop();
                onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e);
            },
            onFocus: function (e) {
                var _a, _b;
                // Both tab and button click trigger focus event. This can be used to determine whether user has taken operations
                refHasOperateSincePropValueChanged.current = true;
                setInputValue((_b = (_a = refInput.current) === null || _a === void 0 ? void 0 : _a.dom) === null || _b === void 0 ? void 0 : _b.value);
                onFocus === null || onFocus === void 0 ? void 0 : onFocus(e);
            },
            onBlur: function (e) {
                setValue(getLegalValue(value));
                setIsUserTyping(false);
                onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
            },
        };
        var getControlButtonEventsHandlers = function (method) {
            return readOnly
                ? {}
                : {
                    onMouseDown: function (e) { return handleArrowKey(e, method, true); },
                    onMouseLeave: stop,
                    onMouseUp: stop,
                };
        };
        var shouldRenderButton = !hideControl && mode === 'button';
        var shouldRenderLayer = !hideControl && !readOnly && mode === 'embed';
        var renderStepButton = function (method, icon) {
            var _a;
            var isStepButtonValid = !disabled &&
                (value.isInvalid ||
                    (method === 'plus'
                        ? maxDecimal.isInvalid || value.less(maxDecimal)
                        : minDecimal.isInvalid || minDecimal.less(value)));
            return (React.createElement("div", __assign$V({ className: cs(prefixCls + "-step-button", (_a = {},
                    _a[prefixCls + "-step-button-disabled"] = !isStepButtonValid,
                    _a)) }, (isStepButtonValid ? getControlButtonEventsHandlers(method) : {})), icon));
        };
        return (React.createElement(Input$4, __assign$V({ _ignorePropsFromGlobal: true, role: "spinbutton", "aria-valuemax": max, "aria-valuemin": min, "aria-valuenow": value.isEmpty ? undefined : value.toNumber() }, omit$1(rest, ['allowClear']), inputEventHandlers, { style: style, className: cs(prefixCls, prefixCls + "-mode-" + mode, prefixCls + "-size-" + mergedSize, (_a = {},
                _a[prefixCls + "-readonly"] = readOnly,
                _a[prefixCls + "-illegal-value"] = !value.isEmpty && isOutOfRange,
                _a), className), ref: refInput, size: mergedSize, error: error, disabled: disabled, readOnly: readOnly, value: displayedInputValue, placeholder: placeholder, prefix: prefix && React.createElement("div", { className: prefixCls + "-prefix" }, prefix), suffix: React.createElement(React.Fragment, null,
                shouldRenderLayer && (React.createElement("div", { className: prefixCls + "-step-layer" },
                    renderStepButton('plus', icons && icons.up ? icons.up : React.createElement(IconUp$1, null)),
                    renderStepButton('minus', icons && icons.down ? icons.down : React.createElement(IconDown$1, null)))),
                suffix && React.createElement("div", { className: prefixCls + "-suffix" }, suffix)), addBefore: shouldRenderButton &&
                renderStepButton('minus', icons && icons.minus ? icons.minus : React.createElement(IconMinus$1, null)), addAfter: shouldRenderButton &&
                renderStepButton('plus', icons && icons.plus ? icons.plus : React.createElement(IconPlus$1, null)) })));
    }
    var InputNumberComponent = React.forwardRef(InputNumber$1);
    InputNumberComponent.displayName = 'InputNumber';
    var ArcoInputNumber = InputNumberComponent;

    var __assign$U = (undefined && undefined.__assign) || function () {
        __assign$U = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$U.apply(this, arguments);
    };
    var __read$B = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var StepType;
    (function (StepType) {
        StepType[StepType["previous"] = 0] = "previous";
        StepType[StepType["next"] = 1] = "next";
    })(StepType || (StepType = {}));
    /**
     * default pager item
     */
    function Pager(props) {
        var _a;
        var locale = React.useContext(ConfigContext).locale;
        var getKeyboardEvents = useKeyboardEvent();
        var pageNum = props.pageNum, current = props.current, rootPrefixCls = props.rootPrefixCls, pageItemStyle = props.pageItemStyle, activePageItemStyle = props.activePageItemStyle, itemRender = props.itemRender;
        var prefixCls = rootPrefixCls + "-item";
        var isActive = current === pageNum;
        var classnames = cs(prefixCls, isActive ? prefixCls + "-active" : '');
        var style = pageItemStyle;
        if (isActive) {
            style = __assign$U(__assign$U({}, style), activePageItemStyle);
        }
        var ariaCurrentProps = isActive ? { 'aria-current': true } : {};
        var onClick = function (e) {
            var pageNum = props.pageNum, onClick = props.onClick, disabled = props.disabled;
            if (e.currentTarget.dataset.active === 'true') {
                return;
            }
            e.stopPropagation();
            if (!disabled) {
                onClick && onClick(pageNum);
            }
        };
        return (React.createElement("li", __assign$U({ style: style, className: classnames, onClick: onClick, tabIndex: props.disabled ? -1 : 0, "aria-label": (_a = locale.Pagination.currentPage) === null || _a === void 0 ? void 0 : _a.replace('{0}', pageNum) }, getKeyboardEvents({ onPressEnter: onClick }), ariaCurrentProps), itemRender ? itemRender(pageNum, 'page', pageNum) : pageNum));
    }
    function getIcon(name, icons) {
        switch (name) {
            case 'prev':
                return icons && icons.prev ? icons.prev : React.createElement(IconLeft$1, null);
            case 'next':
                return icons && icons.next ? icons.next : React.createElement(IconRight$1, null);
            case 'more':
                return icons && icons.more ? icons.more : React.createElement(IconMore$1, null);
            default:
                return null;
        }
    }
    /**
     * preJump or nextJump button
     * @param props
     */
    var JumpPager = function (props) {
        var _a, _b;
        var locale = React.useContext(ConfigContext).locale;
        var rootPrefixCls = props.rootPrefixCls, current = props.current, allPages = props.allPages, jumpPage = props.jumpPage, icons = props.icons, disabled = props.disabled, pageItemStyle = props.pageItemStyle, itemRender = props.itemRender;
        var minCurrent = allPages > 0 ? 1 : 0;
        var nextPage = Math.min(allPages, Math.max(minCurrent, current + jumpPage));
        var prefix = rootPrefixCls + "-item " + rootPrefixCls + "-item-jumper";
        var cls = cs(prefix);
        var onClick = function () {
            !disabled && props.onClick && props.onClick(nextPage);
        };
        var originElement = getIcon('more', icons);
        var ariaLabel = jumpPage > 0
            ? (_a = locale.Pagination.nextSomePages) === null || _a === void 0 ? void 0 : _a.replace('{0}', jumpPage)
            : (_b = locale.Pagination.prevSomePages) === null || _b === void 0 ? void 0 : _b.replace('{0}', -jumpPage);
        return (React.createElement("li", { style: pageItemStyle, className: cls, onClick: onClick, "aria-label": ariaLabel }, itemRender ? itemRender(undefined, 'more', originElement) : originElement));
    };
    /**
     * previous or next button
     * @param props
     */
    var StepPager = function (props) {
        var _a;
        var _b = React.useContext(ConfigContext), locale = _b.locale, rtl = _b.rtl;
        var getKeyboardEvents = useKeyboardEvent();
        var rootPrefixCls = props.rootPrefixCls, current = props.current, allPages = props.allPages, type = props.type, icons = props.icons, disabled = props.disabled, pageItemStyle = props.pageItemStyle, itemRender = props.itemRender;
        var prefixCls = rootPrefixCls + "-item";
        var _c = __read$B(rtl ? ['next', 'prev'] : ['prev', 'next'], 2), prev = _c[0], next = _c[1];
        var StepIcon = type === StepType.previous ? getIcon(prev, icons) : getIcon(next, icons);
        var _disabled = false;
        if (allPages === 0) {
            // total为0
            _disabled = true;
        }
        else if (type === StepType.previous) {
            // 向前翻页
            _disabled = current <= 1; // current ===0 || current===1
        }
        else {
            // 向后翻页
            _disabled = current === allPages;
        }
        var innerDisabled = disabled || _disabled;
        var nextPage = current + (type === StepType.previous ? -1 : 1);
        nextPage = Math.max(0, Math.min(allPages, nextPage));
        var pageType = StepType.previous === type ? 'prev' : 'next';
        var cls = cs(prefixCls, prefixCls + "-" + pageType, (_a = {},
            _a[prefixCls + "-disabled"] = innerDisabled,
            _a));
        var onClick = function () {
            if (innerDisabled) {
                return;
            }
            props.onClick && props.onClick(nextPage);
        };
        return (React.createElement("li", __assign$U({ style: pageItemStyle, className: cls, onClick: onClick, tabIndex: innerDisabled ? -1 : 0, "aria-label": locale.Pagination[pageType] }, getKeyboardEvents({
            onPressEnter: onClick,
        })), itemRender ? itemRender(undefined, pageType, StepIcon) : StepIcon));
    };

    var __assign$T = (undefined && undefined.__assign) || function () {
        __assign$T = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$T.apply(this, arguments);
    };
    var noop = function () { };
    var Option = Select$3.Option;
    var _SizeOptions = [10, 20, 30, 40, 50];
    function PageOption(props) {
        var selectRef = React.useRef();
        var locale = React.useContext(ConfigContext).locale;
        var _a = props.sizeCanChange, sizeCanChange = _a === void 0 ? false : _a, _b = props.onPageSizeChange, onPageSizeChange = _b === void 0 ? noop : _b, rootPrefixCls = props.rootPrefixCls, _c = props.sizeOptions, sizeOptions = _c === void 0 ? _SizeOptions : _c, _d = props.pageSize, pageSize = _d === void 0 ? 10 : _d, size = props.size, selectProps = props.selectProps, disabled = props.disabled;
        return (sizeCanChange && (React.createElement("div", { ref: selectRef, className: rootPrefixCls + "-option", "aria-label": locale.Pagination.pageSize },
            React.createElement(Select$3, __assign$T({ value: sizeOptions.indexOf(pageSize) !== -1 ? pageSize : sizeOptions[0], onChange: function (value) {
                    onPageSizeChange(value);
                }, size: size, getPopupContainer: function () { return selectRef.current; }, disabled: disabled }, selectProps), sizeOptions.map(function (num) {
                return (React.createElement(Option, { key: num, value: num }, num + " " + locale.Pagination.countPerPage));
            })))));
    }

    var __assign$S = (undefined && undefined.__assign) || function () {
        __assign$S = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$S.apply(this, arguments);
    };
    var __read$A = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    function PageJumper(props) {
        var defaultInputText = props.simple ? props.current : undefined;
        var locale = React.useContext(ConfigContext).locale;
        var _a = __read$A(React.useState(defaultInputText), 2), inputText = _a[0], setInputText = _a[1];
        var inputRef = React.useRef();
        React.useEffect(function () {
            if (props.simple) {
                setInputText(props.current);
            }
        }, [props.simple, props.current]);
        var handleChange = function (val) {
            var value = parseInt(val, 10);
            setInputText(isNaN(value) ? undefined : value);
        };
        var handleJump = function () {
            var onPageChange = props.onPageChange, totalPages = props.totalPages, current = props.current, simple = props.simple;
            if (isUndefined(inputText)) {
                return;
            }
            if (inputText === current && !simple) {
                setInputText(undefined);
                return;
            }
            var page = isNaN(Number(inputText)) ? current : Number(inputText);
            if (page < 1) {
                page = 1;
            }
            else if (page > totalPages) {
                page = totalPages;
            }
            setInputText(simple ? page : undefined);
            isFunction$1(onPageChange) && onPageChange(page);
        };
        var onFocus = function () {
            var input = inputRef.current.dom;
            if (String(inputText) && input) {
                input.setSelectionRange(0, String(inputText).length);
            }
        };
        var rootPrefixCls = props.rootPrefixCls, totalPages = props.totalPages, simple = props.simple, size = props.size, disabled = props.disabled;
        var prefixCls = rootPrefixCls + "-jumper";
        var inputConfig = __assign$S({ showJumper: true }, (isObject$1(simple) ? simple : {}));
        return (React.createElement("div", { className: "" + prefixCls },
            !simple && React.createElement("span", { className: prefixCls + "-text-goto" }, locale.Pagination.goto),
            inputConfig.showJumper ? (React.createElement(Input$4, { _ignorePropsFromGlobal: true, ref: function (ref) { return (inputRef.current = ref); }, className: prefixCls + "-input", value: !isUndefined(inputText) ? inputText.toString() : undefined, size: size, disabled: disabled || !totalPages, onChange: handleChange, onPressEnter: handleJump, onFocus: onFocus, onBlur: handleJump })) : (React.createElement("span", null, inputText)),
            simple && (React.createElement(React.Fragment, null,
                React.createElement("span", { className: prefixCls + "-separator" }, "/"),
                React.createElement("span", null, totalPages)))));
    }

    var __assign$R = (undefined && undefined.__assign) || function () {
        __assign$R = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$R.apply(this, arguments);
    };
    var __read$z = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var _defaultCurrent = 1;
    var _defaultPageSize = 10;
    function getAllPages(pageSize, total) {
        return Math.ceil(total / pageSize);
    }
    function getBufferSize(bufferSize, allPages) {
        var min = 0;
        var max = Math.floor(allPages / 2) - 1;
        var newBufferSize = Math.max(bufferSize, min);
        return Math.min(newBufferSize, max);
    }
    function getAdjustPageSize(sizeOptions) {
        if (sizeOptions && sizeOptions.length) {
            return sizeOptions[0];
        }
        return _defaultPageSize;
    }
    var defaultProps$g = {
        total: 0,
        pageSizeChangeResetCurrent: true,
        bufferSize: 2,
    };
    function Pagination(baseProps, ref) {
        var _a;
        var _b;
        var _c = React.useContext(ConfigContext), getPrefixCls = _c.getPrefixCls, ctxSize = _c.size, locale = _c.locale, componentConfig = _c.componentConfig, rtl = _c.rtl;
        var props = useMergeProps(baseProps, defaultProps$g, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Pagination);
        var propTotal = props.total, propPageSize = props.pageSize, propCurrent = props.current, propShowMore = props.showMore, propSizeOptions = props.sizeOptions, pageSizeChangeResetCurrent = props.pageSizeChangeResetCurrent, defaultCurrent = props.defaultCurrent, defaultPageSize = props.defaultPageSize;
        var _d = __read$z(useMergeValue(_defaultCurrent, {
            defaultValue: defaultCurrent,
            value: propCurrent,
        }), 2), current = _d[0], setCurrent = _d[1];
        var _e = __read$z(useMergeValue(getAdjustPageSize(propSizeOptions), {
            defaultValue: defaultPageSize,
            value: propPageSize,
        }), 2), pageSize = _e[0], setPageSize = _e[1];
        var total = propTotal;
        var showMore = !!propShowMore;
        if (propCurrent && !props.onChange) {
            console.warn('Warning: you have provide current prop for pagination but without onChange handler ,' +
                ' this will cause no-change when you change page. ');
        }
        function getAdjustedCurrent(newPageSize, newTotal) {
            var newAllPages = getAllPages(newPageSize, newTotal);
            var newCurrent = current > newAllPages ? newAllPages : current;
            return newCurrent;
        }
        React.useEffect(function () {
            // adjust pageSize after sizeOption changes
            var needAdjust = propSizeOptions && !propSizeOptions.includes(pageSize);
            // trigged when currentPageSize not in the options;
            if (needAdjust) {
                var adjustPageSize = getAdjustPageSize(propSizeOptions);
                if (!('pageSize' in props)) {
                    setPageSize(adjustPageSize);
                }
            }
        }, [propSizeOptions]);
        React.useEffect(function () {
            // adjust currentPage after total and pageSize changes
            var newCurrent = getAdjustedCurrent(pageSize, total);
            if (newCurrent !== current && !('current' in props)) {
                setCurrent(newCurrent);
            }
        }, [total, current, pageSize]);
        var onChange = function (pageNumber, size) {
            if (pageNumber === void 0) { pageNumber = current; }
            if (size === void 0) { size = pageSize; }
            var onChange = props.onChange;
            onChange && onChange(pageNumber, size);
        };
        var onPageSizeChange = function (pageSize) {
            var onPageSizeChange = props.onPageSizeChange;
            var allPages = getAllPages(pageSize, total);
            var newState = {
                pageSize: pageSize,
            };
            if (pageSizeChangeResetCurrent) {
                newState.current = 1;
            }
            else {
                newState.current = current > allPages ? allPages : current;
            }
            if (!('pageSize' in props)) {
                setPageSize(newState.pageSize);
            }
            if (!('current' in props) && current !== newState.current) {
                setCurrent(newState.current);
            }
            onPageSizeChange && onPageSizeChange(pageSize, newState.current);
            onChange(pageSizeChangeResetCurrent ? 1 : newState.current, pageSize);
        };
        var onPageNumberChange = function (pageNumber) {
            if (!('current' in props)) {
                setCurrent(pageNumber);
            }
            onChange(pageNumber);
        };
        var className = props.className, style = props.style, pageItemStyle = props.pageItemStyle, activePageItemStyle = props.activePageItemStyle, showTotal = props.showTotal, sizeCanChange = props.sizeCanChange, sizeOptions = props.sizeOptions, simple = props.simple, mini = props.mini, showJumper = props.showJumper, selectProps = props.selectProps, icons = props.icons, disabled = props.disabled, itemRender = props.itemRender, hideOnSinglePage = props.hideOnSinglePage;
        var size = props.size || ctxSize;
        var prefixCls = getPrefixCls('pagination');
        // compatible 1.0
        var innerSize = mini ? 'mini' : size;
        var classNames = cs(prefixCls, prefixCls + "-size-" + innerSize, (_a = {},
            _a[prefixCls + "-simple"] = simple,
            _a[prefixCls + "-disabled"] = disabled,
            _a[prefixCls + "-rtl"] = rtl,
            _a), className);
        var renderPager;
        var pageList = [];
        var allPages = getAllPages(pageSize, total);
        var bufferSize = getBufferSize(props.bufferSize, allPages);
        if (hideOnSinglePage && allPages <= 1) {
            return null;
        }
        var pagerProps = {
            onClick: onPageNumberChange,
            rootPrefixCls: prefixCls,
            simple: simple,
            current: current,
            allPages: allPages,
            icons: icons,
            disabled: disabled,
            pageItemStyle: pageItemStyle,
            activePageItemStyle: activePageItemStyle,
            itemRender: itemRender,
        };
        // simple mode, no pager list
        if (simple) {
            var prefix = prefixCls + "-item-simple";
            renderPager = (React.createElement("ul", { className: prefixCls + "-list" },
                React.createElement(StepPager, __assign$R({ key: "previous" }, pagerProps, { type: StepType.previous })),
                React.createElement("li", { className: prefix + "-pager" },
                    React.createElement(PageJumper, { disabled: disabled, rootPrefixCls: prefixCls, totalPages: allPages, current: current, onPageChange: onPageNumberChange, simple: { showJumper: typeof showJumper === 'boolean' ? showJumper : true }, size: innerSize })),
                React.createElement(StepPager, __assign$R({ key: "next" }, pagerProps, { type: StepType.next }))));
        }
        else {
            // fold = ... >= 2pages;
            var beginFoldPage = 1 + 2 + bufferSize;
            var endFoldPage = allPages - 2 - bufferSize;
            if (
            // beginPage(1 page) + bufferSize * 2 + endPage(1 page) + ...(2 pages)
            allPages <= 4 + bufferSize * 2 ||
                (current === beginFoldPage && current === endFoldPage)) {
                for (var i = 1; i <= allPages; i++) {
                    pageList.push(React.createElement(Pager, __assign$R({}, pagerProps, { key: i, pageNum: i })));
                }
            }
            else {
                var left = 1;
                var right = allPages;
                var hasJumpPre = true;
                var hasJumpNext = true;
                // fold front and back
                if (current > beginFoldPage && current < endFoldPage) {
                    right = current + bufferSize;
                    left = current - bufferSize;
                    // fold back
                }
                else if (current <= beginFoldPage) {
                    hasJumpPre = false;
                    left = 1;
                    right = Math.max(beginFoldPage, bufferSize + current);
                    // fold begin
                }
                else if (current >= endFoldPage) {
                    hasJumpNext = false;
                    right = allPages;
                    left = Math.min(endFoldPage, current - bufferSize);
                }
                for (var i = left; i <= right; i++) {
                    pageList.push(React.createElement(Pager, __assign$R({ key: i, pageNum: i }, pagerProps)));
                }
                var JumpPre = (React.createElement(JumpPager, __assign$R({}, pagerProps, { key: left - 1, type: StepType.previous, jumpPage: -(bufferSize * 2 + 1) })));
                var JumpNext = (React.createElement(JumpPager, __assign$R({}, pagerProps, { key: right + 1, type: StepType.next, jumpPage: bufferSize * 2 + 1 })));
                var FirstPager = React.createElement(Pager, __assign$R({ key: 1, pageNum: 1 }, pagerProps));
                var LastPager = React.createElement(Pager, __assign$R({}, pagerProps, { key: allPages, pageNum: allPages }));
                if (hasJumpPre) {
                    pageList[0] = React.cloneElement(pageList[0], {
                        className: prefixCls + "-item-after-pre",
                    });
                    // TODO:
                    pageList.unshift(JumpPre);
                    pageList.unshift(FirstPager);
                }
                if (hasJumpNext) {
                    pageList[pageList.length - 1] = React.cloneElement(pageList[pageList.length - 1], {
                        className: prefixCls + "-item-before-next",
                    });
                    pageList.push(JumpNext);
                    pageList.push(LastPager);
                }
            }
            renderPager = (React.createElement("ul", { className: prefixCls + "-list" },
                React.createElement(StepPager, __assign$R({}, pagerProps, { key: "previous", type: StepType.previous })),
                pageList,
                showMore && (React.createElement(JumpPager, __assign$R({}, pagerProps, { key: allPages + 1, type: StepType.next, jumpPage: bufferSize * 2 + 1 }))),
                React.createElement(StepPager, __assign$R({ key: "next" }, pagerProps, { type: StepType.next }))));
        }
        var totalElement = null;
        if (typeof showTotal === 'boolean' && showTotal) {
            totalElement = (React.createElement("div", { className: prefixCls + "-total-text" }, (_b = locale.Pagination.total) === null || _b === void 0 ? void 0 : _b.replace('{0}', total)));
        }
        if (typeof showTotal === 'function') {
            totalElement = (React.createElement("div", { className: prefixCls + "-total-text" }, showTotal(total, [(current - 1) * pageSize + 1, current * pageSize])));
        }
        return (React.createElement("div", __assign$R({}, pickDataAttributes(props), { className: classNames, style: style, ref: ref }),
            totalElement,
            renderPager,
            React.createElement(PageOption, { disabled: disabled, rootPrefixCls: prefixCls, sizeCanChange: sizeCanChange, sizeOptions: sizeOptions, onPageSizeChange: onPageSizeChange, pageSize: pageSize, size: innerSize, selectProps: selectProps }),
            !simple && showJumper && (React.createElement(PageJumper, { disabled: disabled, rootPrefixCls: prefixCls, totalPages: allPages, current: current, onPageChange: onPageNumberChange, size: innerSize }))));
    }
    var PaginationComponent = React.forwardRef(Pagination);
    PaginationComponent.displayName = 'Pagination';
    var Pagination$1 = PaginationComponent;

    var __assign$Q = (undefined && undefined.__assign) || function () {
        __assign$Q = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$Q.apply(this, arguments);
    };
    var __rest$k = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function Meta(props, ref) {
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var className = props.className, avatar = props.avatar, title = props.title, description = props.description, others = __rest$k(props, ["className", "avatar", "title", "description"]);
        var prefixCls = getPrefixCls('list');
        var baseClassName = prefixCls + "-item-meta";
        var hasAvatar = !!avatar;
        var hasContent = !!(title || description);
        return (React.createElement("div", __assign$Q({ ref: ref }, others, { className: cs(baseClassName, className) }),
            hasAvatar && React.createElement("div", { className: baseClassName + "-avatar" }, avatar),
            hasContent && (React.createElement("div", { className: baseClassName + "-content" },
                title && React.createElement("div", { className: baseClassName + "-title" }, title),
                description && React.createElement("div", { className: baseClassName + "-description" }, description)))));
    }
    var MetaComponent = React.forwardRef(Meta);
    MetaComponent.displayName = 'ListItemMeta';
    var Meta$1 = MetaComponent;

    var __assign$P = (undefined && undefined.__assign) || function () {
        __assign$P = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$P.apply(this, arguments);
    };
    var __rest$j = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var defaultProps$f = {
        actionLayout: 'horizontal',
    };
    function Item(baseProps, ref) {
        var _a = React.useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, componentConfig = _a.componentConfig;
        var props = useMergeProps(baseProps, defaultProps$f, componentConfig && componentConfig['List.Item']);
        var children = props.children, className = props.className, actions = props.actions, extra = props.extra, actionLayout = props.actionLayout, rest = __rest$j(props, ["children", "className", "actions", "extra", "actionLayout"]);
        var prefixCls = getPrefixCls('list');
        var baseClassName = prefixCls + "-item";
        var metaContent = [];
        var mainContent = [];
        React.Children.forEach(children, function (element) {
            if (element && element.type && element.type === Meta$1) {
                metaContent.push(element);
            }
            else {
                mainContent.push(element);
            }
        });
        var content = mainContent.length ? (React.createElement("div", { className: baseClassName + "-content" }, mainContent)) : null;
        var extraContent = extra ? (React.createElement("div", { className: baseClassName + "-extra-content" }, extra)) : null;
        var actionsContent = actions && actions.length ? (React.createElement("div", { className: baseClassName + "-action" }, actions.map(function (action, i) { return (React.createElement("li", { key: baseClassName + "-action-" + i }, action)); }))) : null;
        return (React.createElement("div", __assign$P({ role: "listitem", ref: ref, className: cs(baseClassName, className) }, rest),
            React.createElement("div", { className: baseClassName + "-main" },
                metaContent,
                content,
                actionLayout === 'vertical' ? actionsContent : null),
            actionLayout === 'horizontal' ? actionsContent : null,
            extraContent));
    }
    var ForwardRefItem = React.forwardRef(Item);
    var ItemComponent = ForwardRefItem;
    ItemComponent.displayName = 'ListItem';
    ItemComponent.Meta = Meta$1;
    var Item$1 = ItemComponent;

    var __assign$O = (undefined && undefined.__assign) || function () {
        __assign$O = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$O.apply(this, arguments);
    };
    function scrollIntoViewIfNeed (node, options) {
        if (node) {
            scrollIntoView(node, __assign$O({ block: 'start', behavior: 'instant', scrollMode: 'if-needed' }, options));
            var height = node.offsetHeight;
            var scaleHeight = node.getBoundingClientRect().height;
            // trigger 带有scale动画，在 scrollIntoView 的时候，动画未执行完全，此时通过 getBoundingClientRect 获取到的 height 是 scale 后的高度。
            // 所以需要额外滚动一点距离。
            if (options && options.boundary && height !== scaleHeight) {
                // scrollIntoView 的 boundary是函数或者Element类型
                var parentNode = (isFunction$1(options.boundary) ? options.boundary(node) : options.boundary);
                parentNode.scrollTop = Math.round(parentNode.scrollTop * (height / scaleHeight));
            }
        }
    }

    var __assign$N = (undefined && undefined.__assign) || function () {
        __assign$N = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$N.apply(this, arguments);
    };
    var __rest$i = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$y = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var DEFAULT_PAGE_SIZE = 10;
    var DEFAULT_PAGE_CURRENT = 1;
    var SizeList = ['small', 'default', 'large'];
    var defaultProps$e = {
        split: true,
        bordered: true,
        defaultCurrent: 1,
        offsetBottom: 0,
        throttleDelay: 500,
    };
    function List(baseProps, ref) {
        var _a = React.useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, loadingElement = _a.loadingElement, ctxSize = _a.size, renderEmpty = _a.renderEmpty, componentConfig = _a.componentConfig, rtl = _a.rtl;
        var props = useMergeProps(baseProps, defaultProps$e, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.List);
        var style = props.style, wrapperStyle = props.wrapperStyle, className = props.className, wrapperClassName = props.wrapperClassName, _b = props.children, children = _b === void 0 ? [] : _b, _c = props.dataSource, dataSource = _c === void 0 ? [] : _c, propSize = props.size, footer = props.footer, header = props.header, pagination = props.pagination, bordered = props.bordered, split = props.split, render = props.render, grid = props.grid, loading = props.loading, hoverable = props.hoverable, scrollLoading = props.scrollLoading, paginationInFooter = props.paginationInFooter, offsetBottom = props.offsetBottom, throttleDelay = props.throttleDelay, defaultCurrent = props.defaultCurrent, noDataElement = props.noDataElement, listRef = props.listRef, onReachBottom = props.onReachBottom, onListScroll = props.onListScroll;
        var size = propSize || (SizeList.indexOf(ctxSize) > -1 ? ctxSize : 'default');
        var prefixCls = getPrefixCls('list');
        var refDom = React.useRef(null);
        var refVirtualList = React.useRef(null);
        var refScrollElement = React.useRef(null);
        var refItemListWrapper = React.useRef(null);
        var refCanTriggerReachBottom = React.useRef(true);
        var _d = __read$y(React.useState(pagination && typeof pagination === 'object'
            ? pagination.pageSize || pagination.defaultPageSize || DEFAULT_PAGE_SIZE
            : DEFAULT_PAGE_SIZE), 2), pageSize = _d[0], setPageSize = _d[1];
        var _e = __read$y(React.useState(pagination && typeof pagination === 'object'
            ? pagination.current || pagination.defaultCurrent || DEFAULT_PAGE_CURRENT
            : DEFAULT_PAGE_CURRENT), 2), paginationCurrent = _e[0], setPaginationCurrent = _e[1];
        var _f = __read$y(React.useState(defaultCurrent), 2), pageCurrentForScroll = _f[0], setPageCurrentForScroll = _f[1];
        var childrenCount = React.Children.count(children);
        React.useImperativeHandle(listRef, function () {
            return {
                dom: refDom.current,
                scrollIntoView: function (index, options) {
                    if (refVirtualList.current) {
                        refVirtualList.current.scrollTo({ index: index, options: options });
                    }
                    else if (refItemListWrapper.current) {
                        var node = refItemListWrapper.current.children[index];
                        node &&
                            scrollIntoViewIfNeed(node, __assign$N({ boundary: refScrollElement.current }, options));
                    }
                },
            };
        });
        // compatible with old API: height
        var virtualListProps = props.virtualListProps
            ? props.virtualListProps
            : props.height
                ? { height: props.height }
                : undefined;
        // pagination props
        var paginationProps = __assign$N(__assign$N({ pageSize: pageSize, current: paginationCurrent, total: dataSource.length > 0 ? dataSource.length : childrenCount }, (typeof pagination === 'object' ? pagination : {})), { onPageSizeChange: function (size, current) {
                setPageSize(size);
                pagination &&
                    typeof pagination === 'object' &&
                    pagination.onPageSizeChange &&
                    pagination.onPageSizeChange(size, current);
            }, onChange: function (pageNumber, pageSize) {
                setPaginationCurrent(pageNumber);
                pagination &&
                    typeof pagination === 'object' &&
                    pagination.onChange &&
                    pagination.onChange(pageNumber, pageSize);
            } });
        paginationProps.current = Math.min(paginationProps.current, Math.ceil(paginationProps.total / paginationProps.pageSize));
        var needHandleScroll = !!(onListScroll || onReachBottom);
        var throttledScrollHandler = React.useCallback(throttle_1(function () {
            if (onListScroll) {
                onListScroll(refScrollElement.current);
                return;
            }
            var _a = refScrollElement.current, scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
            var scrollBottom = scrollHeight - (scrollTop + clientHeight);
            // https://github.com/arco-design/arco-design/issues/850
            // offsetBottom + 1: scrollTop is a non-rounded number, while scrollHeight and clientHeight are both rounded
            if (Math.abs(scrollBottom) < offsetBottom + 1) {
                if (refCanTriggerReachBottom.current) {
                    setPageCurrentForScroll(pageCurrentForScroll + 1);
                    onReachBottom && onReachBottom(pageCurrentForScroll + 1);
                    refCanTriggerReachBottom.current = false;
                }
            }
            else {
                refCanTriggerReachBottom.current = true;
            }
        }, throttleDelay), [throttleDelay, pageCurrentForScroll, onListScroll, onReachBottom]);
        // render content of list
        var renderListItems = function () {
            // get the data source to render current page
            var getCurrentPageItems = function (items) {
                var current = paginationProps.current, pageSize = paginationProps.pageSize;
                var startIndex = (current - 1) * pageSize;
                return pagination && items.length > startIndex
                    ? items.slice(startIndex, startIndex + pageSize)
                    : items;
            };
            // The current page of the normal list children
            var getItems = function (originItems, render) {
                var currentPageItems = getCurrentPageItems(originItems);
                return render ? currentPageItems.map(render) : currentPageItems;
            };
            // The current page of the Grid list children
            var getGrid = function (originItems, render) {
                var currentPageItems = getCurrentPageItems(originItems);
                if (grid.column || grid.span) {
                    var items = [];
                    var gutter = grid.gutter, justify = grid.justify, align = grid.align, gridRowSize = grid.column, colProps_1 = __rest$i(grid, ["gutter", "justify", "align", "column"]);
                    var rowSize = gridRowSize || Math.floor(24 / grid.span);
                    var span_1 = colProps_1.span || Math.floor(24 / rowSize);
                    var startNum_1 = 0;
                    var _loop_1 = function () {
                        var nextStartNum = startNum_1 + rowSize;
                        var currentRow = ~~(startNum_1 / rowSize);
                        items.push(React.createElement(Row$2, { key: currentRow, className: prefixCls + "-row", gutter: gutter, justify: justify, align: align }, currentPageItems.slice(startNum_1, nextStartNum).map(function (item, index) { return (React.createElement(Col$1, __assign$N({ key: currentRow + "_" + index, className: prefixCls + "-row-col" }, colProps_1, { span: span_1 }), render ? render(item, startNum_1 + index) : item)); })));
                        startNum_1 = nextStartNum;
                    };
                    while (startNum_1 < currentPageItems.length) {
                        _loop_1();
                    }
                    return items;
                }
                return (React.createElement(Row$2, { className: prefixCls + "-row", gutter: grid.gutter }, currentPageItems.map(function (item, index) { return (React.createElement(Col$1, __assign$N({ className: prefixCls + "-row-col" }, omit$1(grid, ['gutter']), { key: index }), render ? render(item, index) : item)); })));
            };
            if (dataSource.length > 0 && render) {
                return grid ? getGrid(dataSource, render) : getItems(dataSource, render);
            }
            if (childrenCount > 0) {
                return grid ? getGrid(children) : getItems(children);
            }
            if (!scrollLoading) {
                return noDataElement || renderEmpty('List');
            }
            return null;
        };
        var renderList = function () {
            var _a, _b;
            var listItems = renderListItems();
            var isVirtual = virtualListProps && virtualListProps.threshold !== null && Array.isArray(listItems);
            var paginationElement = pagination ? (React.createElement(Pagination$1, __assign$N({}, paginationProps, { className: cs(prefixCls + "-pagination", paginationProps && paginationProps.className) }))) : null;
            var paginationElementInsideFooter = paginationInFooter ? paginationElement : null;
            var paginationElementOutsideFooter = paginationInFooter ? null : paginationElement;
            var scrollLoadingEle = scrollLoading !== undefined && scrollLoading !== null ? (React.createElement("div", { className: prefixCls + "-item " + prefixCls + "-scroll-loading" }, scrollLoading)) : null;
            return (React.createElement("div", { ref: function (_ref) {
                    ref = _ref;
                    refDom.current = ref;
                }, style: wrapperStyle, className: cs(prefixCls + "-wrapper", (_a = {}, _a[prefixCls + "-wrapper-rtl"] = rtl, _a), wrapperClassName) },
                React.createElement("div", __assign$N({}, pickDataAttributes(props), { style: style, className: cs(prefixCls, prefixCls + "-" + size, (_b = {},
                        _b[prefixCls + "-no-border"] = !bordered,
                        _b[prefixCls + "-no-split"] = !split,
                        _b[prefixCls + "-hoverable"] = hoverable,
                        _b[prefixCls + "-rtl"] = rtl,
                        _b), className), ref: function (ref) {
                        if (!isVirtual) {
                            refScrollElement.current = ref;
                        }
                    }, onScroll: !isVirtual && needHandleScroll ? throttledScrollHandler : undefined }),
                    header ? React.createElement("div", { className: prefixCls + "-header" }, header) : null,
                    isVirtual ? (React.createElement(React.Fragment, null,
                        React.createElement(VirtualList$1, __assign$N({ role: "list", ref: function (ref) {
                                if (ref) {
                                    refVirtualList.current = ref;
                                    refScrollElement.current = ref.dom;
                                }
                            }, className: prefixCls + "-content " + prefixCls + "-virtual", data: scrollLoadingEle ? listItems.concat(scrollLoadingEle) : listItems, isStaticItemHeight: false, onScroll: needHandleScroll ? throttledScrollHandler : undefined }, virtualListProps), function (child) { return child; }))) : (React.createElement("div", { role: "list", className: prefixCls + "-content", ref: refItemListWrapper },
                        listItems,
                        scrollLoadingEle)),
                    footer || paginationElementInsideFooter ? (React.createElement("div", { className: prefixCls + "-footer" },
                        footer,
                        paginationElementInsideFooter)) : null),
                paginationElementOutsideFooter));
        };
        return 'loading' in props ? (React.createElement(Spin$1, { style: { display: 'block' }, loading: loading, element: loadingElement || React.createElement(Spin$1, null) }, renderList())) : (renderList());
    }
    var ListComponent = React.forwardRef(List);
    ListComponent.displayName = 'List';
    ListComponent.Item = Item$1;
    var List$1 = ListComponent;

    var __assign$M = (undefined && undefined.__assign) || function () {
        __assign$M = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$M.apply(this, arguments);
    };
    function ConfirmModal(props) {
        var _a = getModalConfig(), prefixCls = _a.prefixCls, simple = _a.simple;
        return (React.createElement(Modal$1, __assign$M({ prefixCls: prefixCls, simple: simple }, props), props.content));
    }
    // 如果是消息提示型弹出框，那么只有确认按钮
    var normalizeConfig = function (_config) {
        var icon = _config.icon;
        if (!icon && icon !== null) {
            icon = React.createElement(IconExclamationCircleFill$1, null);
            if (_config.isNotice) {
                switch (_config.noticeType) {
                    case 'info':
                        icon = React.createElement(IconInfoCircleFill$1, null);
                        break;
                    case 'success':
                        icon = React.createElement(IconCheckCircleFill$1, null);
                        break;
                    case 'warning':
                        icon = React.createElement(IconExclamationCircleFill$1, null);
                        break;
                    case 'error':
                        icon = React.createElement(IconCloseCircleFill$1, null);
                        break;
                }
            }
        }
        if (_config.isNotice) {
            _config.hideCancel = true;
        }
        _config.title =
            icon === null && _config.title === null ? null : (React.createElement("span", null,
                icon,
                _config.title));
        return _config;
    };
    function confirm(config, renderFunc) {
        var root;
        var div = document.createElement('div');
        document.body.appendChild(div);
        var configProviderProps = getConfigProviderProps();
        function render$1(props) {
            var dom = (React.createElement(ConfigProvider, __assign$M({}, configProviderProps),
                React.createElement(ConfirmModal, __assign$M({}, props, { onCancel: onCancel }))));
            if (root) {
                root.render(dom);
            }
            else {
                root = render(dom, div);
            }
        }
        var renderFunction = renderFunc || render$1;
        var modalConfig = __assign$M(__assign$M({}, config), { visible: false });
        var onOk = function () {
            var ret;
            var _onOk = config.onOk || config.onConfirm;
            if (_onOk) {
                ret = _onOk();
            }
            if (ret && ret.then) {
                modalConfig.confirmLoading = true;
                renderFunction(modalConfig);
                ret.then(function () {
                    onCancel(true);
                }, function (e) {
                    console.error(e);
                    modalConfig.confirmLoading = false;
                    renderFunction(modalConfig);
                });
            }
            if (!ret) {
                onCancel(true);
            }
        };
        // 如果是promise，那么处理loading和加载完成关闭
        modalConfig.onOk = onOk;
        modalConfig = normalizeConfig(modalConfig);
        modalConfig.visible = true;
        renderFunction(modalConfig);
        function destroy() {
            root = root === null || root === void 0 ? void 0 : root._unmount();
            if (div.parentNode) {
                div.parentNode.removeChild(div);
            }
            for (var i = 0; i < destroyList.length; i++) {
                var fn = destroyList[i];
                if (fn === close) {
                    destroyList.splice(i, 1);
                    break;
                }
            }
        }
        function onCancel(isOnOk) {
            !isOnOk && config.onCancel && config.onCancel();
            modalConfig.visible = false;
            modalConfig.afterClose = function () {
                config.afterClose && config.afterClose();
                destroy();
            };
            renderFunction(modalConfig);
        }
        function update(newConfig) {
            modalConfig = __assign$M(__assign$M(__assign$M({}, modalConfig), { title: config.title }), newConfig);
            modalConfig = normalizeConfig(modalConfig);
            renderFunction(modalConfig);
        }
        function close() {
            modalConfig.visible = false;
            modalConfig.afterClose = function () {
                config.afterClose && config.afterClose();
                destroy();
            };
            renderFunction(modalConfig);
        }
        destroyList.push(close);
        return {
            close: close,
            update: update,
        };
    }

    var __assign$L = (undefined && undefined.__assign) || function () {
        __assign$L = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$L.apply(this, arguments);
    };
    var __read$x = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    function HookModal(props, ref) {
        var _a = __read$x(React.useState(true), 2), visible = _a[0], setVisible = _a[1];
        var _b = __read$x(React.useState(props), 2), config = _b[0], setConfig = _b[1];
        React.useImperativeHandle(ref, function () { return ({
            update: function (config) {
                setConfig(config);
            },
            close: function () {
                setVisible(false);
            },
        }); });
        function onOk() {
            var ret = config.onOk && config.onOk();
            if (ret && ret.then) {
                setConfig(function (config) { return (__assign$L(__assign$L({}, config), { confirmLoading: true })); });
                ret.then(function () {
                    setVisible(false);
                }, function (e) {
                    console.error(e);
                    setConfig(function (config) { return (__assign$L(__assign$L({}, config), { confirmLoading: false })); });
                });
            }
            if (!ret) {
                setVisible(false);
            }
        }
        function onCancel() {
            config.onCancel && config.onCancel();
            setVisible(false);
        }
        return (React.createElement(Modal$1, __assign$L({ unmountOnExit: true, simple: true }, config, { visible: visible, onOk: onOk, onCancel: onCancel }), config.content));
    }
    var HookModal$1 = React.forwardRef(HookModal);

    var __assign$K = (undefined && undefined.__assign) || function () {
        __assign$K = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$K.apply(this, arguments);
    };
    function useModal() {
        var contextHolderRef = React.useRef();
        var holderEle = React.createElement(ContextHolderElement$1, { ref: contextHolderRef });
        var uuid = 0;
        function addNewModal(config) {
            var _a;
            uuid += 1;
            var modalRef = React.createRef();
            var currentConfig = __assign$K({}, config);
            function afterClose() {
                config.afterClose && config.afterClose();
                removeModalInstance();
            }
            var modal = (React.createElement(HookModal$1, __assign$K({ key: uuid, ref: modalRef }, normalizeConfig(__assign$K({}, config)), { afterClose: afterClose })));
            (_a = contextHolderRef.current) === null || _a === void 0 ? void 0 : _a.addInstance(modal);
            function removeModalInstance() {
                var _a;
                (_a = contextHolderRef.current) === null || _a === void 0 ? void 0 : _a.removeInstance(modal);
            }
            function close() {
                var _a;
                (_a = modalRef.current) === null || _a === void 0 ? void 0 : _a.close();
            }
            function update(newConfig) {
                var _a;
                currentConfig = __assign$K(__assign$K({}, currentConfig), newConfig);
                (_a = modalRef.current) === null || _a === void 0 ? void 0 : _a.update(normalizeConfig(__assign$K({}, currentConfig)));
            }
            destroyList.push(close);
            return {
                close: close,
                update: update,
            };
        }
        var modalFuncs = {
            confirm: function (config) {
                return addNewModal(__assign$K({}, config));
            },
        };
        ['info', 'success', 'warning', 'error'].forEach(function (type) {
            modalFuncs[type] = function (config) {
                return addNewModal(__assign$K(__assign$K({}, config), { isNotice: true, noticeType: type }));
            };
        });
        return [modalFuncs, holderEle];
    }

    var __assign$J = (undefined && undefined.__assign) || function () {
        __assign$J = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$J.apply(this, arguments);
    };
    var __rest$h = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$w = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var cursorPosition = null;
    var globalDialogIndex = 0;
    if (!isServerRendering) {
        document.documentElement.addEventListener('click', function (e) {
            cursorPosition = {
                left: e.clientX,
                top: e.clientY,
            };
            // 受控模式下，用户不一定马上打开弹窗，这期间可能出现其他 UI 操作，那这个位置就不可用了。
            setTimeout(function () {
                cursorPosition = null;
            }, 100);
        }, true);
    }
    var defaultProps$d = {
        mask: true,
        maskClosable: true,
        mountOnEnter: true,
        escToExit: true,
        getPopupContainer: function () { return document.body; },
        alignCenter: true,
    };
    function Modal(baseProps, ref) {
        var _a, _b;
        var _c;
        var context = React.useContext(ConfigContext);
        var props = useMergeProps(baseProps, defaultProps$d, (_c = context.componentConfig) === null || _c === void 0 ? void 0 : _c.Modal);
        var className = props.className, style = props.style, visible = props.visible, simple = props.simple, title = props.title, children = props.children, cancelText = props.cancelText, okText = props.okText, okButtonProps = props.okButtonProps, cancelButtonProps = props.cancelButtonProps, _d = props.getPopupContainer, getPopupContainer = _d === void 0 ? function () { return document.body; } : _d, footer = props.footer, afterClose = props.afterClose, confirmLoading = props.confirmLoading, mountOnEnter = props.mountOnEnter, unmountOnExit = props.unmountOnExit, afterOpen = props.afterOpen, hideCancel = props.hideCancel, autoFocus = props.autoFocus, focusLock = props.focusLock, maskClosable = props.maskClosable, mask = props.mask, alignCenter = props.alignCenter, getChildrenPopupContainer = props.getChildrenPopupContainer, wrapClassName = props.wrapClassName, escToExit = props.escToExit, modalRender = props.modalRender, maskStyle = props.maskStyle, wrapStyle = props.wrapStyle, closeIcon = props.closeIcon, rest = __rest$h(props, ["className", "style", "visible", "simple", "title", "children", "cancelText", "okText", "okButtonProps", "cancelButtonProps", "getPopupContainer", "footer", "afterClose", "confirmLoading", "mountOnEnter", "unmountOnExit", "afterOpen", "hideCancel", "autoFocus", "focusLock", "maskClosable", "mask", "alignCenter", "getChildrenPopupContainer", "wrapClassName", "escToExit", "modalRender", "maskStyle", "wrapStyle", "closeIcon"]);
        var modalWrapperRef = React.useRef(null);
        var contentWrapper = React.useRef(null);
        var _e = __read$w(React.useState(), 2), wrapperVisible = _e[0], setWrapperVisible = _e[1];
        var _f = __read$w(React.useState(), 2), popupZIndex = _f[0], setPopupZIndex = _f[1];
        var cursorPositionRef = React.useRef(null);
        var haveOriginTransformOrigin = React.useRef(false);
        var maskClickRef = React.useRef(false);
        var dialogIndex = React.useRef();
        if (!dialogIndex.current) {
            dialogIndex.current = globalDialogIndex++;
        }
        var _g = __read$w(useMergeValue(false, {
            defaultValue: false,
            value: confirmLoading,
        }), 2), loading = _g[0], setLoading = _g[1];
        var prefixCls = context.getPrefixCls('modal', props.prefixCls);
        var locale = context.locale, rtl = context.rtl;
        // 简洁模式下默认不显示关闭按钮
        var defaultClosable = !simple;
        var closable = 'closable' in props ? props.closable : defaultClosable;
        var getContainer = React.useCallback(function () {
            return ReactDOM.findDOMNode(getPopupContainer());
        }, [getPopupContainer]);
        useOverflowHidden(getContainer, { hidden: visible && mask });
        var onCancel = function () {
            props.onCancel && props.onCancel();
        };
        var onEscExit = function (event) {
            if (escToExit && visible && event.key === Esc.key) {
                event.stopPropagation();
                onCancel();
            }
        };
        var inExit = React.useRef(false);
        var onClickMask = function (e) {
            if (!maskClickRef.current)
                return;
            maskClickRef.current = false;
            if (!inExit.current && maskClosable && mask && e.target === e.currentTarget) {
                setTimeout(function () {
                    onCancel();
                }, 100);
            }
        };
        var onConfirmModal = function (e) {
            var onConfirm = props.onConfirm, onOk = props.onOk;
            var _onConfirm = onOk || onConfirm;
            var ret;
            if (_onConfirm) {
                ret = _onConfirm(e);
            }
            if (ret && ret.then) {
                setLoading(true);
                ret.then(function () {
                    setLoading(false);
                }, function (e) {
                    setLoading(false);
                    console.error(e);
                });
            }
        };
        React.useEffect(function () {
            var timer = null;
            if (escToExit) {
                timer = setTimeout(function () {
                    var _a;
                    if (contains$1(document.body, modalWrapperRef.current)) {
                        (_a = modalWrapperRef.current) === null || _a === void 0 ? void 0 : _a.focus();
                    }
                });
            }
            return function () {
                timer && clearTimeout(timer);
            };
        }, [visible, escToExit]);
        React.useEffect(function () {
            var _a;
            if (visible && popupZIndex === undefined) {
                if (modalWrapperRef.current) {
                    // 根据wrapper的zindex，设置内部所有弹出型组件的zindex。
                    var zIndex = +((_a = window.getComputedStyle(modalWrapperRef.current, null)) === null || _a === void 0 ? void 0 : _a.zIndex);
                    if (!isNaN(zIndex)) {
                        setPopupZIndex(zIndex + 1);
                    }
                }
            }
        }, [visible, popupZIndex]);
        var renderFooter = function () {
            if (footer === null)
                return;
            var cancelButtonNode = (React.createElement(Button$3, __assign$J({ onClick: onCancel }, cancelButtonProps), cancelText || locale.Modal.cancelText));
            var okButtonNode = (React.createElement(Button$3, __assign$J({ loading: loading, onClick: onConfirmModal, type: "primary" }, okButtonProps), okText || locale.Modal.okText));
            var footerContent = isFunction$1(footer)
                ? footer(cancelButtonNode, okButtonNode)
                : footer || (React.createElement(React.Fragment, null,
                    !hideCancel && cancelButtonNode,
                    okButtonNode));
            return React.createElement("div", { className: prefixCls + "-footer" }, footerContent);
        };
        var globalFocusLockConfig = context.focusLock.modal;
        var globalFocusLock = !!globalFocusLockConfig;
        var globalAutoFocus = isObject$1(globalFocusLockConfig) && globalFocusLockConfig.autoFocus;
        var innerFocusLock = focusLock !== undefined ? focusLock : globalFocusLock;
        var innerAutoFocus = autoFocus !== undefined ? autoFocus : globalAutoFocus;
        var element = (React.createElement(ConfigProvider, __assign$J({}, context, { prefixCls: props.prefixCls || context.prefixCls, locale: locale, zIndex: popupZIndex || 1050, getPopupContainer: function (node) {
                return typeof getChildrenPopupContainer === 'function'
                    ? getChildrenPopupContainer(node)
                    : contentWrapper.current;
            } }),
            title && (React.createElement("div", { className: prefixCls + "-header" },
                React.createElement("div", { className: prefixCls + "-title", id: "arco-dialog-" + dialogIndex.current }, title))),
            React.createElement("div", { ref: contentWrapper, className: prefixCls + "-content" }, children),
            renderFooter(),
            closable &&
                (closeIcon !== undefined ? (React.createElement("span", { onClick: onCancel, className: prefixCls + "-close-icon" }, closeIcon)) : (React.createElement(IconHover, { tabIndex: -1, onClick: onCancel, className: prefixCls + "-close-icon", role: "button", "aria-label": "Close" },
                    React.createElement(IconClose$1, null))))));
        var ariaProps = title ? { 'aria-labelledby': "arco-dialog-" + dialogIndex.current } : {};
        var modalDom = (React.createElement("div", __assign$J({ role: "dialog", "aria-modal": "true" }, ariaProps, { className: cs(prefixCls, (_a = {},
                _a[prefixCls + "-simple"] = simple,
                _a[prefixCls + "-rtl"] = rtl,
                _a), className), style: style }), innerFocusLock ? (React.createElement(FocusLock, { crossFrame: false, disabled: !visible, autoFocus: innerAutoFocus, lockProps: {
                tabIndex: -1,
                onKeyDown: onEscExit,
            } }, element)) : (React.createElement(React.Fragment, null, element))));
        var setTransformOrigin = function (e) {
            if (haveOriginTransformOrigin.current)
                return;
            var transformOrigin = '';
            if (cursorPositionRef.current) {
                var eRect = e.getBoundingClientRect();
                var _a = cursorPositionRef.current, left = _a.left, top_1 = _a.top;
                transformOrigin = left - eRect.left + "px " + (top_1 - eRect.top) + "px";
            }
            e.style.transformOrigin = transformOrigin;
        };
        return (React.createElement(Portal, { visible: visible, forceRender: !mountOnEnter, getContainer: getPopupContainer },
            React.createElement("div", { ref: ref },
                mask ? (React.createElement(CSSTransition$1, { in: visible, timeout: 400, appear: true, mountOnEnter: mountOnEnter, classNames: "fadeModal", unmountOnExit: unmountOnExit, onEnter: function (e) {
                        e.style.display = 'block';
                    }, onExited: function (e) {
                        e.style.display = 'none';
                    } },
                    React.createElement("div", { "aria-hidden": true, className: prefixCls + "-mask", style: maskStyle }))) : null,
                React.createElement("div", __assign$J({}, omit$1(rest, [
                    'content',
                    'icon',
                    'showIcon',
                    'isNotice',
                    'noticeType',
                    'onCancel',
                    'onOk',
                    'onConfirm',
                    'closable',
                    'prefixCls',
                ]), { tabIndex: !innerFocusLock || !innerAutoFocus ? -1 : null, ref: modalWrapperRef, className: cs(prefixCls + "-wrapper", (_b = {},
                        _b[prefixCls + "-wrapper-no-mask"] = !mask,
                        _b[prefixCls + "-wrapper-align-center"] = alignCenter,
                        _b[prefixCls + "-wrapper-rtl"] = rtl,
                        _b), wrapClassName), style: __assign$J(__assign$J({}, (wrapStyle || {})), { 
                        // 必须 visible=false，立即设置display:none，否则modal加载react-monaco-editor的时候，编辑器显示异常
                        display: visible || wrapperVisible ? 'block' : 'none', overflow: !visible && wrapperVisible ? 'hidden' : '' }), 
                    // 如果 autoFocus 是 false 需要在 modal 外层绑定 onKeyDown, 因为此时 FocusLock 绑定的 onKeyDown 不起作用
                    onKeyDown: !innerFocusLock || !innerAutoFocus ? onEscExit : null, onMouseDown: function (e) {
                        maskClickRef.current = e.target === e.currentTarget;
                    }, onClick: onClickMask }),
                    React.createElement(CSSTransition$1, { in: visible, timeout: 400, appear: true, classNames: "zoomModal", unmountOnExit: unmountOnExit, mountOnEnter: mountOnEnter, onEnter: function (e) {
                            setWrapperVisible(true);
                            cursorPositionRef.current = cursorPosition;
                            haveOriginTransformOrigin.current = !!e.style.transformOrigin;
                            setTransformOrigin(e);
                        }, onEntered: function (e) {
                            setTransformOrigin(e);
                            cursorPositionRef.current = null;
                            afterOpen && afterOpen();
                        }, onExit: function () {
                            inExit.current = true;
                        }, onExited: function (e) {
                            setWrapperVisible(false);
                            setTransformOrigin(e);
                            afterClose && afterClose();
                            inExit.current = false;
                        } }, React.cloneElement((isFunction$1(modalRender) ? modalRender(modalDom) : modalDom), {
                        onMouseDown: function () {
                            maskClickRef.current = false;
                        },
                        onMouseUp: function () {
                            maskClickRef.current = false;
                        },
                    }))))));
    }
    var ExportedModalComponent = React.forwardRef(Modal);
    ExportedModalComponent.displayName = 'Modal';
    ExportedModalComponent.config = setModalConfig;
    ExportedModalComponent.confirm = function (props) {
        return confirm(props);
    };
    ExportedModalComponent.useModal = useModal;
    ['info', 'success', 'warning', 'error'].forEach(function (type) {
        ExportedModalComponent[type] = function (props) {
            return confirm(__assign$J(__assign$J({}, props), { isNotice: true, noticeType: type }));
        };
    });
    ExportedModalComponent.destroyAll = function () {
        while (destroyList.length) {
            var close_1 = destroyList.pop();
            if (close_1) {
                close_1();
            }
        }
    };
    var Modal$1 = ExportedModalComponent;

    var __assign$I = (undefined && undefined.__assign) || function () {
        __assign$I = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$I.apply(this, arguments);
    };
    var getBackground = function (color, percent) {
        if (isObject$1(color)) {
            var val = Object.keys(color)
                .map(function (key) { return color[key] + " " + key; })
                .join(',');
            var sizeProps = percent ? { backgroundSize: (100 * 100) / percent + "%" } : {};
            return __assign$I({ backgroundImage: "linear-gradient(to right, " + val + ")" }, sizeProps);
        }
        return {
            backgroundColor: color,
        };
    };
    var defaultStrokeWidth$1 = {
        small: 3,
        default: 4,
        large: 8,
    };
    function LineProgress(props) {
        var _a, _b;
        var 
        // textInside,
        type = props.type, prefixCls = props.prefixCls, buffer = props.buffer, percent = props.percent, color = props.color, animation = props.animation, bufferColor = props.bufferColor, formatText = props.formatText, trailColor = props.trailColor, _c = props.showText, showText = _c === void 0 ? true : _c, _d = props.size, size = _d === void 0 ? 'default' : _d, _e = props.status, status = _e === void 0 ? 'normal' : _e;
        var strokeWidth = props.strokeWidth || defaultStrokeWidth$1[size];
        var cls = prefixCls + "-" + type;
        var height = strokeWidth;
        var isFinish = status === 'success' || status === 'error' || percent >= 100;
        var getText = React.useCallback(function () {
            if (isFunction$1(formatText)) {
                return formatText(percent);
            }
            switch (status) {
                case 'error':
                    return (React.createElement("span", null,
                        percent,
                        "% ",
                        React.createElement(IconExclamationCircleFill$1, null)));
                default:
                    return percent + "%";
            }
        }, [formatText, percent, status]);
        return (React.createElement("div", { className: cls + "-wrapper" },
            React.createElement("div", { className: cls + "-outer", role: "progressbar", "aria-valuemin": 0, "aria-valuemax": 100, "aria-valuenow": percent, style: { height: height, backgroundColor: trailColor } },
                buffer && !isFinish && (React.createElement("div", { className: cls + "-inner-buffer", style: __assign$I({ width: (percent > 0 ? percent + 10 : 0) + "%" }, getBackground(bufferColor)) })),
                React.createElement("div", { className: cs(cls + "-inner", (_a = {}, _a[cls + "-inner-animate"] = animation, _a)), style: __assign$I({ width: percent + "%" }, getBackground(color, percent)) })),
            showText && (React.createElement("div", { className: cs(cls + "-text", (_b = {}, _b[cls + "-text-with-icon"] = status, _b)) }, getText()))));
    }

    function ownKeys$l(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$m(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$l(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$l(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconExclamationComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$m(_objectSpread$m({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-exclamation")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M23 9H25V30H23z"
      }), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        stroke: "none",
        d: "M23 9H25V30H23z"
      }), /*#__PURE__*/React.createElement("path", {
        d: "M23 37H25V39H23z"
      }), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        stroke: "none",
        d: "M23 37H25V39H23z"
      }));
    }

    var IconExclamation = /*#__PURE__*/React.forwardRef(IconExclamationComponent);
    IconExclamation.defaultProps = {
      isIcon: true
    };
    IconExclamation.displayName = 'IconExclamation';
    var IconExclamation$1 = IconExclamation;

    var defaultStrokeWidth = {
        mini: 4,
        small: 3,
        default: 4,
        large: 4,
    };
    var defaultWidth = {
        mini: 16,
        small: 48,
        default: 64,
        large: 80,
    };
    var CircleProgress = function (props) {
        var size = props.size, _a = props.percent, percent = _a === void 0 ? 0 : _a, prefixCls = props.prefixCls, showText = props.showText, status = props.status, formatText = props.formatText;
        var isLinearGradient = isObject$1(props.color);
        var width = props.width || defaultWidth[size];
        var strokeWidth = props.strokeWidth || (size === 'mini' ? width / 2 : defaultStrokeWidth[size]);
        var radius = (width - strokeWidth) / 2;
        var perimeter = Math.PI * 2 * radius;
        var center = width / 2;
        var cls = prefixCls + "-circle";
        var svgCls = cls + "-svg";
        var getText = React.useCallback(function (status) {
            if (isFunction$1(formatText)) {
                return formatText(percent);
            }
            switch (status) {
                case 'success':
                    return React.createElement(IconCheck$1, null);
                case 'error':
                    return React.createElement(IconExclamation$1, null);
                default:
                    return percent + "%";
            }
        }, [formatText, percent]);
        var linearGradientId = useId(prefixCls + "-linear-gradient-");
        var color = isLinearGradient ? "url(#" + linearGradientId + ")" : props.color;
        var dom = (React.createElement("div", { className: cls + "-wrapper", role: "progressbar", "aria-valuemin": 0, "aria-valuemax": 100, "aria-valuenow": percent, style: { width: width, height: width } },
            React.createElement("svg", { viewBox: "0 0 " + width + " " + width, className: "" + svgCls },
                isLinearGradient && (React.createElement("defs", null,
                    React.createElement("linearGradient", { id: linearGradientId, x1: "0", y1: "1", x2: "0", y2: "0" }, Object.keys(props.color)
                        .sort()
                        .map(function (key) {
                        return React.createElement("stop", { offset: key, key: key, stopColor: props.color[key] });
                    })))),
                React.createElement("circle", { className: cls + "-mask", fill: "none", cx: center, cy: center, r: radius, strokeWidth: props.pathStrokeWidth || (size === 'mini' ? strokeWidth : Math.max(2, strokeWidth - 2)), style: {
                        stroke: props.pathStrokeColor,
                    } }),
                React.createElement("circle", { className: cls + "-path", fill: "none", cx: center, cy: center, r: radius, strokeWidth: strokeWidth, style: {
                        stroke: color,
                        strokeDasharray: perimeter,
                        strokeDashoffset: (percent > 100 ? 100 : 1 - percent / 100) * perimeter,
                    } })),
            showText && size !== 'mini' && React.createElement("div", { className: cls + "-text" }, getText(status))));
        // type === line 时候，返回的是一个圆环
        if (size === 'mini' && status === 'success' && props.type === 'circle') {
            dom = (React.createElement("div", { className: cls + "-wrapper", style: { width: width, height: width } },
                React.createElement(IconCheck$1, { style: { fontSize: width - 2, color: color } })));
        }
        return size === 'mini' && showText ? (React.createElement(Tooltip$1, { content: React.createElement("div", { className: cls + "-text" }, getText('normal')) }, dom)) : (dom);
    };
    var CircleProgress$1 = CircleProgress;

    var __read$v = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$f = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var StepsProgress = function (props) {
        var _a;
        var prefixCls = props.prefixCls, percent = props.percent, color = props.color, type = props.type, formatText = props.formatText, trailColor = props.trailColor, _b = props.showText, showText = _b === void 0 ? true : _b, _c = props.size, size = _c === void 0 ? 'default' : _c, _d = props.status, status = _d === void 0 ? 'normal' : _d;
        var strokeWidth = props.strokeWidth || (size === 'small' ? 8 : 4);
        var cls = prefixCls + "-" + type;
        var height = strokeWidth;
        var getText = React.useCallback(function () {
            if (isFunction$1(formatText)) {
                return formatText(percent);
            }
            switch (status) {
                case 'error':
                    return (React.createElement("span", null,
                        percent,
                        "% ",
                        React.createElement(IconExclamationCircleFill$1, null)));
                default:
                    return percent + "%";
            }
        }, [formatText, percent, status]);
        return (React.createElement("div", { className: cls + "-wrapper" },
            React.createElement("div", { className: cls + "-outer", role: "progressbar", "aria-valuemin": 0, "aria-valuemax": 100, "aria-valuenow": percent, style: { height: height } }, __spreadArray$f([], __read$v(new Array(props.steps)), false).map(function (_, index) {
                var _a;
                var isActive = percent > (100 / props.steps) * index;
                return (React.createElement("div", { key: index, className: cs(cls + "-item", (_a = {},
                        _a[cls + "-item-active"] = isActive,
                        _a)), style: {
                        backgroundColor: isActive ? color : trailColor || '',
                    } }));
            })),
            showText && (React.createElement("div", { className: cs(cls + "-text", (_a = {}, _a[cls + "-text-with-icon"] = status, _a)) }, getText()))));
    };
    var StepsProgress$1 = StepsProgress;

    var __assign$H = (undefined && undefined.__assign) || function () {
        __assign$H = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$H.apply(this, arguments);
    };
    var __rest$g = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var defaultProps$c = {
        type: 'line',
        showText: true,
        percent: 0,
        size: 'default',
    };
    function Progress(baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$c, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Progress);
        var className = props.className, style = props.style, size = props.size, width = props.width, strokeWidth = props.strokeWidth, steps = props.steps, percent = props.percent, rest = __rest$g(props, ["className", "style", "size", "width", "strokeWidth", "steps", "percent"]);
        var type = steps && props.type !== 'circle' ? 'steps' : props.type;
        var prefixCls = getPrefixCls('progress');
        var status = 'status' in props ? props.status : percent >= 100 ? 'success' : 'normal';
        var widthStyle = { width: width };
        if (size === 'mini' && type === 'line') {
            widthStyle.width = width || 16;
            widthStyle.height = width || 16;
        }
        return (React.createElement("div", __assign$H({ ref: ref, className: cs(prefixCls, prefixCls + "-" + type, prefixCls + "-" + size, (_a = {},
                _a[prefixCls + "-is-" + status] = status !== 'normal',
                _a[prefixCls + "-rtl"] = rtl,
                _a), className), style: __assign$H(__assign$H({}, widthStyle), style) }, omit$1(rest, [
            'type',
            'animation',
            'status',
            'color',
            'trailColor',
            'showText',
            'formatText',
            'buffer',
            'bufferColor',
        ])),
            type === 'steps' && (React.createElement(StepsProgress$1, __assign$H({}, props, { type: type, status: status, prefixCls: prefixCls }))),
            type === 'circle' && (React.createElement(CircleProgress$1, __assign$H({ width: props.width }, props, { pathStrokeColor: props.trailColor, status: status, prefixCls: prefixCls }))),
            type === 'line' &&
                (size === 'mini' ? (React.createElement(CircleProgress$1, __assign$H({ pathStrokeColor: props.trailColor }, props, { pathStrokeWidth: strokeWidth || 4, width: width || 16, strokeWidth: strokeWidth || 4, prefixCls: prefixCls, status: status }))) : (React.createElement(LineProgress, __assign$H({}, props, { status: status, prefixCls: prefixCls }))))));
    }
    var ProgressRef = React.forwardRef(Progress);
    ProgressRef.displayName = 'Progress';
    var Progress$1 = ProgressRef;

    var __assign$G = (undefined && undefined.__assign) || function () {
        __assign$G = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$G.apply(this, arguments);
    };
    var __rest$f = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var defaultProps$b = {
        size: 'small',
        direction: 'horizontal',
    };
    function Space$1(baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$b, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Space);
        var className = props.className, style = props.style, children = props.children, size = props.size, direction = props.direction, align = props.align, wrap = props.wrap, split = props.split, rest = __rest$f(props, ["className", "style", "children", "size", "direction", "align", "wrap", "split"]);
        var prefixCls = getPrefixCls('space');
        var innerAlign = align || (direction === 'horizontal' ? 'center' : '');
        var classNames = cs(prefixCls, (_a = {},
            _a[prefixCls + "-" + direction] = direction,
            _a[prefixCls + "-align-" + innerAlign] = innerAlign,
            _a[prefixCls + "-wrap"] = wrap,
            _a[prefixCls + "-rtl"] = rtl,
            _a), className);
        function getMargin(size) {
            if (isNumber(size)) {
                return size;
            }
            switch (size) {
                case 'mini':
                    return 4;
                case 'small':
                    return 8;
                case 'medium':
                    return 16;
                case 'large':
                    return 24;
                default:
                    return 8;
            }
        }
        var childrenList = React.Children.toArray(children);
        function getMarginStyle(index) {
            var _a, _b, _c, _d;
            // const isLastOne =
            //   rtl && direction === 'horizontal' ? index === 0 : childrenList.length === index + 1;
            var isLastOne = childrenList.length === index + 1;
            var marginDirection = rtl ? 'marginLeft' : 'marginRight';
            if (typeof size === 'string' || typeof size === 'number') {
                var margin = getMargin(size);
                if (wrap) {
                    return isLastOne
                        ? { marginBottom: margin }
                        : (_a = {},
                            _a["" + marginDirection] = margin,
                            _a.marginBottom = margin,
                            _a);
                }
                return !isLastOne
                    ? (_b = {},
                        _b[direction === 'vertical' ? 'marginBottom' : marginDirection] = margin,
                        _b) : {};
            }
            if (isArray$1(size)) {
                var marginHorizontal = getMargin(size[0]);
                var marginBottom = getMargin(size[1]);
                if (wrap) {
                    return isLastOne
                        ? { marginBottom: marginBottom }
                        : (_c = {},
                            _c["" + marginDirection] = marginHorizontal,
                            _c.marginBottom = marginBottom,
                            _c);
                }
                if (direction === 'vertical') {
                    return { marginBottom: marginBottom };
                }
                return _d = {}, _d["" + marginDirection] = marginHorizontal, _d;
            }
        }
        return (React.createElement("div", __assign$G({ ref: ref, className: classNames, style: style }, rest), childrenList.map(function (child, index) {
            var _a;
            // Keep the key passed on the child to avoid additional DOM remounting
            // Related issue: https://github.com/arco-design/arco-design/issues/1320
            var key = ((_a = child) === null || _a === void 0 ? void 0 : _a.key) || index;
            var shouldRenderSplit = split !== undefined && split !== null && index > 0;
            return (React.createElement(React.Fragment, { key: key },
                shouldRenderSplit && React.createElement("div", { className: prefixCls + "-item-split" }, split),
                React.createElement("div", { className: prefixCls + "-item", style: getMarginStyle(index) }, child)));
        })));
    }
    var SpaceComponent = React.forwardRef(Space$1);
    SpaceComponent.displayName = 'Space';
    var ArcoSpace = SpaceComponent;

    function Step(props, ref) {
        var _a;
        var style = props.style, className = props.className, prefixCls = props.prefixCls, _b = props.index, index = _b === void 0 ? 1 : _b, _c = props.current, current = _c === void 0 ? 1 : _c, status = props.status, title = props.title, description = props.description, icon = props.icon, nextStepError = props.nextStepError, type = props.type, customDot = props.customDot, labelPlacement = props.labelPlacement, disabled = props.disabled, onClick = props.onClick, onChange = props.onChange, direction = props.direction, id = props.id, lineless = props.lineless;
        function renderIconNode(currentStatus) {
            if (type === 'dot') {
                return null;
            }
            var content = index;
            if (icon) {
                content = icon;
            }
            else if (currentStatus === 'finish') {
                content = React.createElement(IconCheck$1, null);
            }
            else if (currentStatus === 'error') {
                content = React.createElement(IconClose$1, null);
            }
            return React.createElement("div", { className: prefixCls + "-icon" }, content);
        }
        function onClickStep(e) {
            if (!disabled) {
                // Step.onChange
                onChange && current !== index && onChange(index, id);
                // props.onClick
                onClick && onClick(index, id, e);
            }
        }
        var currentStatus;
        if (status) {
            currentStatus = status;
        }
        else {
            if (current < index) {
                currentStatus = 'wait';
            }
            if (current === index) {
                currentStatus = 'process';
            }
            if (current > index) {
                currentStatus = 'finish';
            }
        }
        var classNames = cs(prefixCls + "-item", prefixCls + "-item-" + currentStatus, (_a = {},
            _a[prefixCls + "-item-custom"] = !!icon,
            _a[prefixCls + "-item-next-error"] = nextStepError,
            _a[prefixCls + "-item-disabled"] = disabled,
            _a[prefixCls + "-item-active"] = index === current,
            _a), className);
        var iconNode = renderIconNode(currentStatus);
        var iconNodeWrapped = React.createElement("div", { className: prefixCls + "-item-icon" }, iconNode);
        var customDotElement = customDot
            ? customDot(iconNodeWrapped, {
                index: index,
                status: currentStatus,
                title: title,
                description: description,
            })
            : iconNodeWrapped;
        return (React.createElement("div", { ref: ref, className: classNames, style: style, onClick: onClickStep },
            !lineless && (labelPlacement === 'vertical' || direction === 'vertical') && (React.createElement("div", { className: prefixCls + "-item-tail" })),
            type !== 'arrow' && customDotElement,
            React.createElement("div", { className: prefixCls + "-item-content" },
                React.createElement("div", { className: prefixCls + "-item-title" }, title),
                description && React.createElement("div", { className: prefixCls + "-item-description" }, description))));
    }
    var StepComponent = React.forwardRef(Step);
    StepComponent.displayName = 'Step';
    var Step$1 = StepComponent;

    var __assign$F = (undefined && undefined.__assign) || function () {
        __assign$F = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$F.apply(this, arguments);
    };
    var defaultProps$a = {
        current: 1,
        type: 'default',
        size: 'default',
        direction: 'horizontal',
        labelPlacement: 'horizontal',
    };
    function Steps(baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$a, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Steps);
        var className = props.className, style = props.style, children = props.children, _c = props.current, current = _c === void 0 ? 1 : _c, status = props.status, onChange = props.onChange, type = props.type, size = props.size, direction = props.direction, labelPlacement = props.labelPlacement, customDot = props.customDot, lineless = props.lineless;
        var prefixCls = getPrefixCls('steps');
        var innerLabelPlacement = labelPlacement;
        if (type === 'dot') {
            innerLabelPlacement = direction === 'vertical' ? 'horizontal' : 'vertical';
        }
        if (type === 'navigation') {
            innerLabelPlacement = 'horizontal';
        }
        var innerDirection = direction;
        if (type === 'navigation' || type === 'arrow') {
            innerDirection = 'horizontal';
        }
        var classNames = cs(prefixCls, prefixCls + "-" + innerDirection, prefixCls + "-label-" + innerLabelPlacement, prefixCls + "-size-" + size, (_a = {},
            _a[prefixCls + "-change-onclick"] = typeof onChange === 'function',
            _a[prefixCls + "-mode-" + type] = type !== 'default',
            _a[prefixCls + "-lineless"] = lineless,
            _a[prefixCls + "-rtl"] = rtl,
            _a), className);
        return (React.createElement("div", __assign$F({ ref: ref, style: style, className: classNames }, pickDataAttributes(props)), React.Children.toArray(children)
            .filter(function (child) {
            return child && child.type && child.type.displayName === 'Step';
        })
            .map(function (child, index) {
            // step 的 index 从 1 开始
            index += 1;
            if (child) {
                var childProps = __assign$F({ prefixCls: prefixCls, type: type, index: index, current: current, status: current === index ? status : undefined, customDot: customDot, labelPlacement: innerLabelPlacement, direction: innerDirection, onChange: onChange, lineless: lineless }, child.props);
                if (status === 'error' && current === index + 1) {
                    childProps.nextStepError = true;
                }
                return React.cloneElement(child, childProps);
            }
            return null;
        })));
    }
    var ForwardRefSteps = React.forwardRef(Steps);
    var StepsComponent = ForwardRefSteps;
    StepsComponent.displayName = 'Steps';
    StepsComponent.Step = Step$1;
    var Steps$1 = StepsComponent;

    var __assign$E = (undefined && undefined.__assign) || function () {
        __assign$E = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$E.apply(this, arguments);
    };
    var __rest$e = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$u = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var defaultProps$9 = {
        type: 'circle',
    };
    function Switch$1(baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, ctxSize = _b.size, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$9, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Switch);
        var className = props.className, children = props.children, _c = props.style, style = _c === void 0 ? {} : _c, disabled = props.disabled, propSize = props.size, loading = props.loading, onChange = props.onChange, type = props.type, checkedText = props.checkedText, uncheckedText = props.uncheckedText, checkedIcon = props.checkedIcon, uncheckedIcon = props.uncheckedIcon, rest = __rest$e(props, ["className", "children", "style", "disabled", "size", "loading", "onChange", "type", "checkedText", "uncheckedText", "checkedIcon", "uncheckedIcon"]);
        var prefixCls = getPrefixCls('switch');
        var size = propSize || ctxSize;
        var _d = __read$u(React.useState(props.defaultChecked), 2), checked = _d[0], setChecked = _d[1];
        var mergedChecked = 'checked' in props ? props.checked : checked;
        var onHandleClick = function (event) {
            if (loading) {
                return;
            }
            props.onClick && props.onClick(event);
            if (!('checked' in props)) {
                setChecked(!mergedChecked);
            }
            onChange && onChange(!mergedChecked, event);
        };
        var classNames = cs(prefixCls, size === 'small' ? prefixCls + "-" + size : undefined, (_a = {},
            _a[prefixCls + "-type-" + type] = type,
            _a[prefixCls + "-checked"] = mergedChecked,
            _a[prefixCls + "-loading"] = loading,
            _a[prefixCls + "-rtl"] = rtl,
            _a), className);
        var checkedElement = checkedText;
        var unCheckedElement = uncheckedText;
        // 支持通过 children 传入 checkedText 和 uncheckedText，不过建议直接使用参数 checkedText 和 uncheckedText
        if (children && isArray$1(children)) {
            checkedElement = children.find(function (child) { return child.key === 'open'; });
            unCheckedElement = children.find(function (child) { return child.key === 'close'; });
        }
        else if (children && isObject$1(children)) {
            if (children.key === 'open') {
                checkedElement = children;
            }
            else if (children.key === 'close') {
                unCheckedElement = children;
            }
        }
        var extraProps = omit$1(rest, ['onChange', 'checked', 'error']);
        return (React.createElement("button", __assign$E({ ref: ref, role: "switch", "aria-checked": !!mergedChecked, tabIndex: loading ? -1 : undefined }, extraProps, { style: style, className: classNames, disabled: disabled, onClick: onHandleClick, type: "button" }),
            React.createElement("div", { className: prefixCls + "-dot" },
                !loading && (checkedIcon || uncheckedIcon) && (React.createElement(SwitchTransition$1, null,
                    React.createElement(CSSTransition$1, { key: mergedChecked ? 'checked' : 'unchecked', classNames: "fadeIn", timeout: 200 },
                        React.createElement("span", { className: prefixCls + "-dot-icon" }, mergedChecked ? checkedIcon : uncheckedIcon)))),
                loading && (React.createElement("span", { className: prefixCls + "-dot-icon" },
                    React.createElement(IconLoading$1, null)))),
            size !== 'small' && type !== 'line' && (checkedElement || unCheckedElement) && (React.createElement(React.Fragment, null,
                React.createElement("div", { className: prefixCls + "-text-holder" },
                    checkedElement && mergedChecked && checkedElement,
                    unCheckedElement && !mergedChecked && unCheckedElement),
                React.createElement(CSSTransition$1, { in: mergedChecked, classNames: "switchSlideText", timeout: 200 },
                    React.createElement("div", { className: prefixCls + "-text" },
                        checkedElement && mergedChecked && checkedElement,
                        unCheckedElement && !mergedChecked && unCheckedElement))))));
    }
    var ForwardRefSwitch = React.forwardRef(Switch$1);
    var SwitchComponent = ForwardRefSwitch;
    SwitchComponent.__BYTE_SWITCH = true;
    SwitchComponent.displayName = 'Switch';
    var ArcoSwitch = SwitchComponent;

    function ownKeys$k(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$l(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$k(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$k(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconFilterComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$l(_objectSpread$l({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-filter")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M30 42V22.549a1 1 0 0 1 .463-.844l10.074-6.41A1 1 0 0 0 41 14.45V8a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v6.451a1 1 0 0 0 .463.844l10.074 6.41a1 1 0 0 1 .463.844V37"
      }));
    }

    var IconFilter = /*#__PURE__*/React.forwardRef(IconFilterComponent);
    IconFilter.defaultProps = {
      isIcon: true
    };
    IconFilter.displayName = 'IconFilter';
    var IconFilter$1 = IconFilter;

    var defaultComponents = {
        table: 'table',
        header: {
            operations: function (_a) {
                var selectionNode = _a.selectionNode, expandNode = _a.expandNode;
                return [
                    {
                        name: 'expandNode',
                        node: expandNode,
                    },
                    {
                        name: 'selectionNode',
                        node: selectionNode,
                    },
                ];
            },
            wrapper: 'div',
            thead: 'thead',
            row: 'tr',
            th: 'th',
            cell: 'div',
        },
        body: {
            operations: function (_a) {
                var selectionNode = _a.selectionNode, expandNode = _a.expandNode;
                return [
                    {
                        name: 'expandNode',
                        node: expandNode,
                    },
                    {
                        name: 'selectionNode',
                        node: selectionNode,
                    },
                ];
            },
            wrapper: 'div',
            tbody: 'tbody',
            row: 'tr',
            td: 'td',
            cell: 'span',
        },
    };
    function useComponent(components) {
        var _components = React.useMemo(function () { return (isObject$1(components) ? merge_1({}, defaultComponents, components) : defaultComponents); }, [components]);
        return {
            getHeaderComponentOperations: _components.header.operations,
            getBodyComponentOperations: _components.body.operations,
            ComponentTable: _components.table,
            ComponentHeaderWrapper: _components.header.wrapper,
            ComponentThead: _components.header.thead,
            ComponentHeaderRow: _components.header.row,
            ComponentTh: _components.header.th,
            ComponentHeaderCell: _components.header.cell,
            ComponentBodyWrapper: _components.body.wrapper,
            ComponentTbody: _components.body.tbody,
            ComponentBodyRow: _components.body.row,
            ComponentTd: _components.body.td,
            ComponentBodyCell: _components.body.cell,
        };
    }

    var __assign$D = (undefined && undefined.__assign) || function () {
        __assign$D = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$D.apply(this, arguments);
    };
    var __read$t = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$e = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    function getTooltipContent(nextSorterDirection, locale) {
        if (nextSorterDirection === 'ascend') {
            return locale.Table.sortAscend;
        }
        if (nextSorterDirection === 'descend') {
            return locale.Table.sortDescend;
        }
        return locale.Table.cancelSort;
    }
    function Column(_a) {
        var _b, _c, _d, _e;
        var onSort = _a.onSort, onFilter = _a.onFilter, onHandleFilter = _a.onHandleFilter, onHandleFilterReset = _a.onHandleFilterReset, _f = _a.currentFilters, currentFilters = _f === void 0 ? {} : _f, currentSorter = _a.currentSorter, _key = _a._key, dataIndex = _a.dataIndex, title = _a.title, sorter = _a.sorter, _g = _a.sortDirections, sortDirections = _g === void 0 ? ['ascend', 'descend'] : _g, _h = _a.filters, filters = _h === void 0 ? [] : _h, columnFixedStyle = _a.columnFixedStyle, className = _a.className, cellStyle = _a.cellStyle, headerCellStyle = _a.headerCellStyle, rowSpan = _a.rowSpan, colSpan = _a.colSpan, headerCellProps = _a.headerCellProps, prefixCls = _a.prefixCls, _j = _a.align, align = _j === void 0 ? 'left' : _j, components = _a.components, filterIcon = _a.filterIcon, filterDropdown = _a.filterDropdown, _k = _a.filterMultiple, filterMultiple = _k === void 0 ? true : _k, ellipsis = _a.ellipsis, filterDropdownProps = _a.filterDropdownProps, onFilterDropdownVisibleChange = _a.onFilterDropdownVisibleChange, column = _a.column, showSorterTooltip = _a.showSorterTooltip, index = _a.index;
        var _l = React.useContext(ConfigContext), locale = _l.locale, rtl = _l.rtl;
        var innerDataIndex = dataIndex === undefined ? index : dataIndex;
        // stateCurrentFilter 标记了下拉框中选中的 filter 项目，在受控模式下它与 currentFilter 可以不同
        var _m = __read$t(useMergeValue([], {
            value: currentFilters[innerDataIndex] || [],
        }), 3), currentFilter = _m[0], setCurrentFilter = _m[1], stateCurrentFilter = _m[2];
        var _o = __read$t(React.useState(false), 2), filterVisible = _o[0], setFilterVisible = _o[1];
        var _p = __read$t(React.useState(false), 2), isEnter = _p[0], setEnter = _p[1];
        var enableSort = sorter && isArray$1(sortDirections) && sortDirections.length;
        var nextSortDirection = enableSort ? getNextSortDirection() : undefined;
        React.useEffect(function () {
            setCurrentFilter(currentFilters[innerDataIndex] || []);
        }, [currentFilters, innerDataIndex]);
        React.useEffect(function () {
            if (currentFilter && currentFilter !== stateCurrentFilter) {
                setCurrentFilter(currentFilter);
            }
        }, [filterVisible]);
        function getNextSortDirection() {
            var currentSortDirection = currentSorter && currentSorter.direction;
            if (!currentSortDirection || (currentSorter && currentSorter.field !== innerDataIndex)) {
                return sortDirections[0];
            }
            var sorterIndex = sortDirections.indexOf(currentSortDirection);
            if (sorterIndex < sortDirections.length) {
                return sortDirections[sorterIndex + 1];
            }
        }
        function handleFilter() {
            if (!currentFilter)
                return;
            onHandleFilter &&
                onHandleFilter({ onFilter: onFilter, filters: filters, dataIndex: innerDataIndex }, stateCurrentFilter);
            onVisibleChange(false);
        }
        function handleFilterReset() {
            onHandleFilterReset({ dataIndex: innerDataIndex });
            onVisibleChange(false);
        }
        function onVisibleChange(filterVisible) {
            setFilterVisible(filterVisible);
            onFilterDropdownVisibleChange && onFilterDropdownVisibleChange(filterVisible);
        }
        function onChangeFilterItem(filterValue, checked) {
            var filter = __spreadArray$e([], __read$t(stateCurrentFilter), false);
            if (filterMultiple) {
                if (checked) {
                    filter = filter.concat(filterValue);
                }
                else {
                    filter.splice(filter.findIndex(function (value) { return value === filterValue; }), 1);
                }
            }
            else if (filter.length > 0) {
                if (filter[0] !== filterValue) {
                    filter = [filterValue];
                }
                else {
                    return;
                }
            }
            else {
                filter = [filterValue];
            }
            setCurrentFilter(filter);
        }
        // filterDropdown confirm
        function confirm(_filterKeys) {
            setCurrentFilter(_filterKeys || stateCurrentFilter);
            setFilterVisible(false);
            onHandleFilter &&
                onHandleFilter({ filters: filters, onFilter: onFilter, dataIndex: innerDataIndex }, _filterKeys || stateCurrentFilter);
        }
        function renderFilters() {
            return typeof filterDropdown === 'function' ? (filterDropdown({
                filterKeys: stateCurrentFilter,
                setFilterKeys: function (filterKeys, callback) {
                    setCurrentFilter(filterKeys);
                    callback && callback();
                },
                confirm: confirm,
            })) : (React.createElement("div", { className: prefixCls + "-filters-popup" },
                React.createElement("div", { className: prefixCls + "-filters-list" }, filters.map(function (col) {
                    var checked = stateCurrentFilter.findIndex(function (value) { return value === col.value; }) !== -1;
                    return (React.createElement("div", { className: prefixCls + "-filters-item", key: col.value }, filterMultiple ? (React.createElement(Checkbox$2, { checked: checked, onChange: function (checked) { return onChangeFilterItem(col.value, checked); } }, col.text)) : (React.createElement(Radio$1, { checked: checked, onChange: function (checked) { return onChangeFilterItem(col.value, checked); } }, col.text))));
                })),
                React.createElement(ArcoSpace, { className: prefixCls + "-filters-btn" },
                    React.createElement(Button$3, { onClick: handleFilterReset, size: "mini" }, locale.Table.resetText),
                    React.createElement(Button$3, { onClick: handleFilter, type: "primary", size: "mini" }, locale.Table.okText))));
        }
        var classNameSorter = function (direction) {
            var _a;
            return cs(prefixCls + "-sorter-icon", (_a = {},
                _a[prefixCls + "-sorter-icon-active"] = currentSorter &&
                    currentSorter.direction === direction &&
                    currentSorter.field === innerDataIndex,
                _a));
        };
        var classNameFilter = cs(prefixCls + "-filters", (_b = {},
            _b[prefixCls + "-filters-open"] = filterVisible,
            _b[prefixCls + "-filters-active"] = currentFilter && currentFilter.length,
            _b));
        var styleTh = __assign$D({}, columnFixedStyle);
        if (isObject$1(cellStyle)) {
            styleTh = __assign$D(__assign$D({}, styleTh), cellStyle);
        }
        if (isObject$1(headerCellStyle)) {
            styleTh = __assign$D(__assign$D({}, styleTh), headerCellStyle);
        }
        if (align && align !== 'left') {
            styleTh.textAlign = align;
        }
        var thProps = {
            style: styleTh,
            key: _key || innerDataIndex,
        };
        if (colSpan && colSpan > 1) {
            thProps.colSpan = colSpan;
        }
        if (rowSpan && rowSpan > 1) {
            thProps.rowSpan = rowSpan;
        }
        var _q = useComponent(components), ComponentTh = _q.ComponentTh, ComponentHeaderCell = _q.ComponentHeaderCell;
        var shouldRenderFilters = (isArray$1(filters) && filters.length > 0) || typeof filterDropdown === 'function';
        var titleProps = ellipsis && typeof title === 'string' ? { title: title } : {};
        var filterDropdownTriggerProps = filterDropdownProps && filterDropdownProps.triggerProps;
        var cellChildren = (React.createElement(React.Fragment, null,
            enableSort ? (React.createElement(Tooltip$1, __assign$D({ content: getTooltipContent(nextSortDirection, locale), disabled: !showSorterTooltip }, (isObject$1(showSorterTooltip) ? showSorterTooltip : {})),
                React.createElement("div", { className: prefixCls + "-cell-with-sorter", onMouseEnter: function () {
                        setEnter(true);
                    }, onMouseLeave: function () {
                        setEnter(false);
                    }, onClick: function () { return onSort(nextSortDirection, innerDataIndex); } },
                    React.createElement("span", __assign$D({ className: prefixCls + "-th-item-title" }, titleProps), title),
                    enableSort && (React.createElement("div", { className: cs(prefixCls + "-sorter", (_c = {},
                            _c[prefixCls + "-sorter-direction-one"] = sortDirections.length === 1,
                            _c)) },
                        sortDirections.indexOf('ascend') !== -1 && (React.createElement("div", { className: classNameSorter('ascend') },
                            React.createElement(IconCaretUp$1, null))),
                        sortDirections.indexOf('descend') !== -1 && (React.createElement("div", { className: classNameSorter('descend') },
                            React.createElement(IconCaretDown$1, null)))))))) : (React.createElement("span", __assign$D({ className: prefixCls + "-th-item-title" }, titleProps), title)),
            shouldRenderFilters && (React.createElement(Trigger$1, __assign$D({ popup: renderFilters, trigger: "click", classNames: "slideDynamicOrigin", position: rtl ? 'bl' : 'br', popupAlign: { bottom: 0 }, popupVisible: filterVisible, onVisibleChange: onVisibleChange }, filterDropdownTriggerProps),
                React.createElement("div", { className: classNameFilter }, filterIcon || React.createElement(IconFilter$1, null))))));
        var cellChildrenClassName = cs(prefixCls + "-th-item", (_d = {},
            _d[prefixCls + "-cell-text-ellipsis"] = ellipsis,
            _d[prefixCls + "-cell-mouseenter"] = isEnter,
            _d[prefixCls + "-cell-next-" + nextSortDirection] = isEnter && nextSortDirection,
            _d[prefixCls + "-col-has-sorter"] = enableSort,
            _d[prefixCls + "-col-has-filter"] = shouldRenderFilters,
            _d));
        return (colSpan !== 0 && (React.createElement(ComponentTh, __assign$D({ className: cs(prefixCls + "-th", (_e = {},
                _e[prefixCls + "-col-sorted"] = currentSorter && currentSorter.direction && currentSorter.field === innerDataIndex,
                _e), className) }, thProps, headerCellProps), isString(ComponentHeaderCell) ? (React.createElement(ComponentHeaderCell, { className: cellChildrenClassName }, cellChildren)) : (React.createElement(ComponentHeaderCell, { className: cellChildrenClassName, column: column }, cellChildren)))));
    }

    var INTERNAL_SELECTION_KEY = 'table_internal_selection_key';
    var INTERNAL_EXPAND_KEY = 'table_internal_expand_key';

    var __assign$C = (undefined && undefined.__assign) || function () {
        __assign$C = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$C.apply(this, arguments);
    };
    function THead(props) {
        var sorter = props.sorter, expandedRowRender = props.expandedRowRender, _a = props.expandProps, expandProps = _a === void 0 ? {} : _a, onSort = props.onSort, onHandleFilter = props.onHandleFilter, onHandleFilterReset = props.onHandleFilterReset, onHeaderRow = props.onHeaderRow, prefixCls = props.prefixCls, currentFilters = props.currentFilters, components = props.components, data = props.data, selectedRowKeys = props.selectedRowKeys, rowSelection = props.rowSelection, _b = props.allSelectedRowKeys, allSelectedRowKeys = _b === void 0 ? [] : _b, groupColumns = props.groupColumns, stickyOffsets = props.stickyOffsets, groupStickyClassNames = props.groupStickyClassNames, showSorterTooltip = props.showSorterTooltip;
        var rtl = React.useContext(ConfigContext).rtl;
        var _c = useComponent(components), ComponentThead = _c.ComponentThead, ComponentHeaderRow = _c.ComponentHeaderRow, getHeaderComponentOperations = _c.getHeaderComponentOperations;
        var _checkbox = rowSelection && (rowSelection.type === 'checkbox' || !('type' in rowSelection));
        var _checkAll = rowSelection && 'checkAll' in rowSelection ? rowSelection.checkAll : true;
        var isRadio = rowSelection && rowSelection.type === 'radio';
        var expandColumnTitle = expandProps.columnTitle;
        var currentSelectedRowKeys = React.useMemo(function () {
            var tempSet = new Set(allSelectedRowKeys);
            return selectedRowKeys.filter(function (v) { return tempSet.has(v); });
        }, [selectedRowKeys, allSelectedRowKeys]);
        var selectionRowSpanProps = groupColumns.length > 1 ? { rowSpan: groupColumns.length } : {};
        var operationClassName = cs(prefixCls + "-th", prefixCls + "-operation");
        return (React.createElement(ComponentThead, null, groupColumns.map(function (row, index) {
            var headerRowProps = onHeaderRow && onHeaderRow(row, index);
            var selectionNode = (_checkbox || isRadio) && index === 0 && (React.createElement("th", { className: cs(operationClassName, prefixCls + "-" + (isRadio ? 'radio' : 'checkbox')) },
                React.createElement("div", { className: prefixCls + "-th-item" },
                    _checkAll && !isRadio ? (React.createElement(Checkbox$2, { indeterminate: data &&
                            currentSelectedRowKeys.length > 0 &&
                            currentSelectedRowKeys.length !== allSelectedRowKeys.length, checked: data &&
                            currentSelectedRowKeys.length !== 0 &&
                            currentSelectedRowKeys.length === allSelectedRowKeys.length, disabled: !allSelectedRowKeys.length, onChange: props.onCheckAll })) : null,
                    rowSelection && rowSelection.columnTitle)));
            var expandNode = expandedRowRender && (React.createElement("th", { className: cs(operationClassName, prefixCls + "-expand") }, expandColumnTitle && React.createElement("div", { className: prefixCls + "-th-item" }, expandColumnTitle)));
            var stickyClassNames = groupStickyClassNames[index];
            var headerOperations = getHeaderComponentOperations({ selectionNode: selectionNode, expandNode: expandNode });
            return (React.createElement(ComponentHeaderRow, __assign$C({}, headerRowProps, { key: index, className: prefixCls + "-tr" }), row.map(function (column, colIndex) {
                var _a;
                var _b, _c, _d, _e;
                var stickyOffset = stickyOffsets[colIndex];
                var stickyClassName = stickyClassNames[colIndex];
                if (column.$$isOperation) {
                    var node = column.node;
                    var isExtraOperation = true;
                    if (column.title === INTERNAL_SELECTION_KEY) {
                        node = (_b = headerOperations.find(function (o) { return o.name === 'selectionNode'; })) === null || _b === void 0 ? void 0 : _b.node;
                        isExtraOperation = false;
                    }
                    if (column.title === INTERNAL_EXPAND_KEY) {
                        node = (_c = headerOperations.find(function (o) { return o.name === 'expandNode'; })) === null || _c === void 0 ? void 0 : _c.node;
                        isExtraOperation = false;
                    }
                    var operationNode = node;
                    return React.cloneElement(operationNode, __assign$C(__assign$C(__assign$C({ key: column.key || colIndex }, operationNode.props), selectionRowSpanProps), { className: cs(isExtraOperation ? operationClassName : '', (_d = operationNode === null || operationNode === void 0 ? void 0 : operationNode.props) === null || _d === void 0 ? void 0 : _d.className, stickyClassName), style: __assign$C(__assign$C(__assign$C({}, (_e = operationNode === null || operationNode === void 0 ? void 0 : operationNode.props) === null || _e === void 0 ? void 0 : _e.style), (column.fixed === 'left'
                            ? (_a = {},
                                _a[rtl ? 'right' : 'left'] = stickyOffset,
                                _a) : {})), { width: column.width, minWidth: column.width }) }));
                }
                var headerCellProps = column.onHeaderCell && column.onHeaderCell(column, colIndex);
                var columnClassName = cs(stickyClassName, column.className);
                var columnFixedStyle = {};
                if (column.fixed === 'left') {
                    columnFixedStyle[rtl ? 'right' : 'left'] = stickyOffset;
                }
                if (column.fixed === 'right') {
                    columnFixedStyle[rtl ? 'left' : 'right'] = stickyOffset;
                }
                return (React.createElement(Column, __assign$C({ key: column.key, index: colIndex, onSort: onSort, onHandleFilter: onHandleFilter, onHandleFilterReset: onHandleFilterReset, currentSorter: sorter, currentFilters: currentFilters, _key: column.key || column.dataIndex || colIndex }, column, { column: column, headerCellProps: headerCellProps, prefixCls: prefixCls, components: components, className: columnClassName, columnFixedStyle: columnFixedStyle, showSorterTooltip: showSorterTooltip })));
            })));
        })));
    }

    var __assign$B = (undefined && undefined.__assign) || function () {
        __assign$B = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$B.apply(this, arguments);
    };
    var __read$s = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$d = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    function getScrollBarHeight(ele) {
        return ele ? ele.offsetHeight - ele.clientHeight : 0;
    }
    function getScrollBarWidth(ele) {
        return ele ? ele.offsetWidth - ele.clientWidth : 0;
    }
    function isChildrenNotEmpty(record, field) {
        return isArray$1(record[field]) && record[field].length;
    }
    function deepCloneData(data, childrenColumnName) {
        function travel(data) {
            if (!data) {
                return [];
            }
            var newData = [];
            data.forEach(function (d) {
                // case: [[], []]
                // case: ['', '']
                // case: [1, 2]
                if (!isObject$1(d)) {
                    newData.push(d);
                }
                else {
                    var _d = __assign$B({}, d);
                    _d.__ORIGIN_DATA = d;
                    var children = _d[childrenColumnName];
                    if (isObject$1(_d) && children && isArray$1(children)) {
                        _d[childrenColumnName] = travel(children);
                    }
                    newData.push(_d);
                }
            });
            return newData;
        }
        return travel(data);
    }
    function getOriginData(data) {
        if (isObject$1(data)) {
            return data.__ORIGIN_DATA;
        }
        if (!data || !isArray$1(data)) {
            return data;
        }
        return data.map(function (d) {
            if (!isObject$1(d)) {
                return d;
            }
            return d.__ORIGIN_DATA;
        });
    }
    function getSelectedKeys(record, checked, checkedRowKeys, _indeterminateKeys, getRowKey, childrenColumnName, checkConnected) {
        if (checkedRowKeys === void 0) { checkedRowKeys = []; }
        if (_indeterminateKeys === void 0) { _indeterminateKeys = []; }
        var selectedRowKeys = new Set(checkedRowKeys);
        var indeterminateKeys = new Set(_indeterminateKeys);
        function loop(record) {
            if (checked) {
                selectedRowKeys.add(getRowKey(record));
                indeterminateKeys.delete(getRowKey(record));
            }
            else {
                selectedRowKeys.delete(getRowKey(record));
            }
            if (isArray$1(record[childrenColumnName])) {
                record[childrenColumnName].forEach(function (child) {
                    loop(child);
                });
            }
        }
        if (!checkConnected) {
            if (checked) {
                selectedRowKeys.add(getRowKey(record));
            }
            else {
                selectedRowKeys.delete(getRowKey(record));
            }
        }
        else {
            loop(record);
            updateParent$1(record, selectedRowKeys, indeterminateKeys, getRowKey, childrenColumnName);
        }
        return {
            selectedRowKeys: __spreadArray$d([], __read$s(selectedRowKeys), false),
            indeterminateKeys: __spreadArray$d([], __read$s(indeterminateKeys), false),
        };
    }
    function getSelectedKeysByData(flattenData, checkedKeys, getRowKey, childrenColumnName, checkConnected) {
        if (checkedKeys === void 0) { checkedKeys = []; }
        if (!checkConnected) {
            return {
                selectedRowKeys: checkedKeys,
                indeterminateKeys: [],
            };
        }
        var selectedRowKeys = new Set(checkedKeys);
        var indeterminateKeys = new Set([]);
        function loop(record) {
            selectedRowKeys.add(getRowKey(record));
            indeterminateKeys.delete(getRowKey(record));
            if (isArray$1(record[childrenColumnName])) {
                record[childrenColumnName].forEach(function (child) {
                    loop(child);
                });
            }
        }
        checkedKeys.forEach(function (key) {
            var record = flattenData.find(function (d) { return getRowKey(d) === key; });
            if (!isUndefined(record) && !isNull(record)) {
                loop(record);
                updateParent$1(record, selectedRowKeys, indeterminateKeys, getRowKey, childrenColumnName);
            }
        });
        return {
            selectedRowKeys: __spreadArray$d([], __read$s(selectedRowKeys), false),
            indeterminateKeys: __spreadArray$d([], __read$s(indeterminateKeys), false),
        };
    }
    function updateParent$1(record, selectedKeys, indeterminateKeys, getRowKey, childrenColumnName) {
        if (record.__INTERNAL_PARENT) {
            var parentKey_1 = getRowKey(record.__INTERNAL_PARENT);
            if (isArray$1(record.__INTERNAL_PARENT[childrenColumnName])) {
                var total = record.__INTERNAL_PARENT[childrenColumnName].length;
                var len_1 = 0;
                var flag_1 = false;
                record.__INTERNAL_PARENT[childrenColumnName].forEach(function (c) {
                    if (selectedKeys.has(getRowKey(c))) {
                        len_1 += 1;
                    }
                    if (indeterminateKeys.has(getRowKey(c))) {
                        indeterminateKeys.add(parentKey_1);
                        flag_1 = true;
                    }
                });
                if (total === len_1) {
                    selectedKeys.add(parentKey_1);
                    indeterminateKeys.delete(parentKey_1);
                }
                else if (len_1 > 0 && total > len_1) {
                    selectedKeys.delete(parentKey_1);
                    indeterminateKeys.add(parentKey_1);
                }
                else if (len_1 === 0) {
                    selectedKeys.delete(parentKey_1);
                    if (!flag_1) {
                        indeterminateKeys.delete(parentKey_1);
                    }
                }
            }
            updateParent$1(record.__INTERNAL_PARENT, selectedKeys, indeterminateKeys, getRowKey, childrenColumnName);
        }
    }

    var __assign$A = (undefined && undefined.__assign) || function () {
        __assign$A = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$A.apply(this, arguments);
    };
    var __rest$d = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function isInvalidRenderElement(element) {
        return element && !React.isValidElement(element) && isObject$1(element);
    }
    function Td(props) {
        var _a, _b;
        var components = props.components, InnerComponentTd = props.InnerComponentTd, column = props.column, columnIndex = props.columnIndex, prefixCls = props.prefixCls, stickyClassName = props.stickyClassName, stickyOffset = props.stickyOffset, currentSorter = props.currentSorter, virtualized = props.virtualized, record = props.record, trIndex = props.trIndex, level = props.level, placeholder = props.placeholder, indentSize = props.indentSize, renderExpandIcon = props.renderExpandIcon, rowKey = props.rowKey, recordHaveChildren = props.recordHaveChildren, haveTreeData = props.haveTreeData;
        var rtl = React.useContext(ConfigContext).rtl;
        var ComponentBodyCell = useComponent(components).ComponentBodyCell;
        var classNameTd = cs(prefixCls + "-td", stickyClassName, (_a = {},
            _a[prefixCls + "-col-sorted"] = currentSorter && currentSorter.direction && currentSorter.field === column.dataIndex,
            _a), column.className);
        var tdProps = {};
        var rowSpan;
        var colSpan;
        var styleTd = {};
        if (column.fixed === 'left') {
            styleTd[rtl ? 'right' : 'left'] = stickyOffset;
        }
        if (column.fixed === 'right') {
            styleTd[rtl ? 'left' : 'right'] = stickyOffset;
        }
        if (isObject$1(column.cellStyle)) {
            styleTd = __assign$A(__assign$A({}, styleTd), column.cellStyle);
        }
        if (isObject$1(column.bodyCellStyle)) {
            styleTd = __assign$A(__assign$A({}, styleTd), column.bodyCellStyle);
        }
        if (column.align) {
            styleTd.textAlign = column.align;
        }
        if (virtualized && column.width) {
            styleTd.width = column.width;
            styleTd.minWidth = column.width;
            styleTd.maxWidth = column.width;
        }
        var _c = column.onCell
            ? column.onCell(record, trIndex)
            : { onHandleSave: function () { } }, onHandleSave = _c.onHandleSave, cellProps = __rest$d(_c, ["onHandleSave"]);
        var renderElement = React.useMemo(function () {
            return column.render && column.render(get_1(record, column.dataIndex), getOriginData(record), trIndex);
        }, [record, column, trIndex]);
        if (isInvalidRenderElement(renderElement)) {
            tdProps = renderElement.props;
            rowSpan = tdProps.rowSpan;
            colSpan = tdProps.colSpan;
            renderElement = renderElement.children;
        }
        if (rowSpan === 0 || colSpan === 0) {
            return null;
        }
        var v = get_1(record, column.dataIndex);
        var cellChildren = column.render
            ? renderElement
            : v === undefined || (typeof v === 'string' && v.trim() === '') || v === null
                ? column.placeholder === undefined
                    ? placeholder
                    : column.placeholder
                : v;
        var titleProps = column.ellipsis && typeof cellChildren === 'string' ? { title: cellChildren } : {};
        var hasInlineExpandIcon = haveTreeData && column.$$isFirstColumn;
        var needRenderExpandIcon = hasInlineExpandIcon && recordHaveChildren;
        var paddingLeft = hasInlineExpandIcon && level > 0 ? indentSize * level : 0;
        if (hasInlineExpandIcon && !recordHaveChildren) {
            // expand icon width and margin-right
            paddingLeft += 16 + 4;
        }
        var content = (React.createElement(React.Fragment, null,
            needRenderExpandIcon ? (React.createElement("span", { className: prefixCls + "-cell-expand-icon" }, renderExpandIcon(record, rowKey))) : null,
            isString(ComponentBodyCell) ? (React.createElement(ComponentBodyCell, { className: prefixCls + "-cell-wrap-value" }, cellChildren)) : (React.createElement(ComponentBodyCell, __assign$A({ rowData: record, className: prefixCls + "-cell-wrap-value", column: column, onHandleSave: onHandleSave }, cellProps), cellChildren))));
        return (React.createElement(InnerComponentTd, __assign$A({ className: classNameTd, key: column.key || column.dataIndex || columnIndex, style: styleTd }, pick(cellProps, [
            'onClick',
            'onDoubleClick',
            'onContextMenu',
            'onMouseOver',
            'onMouseEnter',
            'onMouseLeave',
            'onMouseMove',
            'onMouseDown',
            'onMouseUp',
        ]), tdProps),
            React.createElement("div", __assign$A({ className: cs(prefixCls + "-cell", (_b = {},
                    _b[prefixCls + "-cell-text-ellipsis"] = column.ellipsis,
                    _b)) }, titleProps),
                paddingLeft ? (React.createElement("span", { className: prefixCls + "-cell-indent", style: { paddingLeft: paddingLeft } })) : null,
                content)));
    }
    var Td$1 = React.memo(Td);

    var __assign$z = (undefined && undefined.__assign) || function () {
        __assign$z = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$z.apply(this, arguments);
    };
    var __rest$c = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function Tr(props, ref) {
        var _a;
        var expandedRowRender = props.expandedRowRender, onClickExpandBtn = props.onClickExpandBtn, columns = props.columns, components = props.components, onCheck = props.onCheck, onCheckRadio = props.onCheckRadio, prefixCls = props.prefixCls, selectedRowKeys = props.selectedRowKeys, indeterminateKeys = props.indeterminateKeys, rowClassName = props.rowClassName, onRow = props.onRow, rowSelection = props.rowSelection, _b = props.indentSize, indentSize = _b === void 0 ? 16 : _b, currentSorter = props.currentSorter, virtualized = props.virtualized, stickyOffsets = props.stickyOffsets, stickyClassNames = props.stickyClassNames, getRowKey = props.getRowKey, placeholder = props.placeholder, _c = props.expandProps, expandProps = _c === void 0 ? { strictTreeData: true } : _c, data = props.data, expandedRowKeys = props.expandedRowKeys, childrenColumnName = props.childrenColumnName, record = props.record, index = props.index, type = props.type, shouldRowExpand = props.shouldRowExpand, level = props.level;
        var rtl = React.useContext(ConfigContext).rtl;
        var originRecord = getOriginData(record);
        var rowProps = __rest$c((onRow && onRow(originRecord, index)) || {}, []);
        var rowK = getRowKey(record);
        var usedSelectedRowKeys = type === 'radio' ? selectedRowKeys.slice(0, 1) : selectedRowKeys;
        var trKey = rowK || index;
        var checked = usedSelectedRowKeys.indexOf(rowK) > -1;
        var expanded = expandedRowKeys.indexOf(rowK) > -1;
        var indeterminate = indeterminateKeys.indexOf(rowK) > -1;
        var classNameTr = cs(prefixCls + "-tr", (_a = {},
            _a[prefixCls + "-row-checked"] = checked,
            _a[prefixCls + "-row-expanded"] = expanded,
            _a), rowClassName && rowClassName(originRecord, index));
        var checkboxProps = rowSelection && typeof rowSelection.checkboxProps === 'function'
            ? rowSelection.checkboxProps(originRecord)
            : {};
        var operationClassName = cs(prefixCls + "-td", prefixCls + "-operation");
        var getPrefixColClassName = function (name) {
            var _a;
            return cs(operationClassName, prefixCls + "-" + name, (_a = {},
                _a[prefixCls + "-selection-col"] = (virtualized && type === 'checkbox') || type === 'radio',
                _a[prefixCls + "-expand-icon-col"] = virtualized && expandedRowRender,
                _a));
        };
        function isChildrenNotEmpty(record) {
            return expandProps.strictTreeData
                ? isArray$1(record[childrenColumnName]) && record[childrenColumnName].length
                : record[childrenColumnName] !== undefined;
        }
        // tree data
        function isDataHaveChildren() {
            return data.find(function (d) { return isChildrenNotEmpty(d); });
        }
        var shouldRenderExpandRow = shouldRowExpand(record, index);
        var recordHaveChildren = isChildrenNotEmpty(record);
        var haveTreeData = !virtualized && isDataHaveChildren() && !expandedRowRender;
        var shouldRenderTreeDataExpandRow = haveTreeData && recordHaveChildren;
        var expandRowByClick = expandProps.expandRowByClick;
        var rowClickProps = expandRowByClick && (shouldRenderExpandRow || shouldRenderTreeDataExpandRow)
            ? {
                onClick: function (e) {
                    onClickExpandBtn(rowK);
                    rowProps && rowProps.onClick && rowProps.onClick(e);
                },
            }
            : {};
        var _d = useComponent(components), ComponentBodyRow = _d.ComponentBodyRow, ComponentTd = _d.ComponentTd, getBodyComponentOperations = _d.getBodyComponentOperations;
        var InnerComponentBodyRow = virtualized ? 'div' : ComponentBodyRow;
        var InnerComponentTd = virtualized ? 'div' : ComponentTd;
        var baseTrProps = __assign$z(__assign$z({ className: classNameTr, key: trKey }, rowProps), rowClickProps);
        var trProps = isString(ComponentBodyRow) ? baseTrProps : __assign$z(__assign$z({}, baseTrProps), { record: record, index: index });
        function renderExpandIcon(record, rowK) {
            var expandIcon = expandProps.icon;
            var expanded = !!~expandedRowKeys.indexOf(rowK);
            var onClickProps = {
                onClick: function (e) {
                    e.stopPropagation();
                    onClickExpandBtn(rowK);
                },
            };
            return typeof expandIcon === 'function' ? (expandIcon(__assign$z({ expanded: expanded, record: record }, onClickProps))) : (React.createElement("button", __assign$z({}, onClickProps, { type: "button" }), expanded ? React.createElement(IconMinus$1, null) : React.createElement(IconPlus$1, null)));
        }
        var expandNode = expandedRowRender && (React.createElement(InnerComponentTd, { className: getPrefixColClassName('expand-icon-cell') }, shouldRenderExpandRow && renderExpandIcon(record, rowK)));
        var renderSelectionCell = rowSelection && rowSelection.renderCell;
        var selectionNode;
        var checkboxNode = (React.createElement(Checkbox$2, __assign$z({ value: rowK, onChange: function (check) { return onCheck(check, record); }, checked: checked, indeterminate: indeterminate }, checkboxProps)));
        var radioNode = (React.createElement(Radio$1, __assign$z({ onChange: function () { return onCheckRadio(rowK, record); }, value: rowK, checked: checked }, checkboxProps)));
        if (type === 'checkbox') {
            selectionNode = (React.createElement(InnerComponentTd, { className: getPrefixColClassName('checkbox') }, renderSelectionCell
                ? renderSelectionCell(checkboxNode, checked, originRecord)
                : checkboxNode));
        }
        if (type === 'radio') {
            selectionNode = (React.createElement(InnerComponentTd, { className: getPrefixColClassName('radio') }, renderSelectionCell ? renderSelectionCell(radioNode, checked, originRecord) : radioNode));
        }
        var bodyOperations = getBodyComponentOperations({ selectionNode: selectionNode, expandNode: expandNode });
        return (React.createElement(InnerComponentBodyRow, __assign$z({}, trProps, { ref: ref }), columns.map(function (col, colIndex) {
            var _a;
            var _b, _c, _d, _e;
            var stickyOffset = stickyOffsets[colIndex];
            var stickyClassName = stickyClassNames[colIndex];
            if (col.$$isOperation) {
                var node = col.node;
                var isExtraOperation = true;
                if (col.title === INTERNAL_SELECTION_KEY) {
                    node = (_b = bodyOperations.find(function (o) { return o.name === 'selectionNode'; })) === null || _b === void 0 ? void 0 : _b.node;
                    isExtraOperation = false;
                }
                if (col.title === INTERNAL_EXPAND_KEY) {
                    node = (_c = bodyOperations.find(function (o) { return o.name === 'expandNode'; })) === null || _c === void 0 ? void 0 : _c.node;
                    isExtraOperation = false;
                }
                var operationNode = typeof node === 'function' ? node(record) : node;
                return React.cloneElement(operationNode, __assign$z(__assign$z({ key: col.key || colIndex }, operationNode.props), { className: cs(isExtraOperation ? operationClassName : '', (_d = operationNode === null || operationNode === void 0 ? void 0 : operationNode.props) === null || _d === void 0 ? void 0 : _d.className, stickyClassName), style: __assign$z(__assign$z(__assign$z({}, (_e = operationNode === null || operationNode === void 0 ? void 0 : operationNode.props) === null || _e === void 0 ? void 0 : _e.style), (col.fixed === 'left'
                        ? (_a = {},
                            _a[rtl ? 'right' : 'left'] = stickyOffset,
                            _a) : {})), { width: col.width, minWidth: col.width }) }));
            }
            return (React.createElement(Td$1, { key: colIndex, prefixCls: prefixCls, virtualized: virtualized, components: components, currentSorter: currentSorter, placeholder: placeholder, indentSize: indentSize, stickyClassName: stickyClassName, stickyOffset: stickyOffset, InnerComponentTd: InnerComponentTd, column: col, columnIndex: colIndex, record: record, trIndex: index, level: level, haveTreeData: haveTreeData, recordHaveChildren: recordHaveChildren, rowKey: rowK, renderExpandIcon: renderExpandIcon }));
        })));
    }
    var ForwardRefTr = React.forwardRef(Tr);
    var Tr$1 = ForwardRefTr;

    var __assign$y = (undefined && undefined.__assign) || function () {
        __assign$y = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$y.apply(this, arguments);
    };
    function TBody(props) {
        var _a = props.childrenColumnName, childrenColumnName = _a === void 0 ? 'children' : _a, _b = props.expandProps, expandProps = _b === void 0 ? {} : _b, expandedRowRender = props.expandedRowRender, expandedRowKeys = props.expandedRowKeys, data = props.data, columns = props.columns, prefixCls = props.prefixCls, components = props.components, rowSelection = props.rowSelection, noDataElement = props.noDataElement, scroll = props.scroll, _c = props.indentSize, indentSize = _c === void 0 ? 16 : _c, hasFixedColumn = props.hasFixedColumn, tableViewWidth = props.tableViewWidth, virtualized = props.virtualized, getRowKey = props.getRowKey, saveVirtualWrapperRef = props.saveVirtualWrapperRef;
        var er = expandedRowRender
            ? function (r, i) { return expandedRowRender(getOriginData(r), i); }
            : expandedRowRender;
        var ComponentTbody = useComponent(components).ComponentTbody;
        var type;
        if (rowSelection && 'type' in rowSelection) {
            type = rowSelection.type;
        }
        else if (rowSelection && !('type' in rowSelection)) {
            type = 'checkbox';
        }
        function isChildrenNotEmpty(record) {
            return isArray$1(record[childrenColumnName]) && record[childrenColumnName].length;
        }
        function shouldRowExpand(record, index) {
            if ('rowExpandable' in expandProps && typeof expandProps.rowExpandable === 'function') {
                return expandProps.rowExpandable(record);
            }
            return er && er(record, index) !== null;
        }
        var trProps = __assign$y(__assign$y({}, props), { type: type, shouldRowExpand: shouldRowExpand });
        function renderTreeTrs(record, index) {
            var trList = [];
            trList.push(React.createElement(Tr$1, __assign$y({ key: getRowKey(record) }, trProps, { record: record, level: 0, index: index })));
            var travel = function (children, rowKey, level) {
                if (level === void 0) { level = 0; }
                if (isArray$1(children) && children.length) {
                    children.forEach(function (child, i) {
                        if (expandedRowKeys.indexOf(rowKey) !== -1) {
                            trList.push(React.createElement(Tr$1, __assign$y({}, trProps, { key: getRowKey(child), record: child, level: level + 1, index: i })));
                            if (isChildrenNotEmpty(child)) {
                                travel(child[childrenColumnName], getRowKey(child), level + 1);
                            }
                        }
                    });
                }
            };
            if (!er) {
                travel(record[childrenColumnName], getRowKey(record));
            }
            return trList;
        }
        var scrollStyleX = {};
        var scrollStyleY = {};
        if (scroll) {
            if (scroll.x && (typeof scroll.x === 'number' || typeof scroll.x === 'string')) {
                scrollStyleX = {
                    width: scroll.x,
                };
            }
            if (scroll.y && (typeof scroll.y === 'number' || typeof scroll.y === 'string')) {
                scrollStyleY = {
                    maxHeight: scroll.y,
                };
            }
        }
        var noElementProps = {
            className: prefixCls + "-no-data",
        };
        if (tableViewWidth) {
            noElementProps.className = prefixCls + "-no-data " + prefixCls + "-expand-fixed-row";
            noElementProps.style = { width: tableViewWidth };
        }
        var noDataTr = (React.createElement("tr", { className: cs(prefixCls + "-tr", prefixCls + "-empty-row") },
            React.createElement("td", { className: prefixCls + "-td", colSpan: columns.length },
                React.createElement("div", __assign$y({}, noElementProps), noDataElement))));
        // https://github.com/arco-design/arco-design/issues/644
        // except the real scroll container, all parent nodes should not have a overflow style.
        if (virtualized) {
            return data.length > 0 ? (React.createElement(VirtualList$1, { data: data, height: scrollStyleY.maxHeight, isStaticItemHeight: false, 
                // position sticky works
                outerStyle: __assign$y(__assign$y({}, scrollStyleX), { minWidth: '100%', overflow: 'visible' }), className: prefixCls + "-body", ref: function (ref) { return saveVirtualWrapperRef(ref === null || ref === void 0 ? void 0 : ref.dom); } }, function (child, index) { return (React.createElement(Tr$1, __assign$y({}, trProps, { key: getRowKey(child), record: child, index: index, level: 0 }))); })) : (React.createElement("div", { className: prefixCls + "-body" },
                React.createElement("table", null,
                    React.createElement("tbody", null, noDataTr))));
        }
        return (React.createElement(ComponentTbody, null, data.length > 0
            ? data.map(function (record, index) {
                var rowK = getRowKey(record);
                var shouldRenderExpandIcon = shouldRowExpand(record, index) && expandedRowKeys.indexOf(rowK) !== -1;
                return (React.createElement(React.Fragment, { key: rowK },
                    renderTreeTrs(record, index),
                    shouldRenderExpandIcon && (React.createElement("tr", { className: cs(prefixCls + "-tr", prefixCls + "-expand-content"), key: rowK + "-expanded" },
                        React.createElement("td", { className: prefixCls + "-td", colSpan: columns.length, style: { paddingLeft: indentSize } }, hasFixedColumn ? (React.createElement("div", { className: prefixCls + "-expand-fixed-row", style: { width: tableViewWidth } }, er && er(record, index))) : (er && er(record, index)))))));
            })
            : noDataTr));
    }

    var SummaryContext = React.createContext({});

    function Tfoot(props) {
        var summary = props.summary, data = props.data, prefixCls = props.prefixCls, columns = props.columns, stickyOffsets = props.stickyOffsets, stickyClassNames = props.stickyClassNames;
        return (React.createElement("tfoot", { className: prefixCls + "-tfoot" },
            React.createElement(SummaryContext.Provider, { value: { columns: columns, stickyOffsets: stickyOffsets, stickyClassNames: stickyClassNames, prefixCls: prefixCls } }, summary(getOriginData(data)))));
    }

    function fixedWidth(width) {
        return typeof width === 'number' || typeof width === 'string'
            ? {
                width: width,
            }
            : {};
    }
    function ColGroup(props) {
        var prefixCls = props.prefixCls, columns = props.columns;
        return (React.createElement("colgroup", null, columns.map(function (col, index) {
            if (col.title === INTERNAL_EXPAND_KEY) {
                return (React.createElement("col", { key: INTERNAL_EXPAND_KEY, className: prefixCls + "-expand-icon-col", style: fixedWidth(col.width) }));
            }
            if (col.title === INTERNAL_SELECTION_KEY) {
                return (React.createElement("col", { key: INTERNAL_SELECTION_KEY, className: prefixCls + "-selection-col", style: fixedWidth(col.width) }));
            }
            return React.createElement("col", { key: col.key || index, style: fixedWidth(col.width) });
        })));
    }

    var __read$r = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    function useExpand(props, flattenData, getRowKey) {
        var defaultExpandedRowKeys = props.defaultExpandedRowKeys, defaultExpandAllRows = props.defaultExpandAllRows, expandedRowRender = props.expandedRowRender, onExpand = props.onExpand, onExpandedRowsChange = props.onExpandedRowsChange, _a = props.childrenColumnName, childrenColumnName = _a === void 0 ? 'children' : _a, expandProps = props.expandProps;
        var _b = __read$r(React.useState(getDefaultExpandedRowKeys()), 2), expandedRowKeys = _b[0], setExpandedRowKeys = _b[1];
        var mergedExpandedRowKeys = props.expandedRowKeys || expandedRowKeys;
        function getDefaultExpandedRowKeys() {
            var rows = [];
            if (props.expandedRowKeys) {
                rows = props.expandedRowKeys;
            }
            else if (defaultExpandedRowKeys) {
                rows = defaultExpandedRowKeys;
            }
            else if (defaultExpandAllRows) {
                rows = flattenData
                    .map(function (item, index) {
                    var originItem = getOriginData(item);
                    if (expandProps &&
                        'rowExpandable' in expandProps &&
                        typeof expandProps.rowExpandable === 'function') {
                        return expandProps.rowExpandable(originItem);
                    }
                    if (typeof expandedRowRender === 'function') {
                        return expandedRowRender(originItem, index) && getRowKey(item);
                    }
                    return isChildrenNotEmpty(item, childrenColumnName) && getRowKey(item);
                })
                    .filter(function (x) { return x; });
            }
            return rows;
        }
        function onClickExpandBtn(key) {
            var isExpanded = mergedExpandedRowKeys.indexOf(key) === -1;
            var newExpandedRowKeys = isExpanded
                ? mergedExpandedRowKeys.concat(key)
                : mergedExpandedRowKeys.filter(function (_k) { return key !== _k; });
            var sortedExpandedRowKeys = flattenData
                .filter(function (record) { return newExpandedRowKeys.indexOf(getRowKey(record)) !== -1; })
                .map(function (record) { return getRowKey(record); });
            setExpandedRowKeys(sortedExpandedRowKeys);
            handleExpandChange(key, isExpanded);
            onExpandedRowsChange && onExpandedRowsChange(sortedExpandedRowKeys);
        }
        function handleExpandChange(key, expanded) {
            onExpand &&
                onExpand(getOriginData(flattenData.find(function (item) { return getRowKey(item) === key; })), expanded);
        }
        return [mergedExpandedRowKeys, onClickExpandBtn];
    }

    var __assign$x = (undefined && undefined.__assign) || function () {
        __assign$x = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$x.apply(this, arguments);
    };
    var __read$q = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$c = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    function getSet(arr) {
        return __spreadArray$c([], __read$q(new Set(arr)), false);
    }
    function useRowSelection(props, pageData, data, getRowKey) {
        var rowSelection = props.rowSelection, childrenColumnName = props.childrenColumnName;
        var controlledSelectedRowKeys = rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.selectedRowKeys;
        var onSelectAll = rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.onSelectAll;
        var onSelect = rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.onSelect;
        var onChange = rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.onChange;
        var pureKeys = rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.pureKeys; // TODO: remove
        var checkConnected = typeof (rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.checkStrictly) === 'boolean' ? !rowSelection.checkStrictly : false;
        var preserveSelectedRowKeys = rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.preserveSelectedRowKeys;
        // 获取扁平化之后的 data
        function getMetaFromData() {
            var allSelectedRowKeys = [];
            var flattenData = [];
            var travel = function (children) {
                if (isArray$1(children) && children.length) {
                    children.forEach(function (record) {
                        var rowKey = getRowKey(record);
                        var checkboxProps = rowSelection && typeof rowSelection.checkboxProps === 'function'
                            ? rowSelection.checkboxProps(getOriginData(record))
                            : {};
                        if (!checkboxProps.disabled) {
                            allSelectedRowKeys.push(rowKey);
                        }
                        if (isChildrenNotEmpty(record, props.childrenColumnName)) {
                            travel(record[props.childrenColumnName]);
                        }
                    });
                }
            };
            travel(pageData);
            var travelOrigin = function (children, parent) {
                if (isArray$1(children) && children.length) {
                    children.forEach(function (record) {
                        if (parent && checkConnected) {
                            record.__INTERNAL_PARENT = parent;
                        }
                        flattenData.push(record);
                        if (isChildrenNotEmpty(record, props.childrenColumnName)) {
                            var _parent = __assign$x({}, record);
                            travelOrigin(record[props.childrenColumnName], _parent);
                        }
                    });
                }
            };
            travelOrigin(data, undefined);
            return {
                allSelectedRowKeys: allSelectedRowKeys,
                flattenData: flattenData,
            };
        }
        var _a = getMetaFromData(), allSelectedRowKeys = _a.allSelectedRowKeys, flattenData = _a.flattenData;
        var _b = __read$q(React.useState([]), 2), selectedRowKeys = _b[0], setSelectedRowKeys = _b[1];
        var _c = __read$q(React.useState([]), 2), indeterminateKeys = _c[0], setIndeterminateKeys = _c[1];
        var keys = getSelectedKeysByData(flattenData, getSet(controlledSelectedRowKeys || selectedRowKeys), getRowKey, childrenColumnName, checkConnected);
        var mergedSelectedRowKeys = checkConnected && !controlledSelectedRowKeys ? selectedRowKeys : keys.selectedRowKeys;
        var mergedIndeterminateKeys = checkConnected && !controlledSelectedRowKeys ? indeterminateKeys : keys.indeterminateKeys;
        var _d = __read$q(React.useState(pureKeys ? [] : getRowsFromKeys(mergedSelectedRowKeys)), 2), selectedRows = _d[0], setSelectedRows = _d[1];
        function getRowsFromKeys(keys, plus) {
            // selectedRows is placed before flattenData: https://github.com/arco-design/arco-design/issues/1294
            var all = plus ? selectedRows.concat(flattenData) : flattenData;
            var keyMap = new Map(all.map(function (v) { return [getRowKey(v), v]; }));
            return keys.map(function (r) { return keyMap.get(r); }).filter(function (a) { return a; });
        }
        var flattenKeys = new Set(flattenData.map(function (d) { return getRowKey(d); }));
        function deleteUnExistKeys(keys) {
            return preserveSelectedRowKeys ? keys : keys.filter(function (k) { return flattenKeys.has(k); });
        }
        function onCheckAll(checked) {
            var newSelectedRowKeys = [];
            var newSelectedRows = [];
            if (checked) {
                newSelectedRowKeys = deleteUnExistKeys(getSet(mergedSelectedRowKeys.concat(allSelectedRowKeys)));
            }
            else {
                var tempSet_1 = new Set(allSelectedRowKeys);
                newSelectedRowKeys = deleteUnExistKeys(mergedSelectedRowKeys.filter(function (key) { return !tempSet_1.has(key); }));
            }
            if (!pureKeys) {
                newSelectedRows = getRowsFromKeys(newSelectedRowKeys, true);
            }
            var originSelectedRows = getOriginData(newSelectedRows);
            setSelectedRowKeys(newSelectedRowKeys);
            setSelectedRows(newSelectedRows);
            setIndeterminateKeys([]);
            onChange && onChange(newSelectedRowKeys, originSelectedRows);
            onSelectAll && onSelectAll(checked, originSelectedRows);
        }
        function onCheck(checked, record) {
            var _a = getSelectedKeys(record, checked, mergedSelectedRowKeys, indeterminateKeys, getRowKey, childrenColumnName, checkConnected), selectedRowKeys = _a.selectedRowKeys, _indeterminateKeys = _a.indeterminateKeys;
            var newSelectedRowKeys = deleteUnExistKeys(selectedRowKeys);
            var newSelectedRows = getRowsFromKeys(newSelectedRowKeys, true);
            var originSelectedRows = getOriginData(newSelectedRows);
            setSelectedRowKeys(newSelectedRowKeys);
            setSelectedRows(newSelectedRows);
            setIndeterminateKeys(_indeterminateKeys);
            onSelect && onSelect(checked, getOriginData(record), originSelectedRows);
            onChange && onChange(newSelectedRowKeys, originSelectedRows);
        }
        function onCheckRadio(key, record) {
            var newSelectedRows = [flattenData.find(function (d) { return getRowKey(d) === key; })];
            var originSelectedRows = getOriginData(newSelectedRows);
            setSelectedRowKeys([key]);
            onSelect && onSelect(true, getOriginData(record), originSelectedRows);
            onChange && onChange([key], originSelectedRows);
        }
        return {
            selectedRowKeys: mergedSelectedRowKeys,
            indeterminateKeys: mergedIndeterminateKeys,
            onCheckAll: onCheckAll,
            onCheck: onCheck,
            onCheckRadio: onCheckRadio,
            setSelectedRowKeys: setSelectedRowKeys,
            allSelectedRowKeys: allSelectedRowKeys,
            flattenData: flattenData,
        };
    }

    var __read$p = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$b = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };

    // get sticky cell's left and right
    function useStickyOffsets(columns) {
        var colWidths = columns.map(function (c) { return c.width; });
        var colFixed = columns.map(function (c) { return c.fixed; });
        var stickyOffsets = React.useMemo(function () {
            return columns.map(function (column) {
                var offset = 0;
                if (column.fixed === 'left') {
                    columns.some(function (col) {
                        if (col.fixed === 'left') {
                            if (col.key === column.key) {
                                return true;
                            }
                            var colWidth = col.$$isOperation ? col.width || 40 : col.width;
                            offset += colWidth;
                            return false;
                        }
                        return false;
                    });
                }
                if (column.fixed === 'right') {
                    __spreadArray$b([], __read$p(columns), false).reverse().some(function (col) {
                        if (col.fixed === 'right') {
                            if (col.key === column.key) {
                                return true;
                            }
                            var colWidth = col.$$isOperation ? col.width || 40 : col.width;
                            offset += colWidth;
                            return false;
                        }
                        return false;
                    });
                }
                return offset;
            });
        }, [colWidths.join('-'), colFixed.join('-')]);
        return stickyOffsets;
    }

    // get sticky cell's className
    function useStickyClassNames(groupColumns, columns, prefixCls) {
        var colFixed = columns.map(function (c) { return c.fixed; });
        function getClassNameFromColumn(column, index) {
            var _a;
            return cs((_a = {},
                _a[prefixCls + "-col-fixed-left"] = column.fixed === 'left',
                _a[prefixCls + "-col-fixed-right"] = column.fixed === 'right',
                _a[prefixCls + "-col-fixed-left-last"] = column.fixed === 'left' &&
                    (isObject$1(columns[index + 1]) ? columns[index + 1].fixed !== 'left' : true),
                _a[prefixCls + "-col-fixed-right-first"] = column.fixed === 'right' &&
                    (isObject$1(columns[index - 1]) ? columns[index - 1].fixed !== 'right' : true),
                _a));
        }
        var stickyClassNames = React.useMemo(function () {
            return columns.map(function (column, index) { return getClassNameFromColumn(column, index); });
        }, [colFixed.join('-')]);
        var groupStickyClassNames = React.useMemo(function () {
            return groupColumns.map(function (gc) {
                return gc.map(function (column, index) { return getClassNameFromColumn(column, index); });
            });
        }, [groupColumns.map(function (c) { return "|" + c.map(function (a) { return a.fixed || 'undefined'; }).join('-') + "|"; }).join('_')]);
        return [groupStickyClassNames, stickyClassNames];
    }

    var __assign$w = (undefined && undefined.__assign) || function () {
        __assign$w = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$w.apply(this, arguments);
    };
    var __read$o = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$a = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    function getFlattenColumns(columns, childrenColumnName) {
        var rows = [];
        function travel(columns) {
            if (columns && columns.length > 0) {
                columns.forEach(function (column) {
                    if (!column[childrenColumnName]) {
                        rows.push(__assign$w(__assign$w({}, column), { key: column.key || column.dataIndex }));
                    }
                    else {
                        travel(column[childrenColumnName]);
                    }
                });
            }
        }
        travel(columns);
        return rows;
    }
    // 获取 columns 需要分成几行，只有表头分组时可能 > 1。
    function getAllHeaderRowsCount(columns, childrenColumnName) {
        var length = 0;
        if (columns && columns.length > 0) {
            columns.forEach(function (column) {
                var depth = getAllHeaderRowsCount(column[childrenColumnName], childrenColumnName) + 1;
                length = Math.max(depth, length);
            });
        }
        return length;
    }
    function useColumns(props) {
        var components = props.components, rowSelection = props.rowSelection, expandedRowRender = props.expandedRowRender, _a = props.expandProps, expandProps = _a === void 0 ? {} : _a, _b = props.columns, columns = _b === void 0 ? [] : _b, childrenColumnName = props.childrenColumnName;
        var rows = React.useMemo(function () { return getFlattenColumns(columns, childrenColumnName); }, [columns, childrenColumnName]);
        var isCheckbox = (rowSelection && rowSelection.type === 'checkbox') ||
            (rowSelection && !('type' in rowSelection));
        var isRadio = rowSelection && rowSelection.type === 'radio';
        var expandColWidth = expandProps.width;
        var shouldRenderExpandCol = !!expandedRowRender;
        var shouldRenderSelectionCol = isCheckbox || isRadio;
        var _c = useComponent(components), getHeaderComponentOperations = _c.getHeaderComponentOperations, getBodyComponentOperations = _c.getBodyComponentOperations;
        var headerOperations = React.useMemo(function () {
            return getHeaderComponentOperations({
                selectionNode: shouldRenderSelectionCol ? 'holder_node' : '',
                expandNode: shouldRenderExpandCol ? 'holder_node' : '',
            });
        }, [shouldRenderSelectionCol, shouldRenderExpandCol, getHeaderComponentOperations]);
        var bodyOperations = React.useMemo(function () {
            return getBodyComponentOperations({
                selectionNode: shouldRenderSelectionCol ? 'holder_node' : '',
                expandNode: shouldRenderExpandCol ? 'holder_node' : '',
            });
        }, [shouldRenderSelectionCol, shouldRenderExpandCol, getBodyComponentOperations]);
        var selectionFixedLeft = rowSelection && rowSelection.fixed;
        var selectionColumnWidth = rowSelection && rowSelection.columnWidth;
        var getInternalColumns = React.useCallback(function (rows, operations, index) {
            var operationFixedProps = {};
            var _rows = [];
            rows.forEach(function (r, i) {
                var _r = __assign$w({}, r);
                if (!('key' in r)) {
                    _r.key = _r.dataIndex || i;
                }
                if (i === 0) {
                    _r.$$isFirstColumn = true;
                    if (_r.fixed === 'left') {
                        operationFixedProps.fixed = _r.fixed;
                    }
                }
                else {
                    _r.$$isFirstColumn = false;
                }
                _rows.push(_r);
            });
            var expandColumn = shouldRenderExpandCol && {
                key: INTERNAL_EXPAND_KEY,
                title: INTERNAL_EXPAND_KEY,
                width: expandColWidth,
                $$isOperation: true,
            };
            var selectionColumn = shouldRenderSelectionCol && {
                key: INTERNAL_SELECTION_KEY,
                title: INTERNAL_SELECTION_KEY,
                width: selectionColumnWidth,
                $$isOperation: true,
            };
            if (selectionFixedLeft) {
                operationFixedProps.fixed = 'left';
            }
            if (typeof index !== 'number' || index === 0) {
                __spreadArray$a([], __read$o(operations), false).reverse().forEach(function (operation) {
                    if (operation.node) {
                        if (operation.name === 'expandNode') {
                            _rows.unshift(__assign$w(__assign$w({}, expandColumn), operationFixedProps));
                        }
                        else if (operation.name === 'selectionNode') {
                            _rows.unshift(__assign$w(__assign$w({}, selectionColumn), operationFixedProps));
                        }
                        else {
                            _rows.unshift(__assign$w(__assign$w(__assign$w({}, operation), operationFixedProps), { title: operation.name, key: operation.name, $$isOperation: true, width: operation.width || 40 }));
                        }
                    }
                });
            }
            return _rows;
        }, [
            expandColWidth,
            shouldRenderExpandCol,
            shouldRenderSelectionCol,
            selectionColumnWidth,
            selectionFixedLeft,
        ]);
        var flattenColumns = React.useMemo(function () { return getInternalColumns(rows, bodyOperations); }, [rows, getInternalColumns, bodyOperations]);
        // 把表头分组的 columns 分成 n 行，并且加上 colSpan 和 rowSpan，没有表头分组的话是 1 行。
        var rowCount = React.useMemo(function () { return getAllHeaderRowsCount(columns, childrenColumnName); }, [columns, childrenColumnName]);
        // 分行之后的rows
        var groupColumns = React.useMemo(function () {
            if (rowCount === 1) {
                return [getInternalColumns(columns, headerOperations, 0)];
            }
            var rows = [];
            var travel = function (columns, current) {
                if (current === void 0) { current = 0; }
                rows[current] = rows[current] || [];
                columns.forEach(function (col) {
                    var column = __assign$w({}, col);
                    if (column[childrenColumnName]) {
                        column.colSpan = getFlattenColumns(col[childrenColumnName], childrenColumnName).length;
                        column.rowSpan = 1;
                        rows[current].push(column);
                        travel(column[childrenColumnName], current + 1);
                    }
                    else {
                        column.colSpan = 1;
                        column.rowSpan = rowCount - current;
                        rows[current].push(column);
                    }
                });
                rows[current] = getInternalColumns(rows[current], headerOperations, current);
            };
            travel(columns);
            return rows;
        }, [columns, childrenColumnName, rowCount, getInternalColumns, headerOperations]);
        return [groupColumns, flattenColumns];
    }

    var __assign$v = (undefined && undefined.__assign) || function () {
        __assign$v = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$v.apply(this, arguments);
    };
    var __read$n = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var defaultProps$8 = {
        showHeader: true,
        border: true,
        hover: true,
        rowKey: 'key',
        pagePosition: 'br',
        childrenColumnName: 'children',
        indentSize: 15,
        showSorterTooltip: true,
    };
    function Table$1(baseProps, ref) {
        var _a, _b;
        var _c, _d;
        var _e = React.useContext(ConfigContext), getPrefixCls = _e.getPrefixCls, loadingElement = _e.loadingElement, ctxSize = _e.size, tablePagination = _e.tablePagination, renderEmpty = _e.renderEmpty, componentConfig = _e.componentConfig, rtl = _e.rtl;
        var props = useMergeProps(baseProps, defaultProps$8, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Table);
        // priority: props.pagination > ConfigProvider.tablePagination > ConfigProvider.Table.pagination
        var mergePagination = useMergeProps(isObject$1(baseProps === null || baseProps === void 0 ? void 0 : baseProps.pagination) ? baseProps === null || baseProps === void 0 ? void 0 : baseProps.pagination : {}, isObject$1((_c = componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Table) === null || _c === void 0 ? void 0 : _c.pagination) ? (_d = componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Table) === null || _d === void 0 ? void 0 : _d.pagination : {}, tablePagination || {});
        var style = props.style, className = props.className, components = props.components, border = props.border, borderCell = props.borderCell, _f = props.columns, columns = _f === void 0 ? [] : _f, _g = props.data, data = _g === void 0 ? [] : _g, scroll = props.scroll, noDataElement = props.noDataElement, showHeader = props.showHeader, stripe = props.stripe, hover = props.hover, pagination = props.pagination, onChange = props.onChange, pagePosition = props.pagePosition, childrenColumnName = props.childrenColumnName, indentSize = props.indentSize, rowSelection = props.rowSelection, tableLayoutFixed = props.tableLayoutFixed, footer = props.footer, virtualized = props.virtualized, renderPagination = props.renderPagination, summary = props.summary, rowKey = props.rowKey;
        var clonedData = React.useMemo(function () { return deepCloneData(data, childrenColumnName); }, [data, childrenColumnName]);
        var prefixCls = getPrefixCls('table');
        // configProvider 提供的size可能和table size 不匹配，此时默认 'default'
        var size = props.size || (['default', 'middle', 'small'].indexOf(ctxSize) > -1 ? ctxSize : 'default');
        var refTableHead = React.useRef(null);
        var refTableBody = React.useRef(null);
        var refTableFoot = React.useRef(null);
        var refTable = React.useRef(null);
        // Not fixed header
        var refTableNF = React.useRef(null);
        var lastScrollLeft = React.useRef(0);
        var scrollbarChanged = React.useRef(false);
        var _h = getDefaultFiltersAndSorter(columns), currentFilters = _h.currentFilters, currentSorter = _h.currentSorter;
        var _j = __read$n(React.useState(1), 2), currentPage = _j[0], setCurrentPage = _j[1];
        var _k = __read$n(React.useState(mergePagination.pageSize || mergePagination.defaultPageSize || 10), 2), innerPageSize = _k[0], setInnerPageSize = _k[1];
        var _l = __read$n(React.useState(currentFilters), 2), filters = _l[0], setFilters = _l[1];
        var _m = __read$n(React.useState(currentSorter), 2), sorter = _m[0], setSorter = _m[1];
        var _o = __read$n(React.useState(0), 2), tableViewWidth = _o[0], setTableViewWidth = _o[1];
        var _p = __read$n(useColumns(props), 2), groupColumns = _p[0], flattenColumns = _p[1];
        var stickyOffsets = useStickyOffsets(flattenColumns);
        var _q = __read$n(useStickyClassNames(groupColumns, flattenColumns, prefixCls), 2), groupStickyClassNames = _q[0], stickyClassNames = _q[1];
        var _r = useComponent(components), ComponentTable = _r.ComponentTable, ComponentBodyWrapper = _r.ComponentBodyWrapper, ComponentHeaderWrapper = _r.ComponentHeaderWrapper;
        var getRowKey = React.useMemo(function () {
            if (typeof rowKey === 'function') {
                return function (record) { return rowKey(getOriginData(record)); };
            }
            return function (record) { return record[rowKey]; };
        }, [rowKey]);
        function getDefaultFiltersAndSorter(columns) {
            var currentFilters = {};
            var currentSorter = {};
            function travel(columns) {
                if (columns && columns.length > 0) {
                    columns.forEach(function (column, index) {
                        var innerDataIndex = column.dataIndex === undefined ? index : column.dataIndex;
                        if (!column[childrenColumnName]) {
                            if (column.defaultFilters) {
                                currentFilters[innerDataIndex] = column.defaultFilters;
                            }
                            if (column.filteredValue) {
                                currentFilters[innerDataIndex] = column.filteredValue;
                            }
                            if (column.defaultSortOrder) {
                                currentSorter.field = innerDataIndex;
                                currentSorter.direction = column.defaultSortOrder;
                            }
                            if (column.sortOrder) {
                                currentSorter.field = innerDataIndex;
                                currentSorter.direction = column.sortOrder;
                            }
                        }
                        else {
                            travel(column[childrenColumnName]);
                        }
                    });
                }
            }
            travel(columns);
            return { currentFilters: currentFilters, currentSorter: currentSorter };
        }
        var controlledFilter = React.useMemo(function () {
            // 允许 filteredValue 设置为 undefined 表示不筛选
            var flattenFilteredValueColumns = flattenColumns.filter(function (column) { return 'filteredValue' in column; });
            var newFilters = {};
            // 受控的筛选，当columns中的筛选发生改变时，更新state
            if (flattenFilteredValueColumns.length) {
                flattenFilteredValueColumns.forEach(function (column, index) {
                    var innerDataIndex = column.dataIndex === undefined ? index : column.dataIndex;
                    if (innerDataIndex !== undefined) {
                        newFilters[innerDataIndex] = column.filteredValue;
                    }
                });
            }
            return newFilters;
        }, [flattenColumns]);
        var controlledSorter = React.useMemo(function () {
            // 允许 sorter 设置为 null，表示不排序
            var flattenSortOrderColumns = flattenColumns.filter(function (column) { return 'sortOrder' in column; });
            var length = flattenSortOrderColumns.length;
            while (length--) {
                var column = flattenSortOrderColumns[length];
                if (column.sortOrder || length === 0) {
                    return { field: column.dataIndex, direction: column.sortOrder };
                }
            }
            return null;
        }, [flattenColumns]);
        var innerSorter = controlledSorter || sorter || {};
        var innerFilters = React.useMemo(function () {
            return Object.keys(controlledFilter).length ? controlledFilter : filters;
        }, [filters, controlledFilter]);
        /** ----------- Sorter ----------- */
        function onSort(direction, field) {
            var newSorter = {
                field: field,
                direction: direction,
            };
            !controlledSorter && setSorter(newSorter);
            var newProcessedData = getProcessedData(newSorter, innerFilters);
            var currentData = getPageData(newProcessedData);
            onChange &&
                onChange(getPaginationProps(newProcessedData), newSorter, innerFilters, {
                    currentData: getOriginData(currentData),
                    action: 'sort',
                });
        }
        function sorterFn(sorter, direction) {
            if (typeof sorter !== 'function') {
                return;
            }
            return function (a, b) {
                var result = sorter(a, b);
                return direction === 'descend' ? -result : result;
            };
        }
        /** ----------- Sorter End ----------- */
        /** ----------- Filters ----------- */
        function onHandleFilter(column, filter) {
            var _a;
            var newFilters = __assign$v(__assign$v({}, innerFilters), (_a = {}, _a[column.dataIndex] = filter, _a));
            var mergedFilters = __assign$v(__assign$v({}, newFilters), controlledFilter);
            if (isArray$1(filter) && filter.length) {
                setFilters(mergedFilters);
                var newProcessedData = getProcessedData(innerSorter, newFilters);
                var currentData = getPageData(newProcessedData);
                onChange &&
                    onChange(getPaginationProps(newProcessedData), innerSorter, newFilters, {
                        currentData: getOriginData(currentData),
                        action: 'filter',
                    });
            }
            else if (isArray$1(filter) && !filter.length) {
                onHandleFilterReset(column);
            }
        }
        function onHandleFilterReset(_a) {
            var dataIndex = _a.dataIndex;
            var newFilters = __assign$v({}, innerFilters);
            delete newFilters[dataIndex];
            setFilters(newFilters);
            var newProcessedData = getProcessedData(innerSorter, newFilters);
            var currentData = getPageData(newProcessedData);
            onChange &&
                onChange(getPaginationProps(newProcessedData), innerSorter, newFilters, {
                    currentData: getOriginData(currentData),
                    action: 'filter',
                });
        }
        /** ----------- Filters End ----------- */
        var hasFixedColumnLeft = !!flattenColumns.find(function (c) { return c.fixed === 'left'; });
        var hasFixedColumnRight = !!flattenColumns.find(function (c) { return c.fixed === 'right'; });
        var hasFixedColumn = hasFixedColumnLeft || hasFixedColumnRight;
        function getProcessedData(sorter, filters) {
            var _data = (clonedData || []).slice();
            Object.keys(filters).forEach(function (field) {
                if (filters[field] && filters[field].length) {
                    var column_1 = getColumnByDataIndex(field);
                    if (column_1 && typeof column_1.onFilter === 'function') {
                        _data = _data.filter(function (row) {
                            return filters[field].reduce(function (pre, cur) { return pre || column_1.onFilter(cur, row); }, false);
                        });
                    }
                }
            });
            var column = getColumnByDataIndex(sorter.field);
            var getSortData = function (d) {
                return d
                    .slice()
                    .sort(sorterFn(column.sorter, sorter.direction))
                    .map(function (item) {
                    var _a;
                    if (isArray$1(item[childrenColumnName])) {
                        return __assign$v(__assign$v({}, item), (_a = {}, _a[childrenColumnName] = getSortData(item[childrenColumnName]), _a));
                    }
                    return item;
                });
            };
            if (sorter.direction && column && typeof column.sorter === 'function') {
                return getSortData(_data);
            }
            return _data;
        }
        // 获得经过 sorter 和 filters 筛选之后的 data
        var processedData = getProcessedData(innerSorter, innerFilters);
        function getPaginationProps(_processedData) {
            if (_processedData === void 0) { _processedData = processedData; }
            var pageSize = mergePagination.pageSize || innerPageSize || 10;
            var paginationSize = size === 'middle' ? 'default' : size;
            var selectPopupPosition = 'top';
            if (pagePosition === 'tl' || pagePosition === 'bl') {
                selectPopupPosition = 'bottom';
            }
            else {
                selectPopupPosition = 'top';
            }
            var total = isArray$1(_processedData) ? _processedData.length : 0;
            var current = Math.ceil(total / pageSize) < currentPage ? 1 : currentPage;
            if (current !== currentPage) {
                setCurrentPage(current);
            }
            var paginationProps = {
                size: paginationSize,
                total: total,
                pageSize: pageSize,
                current: current,
                selectProps: {
                    triggerProps: {
                        position: selectPopupPosition,
                    },
                },
            };
            if (typeof pagination === 'object' && pagination.selectProps) {
                paginationProps.selectProps = __assign$v(__assign$v({}, paginationProps.selectProps), pagination.selectProps);
            }
            if (isObject$1(pagination)) {
                paginationProps = __assign$v(__assign$v({}, paginationProps), pagination);
            }
            if (isObject$1(mergePagination)) {
                paginationProps = __assign$v(__assign$v({}, paginationProps), mergePagination);
            }
            paginationProps.onChange = onPaginationChange;
            return paginationProps;
        }
        var paginationProps = getPaginationProps();
        var pageData = getPageData();
        function getPageData(currentData, _paginationProps) {
            if (currentData === void 0) { currentData = processedData; }
            if (_paginationProps === void 0) { _paginationProps = paginationProps; }
            var _a = _paginationProps.current, current = _a === void 0 ? 0 : _a, _b = _paginationProps.pageSize, pageSize = _b === void 0 ? 10 : _b;
            if (pagination === false) {
                return currentData;
            }
            if (isObject$1(pagination) && data.length <= pageSize) {
                return currentData;
            }
            return currentData.slice((current - 1) * pageSize, current * pageSize);
        }
        var throttleResizeHandler = debounce_1(resizeHandler, 100);
        var fixedHeader = !!(scroll && scroll.y);
        var summaryNode = summary === null || summary === void 0 ? void 0 : summary(getOriginData(processedData));
        var fixedFooterPosition = summary && React.isValidElement(summaryNode) && summaryNode.props.fixed;
        var fixedFooter = fixedHeader && fixedFooterPosition;
        useIsomorphicLayoutEffect$1(function () {
            resizeHandler();
            on(window, 'resize', throttleResizeHandler);
            var tableHead = refTableHead.current;
            var tableBody = refTableBody.current;
            var tableFoot = refTableFoot.current;
            if (tableBody) {
                on(tableBody, 'scroll', tableScrollHandler);
            }
            var theadScrollContainer = tableHead && tableHead.parentNode;
            if (tableHead) {
                if (theadScrollContainer) {
                    on(theadScrollContainer, 'scroll', tableScrollHandler);
                }
            }
            if (tableFoot) {
                on(tableFoot, 'scroll', tableScrollHandler);
            }
            return function () {
                off(window, 'resize', throttleResizeHandler);
                if (tableBody) {
                    off(tableBody, 'scroll', tableScrollHandler);
                }
                if (theadScrollContainer) {
                    off(theadScrollContainer, 'scroll', tableScrollHandler);
                }
                if (tableFoot) {
                    off(tableFoot, 'scroll', tableScrollHandler);
                }
            };
        }, [hasFixedColumnLeft, hasFixedColumnRight, scroll === null || scroll === void 0 ? void 0 : scroll.x, flattenColumns.length]);
        useUpdate(function () {
            var _a = getPaginationProps(data), total = _a.total, pageSize = _a.pageSize;
            var maxPageNum = Math.ceil(total / pageSize);
            if (maxPageNum < currentPage) {
                setCurrentPage(1);
            }
        }, [data === null || data === void 0 ? void 0 : data.length]);
        useUpdate(function () {
            setFixedColumnClassNames();
        }, [data, hasFixedColumnLeft, hasFixedColumnRight]);
        React.useImperativeHandle(ref, function () { return ({
            getRootDomElement: getRootDomElement,
        }); });
        function getRootDomElement() {
            return refTable.current;
        }
        function resizeHandler() {
            setFixedColumnClassNames();
            var root = getRootDomElement();
            if (root && (hasFixedColumn || (scroll && scroll.x))) {
                var ele = root.querySelector("." + prefixCls + "-body") ||
                    root.querySelector("." + prefixCls + "-content-inner");
                var tableViewWidth_1 = ele.clientWidth;
                setTableViewWidth(tableViewWidth_1);
            }
        }
        var setPositionClassNames = React.useCallback(throttle_1(function () {
            var table = refTable.current;
            var tbody = (fixedHeader ? refTableBody.current : refTableNF.current && refTableNF.current.parentNode);
            if (tbody) {
                var scrollLeft = rtl ? -tbody.scrollLeft : tbody.scrollLeft;
                var alignLeft = scrollLeft === 0;
                // const alignRight = tbody.scrollLeft + tbody.clientWidth >= tbody.scrollWidth;
                var alignRight = scrollLeft + 1 >=
                    tbody.children[0].getBoundingClientRect().width - tbody.getBoundingClientRect().width;
                if (alignLeft && alignRight) {
                    setFixedColumnsClassList(table.classList, prefixCls + "-scroll-position-both");
                }
                else if (alignLeft) {
                    setFixedColumnsClassList(table.classList, prefixCls + "-scroll-position-" + (rtl ? 'right' : 'left'));
                }
                else if (alignRight) {
                    setFixedColumnsClassList(table.classList, prefixCls + "-scroll-position-" + (rtl ? 'left' : 'right'));
                }
                else {
                    setFixedColumnsClassList(table.classList, prefixCls + "-scroll-position-middle");
                }
            }
            else {
                table && resetTableClassName(table.classList);
            }
        }, 100), [refTable.current, refTableBody.current, fixedHeader]);
        function setFixedColumnClassNames() {
            if (hasFixedColumn || (scroll && isObject$1(scroll) && scroll.x)) {
                var table = refTable.current;
                if (table) {
                    if (hasFixedColumnLeft) {
                        setTableFixedClassName(table.classList, prefixCls + "-has-fixed-col-left");
                    }
                    if (hasFixedColumnRight) {
                        setTableFixedClassName(table.classList, prefixCls + "-has-fixed-col-right");
                    }
                }
                setPositionClassNames();
            }
        }
        function setTableFixedClassName(tableClassList, className) {
            if (!tableClassList.contains(className)) {
                tableClassList.add(className);
            }
        }
        function resetTableClassName(classList) {
            classList.remove(prefixCls + "-scroll-position-both");
            classList.remove(prefixCls + "-scroll-position-left");
            classList.remove(prefixCls + "-scroll-position-right");
            classList.remove(prefixCls + "-scroll-position-middle");
        }
        function setFixedColumnsClassList(classList, className) {
            if (!classList.contains(className)) {
                resetTableClassName(classList);
                classList.add(className);
            }
        }
        var _s = useRowSelection(props, pageData, clonedData, getRowKey), selectedRowKeys = _s.selectedRowKeys, indeterminateKeys = _s.indeterminateKeys, onCheckAll = _s.onCheckAll, onCheck = _s.onCheck, onCheckRadio = _s.onCheckRadio, setSelectedRowKeys = _s.setSelectedRowKeys, allSelectedRowKeys = _s.allSelectedRowKeys, flattenData = _s.flattenData;
        function getColumnByDataIndex(dataIndex) {
            return flattenColumns.find(function (column, index) {
                if (column.dataIndex !== undefined) {
                    return column.dataIndex === dataIndex;
                }
                return Number(dataIndex) === index;
            });
        }
        function onPaginationChange(current, pageSize) {
            setCurrentPage(current);
            setInnerPageSize(pageSize);
            if (current !== currentPage) {
                scrollToTop();
            }
            if (rowSelection && !rowSelection.checkCrossPage && selectedRowKeys.length) {
                setSelectedRowKeys([]);
                rowSelection.onChange && rowSelection.onChange([], []);
            }
            var newPaginationProps = __assign$v(__assign$v({}, getPaginationProps()), { current: current, pageSize: pageSize });
            onChange &&
                onChange(newPaginationProps, innerSorter, innerFilters, {
                    currentData: getPageData(processedData, newPaginationProps),
                    action: 'paginate',
                });
            mergePagination.onChange && mergePagination.onChange(current, pageSize);
        }
        function scrollToTop() {
            var tableBody = refTableBody.current;
            if (!tableBody) {
                return;
            }
            var scrollTop = refTableBody.current.scrollTop;
            var tween = new Tween({
                from: { scrollTop: scrollTop },
                to: { scrollTop: 0 },
                easing: 'quintInOut',
                duration: 300,
                onUpdate: function (keys) {
                    refTableBody.current.scrollTop = keys.scrollTop;
                },
            });
            tween.start();
        }
        function tableScrollHandler(e) {
            var target = e.target;
            var tbody = refTableBody.current;
            var theadScrollContainer = refTableHead.current && refTableHead.current.parentNode;
            var tfoot = refTableFoot.current;
            if (target.scrollLeft !== lastScrollLeft.current) {
                if (theadScrollContainer) {
                    theadScrollContainer.scrollLeft = target.scrollLeft;
                }
                if (tbody) {
                    tbody.scrollLeft = target.scrollLeft;
                }
                if (tfoot) {
                    tfoot.scrollLeft = target.scrollLeft;
                }
                setFixedColumnClassNames();
            }
            lastScrollLeft.current = e.target.scrollLeft;
        }
        // isFixedHeader = false
        function tableScrollHandlerNF(e) {
            var target = e.target;
            var table = refTableNF.current;
            if (target.scrollLeft !== lastScrollLeft.current) {
                table.scrollLeft = target.scrollLeft;
                setFixedColumnClassNames();
            }
            lastScrollLeft.current = e.target.scrollLeft;
        }
        var _t = __read$n(useExpand(props, flattenData, getRowKey), 2), expandedRowKeys = _t[0], onClickExpandBtn = _t[1];
        var scrollStyleY = {};
        var scrollStyleX = {};
        if (scroll) {
            if (scroll.x && (typeof scroll.x === 'number' || typeof scroll.x === 'string')) {
                scrollStyleX = {
                    width: scroll.x,
                };
            }
            if (scroll.y && (typeof scroll.y === 'number' || typeof scroll.y === 'string')) {
                scrollStyleY = {
                    maxHeight: scroll.y,
                };
            }
        }
        function setScrollBarStyle() {
            var wrapper = refTableHead.current && refTableHead.current.parentNode;
            var scrollBarHeight = getScrollBarHeight(wrapper);
            if (scrollBarHeight && scrollBarHeight > 0) {
                wrapper.style.marginBottom = "-" + scrollBarHeight + "px";
                wrapper.style.paddingBottom = '0px';
                if (refTableFoot.current) {
                    refTableFoot.current.style.marginBottom = "-" + scrollBarHeight + "px";
                    refTableFoot.current.style.paddingBottom = '0px';
                }
            }
            // 根据 Tbody 决定 Thead 是否显示纵向滚动条
            // TODO: Remove
            setTimeout(function () {
                var scrollWrapper = refTableBody.current;
                var scrollBarWidth = getScrollBarWidth(scrollWrapper);
                if (scrollBarWidth) {
                    scrollbarChanged.current = true;
                    if (wrapper) {
                        wrapper.style.overflowY = 'scroll';
                    }
                    if (refTableFoot.current) {
                        refTableFoot.current.style.overflowY = 'scroll';
                    }
                }
                else if (wrapper && scrollbarChanged.current) {
                    scrollbarChanged.current = false;
                    wrapper.style.overflowY = 'auto';
                    if (refTableFoot.current) {
                        refTableFoot.current.style.overflowY = 'auto';
                    }
                }
            });
        }
        var theadNode = (React.createElement(THead, __assign$v({}, props, { sorter: innerSorter, selectedRowKeys: selectedRowKeys, currentFilters: innerFilters, onCheckAll: onCheckAll, onSort: onSort, data: pageData, onHandleFilter: onHandleFilter, onHandleFilterReset: onHandleFilterReset, prefixCls: prefixCls, allSelectedRowKeys: allSelectedRowKeys, groupColumns: groupColumns, stickyOffsets: stickyOffsets, groupStickyClassNames: groupStickyClassNames })));
        function renderThead() {
            var maxContentWidth = isObject$1(scroll) && scroll.x === 'max-content';
            return fixedHeader || virtualized ? (React.createElement(ComponentHeaderWrapper, { className: prefixCls + "-header" },
                React.createElement(ComponentTable, { ref: refTableHead, style: maxContentWidth ? {} : scrollStyleX },
                    React.createElement(ColGroup, { columns: flattenColumns, prefixCls: prefixCls }),
                    theadNode))) : (theadNode);
        }
        var footerNode = summaryNode && (React.createElement(Tfoot, { prefixCls: prefixCls, summary: summary, data: pageData, columns: flattenColumns, stickyOffsets: stickyOffsets, stickyClassNames: stickyClassNames }));
        var tbodyNode = (React.createElement(TBody, __assign$v({}, props, { selectedRowKeys: selectedRowKeys, indeterminateKeys: indeterminateKeys, expandedRowKeys: expandedRowKeys, onCheck: onCheck, onCheckRadio: onCheckRadio, onClickExpandBtn: onClickExpandBtn, columns: flattenColumns, data: pageData, prefixCls: prefixCls, hasFixedColumn: hasFixedColumn, tableViewWidth: tableViewWidth, indentSize: indentSize, noDataElement: noDataElement || renderEmpty('Table'), currentSorter: innerSorter, stickyOffsets: stickyOffsets, stickyClassNames: stickyClassNames, getRowKey: getRowKey, saveVirtualWrapperRef: function (ref) {
                if (virtualized) {
                    refTableBody.current = ref;
                }
            } })));
        var tbody = !virtualized && !fixedFooter ? (React.createElement(React.Fragment, null,
            tbodyNode,
            footerNode)) : (tbodyNode);
        function renderTbody() {
            return (React.createElement(ResizeObserver$1, { onResize: setScrollBarStyle }, fixedHeader && !virtualized ? (React.createElement(ComponentBodyWrapper, { ref: refTableBody, className: prefixCls + "-body", style: scrollStyleY },
                React.createElement(ComponentTable, { style: scrollStyleX },
                    React.createElement(ColGroup, { columns: flattenColumns, prefixCls: prefixCls }),
                    tbody))) : (tbody)));
        }
        function renderTable() {
            var scrollStyle = {};
            if (scroll && isObject$1(scroll) && scroll.x) {
                scrollStyle = {
                    width: scroll.x,
                };
            }
            var summaryTableNode = (React.createElement("div", { className: prefixCls + "-tfoot", ref: refTableFoot },
                React.createElement(ComponentTable, { style: scrollStyle },
                    React.createElement(ColGroup, { columns: flattenColumns, prefixCls: prefixCls }),
                    footerNode)));
            var summaryFixedTop = summaryNode && fixedHeader && fixedFooterPosition === 'top';
            var summaryFixedBottom = summaryNode && fixedHeader && fixedFooterPosition === 'bottom';
            var body = (React.createElement(React.Fragment, null,
                showHeader ? renderThead() : null,
                summaryFixedTop && summaryTableNode,
                renderTbody(),
                summaryFixedBottom && summaryTableNode));
            return (React.createElement(React.Fragment, null,
                React.createElement("div", { className: prefixCls + "-container" },
                    React.createElement("div", { className: prefixCls + "-content-scroll" },
                        React.createElement("div", { className: prefixCls + "-content-inner", onScroll: !fixedHeader ? tableScrollHandlerNF : undefined }, fixedHeader || virtualized ? (body) : (React.createElement(ComponentTable, { ref: refTableNF, style: scrollStyle },
                            React.createElement(ColGroup, { prefixCls: prefixCls, columns: flattenColumns }),
                            body))))),
                typeof footer === 'function' && (React.createElement("div", { className: prefixCls + "-footer" }, footer(pageData)))));
        }
        if (!columns.length) {
            return null;
        }
        var showWrapperBorder = isObject$1(border) ? border.wrapper : border;
        var showCellBorder = isObject$1(border) ? border.cell : borderCell;
        var showHeaderCellBorder = isObject$1(border) ? border.cell || border.headerCell : borderCell;
        var showBodyCellBorder = isObject$1(border) ? border.cell || border.bodyCell : borderCell;
        var classNames = cs(prefixCls, prefixCls + "-size-" + size, (_a = {},
            _a[prefixCls + "-border"] = showWrapperBorder,
            _a[prefixCls + "-border-cell"] = showCellBorder,
            _a[prefixCls + "-border-header-cell"] = !showCellBorder && showHeaderCellBorder,
            _a[prefixCls + "-border-body-cell"] = !showCellBorder && showBodyCellBorder,
            _a[prefixCls + "-stripe"] = stripe,
            _a[prefixCls + "-hover"] = hover,
            _a[prefixCls + "-type-radio"] = rowSelection && rowSelection.type === 'radio',
            _a[prefixCls + "-layout-fixed"] = tableLayoutFixed ||
                (scroll && (scroll.x || scroll.y)) ||
                columns.find(function (col) { return col.ellipsis; }),
            _a[prefixCls + "-fixed-column"] = hasFixedColumn,
            _a[prefixCls + "-virtualized"] = virtualized,
            _a[prefixCls + "-rtl"] = rtl,
            _a), className);
        var isPaginationTop = pagePosition === 'tl' || pagePosition === 'tr' || pagePosition === 'topCenter';
        var paginationClassName = cs(prefixCls + "-pagination", (_b = {},
            _b[prefixCls + "-pagination-left"] = pagePosition === 'tl' || pagePosition === 'bl',
            _b[prefixCls + "-pagination-center"] = pagePosition === 'topCenter' || pagePosition === 'bottomCenter',
            _b[prefixCls + "-pagination-top"] = isPaginationTop,
            _b));
        var loading = props.loading;
        if (typeof loading === 'boolean') {
            loading = { loading: loading };
        }
        var customPagination = typeof renderPagination === 'function';
        var paginationEle = customPagination ? (renderPagination(React.createElement(Pagination$1, __assign$v({}, paginationProps)))) : (React.createElement("div", { className: paginationClassName },
            React.createElement(Pagination$1, __assign$v({}, paginationProps))));
        return (React.createElement("div", __assign$v({ ref: refTable, style: style, className: classNames }, pickDataAttributes(props)),
            React.createElement(Spin$1, __assign$v({ element: loadingElement || React.createElement(Spin$1, null) }, loading),
                pagination !== false && pageData.length !== 0 && isPaginationTop && paginationEle,
                renderTable(),
                pagination !== false && pageData.length !== 0 && !isPaginationTop && paginationEle)));
    }
    var TableComponent$1 = React.forwardRef(Table$1);
    TableComponent$1.displayName = 'Table';
    var Table$2 = TableComponent$1;

    var __assign$u = (undefined && undefined.__assign) || function () {
        __assign$u = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$u.apply(this, arguments);
    };
    var __rest$b = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function Row(props) {
        var rtl = React.useContext(ConfigContext).rtl;
        var _a = React.useContext(SummaryContext), columns = _a.columns, stickyOffsets = _a.stickyOffsets, stickyClassNames = _a.stickyClassNames, prefixCls = _a.prefixCls;
        var children = props.children, rest = __rest$b(props, ["children"]);
        var colSpans = React.Children.map(children, function (child) { return child.props.colSpan || 1; });
        var element = React.Children.map(children, function (child, index) {
            var _a, _b;
            var _c, _d;
            var childElement = child;
            // childElement?.props?.$$ArcoTableSummaryCell: Compatible Cell.defaultProps.$$ArcoTableSummaryCell
            var isSummaryCell = get_1(childElement, 'type.__ARCO_TABLE_SUMMARY_CELL__') ||
                get_1(childElement, 'props.$$ArcoTableSummaryCell');
            var childStyle = (_c = childElement === null || childElement === void 0 ? void 0 : childElement.props) === null || _c === void 0 ? void 0 : _c.style;
            var childClassName = (_d = childElement === null || childElement === void 0 ? void 0 : childElement.props) === null || _d === void 0 ? void 0 : _d.className;
            var prevAllColSpan = colSpans.slice(0, index).reduce(function (p, n) { return p + n; }, 0);
            var stickyIndex = prevAllColSpan;
            var stickyStyle = columns[stickyIndex].fixed === 'left'
                ? (_a = {}, _a[rtl ? 'right' : 'left'] = stickyOffsets[stickyIndex], _a) : columns[stickyIndex].fixed === 'right'
                ? (_b = {}, _b[rtl ? 'left' : 'right'] = stickyOffsets[stickyIndex], _b) : {};
            var stickyClassName = columns[stickyIndex].fixed === 'left' || columns[stickyIndex].fixed === 'right'
                ? stickyClassNames[stickyIndex]
                : '';
            return isSummaryCell
                ? React.cloneElement(childElement, __assign$u(__assign$u({}, childElement.props), { className: cs(prefixCls + "-td", stickyClassName, childClassName), style: __assign$u(__assign$u({}, childStyle), stickyStyle) }))
                : child;
        });
        return React.createElement("tr", __assign$u({}, rest), element);
    }

    var __assign$t = (undefined && undefined.__assign) || function () {
        __assign$t = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$t.apply(this, arguments);
    };
    var __rest$a = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function Cell(props) {
        var children = props.children, rest = __rest$a(props, ["children"]);
        return React.createElement("td", __assign$t({}, omit$1(rest, ['$$ArcoTableSummaryCell'])), children);
    }
    Cell.__ARCO_TABLE_SUMMARY_CELL__ = true;

    function Summary(props) {
        return props.children;
    }
    Summary.Row = Row;
    Summary.Cell = Cell;

    var TableComponent = Table$2;
    TableComponent.Summary = Summary;
    var Table = TableComponent;

    var __assign$s = (undefined && undefined.__assign) || function () {
        __assign$s = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$s.apply(this, arguments);
    };
    var __rest$9 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function TabPane$2(props, ref) {
        var shouldRender = React.useRef(false);
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var children = props.children, className = props.className, style = props.style, lazyload = props.lazyload, isActive = props.isActive, rest = __rest$9(props, ["children", "className", "style", "lazyload", "isActive"]);
        var prefixCls = getPrefixCls('tabs');
        shouldRender.current = lazyload ? shouldRender.current || isActive : true;
        return (shouldRender.current && (React.createElement("div", __assign$s({ ref: ref }, omit$1(rest, ['destroyOnHide', 'title', 'closable']), { className: cs(prefixCls + "-pane", className), style: style }), children)));
    }
    var TabPaneRef = React.forwardRef(TabPane$2);
    TabPaneRef.displayName = 'TabPane';
    TabPaneRef.isTabPane = true;
    var TabPane$3 = TabPaneRef;

    function DropdownIcon(props) {
        var prefixCls = props.prefixCls, currentOffset = props.currentOffset, headerSize = props.headerSize, headerWrapperSize = props.headerWrapperSize, getTitleRef = props.getTitleRef, paneChildren = props.paneChildren, direction = props.direction;
        var paneKeys = paneChildren.map(function (child) { return child.key; });
        var size = direction === 'vertical' ? headerSize.height : headerSize.width;
        var wrapperSize = direction === 'vertical' ? headerWrapperSize.height : headerWrapperSize.width;
        var tabSizes = React.useMemo(function () {
            var map = {};
            var wrapperRect = headerWrapperSize.domRect;
            paneKeys.map(function (key) {
                var titleDom = getTitleRef(key);
                if (!titleDom)
                    return;
                var rect = titleDom.getBoundingClientRect();
                map[key] = {
                    left: rect.left - wrapperRect.left,
                    right: rect.left - wrapperRect.left + rect.width,
                    top: rect.top - wrapperRect.top,
                    bottom: rect.top - wrapperRect.top + rect.height,
                };
            });
            return map;
        }, [paneKeys.join(','), size, wrapperSize]);
        var rangeIndex = React.useMemo(function () {
            var start = -1;
            var end = -1;
            for (var key in tabSizes) {
                var _a = tabSizes[key], left = _a.left, right = _a.right;
                if (left >= currentOffset && right - currentOffset <= wrapperSize && start === -1) {
                    start = paneKeys.indexOf(key);
                    end = start;
                }
                if (left >= currentOffset && right - currentOffset > wrapperSize) {
                    end = paneKeys.indexOf(key);
                    break;
                }
            }
            return [start, end];
        }, [tabSizes, paneKeys.join(','), currentOffset]);
        return (React.createElement(Dropdown$1, { trigger: "click", droplist: React.createElement(Menu$1, { onClickMenuItem: props.onClickTab }, paneChildren.map(function (child, index) {
                if (index < rangeIndex[0] || index >= rangeIndex[1]) {
                    return (React.createElement(Menu$1.Item, { key: child.key, disabled: child.disabled }, child.props.title));
                }
            })) },
            React.createElement(IconHover, { role: "button", "aria-label": "expand tabs", prefix: prefixCls + "-dropdown", className: prefixCls + "-dropdown-icon" },
                React.createElement(IconDown$1, null))));
    }

    var TabNavIcon = function (props) {
        var _a, _b, _c, _d;
        var direction = props.direction, headerSize = props.headerSize, headerWrapperSize = props.headerWrapperSize, prefixCls = props.prefixCls, iconPos = props.iconPos, curOffset = props.currentOffset, align = props.align, rtl = props.rtl;
        var wrapHeight = headerWrapperSize.height, wrapWidth = headerWrapperSize.width;
        var headerHeight = headerSize.height, headerWidth = headerSize.width;
        var maxHeightOffset = headerHeight - wrapHeight;
        var maxWidthOffset = headerWidth - wrapWidth;
        var onChange = function (offset) {
            if (offset !== props.currentOffset) {
                props.onChange && props.onChange(offset);
            }
        };
        var handleHozClick = function (e, pos) {
            e.preventDefault();
            var nextOffset;
            if (align === 'left') {
                nextOffset = pos === 'left' ? curOffset - wrapWidth : curOffset + wrapWidth;
            }
            else {
                nextOffset = pos === 'left' ? curOffset + wrapWidth : curOffset - wrapWidth;
            }
            onChange(nextOffset);
        };
        var handleVerticalClick = function (e, pos) {
            e.preventDefault();
            var nextOffset;
            if (pos === 'up') {
                nextOffset = curOffset - wrapHeight;
            }
            else {
                nextOffset = curOffset + wrapHeight;
                if (nextOffset >= headerHeight)
                    return;
            }
            onChange(nextOffset);
        };
        var disabledPrev = false;
        var disabledNext = false;
        if (align === 'left') {
            disabledPrev = curOffset <= 0;
            disabledNext =
                direction === 'vertical' ? curOffset >= maxHeightOffset : curOffset >= maxWidthOffset;
        }
        else {
            disabledPrev =
                direction === 'vertical' ? curOffset >= maxHeightOffset : curOffset >= maxWidthOffset;
            disabledNext = curOffset <= 0;
        }
        return direction === 'vertical' ? (iconPos === 'prev' ? (React.createElement(IconHover, { disabled: disabledPrev, prefix: prefixCls, className: cs(prefixCls + "-up-icon", (_a = {},
                _a[prefixCls + "-nav-icon-disabled"] = disabledPrev,
                _a)), onClick: function (e) {
                handleVerticalClick(e, 'up');
            } },
            React.createElement(IconUp$1, null))) : (React.createElement(IconHover, { prefix: prefixCls, className: cs(prefixCls + "-down-icon", (_b = {},
                _b[prefixCls + "-nav-icon-disabled"] = disabledNext,
                _b)), disabled: disabledNext, onClick: function (e) {
                handleVerticalClick(e, 'down');
            } },
            React.createElement(IconDown$1, null)))) : iconPos === 'prev' ? (React.createElement(IconHover, { prefix: prefixCls, disabled: disabledPrev, className: cs(prefixCls + "-left-icon", (_c = {},
                _c[prefixCls + "-nav-icon-disabled"] = disabledPrev,
                _c)), onClick: function (e) {
                handleHozClick(e, 'left');
            } }, rtl ? React.createElement(IconRight$1, null) : React.createElement(IconLeft$1, null))) : (React.createElement(IconHover, { prefix: prefixCls, className: cs(prefixCls + "-right-icon", (_d = {},
                _d[prefixCls + "-nav-icon-disabled"] = disabledNext,
                _d)), disabled: disabledNext, onClick: function (e) {
                handleHozClick(e, 'right');
            } }, rtl ? React.createElement(IconLeft$1, null) : React.createElement(IconRight$1, null)));
    };
    var TabNavIcon$1 = TabNavIcon;

    var getRectDiff = function (node, parentNode) {
        var nodeRect = node.getBoundingClientRect();
        var parentRect = parentNode.getBoundingClientRect();
        var scaleX = parentNode.offsetWidth / parentRect.width;
        var scaleY = parentNode.offsetHeight / parentRect.height;
        return {
            left: (nodeRect.left - parentRect.left) * scaleX,
            top: (nodeRect.top - parentRect.top) * scaleY,
            right: (nodeRect.right - parentRect.right) * scaleX,
            bottom: (nodeRect.bottom - parentRect.bottom) * scaleY,
        };
    };
    // 浏览器默认行为影响，比如说input的autofocus，会导致wrapper自动滚动到focus元素
    // 需要手动校准一下
    // https://github.com/arco-design/arco-design/issues/422
    var updateScrollOffset = function (parentNode, direction) {
        var scrollLeft = parentNode.scrollLeft;
        var scrollTop = parentNode.scrollTop;
        if (direction === 'horizontal' && scrollLeft) {
            parentNode.scrollTo({ left: -1 * scrollLeft });
        }
        if (direction === 'vertical' && scrollTop) {
            parentNode.scrollTo({ top: -1 * scrollTop });
        }
    };
    var getKeyDownEvent = function (_a) {
        var onPressEnter = _a.onPressEnter;
        return {
            onKeyDown: function (e) {
                var keyCode = e.keyCode || e.which;
                if (keyCode === Enter.code) {
                    onPressEnter(e);
                }
            },
        };
    };

    var __assign$r = (undefined && undefined.__assign) || function () {
        __assign$r = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$r.apply(this, arguments);
    };
    var TabHeaderTitle = function (_a, ref) {
        var _b;
        var prefixCls = _a.prefixCls, onDeleteTab = _a.onDeleteTab, tabKey = _a.tabKey, isActive = _a.isActive, onClickTab = _a.onClickTab, _c = _a.disabled, disabled = _c === void 0 ? false : _c, title = _a.title, editable = _a.editable, renderTitle = _a.renderTitle, deleteIcon = _a.deleteIcon, deleteButton = _a.deleteButton, getIdPrefix = _a.getIdPrefix, index = _a.index;
        var render = isFunction$1(renderTitle)
            ? renderTitle
            : function (node) {
                return node;
            };
        var handleDeleteTab = function (e) {
            e.stopPropagation();
            if (disabled)
                return;
            onDeleteTab();
        };
        var handleTabClick = function (e) {
            if (disabled)
                return;
            onClickTab(e);
        };
        return render(React.createElement("div", { ref: ref, key: tabKey, className: cs(prefixCls + "-header-title", (_b = {},
                _b[prefixCls + "-header-title-active"] = isActive,
                _b[prefixCls + "-header-title-editable"] = editable,
                _b[prefixCls + "-header-title-disabled"] = disabled,
                _b)), role: "tab", "aria-selected": isActive, tabIndex: disabled ? -1 : 0, "aria-disabled": disabled || undefined, id: getIdPrefix(index).tab, "aria-controls": getIdPrefix(index).tabpane, onClick: handleTabClick, onKeyDown: function (event) {
                var keyCode = event.keyCode || event.which;
                if (keyCode === Enter.code) {
                    handleTabClick(event);
                }
            } },
            React.createElement("span", { className: prefixCls + "-header-title-text" }, title),
            editable && (React.createElement("span", __assign$r({ role: "button", "aria-label": "remove tab", "aria-disabled": disabled || undefined, tabIndex: disabled ? -1 : 0, className: prefixCls + "-close-icon" }, getKeyDownEvent({ onPressEnter: handleDeleteTab }), { onClick: handleDeleteTab }), deleteButton || React.createElement(IconHover, { prefix: prefixCls }, deleteIcon || React.createElement(IconClose$1, null))))), {
            key: tabKey,
            isActive: isActive,
            disabled: disabled,
            editable: editable,
        });
    };
    var TabHeaderTitle$1 = React.forwardRef(TabHeaderTitle);

    var getInkStyle = function (direction, curTitle, headerRef) {
        var style = {};
        if (curTitle) {
            var diffStyle = getRectDiff(curTitle, headerRef);
            if (direction === 'vertical') {
                style = {
                    top: diffStyle.top + "px",
                    height: curTitle.offsetHeight + "px",
                    left: '',
                    width: '',
                };
            }
            else {
                style = {
                    left: diffStyle.left + "px",
                    width: curTitle.offsetWidth + "px",
                    top: '',
                    height: '',
                };
            }
        }
        return style;
    };
    var TabInk = function (_a) {
        var _b;
        var prefixCls = _a.prefixCls, animation = _a.animation, disabled = _a.disabled, direction = _a.direction, getTitleRef = _a.getTitleRef, activeTab = _a.activeTab, getHeaderRef = _a.getHeaderRef;
        var inkRef = React.useRef();
        var inkStyleRef = React.useRef();
        React.useEffect(function () {
            var setInkStyle = throttleByRaf(function () {
                var newStyle = getInkStyle(direction, getTitleRef(activeTab), getHeaderRef('headerRef').current);
                if (newStyle && !isEqualWith_1(inkStyleRef.current, newStyle)) {
                    inkStyleRef.current = newStyle;
                    Object.keys(newStyle).forEach(function (key) {
                        inkRef.current.style[key] = newStyle[key];
                    });
                }
            });
            setInkStyle();
            return function () {
                setInkStyle.cancel && setInkStyle.cancel();
            };
        });
        return (React.createElement("div", { className: cs(prefixCls + "-header-ink", (_b = {},
                _b[prefixCls + "-header-ink-no-animation"] = !animation,
                _b[prefixCls + "-header-ink-disabled"] = disabled,
                _b)), ref: inkRef }));
    };
    var TabInk$1 = TabInk;

    var __read$m = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    function DomSize() {
        var domRef = React.useRef();
        var _a = __read$m(React.useState({
            height: 0,
            width: 0,
        }), 2), size = _a[0], setSize = _a[1];
        React.useEffect(function () {
            if (domRef.current) {
                setSize({
                    height: domRef.current.offsetHeight,
                    width: domRef.current.offsetWidth,
                    domRect: domRef.current.getBoundingClientRect(),
                });
            }
        }, []);
        return [domRef, size, setSize];
    }

    function useHeaderScroll(props) {
        var headerWrapperRef = props.headerWrapperRef, headerOffset = props.headerOffset, align = props.align, isScrollable = props.isScrollable, direction = props.direction, onScroll = props.onScroll;
        function onOffset(offsetX, offsetY) {
            var offset = 0;
            if (direction === 'vertical') {
                offset = headerOffset + offsetY;
            }
            else {
                offset = align === 'left' ? headerOffset + offsetX : headerOffset - offsetX;
            }
            onScroll && onScroll(offset);
        }
        // wheel
        var lastWheelDirectionRef = React.useRef('x');
        function onWheel(e) {
            if (!isScrollable)
                return;
            e.preventDefault();
            var deltaX = e.deltaX, deltaY = e.deltaY;
            var offset = 0;
            var absX = Math.abs(deltaX);
            var absY = Math.abs(deltaY);
            if (absX === absY) {
                offset = lastWheelDirectionRef.current === 'x' ? deltaX : deltaY;
            }
            else if (absX > absY) {
                offset = deltaX;
                lastWheelDirectionRef.current = 'x';
            }
            else {
                offset = deltaY;
                lastWheelDirectionRef.current = 'y';
            }
            onOffset(offset, offset);
        }
        // touch
        var positionRef = React.useRef({
            clientX: 0,
            clientY: 0,
        });
        var getPosition = function (e) {
            return e && e.touches && e.touches.length && e.touches[0];
        };
        var onTouchMove = function (e) {
            if (e.cancelable)
                e.preventDefault();
            var position = getPosition(e);
            if (!position)
                return;
            var _a = positionRef.current, clientX = _a.clientX, clientY = _a.clientY;
            // 往右移动的距离
            var offsetX = position.clientX - clientX;
            // 往下移动的距离
            var offsetY = position.clientY - clientY;
            onOffset(-offsetX, -offsetY);
        };
        var onTouchMoveEnd = function () {
            off(document.documentElement, 'touchmove', onTouchMove);
            off(document.documentElement, 'touchend', onTouchMoveEnd);
        };
        var onTouchStart = function (e) {
            if (!isScrollable)
                return;
            var position = getPosition(e);
            if (!position)
                return;
            positionRef.current = {
                clientX: position.clientX,
                clientY: position.clientY,
            };
            on(document.documentElement, 'touchmove', onTouchMove, { passive: false });
            on(window, 'touchend', onTouchMoveEnd, { passive: false });
        };
        var eventProxy = React.useRef(null);
        eventProxy.current = { onWheel: onWheel, onTouchStart: onTouchStart };
        React.useEffect(function () {
            on(headerWrapperRef.current, 'wheel', function (e) {
                eventProxy.current.onWheel(e);
            }, { passive: false });
            on(headerWrapperRef.current, 'touchstart', function (e) {
                eventProxy.current.onTouchStart(e);
            }, { passive: true });
        }, [headerWrapperRef.current]);
    }

    var __assign$q = (undefined && undefined.__assign) || function () {
        __assign$q = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$q.apply(this, arguments);
    };
    var __read$l = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var DIRECTION_VERTICAL = 'vertical';
    var ALIGN_RIGHT = 'right';
    var ALIGN_LEFT = 'left';
    var SCROLL_MAP = {
        delete: true,
        add: true,
    };
    var getHeaderStyle = function (_a) {
        var direction = _a.direction, _b = _a.align, align = _b === void 0 ? ALIGN_LEFT : _b, headerOffset = _a.headerOffset;
        var value = "translateX(" + -headerOffset + "px)";
        if (align === ALIGN_RIGHT) {
            value = "translateX(" + headerOffset + "px)";
        }
        if (direction === DIRECTION_VERTICAL) {
            value = "translateY(" + -headerOffset + "px)";
        }
        return setTransformStyle(value);
    };
    var getCurrentHeaderOffset = function (_a) {
        var direction = _a.direction, _b = _a.align, align = _b === void 0 ? ALIGN_LEFT : _b, headerDom = _a.headerDom, headerWrapperDom = _a.headerWrapperDom;
        var diffStyle = getRectDiff(headerDom, headerWrapperDom);
        if (direction === DIRECTION_VERTICAL)
            return -diffStyle.top;
        if (align === ALIGN_RIGHT)
            return diffStyle.right;
        return -diffStyle.left;
    };
    var TabHeader = React.forwardRef(function (props, ref) {
        var _a, _b;
        var ctxProps = React.useContext(TabsContext);
        var rtl = React.useContext(ConfigContext).rtl;
        var mergeProps = __assign$q(__assign$q({}, props), ctxProps);
        var _c = __read$l(DomSize(), 3), headerWrapperRef = _c[0], headerWrapperSize = _c[1], setHeaderWrapperSize = _c[2];
        var _d = __read$l(DomSize(), 3), headerRef = _d[0], headerSize = _d[1], setHeaderSize = _d[2];
        var _e = __read$l(DomSize(), 3), scrollWrapperRef = _e[0], scrollWrapperSize = _e[1], setScrollWrapperSize = _e[2];
        var _f = __read$l(DomSize(), 3), extraRef = _f[0], extraSize = _f[1], setExtraSize = _f[2];
        var _g = __read$l(DomSize(), 3), addBtnRef = _g[0], addBtnSize = _g[1], setAddenBtnSize = _g[2];
        var titleRef = React.useRef({});
        var _h = __read$l(React.useState(0), 2), headerOffset = _h[0], setHeaderOffset = _h[1];
        var _j = __read$l(React.useState(true), 2), shouldScroll = _j[0], setShouldScroll = _j[1];
        var paneChildren = mergeProps.paneChildren, editable = mergeProps.editable, prefixCls = mergeProps.prefixCls, onAddTab = mergeProps.onAddTab, direction = mergeProps.direction, _k = mergeProps.type, type = _k === void 0 ? 'line' : _k, _l = mergeProps.overflow, overflow = _l === void 0 ? 'scroll' : _l, activeTab = mergeProps.activeTab, showAddButton = mergeProps.showAddButton, _m = mergeProps.size, size = _m === void 0 ? 'default' : _m, style = mergeProps.style, tabPosition = mergeProps.tabPosition, className = mergeProps.className, extra = mergeProps.extra, animation = mergeProps.animation, icons = mergeProps.icons, deleteButton = mergeProps.deleteButton, addButton = mergeProps.addButton, renderTabTitle = mergeProps.renderTabTitle, scrollAfterEdit = mergeProps.scrollAfterEdit, _o = mergeProps.scrollPosition, scrollPosition = _o === void 0 ? 'auto' : _o;
        var scrollConfig = isObject$1(scrollAfterEdit)
            ? __assign$q(__assign$q({}, SCROLL_MAP), scrollAfterEdit) : SCROLL_MAP;
        var _p = __read$l(rtl
            ? [ALIGN_RIGHT, ALIGN_LEFT]
            : [ALIGN_LEFT, ALIGN_RIGHT], 2), left = _p[0], right = _p[1];
        var align = type === 'capsule' ? right : left;
        var isScrollable = React.useMemo(function () {
            var headerContentHeight = scrollWrapperSize.height - extraSize.height - addBtnSize.height;
            var headerContentWidth = scrollWrapperSize.width - extraSize.width - addBtnSize.width;
            var res = mergeProps.direction === 'vertical'
                ? headerContentHeight < headerSize.height
                : headerContentWidth < headerSize.width;
            return res;
        }, [mergeProps.direction, scrollWrapperSize, extraSize, headerSize, addBtnSize]);
        var updateScrollWrapperSize = function () {
            if (scrollWrapperRef.current) {
                var dom = scrollWrapperRef.current;
                setScrollWrapperSize({
                    height: dom.offsetHeight,
                    width: dom.offsetWidth,
                });
            }
        };
        var resizeCallback = function (callback) {
            return throttleByRaf(function (entry) {
                updateScrollWrapperSize();
                var dom = entry[0] && entry[0].target;
                if (dom) {
                    callback({
                        height: dom.offsetHeight,
                        width: dom.offsetWidth,
                        domRect: dom.getBoundingClientRect(),
                    });
                }
            });
        };
        var onWrapperResize = resizeCallback(setHeaderWrapperSize);
        var onHeaderResize = resizeCallback(setHeaderSize);
        var onExtraResize = resizeCallback(setExtraSize);
        var onAddBtnResize = resizeCallback(setAddenBtnSize);
        var getValidOffset = React.useCallback(function (offset) {
            var maxOffset = direction === DIRECTION_VERTICAL
                ? headerSize.height - headerWrapperSize.height
                : headerSize.width - headerWrapperSize.width;
            var validOffset = offset;
            validOffset = Math.min(maxOffset, validOffset);
            validOffset = Math.max(validOffset, 0);
            return validOffset;
        }, [direction, headerSize, headerWrapperSize]);
        var updateHeaderOffset = function (offset) {
            var nextOffset = getValidOffset(offset);
            if (nextOffset !== headerOffset) {
                setHeaderOffset(nextOffset);
            }
        };
        React.useEffect(function () {
            return function () {
                var _a, _b, _c, _d;
                (_a = onHeaderResize === null || onHeaderResize === void 0 ? void 0 : onHeaderResize.cancel) === null || _a === void 0 ? void 0 : _a.call(onHeaderResize);
                (_b = onWrapperResize === null || onWrapperResize === void 0 ? void 0 : onWrapperResize.cancel) === null || _b === void 0 ? void 0 : _b.call(onWrapperResize);
                (_c = onExtraResize === null || onExtraResize === void 0 ? void 0 : onExtraResize.cancel) === null || _c === void 0 ? void 0 : _c.call(onExtraResize);
                (_d = onAddBtnResize === null || onAddBtnResize === void 0 ? void 0 : onAddBtnResize.cancel) === null || _d === void 0 ? void 0 : _d.call(onAddBtnResize);
            };
        }, []);
        // 根据激活的 tab 更新 headerOffset，所以依赖里面不能加 headerOffset
        React.useEffect(function () {
            if (!shouldScroll) {
                setShouldScroll(true);
                return;
            }
            var getActiveTabOffset = function () {
                var currentTitleNode = titleRef.current[activeTab];
                if (!currentTitleNode || !isScrollable) {
                    return 0;
                }
                var diffStyle = getRectDiff(currentTitleNode, headerWrapperRef.current);
                var currentOffset = getCurrentHeaderOffset({
                    direction: direction,
                    align: align,
                    headerDom: headerRef.current,
                    headerWrapperDom: headerWrapperRef.current,
                });
                // 垂直方向的 offset 计算，不分type
                if (direction === 'vertical') {
                    var nextOffset_1 = currentOffset;
                    var scrollAlign_1 = scrollPosition;
                    var topOffset = currentOffset + diffStyle.top;
                    var bottomOffset = currentOffset + diffStyle.bottom;
                    if (scrollAlign_1 === 'auto') {
                        scrollAlign_1 = diffStyle.top < 0 ? 'start' : diffStyle.bottom > 0 ? 'end' : scrollPosition;
                    }
                    if (scrollAlign_1 === 'start') {
                        nextOffset_1 = topOffset;
                    }
                    else if (scrollAlign_1 === 'end') {
                        nextOffset_1 = bottomOffset;
                    }
                    else if (scrollAlign_1 === 'center') {
                        nextOffset_1 = topOffset - (diffStyle.top - diffStyle.bottom) / 2;
                    }
                    else if (isNumber(scrollAlign_1)) {
                        nextOffset_1 = Math.max(topOffset - scrollAlign_1, bottomOffset);
                    }
                    return nextOffset_1;
                }
                // 水平方向的 offset 计算，分为 capsule 和其他，因为 capsule 是右对齐
                if (align === 'right') {
                    var startOffset_1 = currentOffset - diffStyle.left;
                    var endOffset_1 = currentOffset - diffStyle.right;
                    var scrollAlign_2 = scrollPosition;
                    var nextOffset_2 = currentOffset;
                    if (scrollPosition === 'auto') {
                        scrollAlign_2 = diffStyle.left < 0 ? 'start' : diffStyle.right > 0 ? 'end' : scrollPosition;
                    }
                    if (scrollAlign_2 === 'start') {
                        nextOffset_2 = startOffset_1;
                    }
                    else if (scrollAlign_2 === 'end') {
                        nextOffset_2 = endOffset_1;
                    }
                    else if (scrollAlign_2 === 'center') {
                        nextOffset_2 = startOffset_1 + (diffStyle.left - diffStyle.right) / 2;
                    }
                    else if (isNumber(scrollAlign_2)) {
                        nextOffset_2 = Math.min(startOffset_1 + scrollAlign_2, endOffset_1);
                    }
                    return nextOffset_2;
                }
                var nextOffset = currentOffset;
                var scrollAlign = scrollPosition;
                var startOffset = currentOffset + diffStyle.left;
                var endOffset = currentOffset + diffStyle.right;
                if (scrollPosition === 'auto') {
                    scrollAlign = diffStyle.left < 0 ? 'start' : diffStyle.right > 0 ? 'end' : scrollPosition;
                }
                if (scrollAlign === 'start') {
                    nextOffset = startOffset;
                }
                else if (scrollAlign === 'end') {
                    nextOffset = endOffset;
                }
                else if (scrollAlign === 'center') {
                    nextOffset = startOffset - (diffStyle.left - diffStyle.right) / 2;
                }
                else if (isNumber(scrollAlign)) {
                    nextOffset = Math.max(startOffset - scrollAlign, endOffset);
                }
                return nextOffset;
            };
            updateScrollOffset(headerWrapperRef.current, direction);
            var offset = getActiveTabOffset();
            offset = getValidOffset(offset);
            setHeaderOffset(offset);
        }, [activeTab, direction, overflow, isScrollable, type, getValidOffset, scrollPosition]);
        var headerStyle = getHeaderStyle({
            direction: direction,
            align: align,
            headerOffset: headerOffset,
        });
        var isDropdown = isScrollable && overflow === 'dropdown' && direction !== 'vertical';
        var isScroll = isScrollable && !isDropdown;
        var isEditable = editable && (type === 'card' || type === 'card-gutter' || type === 'line');
        var handleDelete = function (child) {
            mergeProps.onDeleteTab && mergeProps.onDeleteTab(child.key);
            setShouldScroll(scrollConfig.delete);
        };
        var handleAdd = function () {
            onAddTab && onAddTab();
            setShouldScroll(scrollConfig.add);
        };
        var renderAddIcon = function (isEditable) {
            return (isEditable &&
                showAddButton && (React.createElement(ResizeObserver$1, { onResize: onAddBtnResize },
                React.createElement("div", __assign$q({ className: prefixCls + "-add-icon", "aria-label": "add tab", tabIndex: 0, role: "button", ref: addBtnRef, onClick: handleAdd }, getKeyDownEvent({ onPressEnter: handleAdd })), addButton || (React.createElement(IconHover, { prefix: prefixCls + "-add" },
                    React.createElement("span", { className: prefixCls + "-add" }, (icons === null || icons === void 0 ? void 0 : icons.add) || React.createElement(IconPlus$1, null))))))));
        };
        useHeaderScroll({
            headerWrapperRef: headerWrapperRef,
            headerOffset: headerOffset,
            align: align,
            direction: direction,
            isScrollable: isScrollable,
            onScroll: function (offset) {
                updateHeaderOffset(offset);
            },
        });
        return (React.createElement("div", { className: cs(prefixCls + "-header-nav", prefixCls + "-header-nav-" + direction, prefixCls + "-header-nav-" + tabPosition, prefixCls + "-header-size-" + size, prefixCls + "-header-nav-" + type, className), style: style, ref: ref },
            React.createElement("div", { className: cs(prefixCls + "-header-scroll", (_a = {},
                    _a[prefixCls + "-header-overflow-scroll"] = isScroll,
                    _a[prefixCls + "-header-overflow-dropdown"] = isDropdown,
                    _a)), ref: scrollWrapperRef },
                isScroll && (React.createElement(TabNavIcon$1, { iconPos: "prev", rtl: rtl, prefixCls: prefixCls, currentOffset: headerOffset, headerSize: headerSize, headerWrapperSize: headerWrapperSize, 
                    // getRef={(name) => getCalcArguments()[name]}
                    direction: direction, align: align, onChange: updateHeaderOffset })),
                React.createElement(ResizeObserver$1, { onResize: onWrapperResize },
                    React.createElement("div", { className: prefixCls + "-header-wrapper", ref: headerWrapperRef },
                        React.createElement(ResizeObserver$1, { onResize: onHeaderResize },
                            React.createElement("div", { className: cs(prefixCls + "-header", (_b = {},
                                    _b[prefixCls + "-header-no-padding"] = !props.headerPadding &&
                                        direction === 'horizontal' &&
                                        ['line', 'text'].indexOf(type) > -1,
                                    _b)), ref: headerRef, style: headerStyle },
                                paneChildren.map(function (child, index) { return (React.createElement(TabHeaderTitle$1, __assign$q({ key: index, ref: function (node) {
                                        titleRef.current[child.key] = node;
                                    }, tabKey: child.key }, child.props, { prefixCls: prefixCls, onDeleteTab: function () { return handleDelete(child); }, renderTitle: props.children || renderTabTitle, onClickTab: function () {
                                        mergeProps.onClickTab && mergeProps.onClickTab(child.key);
                                    }, isActive: activeTab === child.key, editable: isEditable && child.props.closable !== false, deleteIcon: icons === null || icons === void 0 ? void 0 : icons.delete, deleteButton: deleteButton, getIdPrefix: ctxProps.getIdPrefix, index: index }))); }),
                                type === 'line' && (React.createElement(TabInk$1, { disabled: !!paneChildren.find(function (child) {
                                        return child && child.props && child.props.disabled && child.key === activeTab;
                                    }), prefixCls: prefixCls, animation: animation, direction: direction, getTitleRef: function (key) { return titleRef.current[key]; }, activeTab: activeTab, getHeaderRef: function () { return headerRef; } })))),
                        !isScrollable && renderAddIcon(isEditable))),
                isScroll && (React.createElement(TabNavIcon$1, { prefixCls: prefixCls, rtl: rtl, currentOffset: headerOffset, headerSize: headerSize, headerWrapperSize: headerWrapperSize, direction: direction, align: align, onChange: updateHeaderOffset })),
                isDropdown && (React.createElement(DropdownIcon, { onClickTab: mergeProps.onClickTab, paneChildren: paneChildren, prefixCls: prefixCls, currentOffset: headerOffset, headerSize: headerSize, headerWrapperSize: headerWrapperSize, getTitleRef: function (key) { return titleRef.current[key]; }, direction: direction })),
                ((isEditable && isScrollable) || extra) && (React.createElement(ResizeObserver$1, { onResize: onExtraResize },
                    React.createElement("div", { className: prefixCls + "-header-extra", ref: extraRef },
                        isScrollable && renderAddIcon(isEditable),
                        extra))))));
    });
    TabHeader.displayName = 'TabHeader';
    var TabHeader$1 = TabHeader;

    function TabContent(props) {
        var _a;
        var animation = props.animation, activeTab = props.activeTab, prefixCls = props.prefixCls, paneChildren = props.paneChildren, direction = props.direction, lazyload = props.lazyload, destroyOnHide = props.destroyOnHide;
        var activeIndex = paneChildren.findIndex(function (p) { return p.key === activeTab; });
        var ctxProps = React.useContext(TabsContext);
        var rtl = React.useContext(ConfigContext).rtl;
        if (paneChildren.every(function (x) {
            return (x === null || x === void 0 ? void 0 : x.props) && (!('children' in x.props) || x.props.children === null);
        })) {
            return null;
        }
        var classNamesContentInner = cs(prefixCls + "-content-inner", (_a = {},
            _a[prefixCls + "-animation"] = animation,
            _a));
        return (React.createElement("div", { className: prefixCls + "-content " + prefixCls + "-content-" + direction },
            React.createElement("div", { className: classNamesContentInner, style: rtl ? { marginRight: "-" + activeIndex * 100 + "%" } : { marginLeft: "-" + activeIndex * 100 + "%" } }, paneChildren.map(function (child, index) {
                var _a;
                var _b = ctxProps.getIdPrefix(index), tabpane = _b.tabpane, tab = _b.tab;
                var mergedDestroyOnHide = 'destroyOnHide' in child.props ? child.props.destroyOnHide : destroyOnHide;
                var isActive = child.key === activeTab;
                return (React.createElement("div", { key: child.key, className: cs(prefixCls + "-content-item", (_a = {},
                        _a[prefixCls + "-content-item-active"] = isActive,
                        _a)), role: "tabpanel", id: tabpane, "aria-hidden": isActive ? undefined : true, tabIndex: isActive ? 0 : -1, "aria-labelledby": tab }, activeIndex !== index && mergedDestroyOnHide
                    ? null
                    : React.cloneElement(child, {
                        lazyload: lazyload,
                        isActive: isActive,
                    })));
            }))));
    }

    var __assign$p = (undefined && undefined.__assign) || function () {
        __assign$p = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$p.apply(this, arguments);
    };
    var __rest$8 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$k = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var sizeList = ['mini', 'small', 'default', 'large'];
    var getPaneChildren = function (props) {
        var children = props.children;
        var paneChildren = [];
        React.Children.forEach(children, function (child) {
            if (child && child.type && child.type.isTabPane) {
                paneChildren.push(child);
            }
        });
        return paneChildren;
    };
    var getTabPaneAnimation = function (props) {
        var direction = props.direction, tabPosition = props.tabPosition, animation = props.animation;
        if (direction === 'vertical' || tabPosition === 'left' || tabPosition === 'right') {
            return false;
        }
        if (isObject$1(animation)) {
            return 'tabPane' in animation ? animation.tabPane : false;
        }
        return animation;
    };
    var defaultProps$7 = {
        tabPosition: 'top',
        type: 'line',
        overflow: 'scroll',
        showAddButton: true,
        lazyload: true,
        headerPadding: true,
        scrollPosition: 'auto',
    };
    var TabsContext = React.createContext({});
    function Tabs(baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, ctxSize = _b.size, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$7, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Tabs);
        var paneChildren = getPaneChildren(props);
        var tabsRef = React.useRef();
        var _c = __read$k(useMergeValue((paneChildren[0] && paneChildren[0].key), {
            defaultValue: 'defaultActiveTab' in props ? props.defaultActiveTab : undefined,
            value: 'activeTab' in props ? props.activeTab : undefined,
        }), 2), activeTab = _c[0], setActiveTab = _c[1];
        var prefixCls = getPrefixCls('tabs');
        var size = props.size || (sizeList.indexOf(ctxSize) > -1 ? ctxSize : 'default');
        var animation = props.animation, className = props.className, direction = props.direction, style = props.style, type = props.type, justify = props.justify, destroyOnHide = props.destroyOnHide, lazyload = props.lazyload, onChange = props.onChange, onClickTab = props.onClickTab, onDeleteTab = props.onDeleteTab, renderTabHeader = props.renderTabHeader, rest = __rest$8(props, ["animation", "className", "direction", "style", "type", "justify", "destroyOnHide", "lazyload", "onChange", "onClickTab", "onDeleteTab", "renderTabHeader"]);
        var idPrefix = useId(prefixCls + "-");
        var tabPosition = direction === 'vertical' ? 'left' : props.tabPosition;
        var tabHeaderProps = {
            animation: isObject$1(animation) && 'inkBar' in animation ? animation.inkBar : true,
            activeTab: activeTab,
            tabPosition: tabPosition,
            direction: ['left', 'right'].indexOf(tabPosition) > -1 ? 'vertical' : 'horizontal',
            paneChildren: paneChildren,
            onClickTab: function (key) {
                isFunction$1(onClickTab) && onClickTab(key);
                if (key !== activeTab) {
                    if (!('activeTab' in props)) {
                        setActiveTab(key);
                    }
                    isFunction$1(onChange) && onChange(key);
                }
            },
            onDeleteTab: onDeleteTab,
            prefixCls: prefixCls,
        };
        React.useImperativeHandle(ref, function () { return tabsRef; }, []);
        var TabContentDom = (React.createElement(TabContent, { direction: ['left', 'right'].indexOf(tabPosition) > -1 ? 'vertical' : 'horizontal', animation: getTabPaneAnimation(props), activeTab: activeTab, paneChildren: paneChildren, prefixCls: prefixCls, destroyOnHide: destroyOnHide, lazyload: lazyload }));
        return (React.createElement("div", __assign$p({}, omit$1(rest, [
            'headerPadding',
            'tabPosition',
            'defaultActiveTab',
            'showAddButton',
            'extra',
            'onAddTab',
            'activeTab',
            'overflow',
            'editable',
            'renderTabTitle',
            'addButton',
            'deleteButton',
            'icons',
            'children',
            'size',
            'type',
            'scrollPosition',
            'offsetAlign',
        ]), { style: style, className: cs(prefixCls, prefixCls + "-" + (['left', 'right'].indexOf(tabPosition) > -1 ? 'vertical' : 'horizontal'), prefixCls + "-" + type, prefixCls + "-" + tabPosition, prefixCls + "-size-" + size, (_a = {},
                _a[prefixCls + "-justify"] = justify,
                _a[prefixCls + "-rtl"] = rtl,
                _a), className), ref: tabsRef }),
            React.createElement(TabsContext.Provider, { value: __assign$p(__assign$p({}, tabHeaderProps), { getIdPrefix: function (suffix) {
                        return {
                            tab: idPrefix && idPrefix + "-tab-" + suffix,
                            tabpane: idPrefix && idPrefix + "-panel-" + suffix,
                        };
                    } }) },
                tabPosition === 'bottom' && TabContentDom,
                isFunction$1(renderTabHeader) ? (renderTabHeader(__assign$p(__assign$p(__assign$p({}, omit$1(props, ['children', 'style', 'className'])), { size: size }), tabHeaderProps), TabHeader$1)) : (React.createElement(TabHeader$1, __assign$p({}, omit$1(props, ['children', 'style', 'className']), { size: size }))),
                tabPosition !== 'bottom' && TabContentDom)));
    }
    var ForwardRefTabs = React.forwardRef(Tabs);
    var TabsComponent = ForwardRefTabs;
    TabsComponent.displayName = 'Tabs';
    TabsComponent.TabPane = TabPane$3;
    var Tabs$1 = TabsComponent;

    function ownKeys$j(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$k(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$j(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$j(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconClockCircleComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$k(_objectSpread$k({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-clock-circle")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M24 14v10h9.5m8.5 0c0 9.941-8.059 18-18 18S6 33.941 6 24 14.059 6 24 6s18 8.059 18 18Z"
      }));
    }

    var IconClockCircle = /*#__PURE__*/React.forwardRef(IconClockCircleComponent);
    IconClockCircle.defaultProps = {
      isIcon: true
    };
    IconClockCircle.displayName = 'IconClockCircle';
    var IconClockCircle$1 = IconClockCircle;

    var __assign$o = (undefined && undefined.__assign) || function () {
        __assign$o = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$o.apply(this, arguments);
    };
    var __read$j = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$9 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    function getFormat(props) {
        return props.format || 'HH:mm:ss';
    }
    var defaultProps$6 = {
        allowClear: true,
        position: 'bl',
        format: 'HH:mm:ss',
        editable: true,
        order: true,
        scrollSticky: true,
    };
    var Picker = function (baseProps) {
        var _a = React.useContext(ConfigContext), locale = _a.locale, getPrefixCls = _a.getPrefixCls, componentConfig = _a.componentConfig, rtl = _a.rtl;
        if (rtl) {
            defaultProps$6.position = 'br';
        }
        var props = useMergeProps(baseProps, defaultProps$6, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.TimePicker);
        var _b = props.allowClear, allowClear = _b === void 0 ? true : _b, className = props.className, disableConfirm = props.disableConfirm, style = props.style, placeholder = props.placeholder, getPopupContainer = props.getPopupContainer, disabled = props.disabled, position = props.position, isRangePicker = props.isRangePicker, picker = props.picker, error = props.error, triggerElement = props.triggerElement, triggerProps = props.triggerProps, propsValue = props.value, onChange = props.onChange, icons = props.icons, size = props.size, editable = props.editable, unmountOnExit = props.unmountOnExit, order = props.order, utcOffset = props.utcOffset, timezone = props.timezone;
        var format = getFormat(props);
        var prefixCls = getPrefixCls('timepicker');
        function getDefaultValue() {
            var value;
            if (props.value) {
                value = getDayjsValue(props.value, format, utcOffset, timezone);
            }
            else if (props.defaultValue) {
                value = getDayjsValue(props.defaultValue, format, utcOffset, timezone);
            }
            return value;
        }
        var _c = __read$j(React.useState(false), 2), popupVisible = _c[0], setPopupVisible = _c[1];
        var _d = __read$j(React.useState(getDefaultValue()), 2), value = _d[0], setValue = _d[1];
        var _e = __read$j(React.useState(), 2), valueShow = _e[0], setValueShow = _e[1];
        var _f = __read$j(React.useState(), 2), inputValue = _f[0], setInputValue = _f[1];
        var _g = __read$j(React.useState(0), 2), focusedInputIndex = _g[0], setFocusedInputIndex = _g[1];
        // controlled mode / uncontrolled mode
        var mergedValue = 'value' in props ? getDayjsValue(propsValue, format, utcOffset, timezone) : value;
        var mergedPopupVisible = 'popupVisible' in props ? props.popupVisible : popupVisible;
        var previousUtcOffset = usePrevious(utcOffset);
        var previousTimezone = usePrevious(timezone);
        // when timezone or utcOffset change changed
        useUpdate(function () {
            if (value && (previousUtcOffset !== utcOffset || timezone !== previousTimezone)) {
                var localValue = isArray$1(value)
                    ? value.map(function (v) { return toLocal(v, previousUtcOffset, previousTimezone); })
                    : toLocal(value, previousUtcOffset, previousTimezone);
                var zoneValue = isArray$1(localValue)
                    ? localValue.map(function (v) { return toTimezone(v, utcOffset, timezone); })
                    : toTimezone(localValue, utcOffset, timezone);
                setValue(zoneValue);
            }
        }, [utcOffset, previousUtcOffset, timezone, previousTimezone]);
        var refInput = React.useRef(null);
        function focusInput(index) {
            refInput.current && refInput.current.focus && refInput.current.focus(index);
        }
        function changeFocusedInputIndex(index) {
            setFocusedInputIndex(index);
            setTimeout(function () { return focusInput(index); });
        }
        function onVisibleChange(visible) {
            if (visible) {
                setOpen(visible, function () {
                    setTimeout(function () { return focusInput(); });
                });
            }
            else {
                setOpen(false);
            }
        }
        function setOpen(visible, callback) {
            setPopupVisible(visible);
            setInputValue(undefined);
            callback && callback();
            if (!visible) {
                setValueShow(undefined);
            }
        }
        function onConfirmValue(vs) {
            var newValue = isRangePicker && order && isArray$1(vs)
                ? getSortedDayjsArray(vs.map(function (v) { return getFormatTime(v); }))
                : vs;
            setValue(newValue);
            setValueShow(undefined);
            setInputValue(undefined);
            onHandleChange(newValue);
            if (!disableConfirm) {
                setOpen(false);
            }
        }
        function onHandleChange(vs) {
            if (isArray$1(vs) && isDayjsArrayChange(mergedValue, vs)) {
                onChange &&
                    onChange(vs.map(function (t) { return toLocal(t, utcOffset, timezone).format(format); }), vs.map(function (t) { return toLocal(t, utcOffset, timezone); }));
            }
            if (isDayjs(vs) && isDayjsChange(mergedValue, vs)) {
                onChange &&
                    onChange(toLocal(vs, utcOffset, timezone).format(format), toLocal(vs, utcOffset, timezone));
            }
        }
        function renderPopup(panelOnly) {
            var vs = isRangePicker
                ? isArray$1(valueShow) && valueShow.length
                    ? valueShow
                    : mergedValue
                : valueShow || mergedValue;
            return (React.createElement("div", { className: cs(prefixCls + "-container", panelOnly ? className : ''), style: panelOnly ? style : {}, onClick: function () { return focusInput(); } }, React.cloneElement(picker, __assign$o(__assign$o({}, props), { format: format, inputValue: inputValue, setInputValue: setInputValue, onConfirmValue: onConfirmValue, setValueShow: setValueShow, valueShow: vs, value: mergedValue, popupVisible: mergedPopupVisible, focusedInputIndex: focusedInputIndex, changeFocusedInputIndex: changeFocusedInputIndex }))));
        }
        function onChangeInput(e) {
            var newInputValue = e.target.value;
            if (!popupVisible) {
                setPopupVisible(true);
            }
            setInputValue(newInputValue);
            confirmInputValue(newInputValue);
        }
        function confirmInputValue(newInputValue) {
            var newInputDayjs = getDayjsValue(newInputValue, format);
            if (isRangePicker) {
                var newValueShow = __spreadArray$9([], __read$j((isArray$1(valueShow) ? valueShow : value || [])), false);
                if (isValidTimeString(newInputValue, format)) {
                    newValueShow[focusedInputIndex] = newInputDayjs;
                    var localDayjsArray = newValueShow.map(function (nv) { return toLocal(nv, utcOffset, timezone); });
                    props.onSelect &&
                        props.onSelect(localDayjsArray.map(function (la) { return la && la.format(format); }), localDayjsArray);
                    setValueShow(newValueShow);
                    setInputValue(undefined);
                }
            }
            else if (isValidTimeString(newInputValue, format)) {
                var localDayjs = toLocal(newInputDayjs, utcOffset, timezone);
                props.onSelect && props.onSelect(localDayjs.format(format), localDayjs);
                setValueShow(newInputDayjs);
                setInputValue(undefined);
            }
        }
        function onPressEnter() {
            if (isRangePicker) {
                if (isArray$1(valueShow) && valueShow.length) {
                    if (inputValue && !isValidTimeString(inputValue, format)) {
                        setOpen(false);
                    }
                    else if (valueShow[0] === undefined || valueShow[1] === undefined) {
                        changeFocusedInputIndex(focusedInputIndex === 0 ? 1 : 0);
                    }
                    else if (valueShow.length === 2) {
                        onConfirmValue(valueShow);
                    }
                }
                else {
                    setOpen(false);
                }
            }
            else {
                onConfirmValue(valueShow || mergedValue);
            }
        }
        function onClear(e) {
            e.stopPropagation();
            onConfirmValue(undefined);
            onChange && onChange(undefined, undefined);
            props.onClear && props.onClear();
        }
        var rangePickerPlaceholder = isRangePicker && isArray$1(placeholder) ? placeholder : locale.TimePicker.placeholders;
        var inputPlaceHolder = placeholder || locale.TimePicker.placeholder;
        var suffixIcon = (icons && icons.inputSuffix) || React.createElement(IconClockCircle$1, null);
        var baseInputProps = __assign$o({ style: style, className: className, popupVisible: mergedPopupVisible, format: format, disabled: disabled, error: error, size: size, onPressEnter: onPressEnter, onClear: onClear, suffixIcon: suffixIcon, editable: editable, allowClear: allowClear, prefix: props.prefix }, pickDataAttributes(props));
        return (React.createElement(PickerContext.Provider, { value: { utcOffset: utcOffset, timezone: timezone } }, triggerElement === null ? (renderPopup(true)) : (React.createElement(Trigger$1, __assign$o({ popup: function () { return renderPopup(); }, trigger: "click", clickToClose: false, position: position, disabled: disabled, popupAlign: { bottom: 4 }, getPopupContainer: getPopupContainer, onVisibleChange: onVisibleChange, popupVisible: mergedPopupVisible, classNames: "slideDynamicOrigin", unmountOnExit: !!unmountOnExit }, triggerProps), triggerElement ||
            (isRangePicker ? (React.createElement(InputRange, __assign$o({}, baseInputProps, { ref: refInput, placeholder: rangePickerPlaceholder, value: (isArray$1(valueShow) && valueShow.length ? valueShow : mergedValue), onChange: onChangeInput, inputValue: inputValue, changeFocusedInputIndex: changeFocusedInputIndex, focusedInputIndex: focusedInputIndex }))) : (React.createElement(Input$2, __assign$o({}, baseInputProps, { ref: refInput, placeholder: inputPlaceHolder, value: (valueShow || mergedValue), inputValue: inputValue, onChange: onChangeInput }))))))));
    };
    var Picker$1 = Picker;

    var __assign$n = (undefined && undefined.__assign) || function () {
        __assign$n = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$n.apply(this, arguments);
    };
    var __rest$7 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function RangePicker$1(props) {
        var _a = props.format, format = _a === void 0 ? 'HH:mm:ss' : _a, onSelect = props.onSelect, focusedInputIndex = props.focusedInputIndex, changeFocusedInputIndex = props.changeFocusedInputIndex, popupVisible = props.popupVisible, onConfirmValue = props.onConfirmValue, _b = props.valueShow, valueShow = _b === void 0 ? [] : _b, setValueShow = props.setValueShow, disableConfirm = props.disableConfirm, rest = __rest$7(props, ["format", "onSelect", "focusedInputIndex", "changeFocusedInputIndex", "popupVisible", "onConfirmValue", "valueShow", "setValueShow", "disableConfirm"]);
        var _c = React.useContext(PickerContext), utcOffset = _c.utcOffset, timezone = _c.timezone;
        function onSelectTime(_, time) {
            var zoneValue = valueShow.slice();
            var v = valueShow.map(function (a) { return toLocal(a, utcOffset, timezone); });
            zoneValue[focusedInputIndex] = toTimezone(time, utcOffset, timezone);
            v[focusedInputIndex] = time;
            onSelect &&
                onSelect(v.map(function (t) { return t.format(format); }), v);
            setValueShow(zoneValue);
            if (disableConfirm && isArray$1(v) && isDayjs(v[0]) && isDayjs(v[1])) {
                onConfirmValue(zoneValue);
            }
        }
        function onConfirmValueInner() {
            if (valueShow.length && (valueShow[0] === undefined || valueShow[1] === undefined)) {
                changeFocusedInputIndex(focusedInputIndex === 0 ? 1 : 0);
            }
            else {
                onConfirmValue(valueShow);
            }
        }
        var timepickerProps = omit$1(rest, ['defaultValue', 'placeholder', 'value', 'onChange']);
        var currentShowValue = valueShow[focusedInputIndex];
        return (React.createElement(TimePicker$3, __assign$n({ onSelect: onSelectTime, value: currentShowValue, format: format, isRangePicker: true, onConfirmValue: onConfirmValueInner, confirmBtnDisabled: !isDayjs(currentShowValue), valueShow: currentShowValue, popupVisible: popupVisible, disableConfirm: disableConfirm }, timepickerProps)));
    }

    var __extends$2 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$m = (undefined && undefined.__assign) || function () {
        __assign$m = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$m.apply(this, arguments);
    };
    function wrapper(picker, displayName, type) {
        var _a;
        return _a = /** @class */ (function (_super) {
                __extends$2(PickerWrapper, _super);
                function PickerWrapper() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                PickerWrapper.prototype.render = function () {
                    return React.createElement(Picker$1, __assign$m({}, this.props, { picker: picker, isRangePicker: type === 'range' }));
                };
                return PickerWrapper;
            }(React.Component)),
            _a.displayName = displayName,
            _a;
    }
    var TimePicker$2 = wrapper(React.createElement(TimePicker$3, null), 'TimePicker');
    var RangePicker = wrapper(React.createElement(RangePicker$1, null), 'TimePickerRangePicker', 'range');
    Object.assign(TimePicker$2, { RangePicker: RangePicker });
    var ArcoTimePicker = TimePicker$2;

    var __assign$l = (undefined && undefined.__assign) || function () {
        __assign$l = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$l.apply(this, arguments);
    };
    var __read$i = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    function TransferItem(props) {
        var _a;
        var className = props.className, prefixCls = props.prefixCls, render = props.render, item = props.item, selectedKeys = props.selectedKeys, disabled = props.disabled, draggable = props.draggable, droppable = props.droppable, allowClear = props.allowClear, onItemSelect = props.onItemSelect, onItemRemove = props.onItemRemove, onDragStart = props.onDragStart, onDragEnd = props.onDragEnd, onDragLeave = props.onDragLeave, onDragOver = props.onDragOver, onDrop = props.onDrop;
        var getKeyboardEvents = useKeyboardEvent();
        var baseClassName = prefixCls + "-view-item";
        var refItem = React.useRef(null);
        var refDraggedTimer = React.useRef(null);
        var _b = __read$i(React.useState('none'), 2), dragStatus = _b[0], setDragStatus = _b[1];
        var _c = __read$i(React.useState(false), 2), dragOver = _c[0], setDragOver = _c[1];
        var _d = __read$i(React.useState(0), 2), dragPosition = _d[0], setDragPosition = _d[1];
        var _disabled = disabled || item.disabled;
        var _draggable = draggable && !_disabled;
        var checked = selectedKeys.indexOf(item.key) > -1;
        var itemContent = render ? render(item) : item.value;
        React.useEffect(function () {
            return function () {
                refDraggedTimer.current && clearTimeout(refDraggedTimer.current);
            };
        }, []);
        React.useEffect(function () {
            if (dragStatus === 'dragged') {
                refDraggedTimer.current = setTimeout(function () { return setDragStatus('none'); }, 1000);
            }
        }, [dragStatus]);
        return (React.createElement("li", { key: item.key, ref: refItem, className: cs(baseClassName, (_a = {},
                _a[baseClassName + "-disabled"] = _disabled,
                _a[baseClassName + "-draggable"] = _draggable,
                _a[baseClassName + "-gap-top"] = dragOver && dragPosition < 0,
                _a[baseClassName + "-gap-bottom"] = dragOver && dragPosition > 0,
                _a[baseClassName + "-" + dragStatus] = dragStatus !== 'none',
                _a), className), draggable: _draggable, onDragStart: function (e) {
                e.stopPropagation();
                setDragStatus('dragging');
                onDragStart && onDragStart(e, item);
                try {
                    // ie throw error
                    // firefox-need-it
                    e.dataTransfer.setData('text/plain', '');
                }
                catch (error) {
                    // empty
                }
            }, onDragEnd: function (e) {
                e.stopPropagation();
                setDragOver(false);
                setDragStatus('dragged');
                onDragEnd && onDragEnd(e, item);
            }, onDragOver: function (e) {
                if (droppable) {
                    e.stopPropagation();
                    e.preventDefault();
                    var rect = refItem.current.getBoundingClientRect();
                    var threshold = window.pageYOffset + rect.top + rect.height / 2;
                    var position = e.pageY > threshold ? 1 : -1;
                    setDragOver(true);
                    setDragPosition(position);
                    onDragOver && onDragOver(e, item);
                }
            }, onDragLeave: function (e) {
                if (droppable) {
                    e.stopPropagation();
                    setDragOver(false);
                    onDragLeave && onDragLeave(e, item);
                }
            }, onDrop: function (e) {
                if (droppable) {
                    e.stopPropagation();
                    e.preventDefault();
                    setDragOver(false);
                    setDragPosition(0);
                    setDragStatus('none');
                    onDrop && onDrop(e, item, dragPosition);
                }
            } },
            draggable ? (React.createElement(IconHover, { className: baseClassName + "-icon-drag" },
                React.createElement(IconDragDotVertical$1, null))) : null,
            allowClear ? (React.createElement(React.Fragment, null,
                React.createElement("span", { className: baseClassName + "-content" }, itemContent),
                !_disabled && (React.createElement(IconHover, __assign$l({ className: baseClassName + "-icon-remove", onClick: function () { return onItemRemove(item.key); }, tabIndex: 0, role: "button" }, getKeyboardEvents({
                    onPressEnter: function () { return onItemRemove(item.key); },
                })),
                    React.createElement(IconClose$1, null))))) : (React.createElement(Checkbox$2, { className: baseClassName + "-content", checked: checked, disabled: _disabled, onChange: function (checked) { return onItemSelect(item.key, checked); } }, itemContent))));
    }

    function ownKeys$i(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$j(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$i(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$i(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconDeleteComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$j(_objectSpread$j({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-delete")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M5 11h5.5m0 0v29a1 1 0 0 0 1 1h25a1 1 0 0 0 1-1V11m-27 0H16m21.5 0H43m-5.5 0H32m-16 0V7h16v4m-16 0h16M20 18v15m8-15v15"
      }));
    }

    var IconDelete = /*#__PURE__*/React.forwardRef(IconDeleteComponent);
    IconDelete.defaultProps = {
      isIcon: true
    };
    IconDelete.displayName = 'IconDelete';
    var IconDelete$1 = IconDelete;

    var __assign$k = (undefined && undefined.__assign) || function () {
        __assign$k = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$k.apply(this, arguments);
    };
    var __read$h = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$8 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var TransferList = function (props, ref) {
        var getKeyboardEvents = useKeyboardEvent();
        var style = props.style, prefixCls = props.prefixCls, className = props.className, listType = props.listType, dataSource = props.dataSource, _a = props.selectedKeys, selectedKeys = _a === void 0 ? [] : _a, validKeys = props.validKeys, selectedDisabledKeys = props.selectedDisabledKeys, _b = props.title, title = _b === void 0 ? '' : _b, disabled = props.disabled, draggable = props.draggable, allowClear = props.allowClear, showSearch = props.showSearch, showFooter = props.showFooter, searchPlaceholder = props.searchPlaceholder, render = props.render, renderList = props.renderList, pagination = props.pagination, handleSelect = props.handleSelect, handleRemove = props.handleRemove, filterOption = props.filterOption, renderHeaderUnit = props.renderHeaderUnit, virtualListProps = props.virtualListProps, onSearch = props.onSearch, onResetData = props.onResetData, onDragStart = props.onDragStart, onDragEnd = props.onDragEnd, onDragLeave = props.onDragLeave, onDragOver = props.onDragOver, onDrop = props.onDrop;
        var baseClassName = prefixCls + "-view";
        var locale = React.useContext(ConfigContext).locale;
        var _c = __read$h(React.useState(null), 2), dragItem = _c[0], setDragItem = _c[1];
        var _d = __read$h(React.useState(''), 2), filterText = _d[0], setFilterText = _d[1];
        var _e = __read$h(React.useState(dataSource), 2), itemsToRender = _e[0], setItemsToRender = _e[1];
        React.useEffect(function () {
            setItemsToRender(filterText ? dataSource.filter(function (item) { return filterOption(filterText, item); }) : dataSource);
        }, [dataSource, filterText, filterOption]);
        // 处理单个条目复选框改变
        var handleItemChecked = function (key, checked) {
            return handleSelect(checked ? selectedKeys.concat(key) : selectedKeys.filter(function (_key) { return _key !== key; }));
        };
        // 处理全选复选框改变，始终避免操作已禁用的选项
        var handleItemAllChecked = function (keys, checked) {
            return handleSelect(checked
                ? __spreadArray$8([], __read$h(new Set(selectedKeys.concat(keys))), false) : selectedKeys.filter(function (selectedKey) { return keys.indexOf(selectedKey) === -1; }));
        };
        var clearItems = function (keys) { return function () { return handleRemove(keys); }; };
        var searchInput = (React.createElement(Input$4, __assign$k({ size: "small", disabled: disabled, placeholder: searchPlaceholder, suffix: React.createElement(IconSearch$1, null) }, (isObject$1(showSearch) ? showSearch : {}), { onChange: function (value, event) {
                setFilterText(value);
                onSearch && onSearch(value);
                isObject$1(showSearch) && showSearch.onChange && showSearch.onChange(value, event);
            } })));
        var renderHeader = function () {
            var countSelected = selectedKeys.length;
            var countRendered = itemsToRender.length;
            var keysCanBeChecked = filterText
                ? validKeys.filter(function (validKey) { return itemsToRender.find(function (_a) {
                    var key = _a.key;
                    return key === validKey;
                }); })
                : validKeys;
            var countCheckedOfRenderedItems = keysCanBeChecked.filter(function (key) { return selectedKeys.indexOf(key) > -1; }).length;
            var checkboxProps = {
                disabled: disabled,
                checked: countCheckedOfRenderedItems > 0 && countCheckedOfRenderedItems === keysCanBeChecked.length,
                indeterminate: countCheckedOfRenderedItems > 0 && countCheckedOfRenderedItems < keysCanBeChecked.length,
                onChange: function (checked) { return handleItemAllChecked(keysCanBeChecked, checked); },
            };
            if (typeof title === 'function') {
                return title({
                    countTotal: countRendered,
                    countSelected: countSelected,
                    clear: clearItems(keysCanBeChecked),
                    checkbox: React.createElement(Checkbox$2, __assign$k({}, checkboxProps)),
                    searchInput: searchInput,
                });
            }
            var eleHeaderUnit = (React.createElement("span", { className: baseClassName + "-header-unit" }, renderHeaderUnit(countSelected, countRendered)));
            return allowClear ? (React.createElement(React.Fragment, null,
                React.createElement("span", { className: baseClassName + "-header-title" }, title),
                eleHeaderUnit,
                !disabled && validKeys.length ? (React.createElement(IconHover, __assign$k({ className: baseClassName + "-icon-clear", onClick: clearItems(keysCanBeChecked), tabIndex: 0, role: "button" }, getKeyboardEvents({
                    onPressEnter: clearItems(keysCanBeChecked),
                })),
                    React.createElement(IconDelete$1, null))) : null)) : (React.createElement(React.Fragment, null,
                React.createElement("span", { className: baseClassName + "-header-title" },
                    React.createElement(Checkbox$2, __assign$k({}, checkboxProps), title)),
                eleHeaderUnit));
        };
        var renderListBody = function () {
            var customList = renderList &&
                renderList({
                    listType: listType,
                    disabled: disabled,
                    selectedKeys: selectedKeys,
                    validKeys: validKeys,
                    selectedDisabledKeys: selectedDisabledKeys,
                    filteredItems: itemsToRender,
                    onItemRemove: function (key) { return handleRemove([key]); },
                    onItemSelect: handleItemChecked,
                    onItemSelectAll: function (keys, checked) {
                        handleSelect(checked ? keys.concat(selectedDisabledKeys) : __spreadArray$8([], __read$h(selectedDisabledKeys), false));
                    },
                });
            return customList ? (React.createElement("div", { className: baseClassName + "-custom-list" }, customList)) : (React.createElement(List$1, { bordered: false, paginationInFooter: true, virtualListProps: virtualListProps, wrapperClassName: baseClassName + "-list", dataSource: itemsToRender, pagination: pagination
                    ? __assign$k({ simple: true, size: 'mini' }, (typeof pagination === 'object' ? pagination : {})) : undefined, footer: showFooter === true ? (React.createElement(Button$3, { size: "mini", disabled: disabled, onClick: onResetData }, locale.Transfer.resetText)) : (showFooter || null), render: function (item) { return (React.createElement(TransferItem, { key: item.key, prefixCls: prefixCls, item: item, disabled: disabled, draggable: draggable, droppable: !!dragItem, allowClear: allowClear, render: render, selectedKeys: selectedKeys, onItemSelect: function (key, selected) { return handleItemChecked(key, selected); }, onItemRemove: function (key) { return handleRemove([key]); }, onDragStart: function (e, item) {
                        setDragItem(item);
                        onDragStart && onDragStart(e, item);
                    }, onDragEnd: function (e, item) {
                        setDragItem(null);
                        onDragEnd && onDragEnd(e, item);
                    }, onDragLeave: function (e, item) { return onDragLeave && onDragLeave(e, item); }, onDragOver: function (e, item) { return onDragOver && onDragOver(e, item); }, onDrop: function (e, dropItem, dropPosition) {
                        if (onDrop && dragItem && dragItem.key !== dropItem.key) {
                            onDrop({
                                e: e,
                                dropItem: dropItem,
                                dropPosition: dropPosition,
                                dragItem: dragItem,
                            });
                        }
                    } })); } }));
        };
        return (React.createElement("div", { ref: ref, className: cs(baseClassName, className), style: style },
            React.createElement("div", { className: baseClassName + "-header" }, renderHeader()),
            showSearch && React.createElement("div", { className: baseClassName + "-search" }, searchInput),
            renderListBody()));
    };
    var TransferListComponent = React.forwardRef(TransferList);
    var TransferList$1 = TransferListComponent;

    var __assign$j = (undefined && undefined.__assign) || function () {
        __assign$j = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$j.apply(this, arguments);
    };
    var __rest$6 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$g = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var defaultProps$5 = {
        titleTexts: ['Source', 'Target'],
        defaultSelectedKeys: [],
        defaultTargetKeys: [],
        dataSource: [],
        filterOption: function (inputValue, item) {
            return typeof (item === null || item === void 0 ? void 0 : item.value) === 'string' && item.value.indexOf(inputValue) !== -1;
        },
    };
    function Transfer$1(baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$5, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Transfer);
        var transferPrefixCls = props.prefixCls, style = props.style, className = props.className, children = props.children, dataSource = props.dataSource, defaultTargetKeys = props.defaultTargetKeys, defaultSelectedKeys = props.defaultSelectedKeys, propTargetKeys = props.targetKeys, propSelectedKeys = props.selectedKeys, oneWay = props.oneWay, simple = props.simple, disabled = props.disabled, titleTexts = props.titleTexts, operationTexts = props.operationTexts, operationStyle = props.operationStyle, onSearch = props.onSearch, onChange = props.onChange, onSelectChange = props.onSelectChange, restProps = __rest$6(props, ["prefixCls", "style", "className", "children", "dataSource", "defaultTargetKeys", "defaultSelectedKeys", "targetKeys", "selectedKeys", "oneWay", "simple", "disabled", "titleTexts", "operationTexts", "operationStyle", "onSearch", "onChange", "onSelectChange"]);
        var prefixCls = transferPrefixCls || getPrefixCls('transfer');
        var mergedOneWay = !!(simple || oneWay);
        var _c = __read$g(useMergeValue([], {
            value: propTargetKeys,
            defaultValue: simple ? defaultTargetKeys.concat(defaultSelectedKeys) : defaultTargetKeys,
        }), 2), targetKeys = _c[0], setTargetKeys = _c[1];
        var _d = __read$g(useMergeValue([], {
            value: propSelectedKeys,
            defaultValue: simple ? [] : defaultSelectedKeys,
        }), 2), selectedKeys = _d[0], setSelectedKeys = _d[1];
        // 严格控制 TransferList 的 dataSource 的引用地址改变
        var _e = __read$g(React.useMemo(function () { return [[], []]; }, [dataSource, targetKeys]), 2), sourceListDataSource = _e[0], targetListDataSource = _e[1];
        var _f = __read$g(React.useMemo(function () {
            // 每次重新计算时，清空数组
            sourceListDataSource.length = 0;
            targetListDataSource.length = 0;
            // 空间换取时间，尽量减少数组遍历的次数
            var sourceInfo = {
                dataSource: sourceListDataSource,
                selectedKeys: [],
                validKeys: [],
                selectedValidKeys: [],
                selectedDisabledKeys: [],
            };
            var targetInfo = {
                dataSource: targetListDataSource,
                selectedKeys: [],
                validKeys: [],
                selectedValidKeys: [],
                selectedDisabledKeys: [],
            };
            dataSource.forEach(function (item) {
                var info = targetKeys.indexOf(item.key) > -1 ? targetInfo : sourceInfo;
                if (!item.disabled) {
                    info.validKeys.push(item.key);
                }
                if (selectedKeys.indexOf(item.key) > -1) {
                    info.selectedKeys.push(item.key);
                    if (item.disabled) {
                        info.selectedDisabledKeys.push(item.key);
                    }
                    else {
                        info.selectedValidKeys.push(item.key);
                    }
                }
                info.dataSource.push(item);
            });
            // 简单模式下，在左侧列表保留被选中的项目
            if (isObject$1(simple) && simple.retainSelectedItems) {
                Object.entries(sourceInfo).forEach(function (_a) {
                    var _b = __read$g(_a, 2), key = _b[0], value = _b[1];
                    if (Array.isArray(value)) {
                        sourceInfo[key] = value.concat(targetInfo[key]);
                    }
                });
                sourceInfo.dataSource = dataSource.slice();
                sourceInfo.selectedKeys = targetKeys.slice();
            }
            return [sourceInfo, targetInfo];
        }, [dataSource, targetKeys, selectedKeys, simple]), 2), sourceInfo = _f[0], targetInfo = _f[1];
        // 移动选项
        var moveTo = function (to, moveKeys) {
            if (moveKeys === void 0) { moveKeys = null; }
            if (Array.isArray(moveKeys) && moveKeys.length === 0) {
                return;
            }
            // 只移动未被禁用的选中项目
            moveKeys =
                moveKeys || (to === 'target' ? sourceInfo.selectedValidKeys : targetInfo.selectedValidKeys);
            var newTargetKeys = to === 'target'
                ? targetKeys.concat(moveKeys)
                : targetKeys.filter(function (key) { return moveKeys.indexOf(key) === -1; });
            // 移动之后取消所有非禁用选项的选中状态
            setSelectedKeys(sourceInfo.selectedDisabledKeys.concat(targetInfo.selectedDisabledKeys));
            setTargetKeys(newTargetKeys);
            onChange && onChange(newTargetKeys, to, moveKeys);
        };
        // 单选 或者 全选
        var handleSelect = function (keys, listType) {
            if (listType === 'source') {
                // 简单模式在选中之后直接移动
                if (simple) {
                    var keysAdded = keys.filter(function (k) { return sourceInfo.selectedKeys.indexOf(k) === -1; });
                    var keysRemoved = sourceInfo.selectedKeys.filter(function (k) { return keys.indexOf(k) === -1; });
                    moveTo('target', keysAdded);
                    moveTo('source', keysRemoved);
                }
                else {
                    setSelectedKeys(keys.concat(targetInfo.selectedKeys));
                    onSelectChange && onSelectChange(keys, targetInfo.selectedKeys);
                }
            }
            else {
                setSelectedKeys(sourceInfo.selectedKeys.concat(keys));
                onSelectChange && onSelectChange(sourceInfo.selectedKeys, keys);
            }
        };
        var renderOperations = function () {
            var _a;
            var leftActive = targetInfo.selectedKeys.length > 0;
            var rightActive = sourceInfo.selectedKeys.length > 0;
            var buttons = mergedOneWay ? ['target'] : ['target', 'source'];
            return simple ? null : (React.createElement("div", { style: operationStyle, className: cs(prefixCls + "-operations", (_a = {},
                    _a[prefixCls + "-operations-words"] = operationTexts,
                    _a)) }, buttons.map(function (to, index) {
                var Icon;
                var _disabled;
                if (to === 'source') {
                    Icon = IconLeft$1;
                    _disabled = disabled || !leftActive;
                }
                else {
                    Icon = IconRight$1;
                    _disabled = disabled || !rightActive;
                }
                return (React.createElement(Button$3, { key: index, tabIndex: _disabled ? -1 : undefined, "aria-label": "move selected " + (to === 'target' ? 'right' : 'left'), type: "secondary", size: "small", shape: "round", disabled: _disabled, onClick: function () { return moveTo(to); }, icon: React.createElement(Icon, null) }, operationTexts && operationTexts[index]));
            })));
        };
        var renderList = function (listType) {
            var info = listType === 'source' ? sourceInfo : targetInfo;
            var isTarget = listType === 'target';
            var usedRestProps = __assign$j({}, restProps);
            Object.entries(usedRestProps).forEach(function (_a) {
                var _b = __read$g(_a, 2), key = _b[0], value = _b[1];
                var propertiesCanBeArray = [
                    'searchPlaceholder',
                    'showSearch',
                    'showFooter',
                    'pagination',
                    'listStyle',
                ];
                if (propertiesCanBeArray.indexOf(key) > -1) {
                    usedRestProps[key] = Array.isArray(value) ? value[listType === 'source' ? 0 : 1] : value;
                }
            });
            return (React.createElement(TransferList$1, __assign$j({}, info, usedRestProps, { style: usedRestProps.listStyle, prefixCls: prefixCls, className: prefixCls + "-view-" + listType, listType: listType, title: titleTexts[isTarget ? 1 : 0], disabled: disabled, allowClear: isTarget && mergedOneWay, renderList: children, handleSelect: function (newSelectKeys) { return handleSelect(newSelectKeys, listType); }, handleRemove: function (removeKeys) { return moveTo(isTarget ? 'source' : 'target', removeKeys); }, onSearch: function (value) { return onSearch && onSearch(value, listType); }, renderHeaderUnit: function (countSelected, countAll) {
                    return "" + (mergedOneWay ? '' : countSelected + " / ") + countAll;
                } })));
        };
        return (React.createElement("div", __assign$j({}, pickDataAttributes(props), { ref: ref, className: cs(prefixCls, (_a = {},
                _a[prefixCls + "-simple"] = simple,
                _a[prefixCls + "-disabled"] = disabled,
                _a[prefixCls + "-rtl"] = rtl,
                _a), className), style: style }),
            renderList('source'),
            renderOperations(),
            renderList('target')));
    }
    var TransferComponent = React.forwardRef(Transfer$1);
    TransferComponent.displayName = 'Transfer';
    var ArcoTransfer = TransferComponent;

    function ownKeys$h(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$i(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$h(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$h(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconFileComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$i(_objectSpread$i({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-file")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M16 21h16m-16 8h10m11 13H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2Z"
      }));
    }

    var IconFile = /*#__PURE__*/React.forwardRef(IconFileComponent);
    IconFile.defaultProps = {
      isIcon: true
    };
    IconFile.displayName = 'IconFile';
    var IconFile$1 = IconFile;

    var TreeContext = React.createContext({});

    /**
     * 该组件用来切换tree 展开收起时的动画
     */
    var __assign$i = (undefined && undefined.__assign) || function () {
        __assign$i = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$i.apply(this, arguments);
    };
    function getKey$1(option) {
        return option.key || option._key;
    }
    var TreeAnimation = function (props) {
        var _a;
        var treeContext = React.useContext(TreeContext);
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var prefixCls = getPrefixCls('tree-node');
        var _b = treeContext.getTreeState(), expandedKeys = _b.expandedKeys, currentExpandKeys = _b.currentExpandKeys;
        var expanded = props.expanded;
        React.useEffect(function () {
            return function () {
                treeContext.onExpandEnd && treeContext.onExpandEnd(props._key);
            };
        }, []);
        var childrenPropsList = React.useMemo(function () {
            var result = [];
            var loop = function (list) {
                list.forEach(function (item) {
                    var data = treeContext.getFieldInfo(item);
                    result.push(data);
                    if (data.children && data.children.length) {
                        loop(data.children);
                    }
                });
            };
            loop(props.childrenData || []);
            return result;
        }, [props.childrenData]);
        var filtedData = React.useMemo(function () {
            var result = [];
            if (childrenPropsList.length) {
                var expandedKeysSet_1 = new Set(expandedKeys || []);
                childrenPropsList.forEach(function (data) {
                    var _a;
                    var isShow;
                    var itemProps = __assign$i({}, treeContext.key2nodeProps[data.key]);
                    if (expanded) {
                        // 只有在每一个父节点都是展开状态时，自己才会展示出来
                        isShow =
                            itemProps.parentKey === props._key ||
                                ((_a = itemProps.pathParentKeys) === null || _a === void 0 ? void 0 : _a.every(function (key) {
                                    return expandedKeysSet_1.has(key);
                                }));
                    }
                    else if (itemProps.pathParentKeys) {
                        // 收起时，只有在props._key 对应的位置之后的所有的自己的父节点都是展开状态，才会展示自己
                        var index = itemProps.pathParentKeys.indexOf(props._key);
                        isShow = itemProps.pathParentKeys.slice(index + 1).every(function (key) {
                            return expandedKeysSet_1.has(key);
                        });
                    }
                    if (isShow) {
                        result.push(__assign$i(__assign$i(__assign$i({}, itemProps), treeContext.getNodeProps(itemProps, expandedKeysSet_1)), { key: data.key }));
                    }
                });
            }
            return result;
        }, [childrenPropsList, props._key, expanded]);
        var realHeight = (_a = treeContext.virtualListProps) === null || _a === void 0 ? void 0 : _a.height;
        realHeight = isNumber(realHeight) ? realHeight : 0;
        React.useEffect(function () {
            // node set loadingMore but has no child nodes.
            // Animation will not be triggered and needs to be removed manually
            if (currentExpandKeys.indexOf(props._key) > -1 && filtedData.length === 0) {
                treeContext.onExpandEnd(props._key);
            }
        }, [filtedData, currentExpandKeys]);
        return (React.createElement(CSSTransition$1, { in: currentExpandKeys.indexOf(props._key) > -1 && filtedData.length > 0, unmountOnExit: true, classNames: "tree-slide-expand", timeout: {
                enter: 200,
                exit: 0,
            }, onEnter: function (e) {
                var scrollHeight = e.scrollHeight;
                e.style.height = expanded ? 0 : Math.min(realHeight || scrollHeight, e.scrollHeight) + "px";
            }, onEntering: function (e) {
                var scrollHeight = e.scrollHeight;
                e.style.height = expanded ? Math.min(realHeight || scrollHeight, scrollHeight) + "px" : 0;
            }, onEntered: function (e) {
                e.style.height = props.expanded ? '' : 0;
                treeContext.onExpandEnd(props._key);
            }, onExit: function (e) {
                e.style.display = 'none';
            } },
            React.createElement(VirtualList$1, __assign$i({ itemKey: getKey$1, className: prefixCls + "-list", isStaticItemHeight: false }, treeContext.virtualListProps, { data: filtedData, "aria-hidden": true, style: { overflow: 'hidden' } }), function (child) {
                return React.createElement(Node$1, __assign$i({}, child));
            })));
    };
    var AnimationNode = TreeAnimation;

    var __assign$h = (undefined && undefined.__assign) || function () {
        __assign$h = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$h.apply(this, arguments);
    };
    var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$3 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __read$f = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$7 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    function TreeNode(props, ref) {
        var _a, _b, _c;
        var _this = this;
        var treeContext = React.useContext(TreeContext);
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        // const prevProps: NodeProps = usePrevious(props) || {};
        var nodeTitleRef = React.useRef();
        var _d = __read$f(React.useState({
            isAllowDrop: true,
            isDragOver: false,
            dragPosition: 0,
            isDragging: false,
        }), 2), state = _d[0], setState = _d[1];
        var _e = props._key, _key = _e === void 0 ? '' : _e, title = props.title, icon = props.icon, checkable = props.checkable, selected = props.selected, disabled = props.disabled, disableCheckbox = props.disableCheckbox, isLeaf = props.isLeaf, draggable = props.draggable, expanded = props.expanded, showLine = props.showLine, loading = props.loading, _f = props.selectable, selectable = _f === void 0 ? true : _f;
        var prefixCls = getPrefixCls('tree-node');
        var classNames = cs(prefixCls, (_a = {},
            _a[prefixCls + "-selected"] = selected,
            _a[prefixCls + "-is-leaf"] = isLeaf,
            _a[prefixCls + "-expanded"] = expanded,
            _a[prefixCls + "-disabled-selectable"] = !selectable,
            _a[prefixCls + "-disabled"] = disabled,
            _a[prefixCls + "-draggable"] = draggable,
            _a), props.className);
        var icons = (function () {
            var treeIcons = isFunction$1(treeContext.icons) ? treeContext.icons(props) : treeContext.icons;
            var propsIcons = isFunction$1(props.icons) ? props.icons(props) : props.icons;
            return __assign$h(__assign$h({}, treeIcons), propsIcons);
        })();
        var setExpand = React.useCallback(function (newExpand) {
            if (newExpand === expanded) {
                return;
            }
            treeContext.onExpand && treeContext.onExpand(newExpand, _key);
        }, [expanded, treeContext.onExpand]);
        var switchExpandStatus = React.useCallback(function () { return __awaiter$3(_this, void 0, void 0, function () {
            var isLeaf, expanded;
            var _a;
            return __generator$3(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        isLeaf = props.isLeaf, expanded = props.expanded;
                        if (isLeaf) {
                            return [2 /*return*/];
                        }
                        if (!(!((_a = props.childrenData) === null || _a === void 0 ? void 0 : _a.length) && isFunction$1(treeContext.loadMore) && !expanded)) return [3 /*break*/, 2];
                        return [4 /*yield*/, treeContext.loadMore(props)];
                    case 1:
                        _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        setExpand(!expanded);
                        _b.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        }); }, [props, setExpand, treeContext.loadMore]);
        var getPrefixIcon = function () {
            if (loading) {
                return 'loadingIcon' in icons ? icons.loadingIcon : React.createElement(IconLoading$1, null);
            }
            var icon = null;
            var needIconHover = false;
            if (!isLeaf) {
                var defaultIcon = showLine ? (React.createElement("span", { className: prefixCls + "-" + (expanded ? 'minus' : 'plus') + "-icon" })) : (React.createElement(IconCaretDown$1, null));
                icon = 'switcherIcon' in icons ? icons.switcherIcon : defaultIcon;
                needIconHover = !showLine;
            }
            else if (showLine) {
                icon = 'switcherIcon' in icons ? icons.switcherIcon : React.createElement(IconFile$1, null);
                needIconHover = true;
            }
            if (icon) {
                icon = (React.createElement("span", { className: prefixCls + "-switcher-icon", "aria-label": expanded ? 'fold button' : 'expand button', role: "button", tabIndex: 0, onClick: switchExpandStatus }, icon));
                return needIconHover ? React.createElement(IconHover, { prefix: prefixCls }, icon) : icon;
            }
        };
        var updateDragOverState = React.useCallback(throttleByRaf(function (e) {
            var dom = nodeTitleRef.current;
            if (!dom)
                return;
            var rect = dom.getBoundingClientRect();
            var offsetY = window.pageYOffset + rect.top;
            var pageY = e.pageY;
            var gapHeight = rect.height / 4;
            var diff = pageY - offsetY;
            var position = diff < gapHeight ? -1 : diff < rect.height - gapHeight ? 0 : 1;
            var isAllowDrop = treeContext.allowDrop(props, position);
            setState(__assign$h(__assign$h({}, state), { isAllowDrop: isAllowDrop, isDragOver: true, dragPosition: position }));
            treeContext.onNodeDragOver && treeContext.onNodeDragOver(e, props, position);
        }), [treeContext.onNodeDragOver]);
        var handleCheck = function (checked, e) {
            var disableCheckbox = props.disableCheckbox, disabled = props.disabled;
            if (disableCheckbox || disabled) {
                return;
            }
            treeContext.onCheck && treeContext.onCheck(checked, _key, e);
        };
        return (React.createElement(React.Fragment, null,
            React.createElement("div", { style: props.style, className: classNames, ref: ref, role: "treeitem", "aria-disabled": disabled, "aria-expanded": expanded, "aria-level": props._level },
                React.createElement("span", { className: prefixCls + "-indent", "aria-hidden": true }, __spreadArray$7([], __read$f(Array(props._level)), false).map(function (_, i) {
                    var _a;
                    return (React.createElement("span", { className: cs(prefixCls + "-indent-block", (_a = {},
                            _a[prefixCls + "-indent-block-lineless"] = props._lineless && props._lineless[i],
                            _a)), key: i }));
                })),
                React.createElement("span", { className: cs(prefixCls + "-switcher", (_b = {},
                        _b[prefixCls + "-switcher-expanded"] = expanded,
                        _b)) }, getPrefixIcon()),
                checkable ? (React.createElement(Checkbox$2, { disabled: disableCheckbox || disabled, value: _key, indeterminate: props.indeterminated, checked: props.checked, onChange: handleCheck })) : null,
                React.createElement("span", { "aria-grabbed": state.isDragging, ref: nodeTitleRef, className: cs(prefixCls + "-title", (_c = {},
                        _c[prefixCls + "-title-draggable"] = draggable,
                        _c[prefixCls + "-title-gap-top"] = state.isDragOver && state.isAllowDrop && state.dragPosition < 0,
                        _c[prefixCls + "-title-gap-bottom"] = state.isDragOver && state.isAllowDrop && state.dragPosition > 0,
                        _c[prefixCls + "-title-highlight"] = !state.isDragging &&
                            state.isDragOver &&
                            state.isAllowDrop &&
                            state.dragPosition === 0,
                        _c[prefixCls + "-title-dragging"] = state.isDragging,
                        _c[prefixCls + "-title-block"] = props.blockNode,
                        _c)), onClick: function (e) {
                        var onSelect = treeContext.onSelect, actionOnClick = treeContext.actionOnClick;
                        if (!props.disabled) {
                            var actions = [].concat(actionOnClick);
                            if (selectable && actions.indexOf('select') > -1) {
                                onSelect && onSelect(_key, e);
                            }
                            if (actions.indexOf('expand') > -1) {
                                switchExpandStatus();
                            }
                            if (checkable && actions.indexOf('check') > -1) {
                                handleCheck(!props.checked, e);
                            }
                        }
                    }, draggable: draggable, onDrop: function (e) {
                        e.stopPropagation();
                        e.preventDefault();
                        treeContext.onNodeDrop && treeContext.onNodeDrop(e, props, state.dragPosition);
                        updateDragOverState.cancel();
                        setState(__assign$h(__assign$h({}, state), { isDragOver: false, dragPosition: 0 }));
                    }, onDragStart: function (e) {
                        if (!draggable)
                            return;
                        e.stopPropagation();
                        // 当前节点正在被拖拽
                        setState(__assign$h(__assign$h({}, state), { isDragging: true }));
                        treeContext.onNodeDragStart && treeContext.onNodeDragStart(e, props);
                        try {
                            // ie throw error
                            // firefox-need-it
                            e.dataTransfer.setData('text/plain', '');
                        }
                        catch (error) {
                            // empty
                        }
                    }, onDragEnd: function (e) {
                        if (!draggable)
                            return;
                        e.stopPropagation();
                        updateDragOverState.cancel();
                        setState(__assign$h(__assign$h({}, state), { isDragOver: false, isDragging: false }));
                        treeContext.onNodeDragEnd && treeContext.onNodeDragEnd(e, props);
                    }, onDragOver: function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        e.persist();
                        updateDragOverState(e);
                    }, onDragLeave: function (e) {
                        if (!draggable)
                            return;
                        e.stopPropagation();
                        updateDragOverState.cancel();
                        setState(__assign$h(__assign$h({}, state), { isDragOver: false }));
                        treeContext.onNodeDragLeave && treeContext.onNodeDragLeave(e, props);
                    } },
                    icon && React.createElement("span", { className: prefixCls + "-icon " + prefixCls + "-custom-icon" }, icon),
                    React.createElement("span", { className: prefixCls + "-title-text" }, isFunction$1(treeContext.renderTitle) ? treeContext.renderTitle(props) : title),
                    draggable && (React.createElement("span", { className: prefixCls + "-icon " + prefixCls + "-drag-icon" }, 'dragIcon' in icons ? icons.dragIcon : React.createElement(IconDragDotVertical$1, null)))),
                isFunction$1(treeContext.renderExtra) && treeContext.renderExtra(props)),
            React.createElement(AnimationNode, __assign$h({}, props))));
    }
    var TreeNodeComponent = React.forwardRef(TreeNode);
    TreeNodeComponent.displayName = 'TreeNode';
    var Node$1 = React.memo(TreeNodeComponent);

    var __assign$g = (undefined && undefined.__assign) || function () {
        __assign$g = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$g.apply(this, arguments);
    };
    var __read$e = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$6 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    function getKey(option) {
        return option.key || option._key;
    }
    function NodeList(props, ref) {
        var className = props.className, style = props.style, filterNode = props.filterNode, virtualListProps = props.virtualListProps, expandedKeys = props.expandedKeys, currentExpandKeys = props.currentExpandKeys, saveCacheNode = props.saveCacheNode, nodeList = props.nodeList, getNodeProps = props.getNodeProps;
        var isVirtual = (virtualListProps === null || virtualListProps === void 0 ? void 0 : virtualListProps.threshold) !== null;
        var virtualListRef = React.useRef();
        var treeWrapperRef = React.useRef();
        var expandedKeysSet = React.useMemo(function () { return new Set(expandedKeys); }, [expandedKeys]);
        var visibleKeys = React.useMemo(function () {
            var newKeys = new Set();
            var currentExpandKeysSet = new Set(currentExpandKeys);
            nodeList.forEach(function (nodeProps) {
                var pathParentKeys = nodeProps.pathParentKeys || [];
                // 如果父节点处于正在展开状态，子节点暂时不可见，因为父节点的children会在animation中渲染出来。
                // 当动画完成时，父节点children隐藏，此时在这里渲染子节点。 anyway，一切为了动画！！！
                if (pathParentKeys.every(function (key) { return !currentExpandKeysSet.has(key) && expandedKeysSet.has(key); })) {
                    newKeys.add(nodeProps._key);
                }
            });
            return newKeys;
        }, [expandedKeysSet, currentExpandKeys, nodeList]);
        var calcChildrenList = React.useCallback(function () {
            return nodeList.filter(function (item) {
                var pass = !filterNode || (filterNode && filterNode(item));
                if (pass && visibleKeys.has(item.key)) {
                    return true;
                }
                // 过滤掉的也缓存一下，避免被收起的节点在onSelect回调中，selectedNodes出现undefined
                saveCacheNode(React.createElement(Node$1, __assign$g({}, item, getNodeProps(item), { key: item.key })));
                return false;
            });
        }, [nodeList, filterNode, visibleKeys]);
        // 默认值不能为nodeList，防止在设置defaultExpandedKeys时，应该被隐藏的节点初始化的时候展示了。
        var _a = __read$e(React.useState(function () {
            return calcChildrenList();
        }), 2), childrenList = _a[0], setChildrenList = _a[1];
        useUpdate(function () {
            setChildrenList(calcChildrenList());
        }, [calcChildrenList]);
        React.useImperativeHandle(ref, function () {
            return {
                // index: 第几个dom元素, 如果传入的是字符串，会作为 node 的 key去查找。
                // nodeProps: _index 是 key 时，对应的node
                scrollIntoView: function (_index, nodeProps) {
                    var index = _index;
                    var isKey = typeof _index === 'string';
                    if (isKey) {
                        var key_1 = _index;
                        // 查找离得最近的可见的父节点，进行滚动。
                        if (!visibleKeys.has(_index) && nodeProps && nodeProps.pathParentKeys) {
                            key_1 =
                                __spreadArray$6([], __read$e(nodeProps.pathParentKeys), false).reverse().find(function (key) { return visibleKeys.has(key); }) || index;
                        }
                        // _index attributes and index are not the same due to some hidden items
                        index = childrenList.findIndex(function (_a) {
                            var _key = _a._key;
                            return _key === key_1;
                        });
                    }
                    if (!isVirtual && treeWrapperRef.current) {
                        var wrapperDom = treeWrapperRef.current;
                        var node = wrapperDom ? wrapperDom.children[index] : null;
                        node &&
                            scrollIntoViewIfNeed(node, {
                                boundary: wrapperDom.parentElement,
                            });
                    }
                    else if (virtualListRef.current) {
                        virtualListRef.current.scrollTo({ index: index });
                    }
                },
            };
        });
        return isVirtual ? (React.createElement(VirtualList$1, __assign$g({ className: className, style: style, ref: virtualListRef, data: childrenList, isStaticItemHeight: false, itemKey: getKey, onMouseDown: props.onMouseDown }, props.ariaProps, virtualListProps), function (item) {
            var node = React.createElement(Node$1, __assign$g({}, item, getNodeProps(item, expandedKeysSet), { key: item.key }));
            saveCacheNode(node);
            return node;
        })) : (React.createElement("div", __assign$g({ role: "tree", tabIndex: 0, className: className, style: style, ref: treeWrapperRef }, props.ariaProps, { onMouseDown: props.onMouseDown }), childrenList.map(function (item) {
            var node = React.createElement(Node$1, __assign$g({}, item, getNodeProps(item, expandedKeysSet), { key: item.key }));
            saveCacheNode(node);
            return node;
        })));
    }
    var NodeList$1 = React.forwardRef(NodeList);

    var __assign$f = (undefined && undefined.__assign) || function () {
        __assign$f = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$f.apply(this, arguments);
    };
    var __read$d = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$5 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };

    var getTreeDataFromTreeChildren = function (treeChildren) {
        var loop = function (children) {
            return React.Children.map(children, function (child) {
                if (!React.isValidElement(child)) {
                    return;
                }
                var key = child.key;
                return __assign$f(__assign$f({}, child.props), { key: key, children: loop(child.props.children) });
            });
        };
        return loop(treeChildren);
    };
    function getChildNodeKeys(node, key2nodeProps) {
        var nodes = new Set();
        var loop = function (children) {
            children.map(function (child) {
                var key = child.key;
                var item = key2nodeProps[key];
                if (!item || item.disabled || item.disableCheckbox || item.checkable === false) {
                    return;
                }
                nodes.add(key);
                loop(item.children || []);
            });
        };
        if (node) {
            loop(node.children || []);
        }
        return nodes;
    }
    var updateParent = function (key, key2nodeProps, allKeys, indeterminateKeysSet) {
        var pathParentKeys = __spreadArray$5([], __read$d(key2nodeProps[key].pathParentKeys), false);
        // 逐级更新父节点的状态
        pathParentKeys.reverse().forEach(function (itemKey) {
            var parent = key2nodeProps[itemKey];
            if (parent && !parent.disabled && !parent.disableCheckbox && parent.checkable !== false) {
                var total_1 = 0;
                var number_1 = 0;
                parent.children.some(function (_a) {
                    var key = _a.key;
                    var item = key2nodeProps[key];
                    // 不符合可选条件
                    if (!item || item.disabled || item.disableCheckbox || item.checkable === false) {
                        return false;
                    }
                    total_1++;
                    if (allKeys.has(key)) {
                        number_1++;
                    }
                    else if (indeterminateKeysSet.has(key)) {
                        // 只要有一个半选，就不用再算了 ，父节点是半选
                        number_1 += 0.5;
                        return true;
                    }
                });
                if (!number_1 || number_1 === total_1) {
                    indeterminateKeysSet.delete(itemKey);
                }
                else {
                    indeterminateKeysSet.add(itemKey);
                }
                if (number_1 && number_1 === total_1) {
                    allKeys.add(itemKey);
                }
                else {
                    allKeys.delete(itemKey);
                }
            }
        });
    };
    // also used by tree-select
    function getCheckedKeysByInitKeys(checkedKeys, key2nodeProps) {
        var checkedKeysSet = new Set(checkedKeys || []);
        var indeterminateKeysSet = new Set();
        var childCheckedKeysSet = new Set();
        checkedKeys.forEach(function (key) {
            if (!childCheckedKeysSet.has(key)) {
                var childKeys = getChildNodeKeys(key2nodeProps[key], key2nodeProps);
                // 选中了节点，就找到所有符合条件的子节点的key.自身的选中状态需要根据children判断。
                childKeys.forEach(function (v) {
                    childCheckedKeysSet.add(v);
                });
            }
            if (key2nodeProps[key] &&
                !key2nodeProps[key].pathParentKeys.some(function (_key) { return checkedKeysSet.has(_key); })) {
                updateParent(key, key2nodeProps, checkedKeysSet, indeterminateKeysSet);
            }
        });
        return {
            checkedKeys: __spreadArray$5([], __read$d(new Set(__spreadArray$5(__spreadArray$5([], __read$d(checkedKeysSet), false), __read$d(childCheckedKeysSet), false))), false),
            indeterminateKeys: __spreadArray$5([], __read$d(indeterminateKeysSet), false),
        };
    }
    // also used by tree-select
    function getAllCheckedKeysByCheck(key, checked, checkedKeys, key2nodeProps, indeterminateKeys) {
        if (!key2nodeProps[key]) {
            return {
                checkedKeys: checkedKeys,
                indeterminateKeys: indeterminateKeys,
            };
        }
        var checkedKeysSet = new Set(checkedKeys);
        var indeterminateKeysSet = new Set(indeterminateKeys);
        var childKeys = getChildNodeKeys(key2nodeProps[key], key2nodeProps);
        var allKeys = checkedKeysSet;
        if (checked) {
            // 选中了节点，就找到所有符合条件的子节点的key.自身的选中状态需要根据children判断。
            allKeys.add(key);
            indeterminateKeysSet.delete(key);
            childKeys.forEach(function (v) {
                allKeys.add(v);
            });
        }
        else {
            indeterminateKeysSet.delete(key);
            // 移除所有符合条件的子节点的key
            allKeys.delete(key);
            childKeys.forEach(function (v) {
                allKeys.delete(v);
            });
        }
        // 之后逐级更新父节点的选中状态。
        updateParent(key, key2nodeProps, checkedKeysSet, indeterminateKeysSet);
        return {
            checkedKeys: __spreadArray$5([], __read$d(allKeys), false),
            indeterminateKeys: __spreadArray$5([], __read$d(indeterminateKeysSet), false),
        };
    }

    var __extends$1 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$e = (undefined && undefined.__assign) || function () {
        __assign$e = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$e.apply(this, arguments);
    };
    var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$2 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __rest$5 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$c = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$4 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var DefaultFieldNames$1 = {
        key: 'key',
        title: 'title',
        children: 'children',
        selectable: 'selectable',
        disabled: 'disabled',
        disableCheckbox: 'disableCheckbox',
        checkable: 'checkable',
        isLeaf: 'isLeaf',
    };
    var defaultProps$4 = {
        selectable: true,
        autoExpandParent: true,
        checkedStrategy: 'all',
        actionOnClick: 'select',
        allowDrop: function () { return true; },
        fieldNames: DefaultFieldNames$1,
    };
    var needMergeKeys = [
        'style',
        'className',
        'height',
        'size',
        'blockNode',
        'autoExpandParent',
        'checkedStrategy',
        'fieldNames',
        'icons',
        'virtualListProps',
        'showLine',
        'selectable',
        'allowDrop',
        'actionOnClick',
    ];
    var Tree = /** @class */ (function (_super) {
        __extends$1(Tree, _super);
        function Tree(props, context) {
            var _this = _super.call(this, props, context) || this;
            // 依旧使用NodeInstance 是为了兼容1.x的一些用法，改动较大
            _this.cacheNodes = {};
            _this.key2nodeProps = {};
            _this.getMergedProps = function (baseProps) {
                var componentConfig = _this.context.componentConfig;
                var props = baseProps || _this.props;
                return needMergeKeys.reduce(function (_props, key) {
                    if (props[key] !== undefined) {
                        _props[key] = props[key];
                    }
                    else if ((componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Tree) && (componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Tree[key]) !== undefined) {
                        _props[key] = componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Tree[key];
                    }
                    else if (defaultProps$4[key] !== undefined) {
                        _props[key] = defaultProps$4[key];
                    }
                    return _props;
                }, {});
            };
            // index: 第几个dom元素, 如果传入的是字符串，会作为 node 的 key去查找。
            // nodeProps 参数似乎咩有什么用。。。但是不知道外部有没有调用，就当key用吧。。
            _this.scrollIntoView = function (_index, nodeProps) {
                var index = _index;
                if (typeof _index === 'string' || nodeProps) {
                    // 作为key
                    index = _index || nodeProps._key;
                }
                if (_this.nodeListRef) {
                    _this.nodeListRef.scrollIntoView(index, nodeProps || _this.key2nodeProps[index]);
                }
            };
            _this.getTreeData = function () {
                return 'treeData' in _this.props
                    ? _this.props.treeData
                    : getTreeDataFromTreeChildren(_this.props.children);
            };
            // 以下外部传入的属性改变时，需要更新nodeList
            _this.needUpdateTreeData = function (prevProps, props) {
                var keys = [
                    'fieldNames',
                    'selectable',
                    'draggable',
                    'checkStrictly',
                    'showLine',
                    'blockNode',
                    'checkable',
                    'treeData',
                    'children',
                ];
                return (prevProps.treeData !== props.treeData ||
                    prevProps.children !== props.children ||
                    keys.some(function (key) { return isEqualWith_1(prevProps[key], props[key]); }));
            };
            // 根据 fieldNames 获取节点数据
            _this.getFieldInfo = function (data) {
                var mergedProps = _this.getMergedProps();
                var selectable = mergedProps.selectable;
                // fieldsNames 仅在treeData时生效。
                var fieldNames = __assign$e(__assign$e({}, DefaultFieldNames$1), ('treeData' in _this.props ? mergedProps.fieldNames : {}));
                var result = {
                    children: data[fieldNames.children],
                    selectable: fieldNames.selectable in data ? data[fieldNames.selectable] : selectable,
                    checkable: fieldNames.checkable in data ? data[fieldNames.checkable] : _this.props.checkable,
                    title: data[fieldNames.title],
                    disabled: data[fieldNames.disabled],
                    disableCheckbox: data[fieldNames.disableCheckbox],
                    isLeaf: data[fieldNames.isLeaf],
                    key: data[fieldNames.key],
                };
                if (!(fieldNames.key in data)) {
                    delete result.key;
                }
                return result;
            };
            _this.getNodeList = function (treedata, prefix) {
                _this.key2nodeProps = {};
                var prefixCls = prefix || _this.context.getPrefixCls('tree');
                var nodeList = [];
                var currentIndex = 0;
                var _a = _this.getMergedProps(), showLine = _a.showLine, blockNode = _a.blockNode;
                var loop = function (treeData, father) {
                    var totalLength = treeData.length;
                    return treeData.map(function (data, index) {
                        var _a = _this.getFieldInfo(data), children = _a.children, selectable = _a.selectable, checkable = _a.checkable, _b = _a.key, key = _b === void 0 ? ((father === null || father === void 0 ? void 0 : father._key) || '') + "-" + index : _b, rest = __rest$5(_a, ["children", "selectable", "checkable", "key"]);
                        var nodeProps = __assign$e(__assign$e(__assign$e({ 
                            // data 中含有dataRef时，优先级较高
                            dataRef: data, draggable: _this.props.draggable, selectable: selectable, checkable: checkable, showLine: showLine, blockNode: blockNode }, data), rest), { key: key, children: children, _key: key, _index: currentIndex++, parentKey: father ? father._key : undefined, pathParentKeys: (father && father.pathParentKeys) || [], _level: father._level || 0, 
                            // 保存node在sowLine模式下是否显示缩进线。如果父节点是其所在层级的最后一个节点，那么所有的子节点（包括孙子节点等）在父节点所在层级的缩进格都不显示缩进线。
                            _lineless: father && father._lineless ? __spreadArray$4(__spreadArray$4([], __read$c((father._lineless || [])), false), [father._isTail], false) : [] });
                        if (totalLength === index + 1) {
                            nodeProps.className = cs(prefixCls + "-node-is-tail", nodeProps.className);
                        }
                        nodeList.push(nodeProps);
                        _this.key2nodeProps[key] = nodeProps;
                        if (children && children.length) {
                            _this.key2nodeProps[key].children = loop(children, {
                                _key: key,
                                _level: nodeProps._level + 1,
                                _lineless: nodeProps._lineless,
                                _isTail: totalLength === index + 1,
                                pathParentKeys: __spreadArray$4(__spreadArray$4([], __read$c(((father === null || father === void 0 ? void 0 : father.pathParentKeys) || [])), false), [key], false),
                            });
                        }
                        return nodeProps;
                    });
                };
                loop(treedata || [], {});
                return nodeList;
            };
            _this.getInitExpandedKeys = function (keys) {
                if (!_this.getMergedProps().autoExpandParent) {
                    return keys || [];
                }
                if (!keys) {
                    return Object.keys(_this.key2nodeProps).filter(function (key) {
                        var props = _this.key2nodeProps[key];
                        return props.children && props.children.length;
                    });
                }
                var expandedKeys = {};
                keys.forEach(function (key) {
                    var item = _this.key2nodeProps[key];
                    if (!item) {
                        return;
                    }
                    expandedKeys[key] = 1;
                    if (item.pathParentKeys) {
                        item.pathParentKeys.forEach(function (x) {
                            expandedKeys[x] = 1;
                        });
                    }
                });
                return Object.keys(expandedKeys);
            };
            _this.getInitCheckedKeys = function (keys) {
                if (!_this.props.checkStrictly) {
                    var _a = getCheckedKeysByInitKeys(keys, _this.key2nodeProps), checkedKeys = _a.checkedKeys, indeterminateKeys = _a.indeterminateKeys;
                    return {
                        checkedKeys: checkedKeys,
                        halfCheckedKeys: indeterminateKeys,
                    };
                }
                return {
                    checkedKeys: keys,
                    halfCheckedKeys: _this.props.halfCheckedKeys || [],
                };
            };
            _this.handleSelect = function (key, e) {
                var onSelect = _this.props.onSelect;
                var extra = { e: e, node: _this.cacheNodes[key] };
                if (_this.props.multiple) {
                    var selectedKeys = __spreadArray$4([], __read$c(_this.state.selectedKeys), false);
                    var index = selectedKeys.indexOf(key);
                    if (index > -1) {
                        selectedKeys.splice(index, 1);
                        extra.selected = false;
                    }
                    else {
                        extra.selected = true;
                        selectedKeys.push(key);
                    }
                    extra.selectedNodes = selectedKeys.map(function (x) { return _this.cacheNodes[x]; });
                    if (!('selectedKeys' in _this.props)) {
                        _this.setState({ selectedKeys: selectedKeys });
                    }
                    onSelect && onSelect(selectedKeys, extra);
                }
                else {
                    extra.selected = true;
                    extra.selectedNodes = [_this.cacheNodes[key]];
                    if (!('selectedKeys' in _this.props)) {
                        _this.setState({ selectedKeys: [key] });
                    }
                    onSelect && onSelect([key], extra);
                }
            };
            _this.handleCheck = function (checked, key, e) {
                var checkedStrategy = _this.getMergedProps().checkedStrategy;
                var _a = _this.props, onCheck = _a.onCheck, checkStrictly = _a.checkStrictly;
                var extra = { e: e, node: _this.cacheNodes[key] };
                var checkedKeys = _this.state.checkedKeys;
                var halfCheckedKeys = _this.state.halfCheckedKeys;
                if (checkStrictly) {
                    if (checked) {
                        checkedKeys = checkedKeys.concat(key);
                    }
                    else {
                        checkedKeys = checkedKeys.filter(function (item) { return item !== key; });
                    }
                    var newState = {};
                    if (!('checkedKeys' in _this.props)) {
                        newState.checkedKeys = checkedKeys;
                    }
                    if (!('halfCheckedKeys' in _this.props)) {
                        newState.halfCheckedKeys = halfCheckedKeys;
                    }
                    if (!isEmptyObject(newState)) {
                        _this.setState(__assign$e({}, newState));
                    }
                }
                else {
                    // 找到所有允许勾选的子节点
                    var _b = getAllCheckedKeysByCheck(key, checked, checkedKeys, _this.key2nodeProps, halfCheckedKeys), newCheckedKeys = _b.checkedKeys, indeterminateKeys = _b.indeterminateKeys;
                    checkedKeys = newCheckedKeys;
                    halfCheckedKeys = indeterminateKeys;
                    if (!('checkedKeys' in _this.props)) {
                        _this.setState({ checkedKeys: checkedKeys, halfCheckedKeys: halfCheckedKeys });
                    }
                    else {
                        _this.setState({ halfCheckedKeys: halfCheckedKeys });
                    }
                    if (checkedStrategy === Tree.SHOW_PARENT) {
                        checkedKeys = checkedKeys.filter(function (x) {
                            var item = _this.key2nodeProps[x];
                            if (!item || checkedKeys.indexOf(item.parentKey) === -1) {
                                return true;
                            }
                        });
                    }
                    else if (checkedStrategy === Tree.SHOW_CHILD) {
                        checkedKeys = checkedKeys.filter(function (x) {
                            var item = _this.key2nodeProps[x];
                            if (!item || !item.children || !item.children.length) {
                                return true;
                            }
                        });
                    }
                }
                onCheck &&
                    onCheck(checkedKeys, __assign$e({ checkedNodes: checkedKeys.map(function (x) { return _this.cacheNodes[x]; }).filter(function (x) { return x; }), checked: checked, halfCheckedKeys: halfCheckedKeys, halfCheckedNodes: halfCheckedKeys.map(function (x) { return _this.cacheNodes[x]; }).filter(function (x) { return x; }) }, extra));
            };
            _this.handleLoadMore = function (node) {
                var loadMore = _this.props.loadMore;
                if (isFunction$1(loadMore)) {
                    var _a = _this.state, _b = _a.loadingKeys, loadingKeys = _b === void 0 ? [] : _b, loadedKeys = _a.loadedKeys;
                    _this.setState({
                        loadingKeys: Array.from(new Set(__spreadArray$4(__spreadArray$4([], __read$c(loadingKeys), false), [node._key], false))),
                        loadedKeys: loadedKeys.filter(function (x) { return x !== node._key; }),
                    }, function () { return __awaiter$2(_this, void 0, void 0, function () {
                        var e_1;
                        return __generator$2(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    _a.trys.push([0, 2, , 3]);
                                    return [4 /*yield*/, loadMore(this.cacheNodes[node._key])];
                                case 1:
                                    _a.sent();
                                    this.setState({
                                        loadedKeys: Array.from(new Set(__spreadArray$4(__spreadArray$4([], __read$c(this.state.loadedKeys), false), [node._key], false))),
                                        loadingKeys: this.state.loadingKeys.filter(function (x) { return x !== node._key; }),
                                    });
                                    this.handleExpand(!node.expanded, node._key);
                                    return [3 /*break*/, 3];
                                case 2:
                                    e_1 = _a.sent();
                                    console.error('[tree]load data error: ', e_1);
                                    this.setState({
                                        loadingKeys: this.state.loadingKeys.filter(function (x) { return x !== node._key; }),
                                    });
                                    return [3 /*break*/, 3];
                                case 3: return [2 /*return*/];
                            }
                        });
                    }); });
                }
            };
            _this.handleNodeDragStart = function (e, node) {
                _this.dragNode = _this.cacheNodes[node._key];
                _this.dropPosition = 0;
                var onDragStart = _this.props.onDragStart;
                onDragStart && onDragStart(e, _this.cacheNodes[node._key]);
            };
            _this.handleNodeDragEnd = function (e, node) {
                _this.dragNode = null;
                _this.dropPosition = 0;
                var onDragEnd = _this.props.onDragEnd;
                onDragEnd && onDragEnd(e, _this.cacheNodes[node._key]);
            };
            _this.handleNodeDragOver = function (e, node, dropPosition) {
                _this.dropPosition = dropPosition;
                var onDragOver = _this.props.onDragOver;
                onDragOver && onDragOver(e, _this.cacheNodes[node._key]);
            };
            _this.handleNodeDragLeave = function (e, node) {
                // this.dropNode = null;
                _this.dropPosition = 0;
                var onDragLeave = _this.props.onDragLeave;
                onDragLeave && onDragLeave(e, _this.cacheNodes[node._key]);
            };
            _this.isChildOfNode = function (node, target) {
                var current = _this.key2nodeProps[node.parentKey];
                while (current) {
                    var _key = current._key, parentKey = current.parentKey;
                    if (_key === target.props._key) {
                        return true;
                    }
                    if (parentKey === _key)
                        return;
                    current = _this.key2nodeProps[parentKey];
                }
            };
            _this.isSameNode = function (node1, node2) {
                // 对比 node
                if (node1 === undefined || node2 === undefined)
                    return false;
                if (node1 === node2)
                    return true;
                // 对比 node.key
                var key1 = node1.key;
                var key2 = node2.key;
                if (key1 !== undefined || key2 !== undefined)
                    return key1 === key2;
                // 对比 node.props._key
                var _key1 = node1.props._key;
                var _key2 = node2.props._key;
                if (_key1 === undefined && _key2 === undefined)
                    return false;
                return _key1 === _key2;
            };
            _this.handleNodeDrop = function (e, node, dropPosition) {
                if (_this.dragNode) {
                    var allowDrop = _this.getMergedProps().allowDrop;
                    var onDrop = _this.props.onDrop;
                    var nodeInstance = _this.cacheNodes[node._key];
                    if (onDrop &&
                        !_this.isChildOfNode(node, _this.dragNode) &&
                        !_this.isSameNode(_this.dragNode, nodeInstance)) {
                        if (allowDrop &&
                            !allowDrop({ dropNode: nodeInstance, dragNode: _this.dragNode, dropPosition: dropPosition })) {
                            return;
                        }
                        onDrop({
                            dragNode: _this.dragNode,
                            dropNode: nodeInstance,
                            dropPosition: dropPosition,
                            e: e,
                        });
                    }
                }
            };
            _this.handleAllowDrop = function (node, dropPosition) {
                var allowDrop = _this.getMergedProps().allowDrop;
                var isAllowDrop = true;
                if (typeof allowDrop === 'function') {
                    isAllowDrop = allowDrop({
                        dropNode: _this.cacheNodes[node._key],
                        dragNode: _this.dragNode,
                        dropPosition: dropPosition,
                    });
                }
                return isAllowDrop;
            };
            _this.handleExpand = function (expanded, key) {
                var _a = _this.state, currentExpandKeys = _a.currentExpandKeys, _b = _a.expandedKeys, expandedKeys = _b === void 0 ? [] : _b;
                var onExpand = _this.props.onExpand;
                if (currentExpandKeys.indexOf(key) > -1) {
                    // 如果当前key节点正在展开/收起，不执行操作。
                    return;
                }
                var newExpandedKeys = [];
                if (expanded) {
                    newExpandedKeys = Array.from(new Set(__spreadArray$4(__spreadArray$4([], __read$c(expandedKeys), false), [key], false)));
                }
                else {
                    newExpandedKeys = expandedKeys.filter(function (k) { return k !== key; });
                }
                if (!('expandedKeys' in _this.props)) {
                    _this.setState({
                        expandedKeys: newExpandedKeys,
                        currentExpandKeys: __spreadArray$4(__spreadArray$4([], __read$c(currentExpandKeys), false), [key], false),
                    });
                }
                onExpand &&
                    onExpand(newExpandedKeys, {
                        expanded: expanded,
                        node: _this.cacheNodes[key],
                        expandedNodes: newExpandedKeys.map(function (x) { return _this.cacheNodes[x]; }).filter(function (x) { return x; }),
                    });
            };
            // 传入构建好的expandedKeysSet
            _this.getNodeProps = function (nodeProps, expandedKeysSet) {
                var autoExpandParent = _this.getMergedProps().autoExpandParent;
                var loadMore = _this.props.loadMore;
                var _a = _this.state, selectedKeys = _a.selectedKeys, expandedKeys = _a.expandedKeys, checkedKeys = _a.checkedKeys, halfCheckedKeys = _a.halfCheckedKeys, _b = _a.loadingKeys, loadingKeys = _b === void 0 ? [] : _b, _c = _a.loadedKeys, loadedKeys = _c === void 0 ? [] : _c;
                var hasChildren = nodeProps.children && nodeProps.children.length;
                var otherProps = {
                    isLeaf: !hasChildren,
                    autoExpandParent: hasChildren ? autoExpandParent : false,
                    expanded: expandedKeysSet
                        ? expandedKeysSet.has(nodeProps._key)
                        : expandedKeys.indexOf(nodeProps._key) > -1,
                };
                if (loadMore) {
                    var loaded = loadedKeys.indexOf(nodeProps._key) > -1;
                    otherProps.loaded = loaded;
                    otherProps.isLeaf = hasChildren ? false : nodeProps.isLeaf;
                }
                return __assign$e(__assign$e(__assign$e({}, nodeProps), otherProps), { selected: selectedKeys && selectedKeys.indexOf(nodeProps._key) > -1, indeterminated: (halfCheckedKeys === null || halfCheckedKeys === void 0 ? void 0 : halfCheckedKeys.indexOf(nodeProps._key)) > -1, loading: loadingKeys.indexOf(nodeProps._key) > -1, checked: checkedKeys && checkedKeys.indexOf(nodeProps._key) > -1, selectedKeys: selectedKeys, checkedKeys: checkedKeys, loadingKeys: loadingKeys, loadedKeys: loadedKeys, expandedKeys: _this.state.expandedKeys, childrenData: nodeProps.children || [], children: null });
            };
            _this.handleExpandEnd = function (key) {
                var currentExpandKeys = _this.state.currentExpandKeys;
                if (currentExpandKeys.indexOf(key) > -1) {
                    _this.setState({
                        currentExpandKeys: currentExpandKeys.filter(function (v) { return v !== key; }),
                    });
                }
            };
            // 获取tree的state数据，在子组件里使用。
            _this.getTreeState = function () {
                return _this.state;
            };
            _this.state = {};
            var treeData = _this.getTreeData();
            var nodeList = _this.getNodeList(treeData, context.getPrefixCls('tree'));
            var _a = _this.getInitCheckedKeys(props.checkedKeys || props.defaultCheckedKeys || []), checkedKeys = _a.checkedKeys, halfCheckedKeys = _a.halfCheckedKeys;
            _this.state = {
                selectedKeys: props.selectedKeys || props.defaultSelectedKeys || [],
                checkedKeys: checkedKeys,
                halfCheckedKeys: halfCheckedKeys,
                expandedKeys: _this.getInitExpandedKeys(props.expandedKeys || props.defaultExpandedKeys),
                loadedKeys: [],
                loadingKeys: [],
                currentExpandKeys: [],
                nodeList: nodeList,
            };
            return _this;
        }
        Tree.getDerivedStateFromProps = function (nextProps, state) {
            var newState = {};
            if ('selectedKeys' in nextProps && !isEqualWith_1(nextProps.selectedKeys, state.selectedKeys)) {
                newState.selectedKeys = nextProps.selectedKeys || [];
            }
            if (Object.keys(newState).length) {
                return newState;
            }
            return null;
        };
        Tree.prototype.componentDidUpdate = function (prevProps) {
            // 类似 componentWillReceiveProps 周期
            var _this = this;
            var prevMergedProps = this.getMergedProps(prevProps);
            var mergedProps = this.getMergedProps();
            if (prevProps !== this.props || !isEqualWith_1(prevMergedProps, mergedProps)) {
                var newState_1 = {};
                if (this.needUpdateTreeData(__assign$e({ prevMergedProps: prevMergedProps }, prevProps), __assign$e(__assign$e({}, mergedProps), this.props))) {
                    var treeData = this.getTreeData();
                    var nodeList = this.getNodeList(treeData);
                    newState_1.treeData = treeData;
                    newState_1.nodeList = nodeList;
                }
                if (newState_1.treeData ||
                    ('checkedKeys' in this.props && !isEqualWith_1(prevProps.checkedKeys, this.props.checkedKeys))) {
                    // 说明treeData变了，需要比较下内部checkedKeys
                    var currentCheckedKeys = 'checkedKeys' in this.props ? this.props.checkedKeys : this.state.checkedKeys;
                    var _a = this.getInitCheckedKeys(currentCheckedKeys || []), halfCheckedKeys = _a.halfCheckedKeys, checkedKeys = _a.checkedKeys;
                    if (!isEqualWith_1(checkedKeys, this.state.checkedKeys)) {
                        newState_1.checkedKeys = checkedKeys;
                    }
                    if (!isEqualWith_1(halfCheckedKeys, this.state.halfCheckedKeys)) {
                        newState_1.halfCheckedKeys = halfCheckedKeys;
                    }
                }
                if (this.props.checkStrictly &&
                    'halfCheckedKeys' in this.props &&
                    !isEqualWith_1(prevProps.halfCheckedKeys, this.props.halfCheckedKeys)) {
                    newState_1.halfCheckedKeys = this.props.halfCheckedKeys;
                }
                if ('expandedKeys' in this.props &&
                    !isEqualWith_1(this.props.expandedKeys, prevProps.expandedKeys)) {
                    newState_1.expandedKeys = this.props.expandedKeys;
                    // 比较前后expandKeys的改变，去重，得到需要收起/展开的动画
                    // 例如 [...[1, 2, 3], ...[1, 3, 4]] 。那么 2 会收起，4会展开。
                    // 如果父节点正在执行收起/展开逻辑，子节点不需要出现在 currentExpandKeys 数组。
                    newState_1.currentExpandKeys = __spreadArray$4(__spreadArray$4([], __read$c(newState_1.expandedKeys), false), __read$c(this.state.expandedKeys), false).reduce(function (total, next) {
                        var index = total.indexOf(next);
                        if (index === -1) {
                            total.push(next);
                        }
                        else {
                            total.splice(index, 1);
                        }
                        return total;
                    }, [])
                        .filter(function (key, _, array) {
                        var _a;
                        if (_this.key2nodeProps[key]) {
                            var pathParentKeys = _this.key2nodeProps[key].pathParentKeys;
                            if (pathParentKeys.some(function (x) { return array.indexOf(x) > -1; })) {
                                return false;
                            }
                            return (_a = _this.key2nodeProps[key].children) === null || _a === void 0 ? void 0 : _a.length;
                        }
                    });
                }
                var currentExpandKeys = newState_1.currentExpandKeys || this.state.currentExpandKeys;
                if (newState_1.treeData && currentExpandKeys) {
                    newState_1.currentExpandKeys = currentExpandKeys.filter(function (key) {
                        var item = newState_1.treeData.find(function (node) { return node._key === key; });
                        return item && item.children && item.children.length;
                    });
                }
                if (Object.keys(newState_1).length) {
                    this.setState(newState_1);
                }
            }
        };
        Tree.prototype.render = function () {
            var _a;
            var _this = this;
            // render 之前重置掉，在NodeList里会进行赋值。
            this.cacheNodes = {};
            var _b = this.getMergedProps(), className = _b.className, showLine = _b.showLine, size = _b.size, _virtualListProps = _b.virtualListProps, height = _b.height, style = _b.style, icons = _b.icons, actionOnClick = _b.actionOnClick;
            var _c = this.props, loadMore = _c.loadMore, checkable = _c.checkable;
            // 兼容旧 APi : height
            var virtualListProps = _virtualListProps
                ? __assign$e({ threshold: 100 }, _virtualListProps) : height
                ? { height: height, threshold: 100 }
                : {
                    threshold: null,
                };
            var _d = this.context, getPrefixCls = _d.getPrefixCls, rtl = _d.rtl;
            var prefixCls = getPrefixCls('tree');
            return (React.createElement(TreeContext.Provider, { value: {
                    icons: icons,
                    key2nodeProps: this.key2nodeProps,
                    getFieldInfo: this.getFieldInfo,
                    getTreeState: this.getTreeState,
                    getNodeProps: this.getNodeProps,
                    onExpandEnd: this.handleExpandEnd,
                    onSelect: this.handleSelect,
                    onCheck: this.handleCheck,
                    onNodeDragStart: this.handleNodeDragStart,
                    onNodeDragEnd: this.handleNodeDragEnd,
                    onNodeDragLeave: this.handleNodeDragLeave,
                    onNodeDragOver: this.handleNodeDragOver,
                    onNodeDrop: this.handleNodeDrop,
                    onExpand: this.handleExpand,
                    renderExtra: this.props.renderExtra,
                    renderTitle: this.props.renderTitle,
                    loadMore: loadMore && this.handleLoadMore,
                    allowDrop: this.handleAllowDrop,
                    actionOnClick: actionOnClick,
                    virtualListProps: virtualListProps,
                } },
                React.createElement(NodeList$1, { ref: function (node) {
                        _this.nodeListRef = node;
                    }, className: cs(prefixCls, (_a = {},
                        _a[prefixCls + "-checkable"] = checkable,
                        _a[prefixCls + "-show-line"] = showLine,
                        _a[prefixCls + "-size-" + size] = size,
                        _a[prefixCls + "-rtl"] = rtl,
                        _a), className), style: style, filterNode: this.props.filterNode, virtualListProps: virtualListProps, expandedKeys: this.state.expandedKeys, currentExpandKeys: this.state.currentExpandKeys, getNodeProps: this.getNodeProps, nodeList: this.state.nodeList, onMouseDown: this.props.onMouseDown, saveCacheNode: function (node) {
                        _this.cacheNodes[node.key] = node;
                    }, ariaProps: __assign$e({ role: 'tree', 'aria-multiselectable': this.props.multiple, tabIndex: 0 }, pickDataAttributes(this.props)) })));
        };
        Tree.displayName = 'Tree';
        Tree.SHOW_PARENT = 'parent';
        Tree.SHOW_ALL = 'all';
        Tree.SHOW_CHILD = 'child';
        Tree.Node = Node$1;
        Tree.contextType = ConfigContext;
        return Tree;
    }(React.Component));
    var Tree$1 = Tree;

    var normalizeValueToArray = function (val) {
        var value = val;
        if (!isArray$1(val)) {
            value = val === null || val === undefined ? [] : [val];
        }
        return value.map(function (x) {
            if (isObject$1(x)) {
                return x.value;
            }
            return x;
        });
    };

    var __assign$d = (undefined && undefined.__assign) || function () {
        __assign$d = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$d.apply(this, arguments);
    };
    var __read$b = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var parseValue = function (v, key2nodeProps, valueMap) {
        if (v === undefined || v === null) {
            return [];
        }
        var value = isArray$1(v) ? v : [v];
        return value.map(function (x) {
            var result = isObject$1(x) ? __assign$d({}, x) : { value: x, label: undefined };
            var item = key2nodeProps[result.value];
            if (item) {
                result.label = result.label || item.title;
                result.disabled = item.disabled;
            }
            else if (isArray$1(valueMap)) {
                var v_1 = valueMap.find(function (y) { return y.value === result.value; });
                result = __assign$d(__assign$d({}, result), v_1);
            }
            if (isUndefined(result.label)) {
                result.label = result.value;
            }
            return result;
        });
    };
    var getInitCheckKeys = function (keys, key2nodeProps, indeterminateKeys, props) {
        if (!props.treeCheckStrictly) {
            var _a = getCheckedKeysByInitKeys(keys, key2nodeProps), allCheckedKeys = _a.checkedKeys, halfKeys = _a.indeterminateKeys;
            var checkedKeys_1 = allCheckedKeys;
            indeterminateKeys.current = halfKeys;
            if (props.treeCheckedStrategy === Tree$1.SHOW_PARENT) {
                checkedKeys_1 = checkedKeys_1.filter(function (x) {
                    var item = key2nodeProps[x];
                    if (!item || checkedKeys_1.indexOf(item.parentKey) === -1) {
                        return true;
                    }
                });
            }
            else if (props.treeCheckedStrategy === Tree$1.SHOW_CHILD) {
                checkedKeys_1 = checkedKeys_1.filter(function (x) {
                    var item = key2nodeProps[x];
                    if (!item || !item.children || !item.children.length) {
                        return true;
                    }
                });
            }
            return checkedKeys_1;
        }
        indeterminateKeys.current = [];
        return keys;
    };
    var useStateValue = function (props, key2nodeProps, indeterminateKeys) {
        var valueCopy = React.useRef([]);
        var calcValue = function () {
            var propsValue = props.value || props.defaultValue || [];
            if (props.treeCheckable) {
                var initCheckedKeys = getInitCheckKeys(normalizeValueToArray(propsValue), key2nodeProps, indeterminateKeys, props);
                var parsedPropValue = parseValue(propsValue, key2nodeProps, valueCopy.current);
                var parsedCheckedValue = parseValue(initCheckedKeys, key2nodeProps, parsedPropValue);
                return parsedCheckedValue;
            }
            return parseValue(propsValue, key2nodeProps);
        };
        var _a = __read$b(React.useState(calcValue), 2), value = _a[0], _setValue = _a[1];
        var setValue = function (value) {
            valueCopy.current = value;
            _setValue(value);
        };
        useUpdate(function () {
            var nextValue = calcValue();
            if ('value' in props) {
                if (props.labelInValue) {
                    // 以外部传入为准,只比较value
                    if (!isEqualWith_1(normalizeValueToArray(value), normalizeValueToArray(nextValue))) {
                        setValue(nextValue);
                    }
                }
                else if (!isEqualWith_1(value, nextValue)) {
                    setValue(nextValue);
                }
            }
        }, [
            props.treeCheckedStrategy,
            props.treeCheckStrictly,
            props.treeCheckable,
            props.value,
            key2nodeProps,
        ]);
        var setStateValue = React.useCallback(function (newValue, extra) {
            var onChange = props.onChange, labelInValue = props.labelInValue;
            var multiple = props.multiple || props.treeCheckable;
            if (!('value' in props)) {
                setValue(newValue);
            }
            var tmp;
            if (multiple) {
                tmp = newValue.map(function (x) {
                    return labelInValue ? { label: x.label, value: x.value } : x.value;
                });
            }
            else {
                tmp = labelInValue ? newValue[0] : newValue[0] && newValue[0].value;
            }
            onChange && onChange(tmp, extra);
        }, [props.onChange, props.labelInValue, props.multiple, props.treeCheckable, props.value]);
        return [value, setStateValue];
    };
    var useStateValue$1 = useStateValue;

    var DefaultFieldNames = {
        key: 'key',
        title: 'title',
        children: 'children',
        selectable: 'selectable',
        disabled: 'disabled',
        disableCheckbox: 'disableCheckbox',
        checkable: 'checkable',
        isLeaf: 'isLeaf',
    };

    var __read$a = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    function useTreeData(props) {
        var prevProps = usePrevious(props) || {};
        var getData = function () {
            return props.treeData || getTreeDataFromTreeChildren(props.children);
        };
        var _a = __read$a(React.useState(getData()), 2), treeData = _a[0], setTreeData = _a[1];
        useUpdate(function () {
            if (props.treeData !== prevProps.treeData || props.children !== prevProps.children) {
                setTreeData(getData());
            }
        }, [props]);
        return [treeData];
    }

    var __assign$c = (undefined && undefined.__assign) || function () {
        __assign$c = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$c.apply(this, arguments);
    };
    var __read$9 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$3 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var getKey2NodeProps = function (treedata, prefixCls, fieldNames) {
        var key2nodeProps = {};
        var currentIndex = 0;
        var loop = function (treeData, father) {
            var totalLength = treeData.length;
            return treeData.map(function (data, index) {
                var children = data[fieldNames.children];
                var key = fieldNames.key in data ? data[fieldNames.key] : ((father === null || father === void 0 ? void 0 : father._key) || '') + "-" + index;
                var nodeProps = __assign$c(__assign$c({}, data), { title: data[fieldNames.title], selectable: data[fieldNames.selectable], disabled: data[fieldNames.disabled], disableCheckbox: data[fieldNames.disableCheckbox], checkable: data[fieldNames.checkable], isLeaf: data[fieldNames.isLeaf], key: key, children: children, _key: key, parentKey: father ? father._key : undefined, pathParentKeys: (father && father.pathParentKeys) || [], _level: father._level || 0, _index: currentIndex++ });
                if (totalLength === index + 1) {
                    nodeProps.className = cs(prefixCls + "-node-is-tail", nodeProps.className);
                }
                key2nodeProps[key] = nodeProps;
                if (children && children.length) {
                    key2nodeProps[key].children = loop(children, {
                        _key: key,
                        _level: nodeProps._level + 1,
                        pathParentKeys: __spreadArray$3(__spreadArray$3([], __read$9(((father === null || father === void 0 ? void 0 : father.pathParentKeys) || [])), false), [key], false),
                    });
                }
                return nodeProps;
            });
        };
        loop(treedata || [], {});
        return key2nodeProps;
    };
    var useKeyCache = function (treeData, fieldNames) {
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var _fieldNames = __assign$c(__assign$c({}, DefaultFieldNames), fieldNames);
        var dispatch = useForceUpdate();
        var prefixCls = getPrefixCls('tree');
        var cache = React.useRef(getKey2NodeProps(treeData, prefixCls, _fieldNames));
        useUpdate(function () {
            cache.current = getKey2NodeProps(treeData, prefixCls, _fieldNames);
            dispatch();
        }, [treeData]);
        return cache.current;
    };
    var useKeyCache$1 = useKeyCache;

    var __assign$b = (undefined && undefined.__assign) || function () {
        __assign$b = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$b.apply(this, arguments);
    };
    var __read$8 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$2 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    function TreeList(props, ref) {
        var value = props.value, multiple = props.multiple, loadMore = props.loadMore, treeCheckedStrategy = props.treeCheckedStrategy, treeCheckStrictly = props.treeCheckStrictly, treeData = props.treeData, treeProps = props.treeProps, prefixCls = props.prefixCls, treeCheckable = props.treeCheckable;
        var propsRenderTitle = treeProps && treeProps.renderTitle;
        var treeRef = React.useRef();
        var handleCheck = React.useCallback(function (keys, _a) {
            var checkedNodes = _a.checkedNodes, checked = _a.checked, node = _a.node;
            var newValue = keys.map(function (key) {
                var item = checkedNodes.find(function (x) { return x && x.props._key === key; });
                if (!item) {
                    var tmp = value.find(function (x) { return x.value === key; });
                    return (tmp || {
                        label: key,
                        value: key,
                    });
                }
                return {
                    label: item.props.title,
                    value: item.props._key,
                    disabled: item.props.disabled,
                };
            });
            props.onChange(newValue, {
                checked: checked,
                trigger: node === null || node === void 0 ? void 0 : node.props,
            });
        }, [props.onChange, value]);
        var handleChange = React.useCallback(function (_, _a) {
            var node = _a.node, selected = _a.selected;
            var newValue = [
                {
                    value: node.props._key,
                    label: node.props.title,
                },
            ];
            if (multiple) {
                newValue = __spreadArray$2([], __read$8(value), false);
                var index = newValue.findIndex(function (x) { return x.value === node.props._key; });
                if (index > -1) {
                    newValue.splice(index, 1);
                }
                else {
                    newValue.push({
                        value: node.props._key,
                        label: node.props.title,
                    });
                }
            }
            props.onChange(newValue, { trigger: node === null || node === void 0 ? void 0 : node.props, selected: selected });
        }, [props.onChange, value, multiple]);
        var handleCheckableSelect = React.useCallback(function (_, _a) {
            var node = _a.node, e = _a.e;
            var _b = node.props, checked = _b.checked, checkable = _b.checkable, disabled = _b.disabled, disableCheckbox = _b.disableCheckbox;
            if (treeRef.current && !disableCheckbox && !disabled && checkable !== false) {
                treeRef.current.handleCheck && treeRef.current.handleCheck(!checked, node.props._key, e);
            }
        }, []);
        var handleLoadMore = React.useCallback(function (treeNode) {
            if (isFunction$1(loadMore)) {
                var dataRef = treeNode.props.dataRef;
                return loadMore(treeNode, dataRef);
            }
            return [];
        }, [loadMore]);
        var renderTitle = React.useCallback(function (nodeProps) {
            if (propsRenderTitle) {
                return propsRenderTitle(nodeProps);
            }
            var inputValue = props.inputValue;
            var title = nodeProps.title;
            if (inputValue && isString(title)) {
                var index = title.toLowerCase().indexOf(inputValue.toLowerCase());
                if (index === -1) {
                    return title;
                }
                var prefix = title.substr(0, index);
                var suffix = title.substr(index + inputValue.length);
                return (React.createElement("span", null,
                    prefix,
                    React.createElement("span", { className: prefixCls + "-highlight" }, title.substr(index, inputValue.length)),
                    suffix));
            }
            return title;
        }, [prefixCls, props.inputValue, propsRenderTitle]);
        var extraProps = React.useMemo(function () {
            return props.treeCheckable
                ? {
                    onCheck: handleCheck,
                    checkedKeys: value.map(function (x) { return x.value; }),
                }
                : {};
        }, [handleCheck, value, props.treeCheckable]);
        var selectedKeys = React.useMemo(function () {
            return props.treeCheckable ? [] : value.map(function (x) { return x.value; });
        }, [props.treeCheckable, value]);
        var onSelect = React.useCallback(function (_, extra) {
            props.treeCheckable ? handleCheckableSelect(_, extra) : handleChange(_, extra);
        }, [props.treeCheckable, handleCheckableSelect, handleChange]);
        React.useImperativeHandle(ref, function () {
            return treeRef.current;
        }, []);
        return (React.createElement(Tree$1, __assign$b({ ref: treeRef, size: props.size, blockNode: true, filterNode: props.filterNode }, treeProps, { checkable: treeCheckable, multiple: multiple, loadMore: props.loadMore ? handleLoadMore : undefined, checkedStrategy: treeCheckedStrategy, checkStrictly: treeCheckStrictly, onMouseDown: function (e) {
                e.preventDefault();
            } }, extraProps, { treeData: treeData, fieldNames: props.fieldNames, renderTitle: renderTitle, onSelect: onSelect, selectedKeys: selectedKeys })));
    }
    var TreeList$1 = React.forwardRef(TreeList);

    var __assign$a = (undefined && undefined.__assign) || function () {
        __assign$a = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$a.apply(this, arguments);
    };
    var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$1 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __read$7 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray$1 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    function isEmptyValue(value) {
        return (!value ||
            (isArray$1(value) && value.length === 0) ||
            (isObject$1(value) && Object.keys(value).length === 0));
    }
    var defaultProps$3 = {
        bordered: true,
        treeCheckedStrategy: Tree$1.SHOW_CHILD,
        fieldNames: DefaultFieldNames,
    };
    var TreeSelect$2 = function (baseProps, ref) {
        var _a = React.useContext(ConfigContext), getPrefixCls = _a.getPrefixCls, renderEmpty = _a.renderEmpty, componentConfig = _a.componentConfig, rtl = _a.rtl;
        var props = useMergeProps(baseProps, defaultProps$3, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.TreeSelect);
        var refIsFirstRender = useIsFirstRender();
        var triggerRef = React.useRef();
        var treeRef = React.useRef(null);
        var refSelectView = React.useRef(null);
        var indeterminateKeys = React.useRef([]);
        var _b = __read$7(useTreeData(props), 1), treeData = _b[0];
        var key2nodeProps = useKeyCache$1(treeData, props.fieldNames);
        var _c = __read$7(React.useState(), 2), hitKeys = _c[0], setHitKeys = _c[1];
        var _d = __read$7(useMergeValue(false, {
            value: props.popupVisible,
        }), 2), popupVisible = _d[0], setPopupVisible = _d[1];
        var _e = __read$7(useMergeValue(undefined, // Compatible with previous behavior 'undefined as default'
        {
            value: 'inputValue' in props ? props.inputValue || '' : undefined,
        }), 2), inputValue = _e[0], setInputValue = _e[1];
        // 触发 onInputValueChange 回调的值
        var refOnInputChangeCallbackValue = React.useRef(inputValue);
        // 触发 onInputValueChange 回调的原因
        var refOnInputChangeCallbackReason = React.useRef(null);
        var onInputValueChange = props.onInputValueChange;
        var _f = __read$7(useStateValue$1(props, key2nodeProps, indeterminateKeys), 2), value = _f[0], setValue = _f[1];
        var multiple = props.multiple || props.treeCheckable;
        var prefixCls = getPrefixCls('tree-select');
        var isFilterNode = inputValue && !isFunction$1(props.onSearch);
        // Unique ID of this select instance
        var instancePopupID = useId(prefixCls + "-popup-");
        // 尝试更新 inputValue，并触发 onInputValueChange
        var tryUpdateInputValue = function (value, reason) {
            if (value !== refOnInputChangeCallbackValue.current ||
                reason !== refOnInputChangeCallbackReason.current) {
                setInputValue(value);
                refOnInputChangeCallbackValue.current = value;
                refOnInputChangeCallbackReason.current = reason;
                onInputValueChange && onInputValueChange(value, reason);
            }
        };
        var handleSearch = React.useCallback(function (inputText) {
            var search = debounce_1(function (inputText) { return __awaiter$1(void 0, void 0, void 0, function () {
                var hitKeys;
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!isFunction$1(props.onSearch)) return [3 /*break*/, 2];
                            return [4 /*yield*/, props.onSearch(inputText)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                        case 2:
                            if (!inputText)
                                return [2 /*return*/, treeData];
                            hitKeys = new Set();
                            Object.keys(key2nodeProps).forEach(function (key) {
                                var nodeProps = key2nodeProps[key];
                                var isHit = false;
                                if (isFunction$1(props.filterTreeNode)) {
                                    // @ts-ignore
                                    if (props.filterTreeNode(inputText, React.createElement(Tree$1.Node, __assign$a({}, nodeProps)))) {
                                        isHit = true;
                                    }
                                }
                                else {
                                    var text = nodeProps.value || nodeProps._key;
                                    if (text && text.indexOf(inputText) > -1) {
                                        isHit = true;
                                    }
                                }
                                if (isHit) {
                                    hitKeys.add(nodeProps.key);
                                }
                            });
                            setHitKeys(hitKeys);
                            return [2 /*return*/];
                    }
                });
            }); }, 100);
            return search(inputText);
        }, [props.onSearch, treeData, key2nodeProps, props.filterTreeNode]);
        var resetInputValue = React.useCallback(function () {
            // 多选选中值时候不清除搜索文本
            var retainInputValueWhileSelect = true;
            if (isObject$1(props.showSearch)) {
                retainInputValueWhileSelect = props.showSearch.retainInputValueWhileSelect !== false;
            }
            // default scene: inputValue = refOnInputChangeCallbackValue =  undefined
            // if updateTo ''，will trigger an unnecessary onsearch
            if (props.multiple && !retainInputValueWhileSelect && inputValue !== undefined) {
                tryUpdateInputValue('', 'optionChecked');
            }
        }, [inputValue, props.multiple, JSON.stringify(props.showSearch)]);
        var triggerChange = React.useCallback(function (newValue, extra) {
            setValue(newValue, extra);
            resetInputValue();
            if (!multiple) {
                setPopupVisible(false);
            }
        }, [setValue, resetInputValue]);
        var handleRemoveCheckedItem = function (item, index, e) {
            e.stopPropagation();
            if (item.disabled) {
                return;
            }
            if (!props.treeCheckable || props.treeCheckStrictly || !key2nodeProps[item.value]) {
                var newValue = value.filter(function (_, i) { return i !== index; });
                triggerChange(newValue, {
                    trigger: key2nodeProps[item.value] || item,
                    checked: false,
                    selected: false,
                });
                return;
            }
            var result = getAllCheckedKeysByCheck(item.value, false, normalizeValueToArray(value), key2nodeProps, indeterminateKeys.current);
            indeterminateKeys.current = result.indeterminateKeys;
            triggerChange(parseValue(result.checkedKeys, key2nodeProps, value), {
                trigger: key2nodeProps[item.value],
                checked: false,
                selected: false,
            });
        };
        React.useEffect(function () {
            inputValue !== undefined && handleSearch(inputValue);
            if (inputValue !== refOnInputChangeCallbackValue.current) {
                refOnInputChangeCallbackValue.current = inputValue;
            }
        }, [inputValue]);
        var searchKeys = React.useMemo(function () {
            var newKeys = [];
            if (inputValue) {
                for (var key in key2nodeProps) {
                    var item = key2nodeProps[key];
                    var pathKeys = __spreadArray$1(__spreadArray$1([], __read$7(item.pathParentKeys), false), [key], false);
                    if (pathKeys.some(function (_key) { return hitKeys && hitKeys.has(_key); })) {
                        newKeys = newKeys.concat(pathKeys);
                    }
                }
            }
            return Array.from(new Set(newKeys));
        }, [inputValue, key2nodeProps, hitKeys]);
        React.useEffect(function () {
            if (popupVisible) {
                setTimeout(function () {
                    var target = value[0];
                    if (treeRef.current && target) {
                        treeRef.current.scrollIntoView(target.value);
                    }
                });
            }
            else if (!refIsFirstRender) {
                inputValue && tryUpdateInputValue('', 'optionListHide');
            }
        }, [popupVisible]);
        React.useImperativeHandle(ref, function () { return ({
            focus: function () {
                refSelectView.current && refSelectView.current.focus();
            },
            blur: function () {
                refSelectView.current && refSelectView.current.blur();
            },
        }); });
        var filterNode = React.useCallback(function (node) {
            return isFilterNode ? searchKeys.indexOf(node._key) > -1 : true;
        }, [isFilterNode, searchKeys]);
        var renderText = React.useCallback(function (val) {
            var _a = val || {}, _b = _a.label, label = _b === void 0 ? '' : _b, disabled = _a.disabled;
            return { text: label, disabled: disabled };
        }, []);
        var tryUpdateSelectValue = function (value) {
            setValue(value, {});
        };
        var renderView = function (eleView) {
            return (React.createElement(Trigger$1, __assign$a({ autoAlignPopupWidth: false, autoAlignPopupMinWidth: true, ref: triggerRef, classNames: "slideDynamicOrigin", trigger: "click", position: "bl", getPopupContainer: props.getPopupContainer, popupAlign: { bottom: 4 }, unmountOnExit: props.unmountOnExit }, props.triggerProps, { className: cs(prefixCls + "-trigger", props.triggerProps && props.triggerProps.className), popup: function () {
                    var _a;
                    var _b, _c, _d;
                    var dropdownRender = props.dropdownRender;
                    var dom = (isFilterNode && isEmptyValue(searchKeys)) || isEmptyValue(treeData) ? (props.notFoundContent || renderEmpty('TreeSelect')) : (React.createElement(TreeList$1, __assign$a({ prefixCls: prefixCls, ref: treeRef }, props, { inputValue: inputValue, filterNode: filterNode, value: value, onChange: triggerChange, multiple: multiple, treeData: treeData })));
                    return (React.createElement("div", { id: instancePopupID, className: cs(prefixCls + "-popup", (_a = {}, _a[prefixCls + "-rtl-popup"] = rtl, _a)), style: __assign$a({ maxHeight: ((_b = props.treeProps) === null || _b === void 0 ? void 0 : _b.height) || ((_d = (_c = props.treeProps) === null || _c === void 0 ? void 0 : _c.virtualListProps) === null || _d === void 0 ? void 0 : _d.height)
                                ? 'unset'
                                : '' }, props.dropdownMenuStyle) }, isFunction$1(dropdownRender) ? dropdownRender(dom) : dom));
                }, disabled: props.disabled, onVisibleChange: function (visible) {
                    setPopupVisible(visible);
                    props.onVisibleChange && props.onVisibleChange(visible);
                }, popupVisible: popupVisible }), eleView));
        };
        var customTriggerElement = typeof props.triggerElement === 'function'
            ? (function () {
                var _a;
                var valueForCallback;
                if (multiple) {
                    valueForCallback = value.map(function (x) {
                        return props.labelInValue ? { label: x.label, value: x.value } : x.value;
                    });
                }
                else {
                    valueForCallback = props.labelInValue ? value[0] : (_a = value[0]) === null || _a === void 0 ? void 0 : _a.value;
                }
                return props.triggerElement({ value: valueForCallback });
            })()
            : props.triggerElement;
        return !isNullOrUndefined(customTriggerElement) ? (renderView(customTriggerElement)) : (React.createElement(SelectView$1, __assign$a({ ref: refSelectView, rtl: rtl, ariaControls: instancePopupID }, props, { popupVisible: popupVisible, value: !multiple && isArray$1(value) ? value[0] : value, inputValue: inputValue, 
            // other
            isEmptyValue: isEmptyValue(value), prefixCls: prefixCls, isMultiple: multiple, renderText: renderText, onSort: tryUpdateSelectValue, onRemoveCheckedItem: handleRemoveCheckedItem, onClear: function (e) {
                var _a;
                e.stopPropagation();
                triggerChange([], {});
                (_a = props.onClear) === null || _a === void 0 ? void 0 : _a.call(props, !!popupVisible);
            }, onKeyDown: function (e) {
                var _a;
                e.stopPropagation();
                (_a = props.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(props, e);
            }, onFocus: function (e) {
                e && e.stopPropagation();
            }, onChangeInputValue: function (value) {
                tryUpdateInputValue(value, 'manual');
            }, renderView: renderView })));
    };
    var ForwardRefTreeSelect = React.forwardRef(TreeSelect$2);
    var TreeSelectComponent = ForwardRefTreeSelect;
    TreeSelectComponent.displayName = 'TreeSelect';
    TreeSelectComponent.Node = Tree$1.Node;
    TreeSelectComponent.SHOW_ALL = Tree$1.SHOW_ALL;
    TreeSelectComponent.SHOW_PARENT = Tree$1.SHOW_PARENT;
    TreeSelectComponent.SHOW_CHILD = Tree$1.SHOW_CHILD;
    var TreeSelect$3 = TreeSelectComponent;

    var STATUS = {
        init: 'init',
        uploading: 'uploading',
        success: 'done',
        fail: 'error',
    };

    function ownKeys$g(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$h(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$g(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$g(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconUploadComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$h(_objectSpread$h({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-upload")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M14.93 17.071 24.001 8l9.071 9.071m-9.07 16.071v-25M40 35v6H8v-6"
      }));
    }

    var IconUpload = /*#__PURE__*/React.forwardRef(IconUploadComponent);
    IconUpload.defaultProps = {
      isIcon: true
    };
    IconUpload.displayName = 'IconUpload';
    var IconUpload$1 = IconUpload;

    function ownKeys$f(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$g(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$f(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$f(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconPlayArrowFillComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$g(_objectSpread$g({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-play-arrow-fill")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        stroke: "none",
        d: "M17.533 10.974a1 1 0 0 0-1.537.844v24.356a1 1 0 0 0 1.537.844L36.67 24.84a1 1 0 0 0 0-1.688L17.533 10.974Z"
      }));
    }

    var IconPlayArrowFill = /*#__PURE__*/React.forwardRef(IconPlayArrowFillComponent);
    IconPlayArrowFill.defaultProps = {
      isIcon: true
    };
    IconPlayArrowFill.displayName = 'IconPlayArrowFill';
    var IconPlayArrowFill$1 = IconPlayArrowFill;

    function ownKeys$e(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$f(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$e(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$e(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconPauseComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$f(_objectSpread$f({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-pause")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M14 12H18V36H14z"
      }), /*#__PURE__*/React.createElement("path", {
        d: "M30 12H34V36H30z"
      }), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        stroke: "none",
        d: "M14 12H18V36H14z"
      }), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        stroke: "none",
        d: "M30 12H34V36H30z"
      }));
    }

    var IconPause = /*#__PURE__*/React.forwardRef(IconPauseComponent);
    IconPause.defaultProps = {
      isIcon: true
    };
    IconPause.displayName = 'IconPause';
    var IconPause$1 = IconPause;

    var __assign$9 = (undefined && undefined.__assign) || function () {
        __assign$9 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$9.apply(this, arguments);
    };
    var UploadProgress = function (props) {
        var keyboardEvents = useKeyboardEvent();
        var file = props.file, prefixCls = props.prefixCls, progressProps = props.progressProps, progressRender = props.progressRender;
        var locale = React.useContext(ConfigContext).locale;
        var status = file.status, _a = file.percent, percent = _a === void 0 ? 0 : _a;
        var cls = prefixCls + "-list";
        var widthStyle = progressProps && progressProps.width ? { width: progressProps.width } : {};
        var dom = (React.createElement(React.Fragment, null,
            status === STATUS.fail && props.reuploadIcon !== null && (React.createElement("span", __assign$9({ className: prefixCls + "-list-reupload-icon", onClick: function () {
                    props.onReupload && props.onReupload(file);
                }, tabIndex: 0, role: "button", "aria-label": locale.Upload.reupload }, keyboardEvents({
                onPressEnter: function () {
                    props.onReupload && props.onReupload(file);
                },
            })), props.reuploadIcon ||
                (props.listType === 'picture-card' ? React.createElement(IconUpload$1, null) : locale.Upload.reupload))),
            status === STATUS.success && props.successIcon !== null && (React.createElement("span", { className: prefixCls + "-list-success-icon" }, props.successIcon || React.createElement(IconCheck$1, null))),
            status !== STATUS.success && (React.createElement("div", { className: cls + "-status", style: widthStyle },
                React.createElement(Progress$1, __assign$9({ showText: false, className: cls + "-progress", type: "circle", status: status === STATUS.fail ? 'error' : status === STATUS.success ? 'success' : 'normal', percent: percent, size: "mini" }, progressProps)),
                status === STATUS.init && props.startIcon !== null && (React.createElement("span", __assign$9({ tabIndex: 0, role: "button", "aria-label": locale.Upload.start, className: prefixCls + "-list-start-icon", onClick: function () {
                        props.onUpload && props.onUpload(file);
                    } }, keyboardEvents({
                    onPressEnter: function () {
                        props.onUpload && props.onUpload(file);
                    },
                })), props.startIcon || (React.createElement(Tooltip$1, { content: locale.Upload.start },
                    React.createElement(IconPlayArrowFill$1, null))))),
                status === STATUS.uploading && props.cancelIcon !== null && (React.createElement("span", __assign$9({ className: props.prefixCls + "-list-cancel-icon", onClick: function () {
                        props.onAbort && props.onAbort(file);
                    }, tabIndex: 0, "aria-label": locale.Upload.cancel }, keyboardEvents({
                    onPressEnter: function () {
                        props.onAbort && props.onAbort(file);
                    },
                })), props.cancelIcon || (React.createElement(Tooltip$1, { content: locale.Upload.cancel },
                    React.createElement(IconPause$1, null)))))))));
        return isFunction$1(progressRender) ? progressRender(file, dom) : dom;
    };
    var UploadProgress$1 = UploadProgress;

    function ownKeys$d(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$e(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$d(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$d(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconImageCloseComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$e(_objectSpread$e({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-image-close")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M41 26V9a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v30a2 2 0 0 0 2 2h17"
      }), /*#__PURE__*/React.createElement("path", {
        d: "m24 33 9-8.5V27s-2 1-3.5 2.5C27.841 31.159 27 33 27 33h-3Zm0 0-3.5-4.5L17 33h7Z"
      }), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        stroke: "none",
        d: "M20.5 28.5 17 33h7l-3.5-4.5ZM33 24.5 24 33h3s.841-1.841 2.5-3.5C31 28 33 27 33 27v-2.5Z"
      }), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        fillRule: "evenodd",
        stroke: "none",
        d: "M46 38a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-4.95-4.782 1.74 1.74-3.045 3.046 3.046 3.046-1.74 1.74-3.047-3.045-3.046 3.046-1.74-1.74 3.046-3.047-3.046-3.046 1.74-1.74 3.046 3.046 3.046-3.046Z",
        clipRule: "evenodd"
      }), /*#__PURE__*/React.createElement("path", {
        d: "M17 15h-2v2h2v-2Z"
      }));
    }

    var IconImageClose = /*#__PURE__*/React.forwardRef(IconImageCloseComponent);
    IconImageClose.defaultProps = {
      isIcon: true
    };
    IconImageClose.displayName = 'IconImageClose';
    var IconImageClose$1 = IconImageClose;

    var __assign$8 = (undefined && undefined.__assign) || function () {
        __assign$8 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$8.apply(this, arguments);
    };
    var PictureItem = function (props) {
        var disabled = props.disabled, prefixCls = props.prefixCls, file = props.file, showUploadList = props.showUploadList, locale = props.locale;
        var keyboardEvents = useKeyboardEvent();
        var cls = prefixCls + "-list-item-picture";
        var status = file.status, originFile = file.originFile;
        var url = file.url !== undefined
            ? file.url
            : originFile && isFunction$1(URL.createObjectURL) && URL.createObjectURL(originFile);
        var actionIcons = isObject$1(showUploadList) ? showUploadList : {};
        return (React.createElement("div", { className: cls }, status === STATUS.uploading ? (React.createElement(UploadProgress$1, __assign$8({ onReupload: props.onReupload, onUpload: props.onUpload, onAbort: props.onAbort, listType: "picture-card", file: file, prefixCls: prefixCls, progressProps: props.progressProps }, actionIcons))) : (React.createElement(React.Fragment, null,
            isFunction$1(actionIcons.imageRender) ? (actionIcons.imageRender(file)) : (React.createElement("img", { src: url, alt: file.name })),
            React.createElement("div", { className: cls + "-mask", role: "radiogroup" },
                file.status === STATUS.fail && (React.createElement("div", { className: cls + "-error-tip" }, actionIcons.errorIcon !== null && (React.createElement("span", { className: prefixCls + "-list-error-icon" }, actionIcons.errorIcon || React.createElement(IconImageClose$1, null))))),
                React.createElement("div", { className: cls + "-operation" },
                    file.status !== STATUS.fail && actionIcons.previewIcon !== null && (React.createElement("span", __assign$8({ className: prefixCls + "-list-preview-icon", tabIndex: 0, role: "button", "aria-label": locale.Upload.preview }, keyboardEvents({
                        onPressEnter: function () {
                            props.onPreview && props.onPreview(file);
                        },
                    }), { onClick: function () {
                            props.onPreview && props.onPreview(file);
                        } }), actionIcons.previewIcon || React.createElement(IconEye$1, null))),
                    file.status === STATUS.fail && actionIcons.reuploadIcon !== null && (React.createElement("span", __assign$8({ className: props.prefixCls + "-list-reupload-icon", onClick: function () {
                            props.onReupload && props.onReupload(file);
                        }, tabIndex: 0, role: "button", "aria-label": locale.Upload.reupload }, keyboardEvents({
                        onPressEnter: function () {
                            props.onReupload && props.onReupload(file);
                        },
                    })), actionIcons.reuploadIcon || React.createElement(IconUpload$1, null))),
                    !disabled && actionIcons.removeIcon !== null && (React.createElement("span", __assign$8({ className: prefixCls + "-list-remove-icon", onClick: function () {
                            props.onRemove && props.onRemove(file);
                        }, role: "button", "aria-label": locale.Upload.delete, tabIndex: 0 }, keyboardEvents({
                        onPressEnter: function () {
                            props.onRemove && props.onRemove(file);
                        },
                    })), actionIcons.removeIcon || React.createElement(IconDelete$1, null)))))))));
    };
    var PictureItem$1 = PictureItem;

    function ownKeys$c(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$d(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$c(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$c(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconFilePdfComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$d(_objectSpread$d({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-file-pdf")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M11 42h26a2 2 0 0 0 2-2V13.828a2 2 0 0 0-.586-1.414l-5.828-5.828A2 2 0 0 0 31.172 6H11a2 2 0 0 0-2 2v32a2 2 0 0 0 2 2Z"
      }), /*#__PURE__*/React.createElement("path", {
        d: "M22.305 21.028c.874 1.939 3.506 6.265 4.903 8.055 1.747 2.237 3.494 2.685 4.368 2.237.873-.447 1.21-4.548-7.425-2.685-7.523 1.623-7.424 3.58-6.988 4.476.728 1.193 2.522 2.627 5.678-6.266C25.699 18.79 24.489 17 23.277 17c-1.409 0-2.538.805-.972 4.028Z"
      }));
    }

    var IconFilePdf = /*#__PURE__*/React.forwardRef(IconFilePdfComponent);
    IconFilePdf.defaultProps = {
      isIcon: true
    };
    IconFilePdf.displayName = 'IconFilePdf';
    var IconFilePdf$1 = IconFilePdf;

    function ownKeys$b(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$c(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$b(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$b(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconFileImageComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$c(_objectSpread$c({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-file-image")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "m26 33 5-6v6h-5Zm0 0-3-4-4 4h7Zm11 9H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2ZM17 19h1v1h-1v-1Z"
      }));
    }

    var IconFileImage = /*#__PURE__*/React.forwardRef(IconFileImageComponent);
    IconFileImage.defaultProps = {
      isIcon: true
    };
    IconFileImage.displayName = 'IconFileImage';
    var IconFileImage$1 = IconFileImage;

    function ownKeys$a(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$b(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$a(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$a(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconFileVideoComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$b(_objectSpread$b({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-file-video")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M37 42H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2Z"
      }), /*#__PURE__*/React.createElement("path", {
        d: "M22 27.796v-6l5 3-5 3Z"
      }));
    }

    var IconFileVideo = /*#__PURE__*/React.forwardRef(IconFileVideoComponent);
    IconFileVideo.defaultProps = {
      isIcon: true
    };
    IconFileVideo.displayName = 'IconFileVideo';
    var IconFileVideo$1 = IconFileVideo;

    function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$a(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconFileAudioComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$a(_objectSpread$a({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-file-audio")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M37 42H11a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h21l7 7v27a2 2 0 0 1-2 2Z"
      }), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        stroke: "none",
        d: "M25 30a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"
      }), /*#__PURE__*/React.createElement("path", {
        d: "M25 30a3 3 0 1 1-6 0 3 3 0 0 1 6 0Zm0 0-.951-12.363a.5.5 0 0 1 .58-.532L30 18"
      }));
    }

    var IconFileAudio = /*#__PURE__*/React.forwardRef(IconFileAudioComponent);
    IconFileAudio.defaultProps = {
      isIcon: true
    };
    IconFileAudio.displayName = 'IconFileAudio';
    var IconFileAudio$1 = IconFileAudio;

    var __assign$7 = (undefined && undefined.__assign) || function () {
        __assign$7 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$7.apply(this, arguments);
    };
    var getIconType = function (file) {
        var type = '';
        if (file.originFile && file.originFile.type) {
            // 上传文件
            type = file.originFile.type;
        }
        else {
            var name_1 = file.name || '';
            var fileExtension = name_1.split('.').pop() || '';
            type = fileExtension;
            if (['png', 'jpg', 'jpeg', 'bmp', 'gif'].indexOf(fileExtension) > -1) {
                type = 'image';
            }
            else if (['mp4', 'm2v', 'mkv'].indexOf(fileExtension) > -1) {
                type = 'video';
            }
            else if (['mp3', 'wav', 'wmv'].indexOf(fileExtension) > -1) {
                type = 'audio';
            }
        }
        if (type.indexOf('image') > -1) {
            return IconFileImage$1;
        }
        if (type.indexOf('pdf') > -1) {
            return IconFilePdf$1;
        }
        if (type.indexOf('audio') > -1) {
            return IconFileAudio$1;
        }
        if (type.indexOf('video') > -1) {
            return IconFileVideo$1;
        }
        return IconFile$1;
    };
    var TextItem = function (props) {
        var prefixCls = props.prefixCls, disabled = props.disabled, file = props.file, locale = props.locale;
        var cls = prefixCls + "-list-item-text";
        var getKeyboardEvents = useKeyboardEvent();
        var Icon = getIconType(file);
        var showUploadList = isObject$1(props.showUploadList)
            ? props.showUploadList
            : {};
        // custom icons
        var actionIcons = isObject$1(showUploadList) ? showUploadList : {};
        var fileName = file.name || (file.originFile && file.originFile.name);
        var url = file.url !== undefined
            ? file.url
            : file.originFile && isFunction$1(URL.createObjectURL) && URL.createObjectURL(file.originFile);
        var triggerProps = {};
        // 重新上传后，如果成功，但是鼠标仍然hover在内容区，错误提示不会消失。所以需要设置 popupVisible 为false，来隐藏tooltip
        if (file.status !== STATUS.fail) {
            triggerProps = {
                popupVisible: false,
            };
        }
        return (React.createElement("div", { className: prefixCls + "-list-item " + prefixCls + "-list-item-" + file.status },
            React.createElement("div", { className: cls },
                props.listType === 'picture-list' && (React.createElement("div", { className: cls + "-thumbnail" }, isFunction$1(showUploadList.imageRender) ? (showUploadList.imageRender(file)) : (React.createElement("img", { src: url })))),
                React.createElement("div", { className: cls + "-content" },
                    React.createElement("div", { className: cls + "-name" },
                        props.listType === 'text' && actionIcons.fileIcon !== null && (React.createElement("span", { className: prefixCls + "-list-file-icon" }, actionIcons.fileIcon || React.createElement(Icon, null))),
                        isFunction$1(showUploadList.fileName) ? (React.createElement("span", { className: cls + "-name-text" }, showUploadList.fileName(file))) : file.url ? (React.createElement("a", { href: file.url, target: "_blank", rel: "noreferrer", className: cls + "-name-link" }, fileName)) : (React.createElement("span", { className: cls + "-name-text" }, fileName)),
                        file.status === STATUS.fail && actionIcons.errorIcon !== null && (React.createElement(Tooltip$1, __assign$7({ content: file.response || locale.Upload.error }, triggerProps, { disabled: file.status !== STATUS.fail }),
                            React.createElement("span", { className: props.prefixCls + "-list-error-icon" }, actionIcons.errorIcon ||
                                (props.listType === 'picture-card' ? (React.createElement(IconFileImage$1, null)) : (React.createElement(IconExclamationCircleFill$1, null))))))),
                    React.createElement(UploadProgress$1, __assign$7({ file: file, prefixCls: prefixCls, progressProps: props.progressProps, onReupload: props.onReupload, onUpload: props.onUpload, onAbort: props.onAbort }, actionIcons)))),
            React.createElement("div", { className: prefixCls + "-list-item-operation" }, !disabled && actionIcons.removeIcon !== null && (React.createElement(IconHover, __assign$7({ className: prefixCls + "-list-remove-icon-hover", onClick: function () {
                    props.onRemove && props.onRemove(file);
                }, tabIndex: 0, "aria-label": locale.Upload.delete }, getKeyboardEvents({
                onPressEnter: function () {
                    props.onRemove && props.onRemove(file);
                },
            })),
                React.createElement("span", { className: prefixCls + "-list-remove-icon" }, actionIcons.removeIcon || React.createElement(IconDelete$1, null)))))));
    };
    var TextItem$1 = TextItem;

    function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconZoomOutComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$9(_objectSpread$9({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-zoom-out")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M32.607 32.607A14.953 14.953 0 0 0 37 22c0-8.284-6.716-15-15-15-8.284 0-15 6.716-15 15 0 8.284 6.716 15 15 15 4.142 0 7.892-1.679 10.607-4.393Zm0 0L41.5 41.5M29 22H15"
      }));
    }

    var IconZoomOut = /*#__PURE__*/React.forwardRef(IconZoomOutComponent);
    IconZoomOut.defaultProps = {
      isIcon: true
    };
    IconZoomOut.displayName = 'IconZoomOut';
    var IconZoomOut$1 = IconZoomOut;

    function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconZoomInComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$8(_objectSpread$8({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-zoom-in")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M32.607 32.607A14.953 14.953 0 0 0 37 22c0-8.284-6.716-15-15-15-8.284 0-15 6.716-15 15 0 8.284 6.716 15 15 15 4.142 0 7.892-1.679 10.607-4.393Zm0 0L41.5 41.5M29 22H15m7 7V15"
      }));
    }

    var IconZoomIn = /*#__PURE__*/React.forwardRef(IconZoomInComponent);
    IconZoomIn.defaultProps = {
      isIcon: true
    };
    IconZoomIn.displayName = 'IconZoomIn';
    var IconZoomIn$1 = IconZoomIn;

    function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconFullscreenComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$7(_objectSpread$7({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-fullscreen")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M42 17V9a1 1 0 0 0-1-1h-8M6 17V9a1 1 0 0 1 1-1h8m27 23v8a1 1 0 0 1-1 1h-8M6 31v8a1 1 0 0 0 1 1h8"
      }));
    }

    var IconFullscreen = /*#__PURE__*/React.forwardRef(IconFullscreenComponent);
    IconFullscreen.defaultProps = {
      isIcon: true
    };
    IconFullscreen.displayName = 'IconFullscreen';
    var IconFullscreen$1 = IconFullscreen;

    function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconRotateLeftComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$6(_objectSpread$6({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-rotate-left")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M10 22a1 1 0 0 1 1-1h20a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H11a1 1 0 0 1-1-1V22ZM23 11h11a6 6 0 0 1 6 6v6M22.5 12.893 19.587 11 22.5 9.107v3.786Z"
      }));
    }

    var IconRotateLeft = /*#__PURE__*/React.forwardRef(IconRotateLeftComponent);
    IconRotateLeft.defaultProps = {
      isIcon: true
    };
    IconRotateLeft.displayName = 'IconRotateLeft';
    var IconRotateLeft$1 = IconRotateLeft;

    function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconRotateRightComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$5(_objectSpread$5({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-rotate-right")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M38 22a1 1 0 0 0-1-1H17a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1h20a1 1 0 0 0 1-1V22ZM25 11H14a6 6 0 0 0-6 6v6M25.5 12.893 28.413 11 25.5 9.107v3.786Z"
      }));
    }

    var IconRotateRight = /*#__PURE__*/React.forwardRef(IconRotateRightComponent);
    IconRotateRight.defaultProps = {
      isIcon: true
    };
    IconRotateRight.displayName = 'IconRotateRight';
    var IconRotateRight$1 = IconRotateRight;

    function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconOriginalSizeComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$4(_objectSpread$4({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-original-size")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "m5.5 11.5 5-2.5h1v32M34 11.5 39 9h1v32"
      }), /*#__PURE__*/React.createElement("path", {
        fill: "currentColor",
        stroke: "none",
        d: "M24 17h1v1h-1v-1ZM24 30h1v1h-1v-1Z"
      }), /*#__PURE__*/React.createElement("path", {
        d: "M24 17h1v1h-1v-1ZM24 30h1v1h-1v-1Z"
      }));
    }

    var IconOriginalSize = /*#__PURE__*/React.forwardRef(IconOriginalSizeComponent);
    IconOriginalSize.defaultProps = {
      isIcon: true
    };
    IconOriginalSize.displayName = 'IconOriginalSize';
    var IconOriginalSize$1 = IconOriginalSize;

    var __read$6 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    function useImageStatus(defaultValue) {
        var _a = __read$6(React.useState(defaultValue), 2), status = _a[0], setStatus = _a[1];
        var isBeforeLoad = status === 'beforeLoad';
        var isLoading = status === 'loading';
        var isError = status === 'error';
        var isLoaded = status === 'loaded';
        return {
            status: status,
            isBeforeLoad: isBeforeLoad,
            isLoading: isLoading,
            isError: isError,
            isLoaded: isLoaded,
            setStatus: setStatus,
        };
    }

    var defaultScales = [
        25, 33, 50, 67, 75, 80, 90, 100, 110, 125, 150, 175, 200, 250, 300, 400, 500,
    ];
    var PreviewScales = /** @class */ (function () {
        function PreviewScales(scales) {
            this.updateScale(scales);
        }
        Object.defineProperty(PreviewScales.prototype, "scales", {
            get: function () {
                return this.scaleAttr;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PreviewScales.prototype, "minScale", {
            get: function () {
                return this.scaleAttr[0];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PreviewScales.prototype, "maxScale", {
            get: function () {
                return this.scaleAttr[this.scaleAttr.length - 1];
            },
            enumerable: false,
            configurable: true
        });
        PreviewScales.prototype.updateScale = function (scales) {
            var validScales = defaultScales;
            if (isArray$1(scales) && scales.filter(function (num) { return num > 0; }).length) {
                validScales = scales.filter(function (num) { return num > 0; });
            }
            validScales = validScales.map(function (num) { return +(num / 100).toFixed(2); });
            // 如果缩放比例中不含1， 则需要手动添加在最合适的位置
            if (!validScales.includes(1)) {
                var closestIndex = this.findClosestIndex(1, validScales);
                var closeSale = validScales[closestIndex];
                var addIndex = closeSale < 1 ? closestIndex + 1 : closestIndex;
                validScales.splice(addIndex, 0, 1);
            }
            this.scaleAttr = validScales;
        };
        PreviewScales.prototype.findClosestIndex = function (scale, scales) {
            if (scales === void 0) { scales = this.scaleAttr; }
            if (!scales.length)
                return;
            if (scales.length === 1)
                return 0;
            var closestIndex = scales.length - 1;
            for (var i = 0; i < scales.length; i++) {
                var current = scales[i];
                if (scale === current) {
                    closestIndex = i;
                    break;
                }
                if (scale < current) {
                    var pre = scales[i - 1];
                    closestIndex =
                        pre === undefined || Math.abs(pre - scale) <= Math.abs(current - scale) ? i - 1 : i;
                    break;
                }
            }
            return closestIndex;
        };
        PreviewScales.prototype.getNextScale = function (cur, type) {
            if (type === void 0) { type = 'zoomIn'; }
            var index = this.scaleAttr.indexOf(cur);
            if (index === -1) {
                index = this.findClosestIndex(cur);
            }
            if (type === 'zoomIn') {
                return index === this.scaleAttr.length - 1 ? cur : this.scaleAttr[index + 1];
            }
            return index === 0 ? cur : this.scaleAttr[index - 1];
        };
        return PreviewScales;
    }());
    var PreviewScales$1 = PreviewScales;

    function getFixTranslate(wrapperRect, imgRect, translateX, translateY, scale) {
        var fixTranslateX = translateX;
        var fixTranslateY = translateY;
        if (translateX) {
            // No translateX if width of img is smaller than width of wrapper
            if (wrapperRect.width > imgRect.width) {
                fixTranslateX = 0;
            }
            else {
                // Width of image is greater than width of wrapper
                if (imgRect.left > wrapperRect.left) {
                    // Reduce translateX to make image move to left if left side of image is within wrapper
                    fixTranslateX -= Math.abs(wrapperRect.left - imgRect.left) / scale;
                }
                if (imgRect.right < wrapperRect.right) {
                    // Enlarge translateX to make image move to right if right side of image is within wrapper
                    fixTranslateX += Math.abs(wrapperRect.right - imgRect.right) / scale;
                }
            }
        }
        if (translateY) {
            // No translateY if height of img is smaller than height of wrapper
            if (wrapperRect.height > imgRect.height) {
                fixTranslateY = 0;
            }
            else {
                // Height of image is greater than height of wrapper
                if (imgRect.top > wrapperRect.top) {
                    // Reduce translateY to make image move to top if top side of image is within wrapper
                    fixTranslateY -= Math.abs(wrapperRect.top - imgRect.top) / scale;
                }
                if (imgRect.bottom < wrapperRect.bottom) {
                    // Enlarge translateY to make image move to bottom if bottom side of image is within wrapper
                    fixTranslateY += Math.abs(wrapperRect.bottom - imgRect.bottom) / scale;
                }
            }
        }
        return [fixTranslateX, fixTranslateY];
    }

    var TriggerForToolbar = function (props) {
        var style = props.style, className = props.className, prefixCls = props.prefixCls, popup = props.popup, children = props.children;
        var classNames = cs(prefixCls + "-trigger", className);
        return (React.createElement(Trigger$1, { style: style, className: classNames, popup: popup, showArrow: true }, children));
    };

    var __assign$6 = (undefined && undefined.__assign) || function () {
        __assign$6 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$6.apply(this, arguments);
    };
    var __rest$4 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$5 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var ImagePreviewToolbar = function (props, ref) {
        var _a;
        var prefixCls = props.prefixCls, previewPrefixCls = props.previewPrefixCls, _b = props.simple, simple = _b === void 0 ? false : _b, _c = props.actions, actions = _c === void 0 ? [] : _c, _d = props.actionsLayout, actionsLayout = _d === void 0 ? [] : _d, _e = props.defaultActions, defaultActions = _e === void 0 ? [] : _e;
        // Filter based on layout
        var actionsLayoutSet = new Set(actionsLayout);
        var filterWithLayout = function (item) { return actionsLayoutSet.has(item.key); };
        var filteredActions = __spreadArray(__spreadArray([], __read$5(defaultActions.filter(filterWithLayout)), false), __read$5(actions.filter(filterWithLayout)), false);
        var extraActions = actions.filter(function (item) { return !actionsLayoutSet.has(item.key); });
        // Sort by layout
        var resultActions = filteredActions.sort(function (pre, cur) {
            var preIndex = actionsLayout.indexOf(pre.key);
            var curIndex = actionsLayout.indexOf(cur.key);
            return preIndex > curIndex ? 1 : -1;
        });
        if (actionsLayoutSet.has('extra')) {
            var extraIndex = actionsLayout.indexOf('extra');
            resultActions.splice.apply(resultActions, __spreadArray([extraIndex, 0], __read$5(extraActions), false));
        }
        var renderAction = function (itemData, renderName) {
            var _a;
            if (renderName === void 0) { renderName = false; }
            var content = itemData.content, disabled = itemData.disabled, key = itemData.key, name = itemData.name, getContainer = itemData.getContainer, onClick = itemData.onClick, rest = __rest$4(itemData, ["content", "disabled", "key", "name", "getContainer", "onClick"]);
            var action = (React.createElement("div", __assign$6({ className: cs(previewPrefixCls + "-toolbar-action", (_a = {},
                    _a[previewPrefixCls + "-toolbar-action-disabled"] = disabled,
                    _a)), key: key, onClick: function (e) {
                    if (!disabled && onClick) {
                        onClick(e);
                    }
                }, onMouseDown: function (e) {
                    // To solve the problem that tooltip is selected when button is quickly clicked
                    e.preventDefault();
                } }, rest),
                content && React.createElement("span", { className: previewPrefixCls + "-toolbar-action-content" }, content),
                renderName && name && (React.createElement("span", { className: previewPrefixCls + "-toolbar-action-name" }, name))));
            if (getContainer) {
                return getContainer(action);
            }
            return action;
        };
        if (!resultActions.length)
            return null;
        var actionList = resultActions.map(function (item) {
            var action = renderAction(item, simple);
            if (!simple && item.name && !item.getContainer) {
                return (React.createElement(Tooltip$1, { content: item.name, key: item.key }, action));
            }
            return action;
        });
        return (React.createElement("div", { ref: ref, className: cs(previewPrefixCls + "-toolbar", (_a = {},
                _a[previewPrefixCls + "-toolbar-simple"] = simple,
                _a), props.className), style: props.style },
            simple && (React.createElement(TriggerForToolbar, { prefixCls: prefixCls, className: previewPrefixCls + "-trigger", popup: function () { return React.createElement("div", null, actionList); } }, renderAction({
                key: 'trigger',
                content: (React.createElement("span", null,
                    React.createElement(IconMore$1, null))),
            }))),
            !simple && actionList));
    };
    var ImagePreviewToolbar$1 = React.forwardRef(ImagePreviewToolbar);

    var PreviewGroupContext = React.createContext({
        previewGroup: false,
        previewUrlMap: new Map(),
        previewPropsMap: new Map(),
        infinite: true,
        currentIndex: 0,
        setCurrentIndex: function () { return null; },
        setPreviewUrlMap: function () { return null; },
        registerPreviewUrl: function () { return null; },
        registerPreviewProps: function () { return null; },
        visible: false,
        handleVisibleChange: function () { return null; },
    });

    function ImagePreviewArrow(props) {
        var _a, _b;
        var current = props.current, previewCount = props.previewCount, _c = props.infinite, infinite = _c === void 0 ? false : _c, onPrev = props.onPrev, onNext = props.onNext;
        var getPrefixCls = React.useContext(ConfigContext).getPrefixCls;
        var prefixCls = getPrefixCls('image-preview');
        var classNames = cs(prefixCls + "-arrow");
        var disableLeft = !infinite && current <= 0;
        var disableRight = !infinite && current >= previewCount - 1;
        return (React.createElement("div", { className: classNames },
            React.createElement("div", { className: cs(prefixCls + "-arrow-left", (_a = {},
                    _a[prefixCls + "-arrow-disabled"] = disableLeft,
                    _a)), onClick: function (e) {
                    e.preventDefault();
                    !disableLeft && onPrev && onPrev();
                } },
                React.createElement(IconLeft$1, null)),
            React.createElement("div", { className: cs(prefixCls + "-arrow-right", (_b = {},
                    _b[prefixCls + "-arrow-disabled"] = disableRight,
                    _b)), onClick: function (e) {
                    e.preventDefault();
                    !disableRight && onNext && onNext();
                } },
                React.createElement(IconRight$1, null))));
    }

    var __assign$5 = (undefined && undefined.__assign) || function () {
        __assign$5 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$5.apply(this, arguments);
    };
    var __rest$3 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$4 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var ROTATE_STEP = 90;
    var defaultProps$2 = {
        maskClosable: true,
        closable: true,
        breakPoint: 316,
        actionsLayout: [
            'fullScreen',
            'rotateRight',
            'rotateLeft',
            'zoomIn',
            'zoomOut',
            'originalSize',
            'extra',
        ],
        getPopupContainer: function () { return document.body; },
        escToExit: true,
        scales: defaultScales,
    };
    function Preview(baseProps, ref) {
        var _a, _b;
        var _c = React.useContext(PreviewGroupContext), previewGroup = _c.previewGroup, previewUrlMap = _c.previewUrlMap, currentIndex = _c.currentIndex, setCurrentIndex = _c.setCurrentIndex, infinite = _c.infinite, previewPropsMap = _c.previewPropsMap;
        var mergedPreviewProps = previewGroup ? previewPropsMap.get(currentIndex) : {};
        var mergedProps = useMergeProps(baseProps, defaultProps$2, mergedPreviewProps);
        var className = mergedProps.className, style = mergedProps.style, src = mergedProps.src, defaultVisible = mergedProps.defaultVisible, maskClosable = mergedProps.maskClosable, closable = mergedProps.closable, breakPoint = mergedProps.breakPoint, actions = mergedProps.actions, actionsLayout = mergedProps.actionsLayout, getPopupContainer = mergedProps.getPopupContainer, onVisibleChange = mergedProps.onVisibleChange, scales = mergedProps.scales, escToExit = mergedProps.escToExit, _d = mergedProps.imgAttributes, imgAttributes = _d === void 0 ? {} : _d;
        var mergedSrc = previewGroup ? previewUrlMap.get(currentIndex) : src;
        var _e = __read$4(React.useState(mergedSrc), 2), previewImgSrc = _e[0], setPreviewImgSrc = _e[1];
        var _f = __read$4(useMergeValue(false, {
            defaultValue: defaultVisible,
            value: mergedProps.visible,
        }), 2), visible = _f[0], setVisible = _f[1];
        var globalContext = React.useContext(ConfigContext);
        var getPrefixCls = globalContext.getPrefixCls, locale = globalContext.locale, rtl = globalContext.rtl;
        var prefixCls = getPrefixCls('image');
        var previewPrefixCls = prefixCls + "-preview";
        var classNames = cs(previewPrefixCls, (_a = {},
            _a[previewPrefixCls + "-hide"] = !visible,
            _a[previewPrefixCls + "-rtl"] = rtl,
            _a), className);
        var refImage = React.useRef();
        var refImageContainer = React.useRef();
        var refWrapper = React.useRef();
        var keyboardEventOn = React.useRef(false);
        var refMoveData = React.useRef({
            pageX: 0,
            pageY: 0,
            originX: 0,
            originY: 0,
        });
        var _g = useImageStatus('loading'), isLoading = _g.isLoading, isLoaded = _g.isLoaded, setStatus = _g.setStatus;
        var _h = __read$4(React.useState(false), 2), toolbarSimple = _h[0], setToolbarSimple = _h[1];
        var _j = __read$4(React.useState({ x: 0, y: 0 }), 2), translate = _j[0], setTranslate = _j[1];
        var _k = __read$4(React.useState(1), 2), scale = _k[0], setScale = _k[1];
        var _l = __read$4(React.useState(false), 2), scaleValueVisible = _l[0], setScaleValueVisible = _l[1];
        var _m = __read$4(React.useState(0), 2), rotate = _m[0], setRotate = _m[1];
        var _o = __read$4(React.useState(false), 2), moving = _o[0], setMoving = _o[1];
        var previewScales = React.useMemo(function () {
            return new PreviewScales$1(scales);
        }, []);
        var onLoad = imgAttributes.onLoad, onError = imgAttributes.onError, onMouseDown = imgAttributes.onMouseDown, imgStyle = imgAttributes.style, imgClassName = imgAttributes.className, restImgAttributes = __rest$3(imgAttributes, ["onLoad", "onError", "onMouseDown", "style", "className"]);
        // Reset image params
        function reset() {
            setTranslate({ x: 0, y: 0 });
            setScale(1);
            setRotate(0);
        }
        React.useImperativeHandle(ref, function () { return ({
            reset: reset,
        }); });
        var _p = __read$4(React.useState(), 2), container = _p[0], setContainer = _p[1];
        var getContainer = React.useCallback(function () { return container; }, [container]);
        React.useEffect(function () {
            var container = getPopupContainer && getPopupContainer();
            var containerDom = (ReactDOM.findDOMNode(container) || document.body);
            setContainer(containerDom);
        }, [getPopupContainer]);
        useOverflowHidden(getContainer, { hidden: visible });
        var isFixed = React.useMemo(function () { return !isServerRendering && container === document.body; }, [container]);
        // Jump to image at the specified index
        function jumpTo(index) {
            var previewListLen = previewUrlMap.size;
            if (infinite) {
                index %= previewListLen;
                if (index < 0)
                    index = previewListLen - Math.abs(index);
            }
            if (index !== currentIndex && index >= 0 && index <= previewListLen - 1) {
                setCurrentIndex(index);
            }
        }
        function onPrev() {
            jumpTo(currentIndex - 1);
        }
        function onNext() {
            jumpTo(currentIndex + 1);
        }
        // Anticlockwise rotation
        function onRotateLeft() {
            setRotate(rotate === 0 ? 360 - ROTATE_STEP : rotate - ROTATE_STEP);
        }
        // Clockwise rotation
        function onRotateRight() {
            setRotate((rotate + ROTATE_STEP) % 360);
        }
        // Scale
        var hideScaleTimer = React.useRef(null);
        var showScaleValue = function () {
            !scaleValueVisible && setScaleValueVisible(true);
            hideScaleTimer.current && clearTimeout(hideScaleTimer.current);
            hideScaleTimer.current = setTimeout(function () {
                setScaleValueVisible(false);
            }, 1000);
        };
        var onScaleChange = function (newScale) {
            if (scale !== newScale) {
                setScale(newScale);
                showScaleValue();
            }
        };
        function onZoomIn() {
            var newScale = previewScales.getNextScale(scale, 'zoomIn');
            onScaleChange(newScale);
        }
        function onZoomOut() {
            var newScale = previewScales.getNextScale(scale, 'zoomOut');
            onScaleChange(newScale);
        }
        function onResetScale() {
            onScaleChange(1);
        }
        function onFullScreen() {
            var wrapperRect = refWrapper.current.getBoundingClientRect();
            var imgRect = refImage.current.getBoundingClientRect();
            var newHeightScale = wrapperRect.height / (imgRect.height / scale);
            var newWidthScale = wrapperRect.width / (imgRect.width / scale);
            var newScale = Math.max(newHeightScale, newWidthScale);
            onScaleChange(newScale);
        }
        // Image container is clicked
        function onOutsideImgClick(e) {
            if (e.target === e.currentTarget && maskClosable) {
                close();
            }
        }
        // Close button is clicked.
        function onCloseClick() {
            close();
        }
        function close() {
            if (visible) {
                onVisibleChange && onVisibleChange(false, visible);
                isUndefined(mergedProps.visible) && setVisible(false);
            }
        }
        function onWrapperResize(entry) {
            if (entry && entry.length) {
                var wrapperRect = entry[0].contentRect;
                var nextSimple = wrapperRect.width < breakPoint;
                setToolbarSimple(nextSimple);
            }
        }
        // Check the translate and correct it if needed
        var checkAndFixTranslate = function () {
            if (!refWrapper.current || !refImage.current)
                return;
            var wrapperRect = refWrapper.current.getBoundingClientRect();
            var imgRect = refImage.current.getBoundingClientRect();
            var _a = __read$4(getFixTranslate(wrapperRect, imgRect, translate.x, translate.y, scale), 2), x = _a[0], y = _a[1];
            if (x !== translate.x || y !== translate.y) {
                setTranslate({
                    x: x,
                    y: y,
                });
            }
        };
        // Update position on moving if needed
        var onMoving = function (e) {
            if (visible && moving) {
                e.preventDefault && e.preventDefault();
                var _a = refMoveData.current, originX = _a.originX, originY = _a.originY, pageX = _a.pageX, pageY = _a.pageY;
                var nextX = originX + (e.pageX - pageX) / scale;
                var nextY = originY + (e.pageY - pageY) / scale;
                setTranslate({
                    x: nextX,
                    y: nextY,
                });
            }
        };
        var onMoveEnd = function (e) {
            e.preventDefault && e.preventDefault();
            setMoving(false);
        };
        function onImgLoaded(e) {
            setStatus('loaded');
            onLoad && onLoad(e);
        }
        function onImgLoadError(e) {
            setStatus('error');
            onError && onError(e);
        }
        // Record position data on move start
        var onMoveStart = function (e) {
            e.preventDefault && e.preventDefault();
            setMoving(true);
            var ev = e.type === 'touchstart' ? e.touches[0] : e;
            refMoveData.current.pageX = ev.pageX;
            refMoveData.current.pageY = ev.pageY;
            refMoveData.current.originX = translate.x;
            refMoveData.current.originY = translate.y;
            onMouseDown && onMouseDown(e);
        };
        React.useEffect(function () {
            if (visible && moving) {
                on(document, 'mousemove', onMoving, false);
                on(document, 'mouseup', onMoveEnd, false);
            }
            return function () {
                off(document, 'mousemove', onMoving, false);
                off(document, 'mouseup', onMoveEnd, false);
            };
        }, [visible, moving]);
        // Correct translate after moved
        React.useEffect(function () {
            if (!moving) {
                checkAndFixTranslate();
            }
        }, [moving, translate]);
        // Correct translate when scale changes
        React.useEffect(function () {
            checkAndFixTranslate();
        }, [scale]);
        // Reset when preview is opened
        React.useEffect(function () {
            if (visible) {
                reset();
            }
        }, [visible]);
        // Reset on first mount or image switches
        React.useEffect(function () {
            setPreviewImgSrc(mergedSrc);
            setStatus(mergedSrc ? 'loading' : 'loaded');
            reset();
        }, [mergedSrc]);
        useUpdate(function () {
            previewScales.updateScale(scales);
            setScale(1);
        }, [scales]);
        // Close when pressing esc
        React.useEffect(function () {
            var onKeyDown = function (e) {
                if (escToExit && e && e.key === Esc.key) {
                    close();
                }
            };
            if (visible && !moving && !keyboardEventOn.current) {
                keyboardEventOn.current = true;
                on(document, 'keydown', onKeyDown);
            }
            return function () {
                keyboardEventOn.current = false;
                off(document, 'keydown', onKeyDown);
            };
        }, [visible, escToExit, moving]);
        var defaultActions = [
            {
                key: 'fullScreen',
                name: locale.ImagePreview.fullScreen,
                content: React.createElement(IconFullscreen$1, null),
                onClick: onFullScreen,
            },
            {
                key: 'rotateRight',
                name: locale.ImagePreview.rotateRight,
                content: React.createElement(IconRotateRight$1, null),
                onClick: onRotateRight,
            },
            {
                key: 'rotateLeft',
                name: locale.ImagePreview.rotateLeft,
                content: React.createElement(IconRotateLeft$1, null),
                onClick: onRotateLeft,
            },
            {
                key: 'zoomIn',
                name: locale.ImagePreview.zoomIn,
                content: React.createElement(IconZoomIn$1, null),
                onClick: onZoomIn,
                disabled: scale === previewScales.maxScale,
            },
            {
                key: 'zoomOut',
                name: locale.ImagePreview.zoomOut,
                content: React.createElement(IconZoomOut$1, null),
                onClick: onZoomOut,
                disabled: scale === previewScales.minScale,
            },
            {
                key: 'originalSize',
                name: locale.ImagePreview.originalSize,
                content: React.createElement(IconOriginalSize$1, null),
                onClick: onResetScale,
            },
        ];
        return (React.createElement(Portal, { visible: visible, forceRender: false, getContainer: getContainer },
            React.createElement(ConfigProvider, __assign$5({}, globalContext, { getPopupContainer: function () { return refWrapper.current; } }),
                React.createElement("div", { className: classNames, style: __assign$5(__assign$5({}, (style || {})), (isFixed ? {} : { zIndex: 'inherit', position: 'absolute' })) },
                    React.createElement(CSSTransition$1, { in: visible, timeout: 400, appear: true, classNames: "fadeImage", mountOnEnter: true, unmountOnExit: false, onEnter: function (e) {
                            e.parentNode.style.display = 'block';
                            e.style.display = 'block';
                        }, onExited: function (e) {
                            e.parentNode.style.display = '';
                            e.style.display = 'none';
                        } },
                        React.createElement("div", { className: previewPrefixCls + "-mask" })),
                    visible && (React.createElement(ResizeObserver$1, { onResize: onWrapperResize },
                        React.createElement("div", { ref: refWrapper, className: previewPrefixCls + "-wrapper", onClick: onOutsideImgClick },
                            React.createElement("div", { ref: refImageContainer, className: previewPrefixCls + "-img-container", style: { transform: "scale(" + scale + ", " + scale + ")" }, onClick: onOutsideImgClick },
                                React.createElement("img", __assign$5({ ref: refImage, className: cs(imgClassName, previewPrefixCls + "-img", (_b = {},
                                        _b[previewPrefixCls + "-img-moving"] = moving,
                                        _b)), style: __assign$5(__assign$5({}, imgStyle), { transform: "translate(" + translate.x + "px, " + translate.y + "px) rotate(" + rotate + "deg)" }) }, restImgAttributes, { onLoad: onImgLoaded, onError: onImgLoadError, onMouseDown: onMoveStart, key: previewImgSrc, src: previewImgSrc })),
                                isLoading && (React.createElement("div", { className: previewPrefixCls + "-loading" },
                                    React.createElement(IconLoading$1, null)))),
                            React.createElement(CSSTransition$1, { in: scaleValueVisible, timeout: 400, appear: true, classNames: "fadeImage", unmountOnExit: true },
                                React.createElement("div", { className: previewPrefixCls + "-scale-value" },
                                    (scale * 100).toFixed(0),
                                    "%")),
                            isLoaded && (React.createElement(ImagePreviewToolbar$1, { prefixCls: prefixCls, previewPrefixCls: previewPrefixCls, actions: actions, actionsLayout: actionsLayout, defaultActions: defaultActions, simple: toolbarSimple })),
                            closable && (React.createElement("div", { className: previewPrefixCls + "-close-btn", onClick: onCloseClick },
                                React.createElement(IconClose$1, null))),
                            previewGroup && (React.createElement(ImagePreviewArrow, { previewCount: previewUrlMap.size, current: currentIndex, infinite: infinite, onPrev: onPrev, onNext: onNext })))))))));
    }
    var PreviewComponent = React.forwardRef(Preview);
    PreviewComponent.displayName = 'ImagePreview';
    var ImagePreview = PreviewComponent;

    var __assign$4 = (undefined && undefined.__assign) || function () {
        __assign$4 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$4.apply(this, arguments);
    };
    var __rest$2 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$3 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    function PreviewGroup(props, ref) {
        var children = props.children, srcList = props.srcList, infinite = props.infinite, propCurrentIndex = props.current, defaultCurrent = props.defaultCurrent, onChange = props.onChange, propVisible = props.visible, defaultVisible = props.defaultVisible, onVisibleChange = props.onVisibleChange, restProps = __rest$2(props, ["children", "srcList", "infinite", "current", "defaultCurrent", "onChange", "visible", "defaultVisible", "onVisibleChange"]);
        var _a = __read$3(useMergeValue(false, {
            value: propVisible,
            defaultValue: defaultVisible,
        }), 2), visible = _a[0], setVisible = _a[1];
        var propPreviewUrlMap = React.useMemo(function () { return (srcList ? new Map(srcList.map(function (url, index) { return [index, { url: url, preview: true }]; })) : null); }, [srcList]);
        var isFirstRender = useIsFirstRender();
        var getPreviewUrlMap = function () { return (propPreviewUrlMap ? new Map(propPreviewUrlMap) : new Map()); };
        var _b = __read$3(React.useState(getPreviewUrlMap()), 2), previewUrlMap = _b[0], setPreviewUrlMap = _b[1];
        var _c = __read$3(React.useState(new Map()), 2), previewPropsMap = _c[0], setPreviewPropsMap = _c[1];
        React.useEffect(function () {
            if (isFirstRender)
                return;
            setPreviewUrlMap(getPreviewUrlMap());
        }, [propPreviewUrlMap]);
        var canPreviewUrlMap = new Map(Array.from(previewUrlMap)
            .filter(function (_a) {
            var _b = __read$3(_a, 2), preview = _b[1].preview;
            return preview;
        })
            .map(function (_a) {
            var _b = __read$3(_a, 2), id = _b[0], url = _b[1].url;
            return [id, url];
        }));
        var _d = __read$3(useMergeValue(0, {
            value: propCurrentIndex,
            defaultValue: defaultCurrent,
        }), 2), currentIndex = _d[0], setCurrentIndex = _d[1];
        function registerPreviewUrl(id, url, preview) {
            if (!propPreviewUrlMap) {
                setPreviewUrlMap(function (pre) {
                    return new Map(pre).set(id, {
                        url: url,
                        preview: preview,
                    });
                });
            }
            return function unRegisterPreviewUrl() {
                if (!propPreviewUrlMap) {
                    setPreviewUrlMap(function (pre) {
                        var cloneMap = new Map(pre);
                        var hasDelete = cloneMap.delete(id);
                        return hasDelete ? cloneMap : pre;
                    });
                }
            };
        }
        function registerPreviewProps(id, previewProps) {
            setPreviewPropsMap(function (pre) { return new Map(pre).set(id, isObject$1(previewProps) ? previewProps : {}); });
            return function unRegisterPreviewProps() {
                setPreviewPropsMap(function (pre) {
                    var cloneMap = new Map(pre);
                    var hasDelete = cloneMap.delete(id);
                    return hasDelete ? cloneMap : pre;
                });
            };
        }
        var refPreview = React.useRef();
        React.useImperativeHandle(ref, function () { return ({
            reset: function () {
                refPreview.current && refPreview.current.reset();
            },
        }); });
        var handleVisibleChange = function (newVisible, preVisible) {
            var _preVisible = isUndefined(preVisible) ? visible : preVisible;
            onVisibleChange && onVisibleChange(newVisible, _preVisible);
            setVisible(newVisible);
        };
        var handleSwitch = function (index) {
            onChange && onChange(index);
            setCurrentIndex(index);
        };
        var loopImageIndex = function (children) {
            var index = 0;
            var loop = function (children) {
                var result = React.Children.map(children, function (child) {
                    if (child && child.props && child.type) {
                        var displayName = child.type.displayName;
                        if (displayName === 'Image') {
                            return React.cloneElement(child, { _index: index++ });
                        }
                    }
                    if (child && child.props && child.props.children) {
                        return React.cloneElement(child, {
                            children: loop(child.props.children),
                        });
                    }
                    return child;
                });
                // 避免单个子节点 <div></div> 被处理为  [<div></div>] 格式
                if (!isArray$1(children) && React.Children.count(children) === 1) {
                    return result[0];
                }
                return result;
            };
            return loop(children);
        };
        return (React.createElement(PreviewGroupContext.Provider, { value: {
                previewGroup: true,
                previewUrlMap: canPreviewUrlMap,
                previewPropsMap: previewPropsMap,
                infinite: infinite,
                currentIndex: currentIndex,
                setCurrentIndex: handleSwitch,
                setPreviewUrlMap: setPreviewUrlMap,
                registerPreviewUrl: registerPreviewUrl,
                registerPreviewProps: registerPreviewProps,
                visible: visible,
                handleVisibleChange: handleVisibleChange,
            } },
            loopImageIndex(children),
            React.createElement(ImagePreview, __assign$4({ ref: refPreview, src: "", visible: visible, onVisibleChange: handleVisibleChange }, restProps))));
    }
    var PreviewGroupComponent = React.forwardRef(PreviewGroup);
    PreviewGroupComponent.displayName = 'ImagePreviewGroup';
    var ImagePreviewGroup = PreviewGroupComponent;

    var __assign$3 = (undefined && undefined.__assign) || function () {
        __assign$3 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$3.apply(this, arguments);
    };
    var __rest$1 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$2 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var FileList = function (props) {
        var _a;
        var _b = React.useContext(ConfigContext), locale = _b.locale, rtl = _b.rtl;
        var listType = props.listType, fileList = props.fileList, renderUploadList = props.renderUploadList, renderUploadItem = props.renderUploadItem, prefixCls = props.prefixCls, rest = __rest$1(props, ["listType", "fileList", "renderUploadList", "renderUploadItem", "prefixCls"]);
        // hide image preview when previewCurrent = -1
        var _c = __read$2(React.useState(-1), 2), previewCurrent = _c[0], setPreviewCurrent = _c[1];
        var srcList = React.useMemo(function () {
            return fileList
                .map(function (file) {
                var url = file.url;
                if (file.url === undefined && [STATUS.init, STATUS.success].indexOf(file.status) > -1) {
                    url =
                        file.originFile &&
                            isFunction$1(URL.createObjectURL) &&
                            URL.createObjectURL(file.originFile);
                }
                return url;
            })
                .filter(Boolean);
        }, [fileList]);
        if (isFunction$1(renderUploadList)) {
            return React.createElement("div", { className: prefixCls + "-list" }, renderUploadList(fileList, rest));
        }
        var updatePreviewCurrent = function (current) {
            if (props.imagePreview) {
                setPreviewCurrent(current);
            }
        };
        return (React.createElement(React.Fragment, null,
            React.createElement(TransitionGroup$1, { className: cs(prefixCls + "-list", prefixCls + "-list-type-" + listType, (_a = {},
                    _a[prefixCls + "-list-rtl"] = rtl,
                    _a)) }, fileList.map(function (file, index) {
                var originNode = listType === 'picture-card' ? (React.createElement("div", { className: prefixCls + "-list-item " + prefixCls + "-list-item-" + file.status },
                    React.createElement(PictureItem$1, __assign$3({}, props, { onPreview: function (file) {
                            var _a;
                            updatePreviewCurrent(index);
                            (_a = props.onPreview) === null || _a === void 0 ? void 0 : _a.call(props, file);
                        }, file: file, locale: locale })))) : (React.createElement(TextItem$1, __assign$3({}, props, { file: file, locale: locale })));
                if (isFunction$1(renderUploadItem)) {
                    originNode = renderUploadItem(originNode, file, fileList);
                }
                return listType === 'picture-card' ? (React.createElement(CSSTransition$1, { key: file.uid, timeout: { enter: 200, exit: 400 }, classNames: prefixCls + "-slide-inline", onEntered: function (e) {
                        e.style.width = '';
                    }, onExit: function (e) {
                        e.style.width = e.scrollWidth + "px";
                    }, onExiting: function (e) {
                        e.style.width = 0;
                    }, onExited: function (e) {
                        e.style.width = 0;
                    } }, originNode)) : (React.createElement(CSSTransition$1, { key: file.uid, timeout: { enter: 200, exit: 400 }, classNames: prefixCls + "-slide-up", onExit: function (e) {
                        e.style.height = e.scrollHeight + "px";
                    }, onExiting: function (e) {
                        e.style.height = 0;
                    }, onExited: function (e) {
                        e.style.height = 0;
                    } }, originNode));
            })),
            listType === 'picture-card' && props.imagePreview && (React.createElement(ImagePreviewGroup, { srcList: srcList, visible: previewCurrent !== -1, current: previewCurrent, onChange: updatePreviewCurrent, onVisibleChange: function (visible) {
                    updatePreviewCurrent(visible ? previewCurrent : -1);
                } }))));
    };
    FileList.displayName = 'FileList';
    var UploadList = FileList;

    function getBody(xhr) {
        var text = xhr.responseText || xhr.response;
        if (!text) {
            return text;
        }
        try {
            return JSON.parse(text);
        }
        catch (e) {
            return text;
        }
    }
    var uploadRequest = function (options) {
        var _a = options.onProgress, onProgress = _a === void 0 ? NOOP : _a, _b = options.onError, onError = _b === void 0 ? NOOP : _b, _c = options.onSuccess, onSuccess = _c === void 0 ? NOOP : _c, action = options.action, _d = options.headers, headers = _d === void 0 ? {} : _d, originName = options.name, file = options.file, _e = options.data, originData = _e === void 0 ? {} : _e, _f = options.withCredentials, withCredentials = _f === void 0 ? false : _f;
        function getValue(value) {
            if (typeof value === 'function') {
                return value(file);
            }
            return value;
        }
        var name = getValue(originName);
        var data = getValue(originData);
        var xhr = new XMLHttpRequest();
        if (onProgress && xhr.upload) {
            xhr.upload.onprogress = function (event) {
                var percent;
                if (event.total > 0) {
                    percent = (event.loaded / event.total) * 100;
                }
                onProgress(parseInt(percent, 10), event);
            };
        }
        xhr.onerror = function error(e) {
            onError(e);
        };
        xhr.onload = function onload() {
            if (xhr.status < 200 || xhr.status >= 300) {
                return onError(getBody(xhr));
            }
            onSuccess(getBody(xhr));
        };
        var formData = new FormData();
        if (data) {
            Object.keys(data).map(function (key) { return formData.append(key, data[key]); });
        }
        formData.append(name || 'file', file);
        xhr.open('post', action, true);
        if (withCredentials && 'withCredentials' in xhr) {
            xhr.withCredentials = true;
        }
        for (var h in headers) {
            if (headers.hasOwnProperty(h) && headers[h] !== null) {
                xhr.setRequestHeader(h, headers[h]);
            }
        }
        xhr.send(formData);
        return {
            abort: function () {
                xhr.abort();
            },
        };
    };
    var uploadRequest$1 = uploadRequest;

    var isAcceptFile = function (file, accept) {
        if (accept && file) {
            var accepts = isArray$1(accept)
                ? accept
                : accept
                    .split(',')
                    .map(function (x) { return x.trim(); })
                    .filter(function (x) { return x; });
            var fileExtension_1 = (file.name.indexOf('.') > -1 ? "." + file.name.split('.').pop() : '').toLowerCase();
            return accepts.some(function (type) {
                var typeText = type && type.toLowerCase();
                var fileType = (file.type || '').toLowerCase();
                var baseFileType = fileType.split('/')[0]; // audio/mpeg => audio;
                // `${baseFileType}/${fileExtension}` === typeText
                // filetype is audio/mpeg, but accept is audio/mp3, should return true
                if (typeText === fileType ||
                    "" + baseFileType + fileExtension_1.replace('.', '/') === typeText) {
                    // 类似excel文件这种
                    // 比如application/vnd.ms-excel和application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
                    // 本身就带有.字符的，不能走下面的.jpg等文件扩展名判断处理
                    // 所以优先对比input的accept类型和文件对象的type值
                    return true;
                }
                // */*,*  之类的所有类型
                if (/^\*(\/\*)?$/.test(typeText)) {
                    return true;
                }
                if (/\/\*/.test(typeText)) {
                    // image/* 这种通配的形式处理
                    return fileType.replace(/\/.*$/, '') === typeText.replace(/\/.*$/, '');
                }
                if (/\..*/.test(typeText)) {
                    // .jpg 等后缀名
                    var suffixList = [typeText];
                    // accept=".jpg", jpeg后缀类型同样可以上传，反之亦然
                    if (typeText === '.jpg' || typeText === '.jpeg') {
                        suffixList = ['.jpg', '.jpeg'];
                    }
                    return suffixList.indexOf(fileExtension_1) > -1;
                }
                return false;
            });
        }
        return !!file;
    };
    var getFiles = function (fileList, accept) {
        if (!fileList) {
            return;
        }
        var files = [].slice.call(fileList);
        if (accept) {
            files = files.filter(function (file) {
                return isAcceptFile(file, accept);
            });
        }
        return files;
    };
    var loopDirectory = function (items, accept, callback) {
        var files = [];
        var restFileCount = 0; // 剩余上传文件的数量
        var onFinish = function () {
            !restFileCount && callback(files);
        };
        var _loopDirectory = function (item) {
            restFileCount += 1;
            if (item.isFile) {
                item.file(function (file) {
                    restFileCount -= 1;
                    if (isAcceptFile(file, accept)) {
                        Object.defineProperty(file, 'webkitRelativePath', {
                            value: item.fullPath.replace(/^\//, ''),
                        });
                        files.push(file);
                    }
                    onFinish();
                });
                return;
            }
            if (item.isDirectory) {
                // item 是个文件夹
                var reader_1 = item.createReader();
                var flag_1 = false;
                var readEntries_1 = function () {
                    reader_1.readEntries(function (entries) {
                        if (!flag_1) {
                            restFileCount -= 1;
                            flag_1 = true;
                        }
                        if (entries.length === 0) {
                            onFinish();
                        }
                        else {
                            readEntries_1(); // the maximum files read using readEntries is 100
                            entries.forEach(_loopDirectory);
                        }
                    });
                };
                readEntries_1();
                return;
            }
            restFileCount -= 1;
            onFinish();
        };
        var list = [].slice.call(items);
        list.forEach(function (item) {
            if (item.webkitGetAsEntry) {
                _loopDirectory(item.webkitGetAsEntry());
            }
        });
    };

    var __assign$2 = (undefined && undefined.__assign) || function () {
        __assign$2 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$2.apply(this, arguments);
    };
    var __read$1 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var TriggerNode = function (props) {
        var _a, _b;
        var getKeyboardEvents = useKeyboardEvent();
        var locale = React.useContext(ConfigContext).locale;
        var _c = __read$1(React.useState(false), 2), isDragging = _c[0], setIsDragging = _c[1];
        var _d = __read$1(React.useState(0), 2), dragEnterCount = _d[0], setDragEnterCount = _d[1]; // the number of times ondragenter was triggered
        var tip = props.tip, children = props.children, disabled = props.disabled, drag = props.drag, listType = props.listType, prefixCls = props.prefixCls, accept = props.accept, multiple = props.multiple;
        var nodeProps = {
            disabled: disabled,
        };
        React.useEffect(function () {
            setDragEnterCount(0);
        }, [isDragging]);
        return children === null ? null : (React.createElement("div", __assign$2({ className: prefixCls + "-trigger", onClick: disabled ? undefined : props.onClick }, getKeyboardEvents({
            onPressEnter: function () {
                var _a;
                !disabled && ((_a = props.onClick) === null || _a === void 0 ? void 0 : _a.call(props));
            },
        }), { onDragEnter: function () {
                setDragEnterCount(dragEnterCount + 1);
            }, onDragLeave: function (e) {
                var _a;
                e.preventDefault();
                /**  When dragging into a child element, it will trigger the dragleave and dragenter of the parent node.
                 * Record the number of triggers of dragenter, and subtract 1 each time dragleave.
                 * When dragEnterCount is equal to 0,  it means that the mouse has left the current node, then the drag state is cancelled.
                 * https://github.com/arco-design/arco-design/issues/210
                 */
                if (dragEnterCount === 0) {
                    setIsDragging(false);
                    !disabled && ((_a = props.onDragLeave) === null || _a === void 0 ? void 0 : _a.call(props, e));
                }
                else {
                    setDragEnterCount(dragEnterCount - 1);
                }
            }, onDrop: function (e) {
                e.preventDefault();
                if (!disabled && props.drag !== false) {
                    setIsDragging(false);
                    if (props.directory) {
                        loopDirectory(e.dataTransfer.items, accept, function (files) {
                            props.onDragFiles && props.onDragFiles(files);
                        });
                    }
                    else {
                        var files = getFiles(e.dataTransfer.files, accept);
                        props.onDragFiles && props.onDragFiles(multiple ? files : files.slice(0, 1));
                    }
                    props.onDrop && props.onDrop(e);
                }
            }, onDragOver: function (e) {
                var _a;
                e.preventDefault();
                if (!disabled && !isDragging) {
                    setIsDragging(true);
                    (_a = props.onDragOver) === null || _a === void 0 ? void 0 : _a.call(props, e);
                }
            } }), React.isValidElement(children) ? (React.createElement("div", { className: cs((_a = {}, _a[prefixCls + "-trigger-custom-active"] = isDragging, _a)) }, React.cloneElement(children, nodeProps))) : listType === 'picture-card' ? (React.createElement("div", { className: prefixCls + "-trigger-picture-wrapper" },
            React.createElement("div", { className: prefixCls + "-trigger-picture", tabIndex: 0, "aria-label": locale.Upload.upload },
                React.createElement("div", { className: prefixCls + "-trigger-picture-text" },
                    React.createElement(IconPlus$1, null))))) : drag ? (React.createElement("div", { className: cs(prefixCls + "-trigger-drag", (_b = {},
                _b[prefixCls + "-trigger-drag-active"] = isDragging,
                _b)), tabIndex: 0, "aria-label": locale.Upload.drag },
            React.createElement(IconPlus$1, null),
            React.createElement("p", { className: prefixCls + "-trigger-drag-text" }, isDragging ? locale.Upload.dragHover : locale.Upload.drag),
            tip && React.createElement("div", { className: prefixCls + "-trigger-tip" }, tip))) : (React.createElement(Button$3, __assign$2({}, nodeProps, { "aria-label": locale.Upload.upload, type: "primary", className: prefixCls + "-trigger-with-icon" }),
            React.createElement(IconUpload$1, null),
            locale.Upload.upload))));
    };
    var TriggerNode$1 = TriggerNode;

    var __extends = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$1 = (undefined && undefined.__assign) || function () {
        __assign$1 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1.apply(this, arguments);
    };
    var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var Uploader = /** @class */ (function (_super) {
        __extends(Uploader, _super);
        function Uploader(props) {
            var _this = _super.call(this, props) || this;
            // 提供 ref 调用
            _this.upload = function (file) {
                _this.doUpload(file);
            };
            // 提供 ref 调用。终止
            _this.abort = function (file) {
                var req = _this.state.uploadRequests[file.uid];
                if (req) {
                    req.abort && req.abort();
                    _this.updateFileStatus(__assign$1(__assign$1({}, file), { status: STATUS.fail }));
                    _this.deleteReq(file.uid);
                }
            };
            // 重新上传 。提供 ref 调用
            _this.reupload = function (file) {
                _this.doUpload(__assign$1(__assign$1({}, file), { percent: 0, status: STATUS.uploading }));
            };
            _this.deleteReq = function (uid) {
                var newValue = __assign$1({}, _this.state.uploadRequests);
                delete newValue[uid];
                _this.setState({
                    uploadRequests: newValue,
                });
            };
            // 提供 ref 调用
            // 删除上传（手动上传时，文件会出现在上传列表，但属于init状态）
            _this.delete = _this.deleteReq;
            _this.updateFileStatus = function (file) {
                var onFileStatusChange = _this.props.onFileStatusChange;
                onFileStatusChange && onFileStatusChange(file);
            };
            _this.getTargetFile = function (file) {
                var key = 'uid' in file ? 'uid' : 'name';
                var targetFile = _this.props.fileList.find(function (item) { return item[key] === file[key]; });
                return targetFile;
            };
            // 执行上传
            _this.doUpload = function (file) { return __awaiter(_this, void 0, void 0, function () {
                var _a, action, headers, name, data, withCredentials, customRequest, onProgress, onSuccess, onError, options, request;
                var _b;
                var _this = this;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            _a = this.props, action = _a.action, headers = _a.headers, name = _a.name, data = _a.data, withCredentials = _a.withCredentials, customRequest = _a.customRequest;
                            onProgress = function (percent, event) {
                                var targetFile = _this.getTargetFile(file);
                                if (targetFile) {
                                    targetFile.status = STATUS.uploading;
                                    targetFile.percent = percent;
                                    _this.props.onProgress && _this.props.onProgress(targetFile, event);
                                }
                            };
                            onSuccess = function (response) {
                                var targetFile = _this.getTargetFile(file);
                                if (targetFile) {
                                    targetFile.status = STATUS.success;
                                    // 传入的响应将会作为 response 字段被附加到上传列表中对应的文件
                                    targetFile.response = response;
                                    _this.updateFileStatus(targetFile);
                                }
                                _this.deleteReq(file.uid);
                            };
                            onError = function (response) {
                                var targetFile = _this.getTargetFile(file);
                                if (targetFile) {
                                    targetFile.status = STATUS.fail;
                                    // 传入的响应将会作为 response 字段被附加到上传列表中对应的文件
                                    targetFile.response = response;
                                    _this.updateFileStatus(targetFile);
                                }
                                _this.deleteReq(file.uid);
                            };
                            options = {
                                onProgress: onProgress,
                                onSuccess: onSuccess,
                                onError: onError,
                                headers: headers,
                                name: name,
                                file: file.originFile,
                                data: data,
                                withCredentials: withCredentials,
                            };
                            // 更新上传状态
                            this.updateFileStatus(file);
                            if (!action) return [3 /*break*/, 1];
                            request = uploadRequest$1(__assign$1(__assign$1({}, options), { action: action }));
                            return [3 /*break*/, 3];
                        case 1:
                            if (!customRequest) return [3 /*break*/, 3];
                            return [4 /*yield*/, customRequest(options)];
                        case 2:
                            request = _c.sent();
                            _c.label = 3;
                        case 3:
                            this.setState({
                                uploadRequests: __assign$1(__assign$1({}, this.state.uploadRequests), (_b = {}, _b[file.uid] = request, _b)),
                            });
                            return [2 /*return*/];
                    }
                });
            }); };
            _this.handleFiles = function (files) {
                var _a = _this.props, limit = _a.limit, fileList = _a.fileList, onExceedLimit = _a.onExceedLimit, autoUpload = _a.autoUpload;
                if (isNumber(limit) && limit < fileList.length + files.length) {
                    return onExceedLimit && onExceedLimit(files, fileList);
                }
                var asyncUpload = function (file, index) {
                    var upload = {
                        uid: "" + String(+new Date()) + index,
                        originFile: file,
                        percent: 0,
                        status: STATUS.init,
                        name: file.name,
                    };
                    // 更新上传状态为 init
                    _this.updateFileStatus(upload);
                    if (autoUpload) {
                        /**
                         * 需要setTimeout，否则一次上传较多文件时，可能出现第i个文件和第i+1个文件同时更新上传列表中的状态，
                         * 状态被相互覆盖的情况。
                         */
                        setTimeout(function () {
                            _this.doUpload(__assign$1(__assign$1({}, upload), { status: STATUS.uploading }));
                        }, 0);
                    }
                };
                files.forEach(function (file, index) {
                    if (isAcceptFile(file, _this.props.accept)) {
                        // windows can upload file type not in accept bug
                        if (isFunction$1(_this.props.beforeUpload)) {
                            // 只有在beforeUpload返回值 === false 时，取消上传操作
                            Promise.resolve(_this.props.beforeUpload(file, files))
                                .then(function (val) {
                                if (val !== false) {
                                    var newFile = isFile(val) ? val : file;
                                    asyncUpload(newFile, index);
                                }
                            })
                                .catch(function (e) {
                                console.error(e);
                            });
                        }
                        else {
                            asyncUpload(file, index);
                        }
                    }
                });
            };
            _this.state = {
                uploadRequests: {},
            };
            return _this;
        }
        Uploader.prototype.render = function () {
            var _this = this;
            var _a = this.props, accept = _a.accept, multiple = _a.multiple, children = _a.children, prefixCls = _a.prefixCls, tip = _a.tip, disabled = _a.disabled, drag = _a.drag, listType = _a.listType, hide = _a.hide, directory = _a.directory, onDrop = _a.onDrop, onDragOver = _a.onDragOver, onDragLeave = _a.onDragLeave;
            return (React.createElement(React.Fragment, null,
                React.createElement("input", __assign$1({ key: "trigger-input", ref: function (node) { return (_this.inputRef = node); }, style: { display: 'none' }, type: "file", accept: accept, multiple: multiple }, (directory ? { webkitdirectory: 'true' } : {}), { onChange: function (e) {
                        var files = e.target.files;
                        if (files) {
                            _this.handleFiles([].slice.call(files));
                            _this.inputRef.value = '';
                        }
                    }, onClick: function (e) {
                        e.stopPropagation();
                    } })),
                React.createElement(CSSTransition$1, { key: "trigger-node", in: !hide, timeout: 100, unmountOnExit: true, classNames: "fadeIn" },
                    React.createElement(TriggerNode$1, { directory: directory, tip: tip, multiple: multiple, accept: accept, disabled: disabled, drag: drag, listType: listType, onDrop: onDrop, onDragOver: onDragOver, onDragLeave: onDragLeave, onDragFiles: this.handleFiles, onClick: function () {
                            !disabled && _this.inputRef && _this.inputRef.click();
                        }, prefixCls: prefixCls }, isFunction$1(children) ? children({ fileList: this.props.fileList }) : children)),
                tip && listType !== 'picture-card' && !drag ? (React.createElement("div", { key: "trigger-tip", className: prefixCls + "-trigger-tip" }, tip)) : null));
        };
        return Uploader;
    }(React.Component));
    var Uploader$1 = Uploader;

    var __assign = (undefined && undefined.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    var __rest = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var processFile = function (fileList) {
        var res = {};
        if (!isArray$1(fileList)) {
            return res;
        }
        fileList.forEach(function (file, index) {
            if (file.uid) {
                res[file.uid] = __assign({ status: STATUS.success, percent: 100 }, file);
            }
            else {
                var uid = "" + String(+new Date()) + index;
                res[uid] = __assign(__assign({}, file), { uid: uid, status: STATUS.success, percent: 100 });
            }
        });
        return res;
    };
    var getFileList = function (uploadState) {
        return Object.keys(uploadState).map(function (x) { return uploadState[x]; });
    };
    var defaultProps$1 = {
        listType: 'text',
        autoUpload: true,
        showUploadList: true,
        beforeUpload: function () { return true; },
    };
    var Upload$1 = function (baseProps, ref) {
        var _a;
        var _b = React.useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig, rtl = _b.rtl;
        var props = useMergeProps(baseProps, defaultProps$1, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Upload);
        var prefixCls = getPrefixCls('upload');
        var uploaderRef = React.useRef();
        var uploadState = React.useRef({});
        var _c = __read(React.useState('fileList' in props
            ? processFile(props.fileList)
            : 'defaultFileList' in props
                ? processFile(props.defaultFileList)
                : {}), 2), innerUploadState = _c[0], setInnerUploadState = _c[1];
        uploadState.current = 'fileList' in props ? processFile(props.fileList) : innerUploadState;
        var deleteUpload = function (file) {
            var obj = __assign({}, uploadState.current);
            delete obj[file.uid];
            if (!('fileList' in props)) {
                setInnerUploadState(obj);
            }
            props.onChange && props.onChange(getFileList(obj), file);
        };
        var uploadFile = function (file) {
            file &&
                setTimeout(function () {
                    uploaderRef.current && uploaderRef.current.upload(file);
                }, 0);
        };
        // 重新上传
        var reuploadFile = function (file) {
            uploaderRef.current && uploaderRef.current.reupload(file);
            props.onReupload && props.onReupload(file);
        };
        // 移除文件，如果正在上传，终止上传
        var removeFile = function (file) {
            if (file) {
                var onRemove = props.onRemove;
                Promise.resolve(isFunction$1(onRemove) ? onRemove(file) : onRemove)
                    .then(function (val) {
                    if (val !== false) {
                        uploaderRef.current && uploaderRef.current.abort(file);
                        deleteUpload(file);
                    }
                })
                    .catch(function (e) {
                    console.error(e);
                });
            }
        };
        // 中止文件上传
        var abortFile = function (file) {
            if (file) {
                uploaderRef.current && uploaderRef.current.abort(file);
            }
        };
        React.useImperativeHandle(ref, function () {
            return {
                submit: function (file) {
                    var list = [];
                    if (file) {
                        list = [file];
                    }
                    else {
                        list = getFileList(uploadState.current).filter(function (x) { return x.status === STATUS.init; });
                    }
                    list.forEach(function (x) {
                        uploadFile(x);
                    });
                },
                // file: fileList中的file对象
                abort: function (file) {
                    abortFile(file);
                },
                // file: fileList中的file对象
                reupload: function (file) {
                    reuploadFile(file);
                },
            };
        });
        var listType = props.listType, className = props.className, style = props.style, renderUploadItem = props.renderUploadItem, showUploadList = props.showUploadList, renderUploadList = props.renderUploadList, progressProps = props.progressProps, imagePreview = props.imagePreview, rest = __rest(props, ["listType", "className", "style", "renderUploadItem", "showUploadList", "renderUploadList", "progressProps", "imagePreview"]);
        var fileList = getFileList(uploadState.current);
        var limit = isNumber(props.limit)
            ? { hideOnExceedLimit: true, maxCount: props.limit }
            : __assign({ hideOnExceedLimit: true }, props.limit);
        var exceedLimit = limit.maxCount && limit.maxCount <= fileList.length;
        var disabledUploadDom = 'disabled' in props ? props.disabled : !limit.hideOnExceedLimit && exceedLimit;
        var uploadDom = (React.createElement("div", __assign({}, omit$1(rest, [
            'disabled',
            'directory',
            'onReupload',
            'defaultFileList',
            'fileList',
            'autoUpload',
            'error',
            'action',
            'multiple',
            'name',
            'accept',
            'customRequest',
            'children',
            'autoUpload',
            'limit',
            'drag',
            'tip',
            'headers',
            'data',
            'withCredentials',
            'onChange',
            'onPreview',
            'onRemove',
            'onProgress',
            'onExceedLimit',
            'beforeUpload',
            'onDrop',
            'onDragOver',
            'onDragLeave',
        ]), { className: cs(prefixCls, (_a = {},
                _a[prefixCls + "-type-" + listType] = listType,
                _a[prefixCls + "-drag"] = props.drag,
                _a[prefixCls + "-disabled"] = disabledUploadDom,
                _a[prefixCls + "-hide"] = limit.hideOnExceedLimit && exceedLimit,
                _a[prefixCls + "-rtl"] = rtl,
                _a), className), style: style }),
            React.createElement(Uploader$1, __assign({ ref: uploaderRef }, props, { limit: limit.maxCount, hide: limit.hideOnExceedLimit && exceedLimit, disabled: disabledUploadDom, prefixCls: prefixCls, fileList: fileList, onProgress: function (file, e) {
                    if (file) {
                        if (!('fileList' in props)) {
                            setInnerUploadState(function (v) {
                                var _a;
                                return __assign(__assign({}, v), (_a = {}, _a[file.uid] = file, _a));
                            });
                        }
                        props.onProgress && props.onProgress(file, e);
                    }
                }, onFileStatusChange: function (file) {
                    var _a;
                    if (!('fileList' in props)) {
                        setInnerUploadState(function (v) {
                            var _a;
                            return __assign(__assign({}, v), (_a = {}, _a[file.uid] = file, _a));
                        });
                    }
                    props.onChange &&
                        props.onChange(getFileList(__assign(__assign({}, uploadState.current), (_a = {}, _a[file.uid] = file, _a))), file);
                } }))));
        return (React.createElement(React.Fragment, null,
            listType !== 'picture-card' && uploadDom,
            showUploadList && (React.createElement(UploadList, { imagePreview: imagePreview, progressProps: progressProps, showUploadList: showUploadList, disabled: props.disabled, listType: listType, fileList: fileList, renderUploadItem: renderUploadItem, renderUploadList: renderUploadList, onUpload: uploadFile, onAbort: abortFile, onRemove: removeFile, onReupload: reuploadFile, onPreview: props.onPreview, prefixCls: prefixCls })),
            listType === 'picture-card' && uploadDom,
            props.tip && listType === 'picture-card' && (React.createElement("div", { className: prefixCls + "-trigger-tip" }, props.tip))));
    };
    var UploadRef = React.forwardRef(Upload$1);
    UploadRef.displayName = 'Upload';
    var Upload$2 = UploadRef;

    function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconRightCircleComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$3(_objectSpread$3({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-right-circle")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("circle", {
        cx: "24",
        cy: "24",
        r: "18"
      }), /*#__PURE__*/React.createElement("path", {
        d: "M19.485 15.515 27.971 24l-8.486 8.485"
      }));
    }

    var IconRightCircle = /*#__PURE__*/React.forwardRef(IconRightCircleComponent);
    IconRightCircle.defaultProps = {
      isIcon: true
    };
    IconRightCircle.displayName = 'IconRightCircle';
    var IconRightCircle$1 = IconRightCircle;

    function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconInfoCircleComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$2(_objectSpread$2({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-info-circle")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M24 20v14m0-16v-4m18 10c0 9.941-8.059 18-18 18S6 33.941 6 24 14.059 6 24 6s18 8.059 18 18Z"
      }));
    }

    var IconInfoCircle = /*#__PURE__*/React.forwardRef(IconInfoCircleComponent);
    IconInfoCircle.defaultProps = {
      isIcon: true
    };
    IconInfoCircle.displayName = 'IconInfoCircle';
    var IconInfoCircle$1 = IconInfoCircle;

    function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function IconMenuComponent(iconProps, ref) {
      var _useContext = React.useContext(IconContext),
          _useContext$prefixCls = _useContext.prefixCls,
          prefixCls = _useContext$prefixCls === void 0 ? 'arco' : _useContext$prefixCls;

      var spin = iconProps.spin,
          className = iconProps.className;

      var props = _objectSpread$1(_objectSpread$1({
        "aria-hidden": true,
        focusable: false,
        ref: ref
      }, iconProps), {}, {
        className: "".concat(className ? className + ' ' : '').concat(prefixCls, "-icon ").concat(prefixCls, "-icon-menu")
      });

      if (spin) {
        props.className = "".concat(props.className, " ").concat(prefixCls, "-icon-loading");
      }

      delete props.spin;
      delete props.isIcon;
      return /*#__PURE__*/React.createElement("svg", _extends({
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "4",
        viewBox: "0 0 48 48"
      }, props), /*#__PURE__*/React.createElement("path", {
        d: "M5 10h38M5 24h38M5 38h38"
      }));
    }

    var IconMenu = /*#__PURE__*/React.forwardRef(IconMenuComponent);
    IconMenu.defaultProps = {
      isIcon: true
    };
    IconMenu.displayName = 'IconMenu';
    var IconMenu$1 = IconMenu;

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArrayLimit(arr, i) {
      var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
      if (null != _i) {
        var _s,
          _e,
          _x,
          _r,
          _arr = [],
          _n = !0,
          _d = !1;
        try {
          if (_x = (_i = _i.call(arr)).next, 0 === i) {
            if (Object(_i) !== _i) return;
            _n = !1;
          } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return;
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }

    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? Object(arguments[i]) : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      }
      return target;
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }

    /**
     * Use invariant() to assert state which your program assumes to be true.
     *
     * Provide sprintf-style format (only %s is supported) and arguments
     * to provide information about what broke and what you were
     * expecting.
     *
     * The invariant message will be stripped in production, but the invariant
     * will remain to ensure logic does not differ in production.
     */

    var NODE_ENV = process.env.NODE_ENV;

    var invariant = function(condition, format, a, b, c, d, e, f) {
      if (NODE_ENV !== 'production') {
        if (format === undefined) {
          throw new Error('invariant requires an error message argument');
        }
      }

      if (!condition) {
        var error;
        if (format === undefined) {
          error = new Error(
            'Minified exception occurred; use the non-minified dev environment ' +
            'for the full error message and additional helpful warnings.'
          );
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(
            format.replace(/%s/g, function() { return args[argIndex++]; })
          );
          error.name = 'Invariant Violation';
        }

        error.framesToPop = 1; // we don't care about invariant's own frame
        throw error;
      }
    };

    var invariant_1 = invariant;

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }

    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }

    var Manager = function () {
      function Manager() {
        _classCallCheck(this, Manager);

        _defineProperty(this, "refs", {});
      }

      _createClass(Manager, [{
        key: "add",
        value: function add(collection, ref) {
          if (!this.refs[collection]) {
            this.refs[collection] = [];
          }

          this.refs[collection].push(ref);
        }
      }, {
        key: "remove",
        value: function remove(collection, ref) {
          var index = this.getIndex(collection, ref);

          if (index !== -1) {
            this.refs[collection].splice(index, 1);
          }
        }
      }, {
        key: "isActive",
        value: function isActive() {
          return this.active;
        }
      }, {
        key: "getActive",
        value: function getActive() {
          var _this = this;

          return this.refs[this.active.collection].find(function (_ref) {
            var node = _ref.node;
            return node.sortableInfo.index == _this.active.index;
          });
        }
      }, {
        key: "getIndex",
        value: function getIndex(collection, ref) {
          return this.refs[collection].indexOf(ref);
        }
      }, {
        key: "getOrderedRefs",
        value: function getOrderedRefs() {
          var collection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.active.collection;
          return this.refs[collection].sort(sortByIndex);
        }
      }]);

      return Manager;
    }();

    function sortByIndex(_ref2, _ref3) {
      var index1 = _ref2.node.sortableInfo.index;
      var index2 = _ref3.node.sortableInfo.index;
      return index1 - index2;
    }
    function omit(obj, keysToOmit) {
      return Object.keys(obj).reduce(function (acc, key) {
        if (keysToOmit.indexOf(key) === -1) {
          acc[key] = obj[key];
        }

        return acc;
      }, {});
    }
    var events = {
      end: ['touchend', 'touchcancel', 'mouseup'],
      move: ['touchmove', 'mousemove'],
      start: ['touchstart', 'mousedown']
    };
    var vendorPrefix = function () {
      if (typeof window === 'undefined' || typeof document === 'undefined') {
        return '';
      }

      var styles = window.getComputedStyle(document.documentElement, '') || ['-moz-hidden-iframe'];
      var pre = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];

      switch (pre) {
        case 'ms':
          return 'ms';

        default:
          return pre && pre.length ? pre[0].toUpperCase() + pre.substr(1) : '';
      }
    }();
    function setInlineStyles(node, styles) {
      Object.keys(styles).forEach(function (key) {
        node.style[key] = styles[key];
      });
    }
    function setTranslate3d(node, translate) {
      node.style["".concat(vendorPrefix, "Transform")] = translate == null ? '' : "translate3d(".concat(translate.x, "px,").concat(translate.y, "px,0)");
    }
    function setTransitionDuration(node, duration) {
      node.style["".concat(vendorPrefix, "TransitionDuration")] = duration == null ? '' : "".concat(duration, "ms");
    }
    function closest(el, fn) {
      while (el) {
        if (fn(el)) {
          return el;
        }

        el = el.parentNode;
      }

      return null;
    }
    function limit(min, max, value) {
      return Math.max(min, Math.min(value, max));
    }

    function getPixelValue(stringValue) {
      if (stringValue.substr(-2) === 'px') {
        return parseFloat(stringValue);
      }

      return 0;
    }

    function getElementMargin(element) {
      var style = window.getComputedStyle(element);
      return {
        bottom: getPixelValue(style.marginBottom),
        left: getPixelValue(style.marginLeft),
        right: getPixelValue(style.marginRight),
        top: getPixelValue(style.marginTop)
      };
    }
    function provideDisplayName(prefix, Component$$1) {
      var componentName = Component$$1.displayName || Component$$1.name;
      return componentName ? "".concat(prefix, "(").concat(componentName, ")") : prefix;
    }
    function getScrollAdjustedBoundingClientRect(node, scrollDelta) {
      var boundingClientRect = node.getBoundingClientRect();
      return {
        top: boundingClientRect.top + scrollDelta.top,
        left: boundingClientRect.left + scrollDelta.left
      };
    }
    function getPosition(event) {
      if (event.touches && event.touches.length) {
        return {
          x: event.touches[0].pageX,
          y: event.touches[0].pageY
        };
      } else if (event.changedTouches && event.changedTouches.length) {
        return {
          x: event.changedTouches[0].pageX,
          y: event.changedTouches[0].pageY
        };
      } else {
        return {
          x: event.pageX,
          y: event.pageY
        };
      }
    }
    function isTouchEvent(event) {
      return event.touches && event.touches.length || event.changedTouches && event.changedTouches.length;
    }
    function getEdgeOffset(node, parent) {
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        left: 0,
        top: 0
      };

      if (!node) {
        return undefined;
      }

      var nodeOffset = {
        left: offset.left + node.offsetLeft,
        top: offset.top + node.offsetTop
      };

      if (node.parentNode === parent) {
        return nodeOffset;
      }

      return getEdgeOffset(node.parentNode, parent, nodeOffset);
    }
    function getTargetIndex(newIndex, prevIndex, oldIndex) {
      if (newIndex < oldIndex && newIndex > prevIndex) {
        return newIndex - 1;
      } else if (newIndex > oldIndex && newIndex < prevIndex) {
        return newIndex + 1;
      } else {
        return newIndex;
      }
    }
    function getLockPixelOffset(_ref) {
      var lockOffset = _ref.lockOffset,
          width = _ref.width,
          height = _ref.height;
      var offsetX = lockOffset;
      var offsetY = lockOffset;
      var unit = 'px';

      if (typeof lockOffset === 'string') {
        var match = /^[+-]?\d*(?:\.\d*)?(px|%)$/.exec(lockOffset);
        invariant_1(match !== null, 'lockOffset value should be a number or a string of a ' + 'number followed by "px" or "%". Given %s', lockOffset);
        offsetX = parseFloat(lockOffset);
        offsetY = parseFloat(lockOffset);
        unit = match[1];
      }

      invariant_1(isFinite(offsetX) && isFinite(offsetY), 'lockOffset value should be a finite. Given %s', lockOffset);

      if (unit === '%') {
        offsetX = offsetX * width / 100;
        offsetY = offsetY * height / 100;
      }

      return {
        x: offsetX,
        y: offsetY
      };
    }
    function getLockPixelOffsets(_ref2) {
      var height = _ref2.height,
          width = _ref2.width,
          lockOffset = _ref2.lockOffset;
      var offsets = Array.isArray(lockOffset) ? lockOffset : [lockOffset, lockOffset];
      invariant_1(offsets.length === 2, 'lockOffset prop of SortableContainer should be a single ' + 'value or an array of exactly two values. Given %s', lockOffset);

      var _offsets = _slicedToArray(offsets, 2),
          minLockOffset = _offsets[0],
          maxLockOffset = _offsets[1];

      return [getLockPixelOffset({
        height: height,
        lockOffset: minLockOffset,
        width: width
      }), getLockPixelOffset({
        height: height,
        lockOffset: maxLockOffset,
        width: width
      })];
    }

    function isScrollable(el) {
      var computedStyle = window.getComputedStyle(el);
      var overflowRegex = /(auto|scroll)/;
      var properties = ['overflow', 'overflowX', 'overflowY'];
      return properties.find(function (property) {
        return overflowRegex.test(computedStyle[property]);
      });
    }

    function getScrollingParent(el) {
      if (!(el instanceof HTMLElement)) {
        return null;
      } else if (isScrollable(el)) {
        return el;
      } else {
        return getScrollingParent(el.parentNode);
      }
    }
    function getContainerGridGap(element) {
      var style = window.getComputedStyle(element);

      if (style.display === 'grid') {
        return {
          x: getPixelValue(style.gridColumnGap),
          y: getPixelValue(style.gridRowGap)
        };
      }

      return {
        x: 0,
        y: 0
      };
    }
    var KEYCODE = {
      TAB: 9,
      ESC: 27,
      SPACE: 32,
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40
    };
    var NodeType = {
      Anchor: 'A',
      Button: 'BUTTON',
      Canvas: 'CANVAS',
      Input: 'INPUT',
      Option: 'OPTION',
      Textarea: 'TEXTAREA',
      Select: 'SELECT'
    };
    function cloneNode(node) {
      var selector = 'input, textarea, select, canvas, [contenteditable]';
      var fields = node.querySelectorAll(selector);
      var clonedNode = node.cloneNode(true);

      var clonedFields = _toConsumableArray(clonedNode.querySelectorAll(selector));

      clonedFields.forEach(function (field, i) {
        if (field.type !== 'file') {
          field.value = fields[i].value;
        }

        if (field.type === 'radio' && field.name) {
          field.name = "__sortableClone__".concat(field.name);
        }

        if (field.tagName === NodeType.Canvas && fields[i].width > 0 && fields[i].height > 0) {
          var destCtx = field.getContext('2d');
          destCtx.drawImage(fields[i], 0, 0);
        }
      });
      return clonedNode;
    }

    function sortableHandle(WrappedComponent) {
      var _class, _temp;

      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        withRef: false
      };
      return _temp = _class = function (_React$Component) {
        _inherits(WithSortableHandle, _React$Component);

        function WithSortableHandle() {
          var _getPrototypeOf2;

          var _this;

          _classCallCheck(this, WithSortableHandle);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WithSortableHandle)).call.apply(_getPrototypeOf2, [this].concat(args)));

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "wrappedInstance", React.createRef());

          return _this;
        }

        _createClass(WithSortableHandle, [{
          key: "componentDidMount",
          value: function componentDidMount() {
            var node = ReactDOM.findDOMNode(this);
            node.sortableHandle = true;
          }
        }, {
          key: "getWrappedInstance",
          value: function getWrappedInstance() {
            invariant_1(config.withRef, 'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableHandle() call');
            return this.wrappedInstance.current;
          }
        }, {
          key: "render",
          value: function render() {
            var ref = config.withRef ? this.wrappedInstance : null;
            return React.createElement(WrappedComponent, _extends$1({
              ref: ref
            }, this.props));
          }
        }]);

        return WithSortableHandle;
      }(React.Component), _defineProperty(_class, "displayName", provideDisplayName('sortableHandle', WrappedComponent)), _temp;
    }
    function isSortableHandle(node) {
      return node.sortableHandle != null;
    }

    var AutoScroller = function () {
      function AutoScroller(container, onScrollCallback) {
        _classCallCheck(this, AutoScroller);

        this.container = container;
        this.onScrollCallback = onScrollCallback;
      }

      _createClass(AutoScroller, [{
        key: "clear",
        value: function clear() {
          if (this.interval == null) {
            return;
          }

          clearInterval(this.interval);
          this.interval = null;
        }
      }, {
        key: "update",
        value: function update(_ref) {
          var _this = this;

          var translate = _ref.translate,
              minTranslate = _ref.minTranslate,
              maxTranslate = _ref.maxTranslate,
              width = _ref.width,
              height = _ref.height;
          var direction = {
            x: 0,
            y: 0
          };
          var speed = {
            x: 1,
            y: 1
          };
          var acceleration = {
            x: 10,
            y: 10
          };
          var _this$container = this.container,
              scrollTop = _this$container.scrollTop,
              scrollLeft = _this$container.scrollLeft,
              scrollHeight = _this$container.scrollHeight,
              scrollWidth = _this$container.scrollWidth,
              clientHeight = _this$container.clientHeight,
              clientWidth = _this$container.clientWidth;
          var isTop = scrollTop === 0;
          var isBottom = scrollHeight - scrollTop - clientHeight === 0;
          var isLeft = scrollLeft === 0;
          var isRight = scrollWidth - scrollLeft - clientWidth === 0;

          if (translate.y >= maxTranslate.y - height / 2 && !isBottom) {
            direction.y = 1;
            speed.y = acceleration.y * Math.abs((maxTranslate.y - height / 2 - translate.y) / height);
          } else if (translate.x >= maxTranslate.x - width / 2 && !isRight) {
            direction.x = 1;
            speed.x = acceleration.x * Math.abs((maxTranslate.x - width / 2 - translate.x) / width);
          } else if (translate.y <= minTranslate.y + height / 2 && !isTop) {
            direction.y = -1;
            speed.y = acceleration.y * Math.abs((translate.y - height / 2 - minTranslate.y) / height);
          } else if (translate.x <= minTranslate.x + width / 2 && !isLeft) {
            direction.x = -1;
            speed.x = acceleration.x * Math.abs((translate.x - width / 2 - minTranslate.x) / width);
          }

          if (this.interval) {
            this.clear();
            this.isAutoScrolling = false;
          }

          if (direction.x !== 0 || direction.y !== 0) {
            this.interval = setInterval(function () {
              _this.isAutoScrolling = true;
              var offset = {
                left: speed.x * direction.x,
                top: speed.y * direction.y
              };
              _this.container.scrollTop += offset.top;
              _this.container.scrollLeft += offset.left;

              _this.onScrollCallback(offset);
            }, 5);
          }
        }
      }]);

      return AutoScroller;
    }();

    function defaultGetHelperDimensions(_ref) {
      var node = _ref.node;
      return {
        height: node.offsetHeight,
        width: node.offsetWidth
      };
    }

    function defaultShouldCancelStart(event) {
      var interactiveElements = [NodeType.Input, NodeType.Textarea, NodeType.Select, NodeType.Option, NodeType.Button];

      if (interactiveElements.indexOf(event.target.tagName) !== -1) {
        return true;
      }

      if (closest(event.target, function (el) {
        return el.contentEditable === 'true';
      })) {
        return true;
      }

      return false;
    }

    var propTypes = {
      axis: PropTypes.oneOf(['x', 'y', 'xy']),
      contentWindow: PropTypes.any,
      disableAutoscroll: PropTypes.bool,
      distance: PropTypes.number,
      getContainer: PropTypes.func,
      getHelperDimensions: PropTypes.func,
      helperClass: PropTypes.string,
      helperContainer: PropTypes.oneOfType([PropTypes.func, typeof HTMLElement === 'undefined' ? PropTypes.any : PropTypes.instanceOf(HTMLElement)]),
      hideSortableGhost: PropTypes.bool,
      keyboardSortingTransitionDuration: PropTypes.number,
      lockAxis: PropTypes.string,
      lockOffset: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string]))]),
      lockToContainerEdges: PropTypes.bool,
      onSortEnd: PropTypes.func,
      onSortMove: PropTypes.func,
      onSortOver: PropTypes.func,
      onSortStart: PropTypes.func,
      pressDelay: PropTypes.number,
      pressThreshold: PropTypes.number,
      keyCodes: PropTypes.shape({
        lift: PropTypes.arrayOf(PropTypes.number),
        drop: PropTypes.arrayOf(PropTypes.number),
        cancel: PropTypes.arrayOf(PropTypes.number),
        up: PropTypes.arrayOf(PropTypes.number),
        down: PropTypes.arrayOf(PropTypes.number)
      }),
      shouldCancelStart: PropTypes.func,
      transitionDuration: PropTypes.number,
      updateBeforeSortStart: PropTypes.func,
      useDragHandle: PropTypes.bool,
      useWindowAsScrollContainer: PropTypes.bool
    };
    var defaultKeyCodes = {
      lift: [KEYCODE.SPACE],
      drop: [KEYCODE.SPACE],
      cancel: [KEYCODE.ESC],
      up: [KEYCODE.UP, KEYCODE.LEFT],
      down: [KEYCODE.DOWN, KEYCODE.RIGHT]
    };
    var defaultProps = {
      axis: 'y',
      disableAutoscroll: false,
      distance: 0,
      getHelperDimensions: defaultGetHelperDimensions,
      hideSortableGhost: true,
      lockOffset: '50%',
      lockToContainerEdges: false,
      pressDelay: 0,
      pressThreshold: 5,
      keyCodes: defaultKeyCodes,
      shouldCancelStart: defaultShouldCancelStart,
      transitionDuration: 300,
      useWindowAsScrollContainer: false
    };
    var omittedProps = Object.keys(propTypes);
    function validateProps(props) {
      invariant_1(!(props.distance && props.pressDelay), 'Attempted to set both `pressDelay` and `distance` on SortableContainer, you may only use one or the other, not both at the same time.');
    }

    function _finallyRethrows(body, finalizer) {
      try {
        var result = body();
      } catch (e) {
        return finalizer(true, e);
      }

      if (result && result.then) {
        return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
      }

      return finalizer(false, value);
    }
    var SortableContext = React.createContext({
      manager: {}
    });
    function sortableContainer(WrappedComponent) {
      var _class, _temp;

      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        withRef: false
      };
      return _temp = _class = function (_React$Component) {
        _inherits(WithSortableContainer, _React$Component);

        function WithSortableContainer(props) {
          var _this;

          _classCallCheck(this, WithSortableContainer);

          _this = _possibleConstructorReturn(this, _getPrototypeOf(WithSortableContainer).call(this, props));

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {});

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "handleStart", function (event) {
            var _this$props = _this.props,
                distance = _this$props.distance,
                shouldCancelStart = _this$props.shouldCancelStart;

            if (event.button === 2 || shouldCancelStart(event)) {
              return;
            }

            _this.touched = true;
            _this.position = getPosition(event);
            var node = closest(event.target, function (el) {
              return el.sortableInfo != null;
            });

            if (node && node.sortableInfo && _this.nodeIsChild(node) && !_this.state.sorting) {
              var useDragHandle = _this.props.useDragHandle;
              var _node$sortableInfo = node.sortableInfo,
                  index = _node$sortableInfo.index,
                  collection = _node$sortableInfo.collection,
                  disabled = _node$sortableInfo.disabled;

              if (disabled) {
                return;
              }

              if (useDragHandle && !closest(event.target, isSortableHandle)) {
                return;
              }

              _this.manager.active = {
                collection: collection,
                index: index
              };

              if (!isTouchEvent(event) && event.target.tagName === NodeType.Anchor) {
                event.preventDefault();
              }

              if (!distance) {
                if (_this.props.pressDelay === 0) {
                  _this.handlePress(event);
                } else {
                  _this.pressTimer = setTimeout(function () {
                    return _this.handlePress(event);
                  }, _this.props.pressDelay);
                }
              }
            }
          });

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "nodeIsChild", function (node) {
            return node.sortableInfo.manager === _this.manager;
          });

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "handleMove", function (event) {
            var _this$props2 = _this.props,
                distance = _this$props2.distance,
                pressThreshold = _this$props2.pressThreshold;

            if (!_this.state.sorting && _this.touched && !_this._awaitingUpdateBeforeSortStart) {
              var position = getPosition(event);
              var delta = {
                x: _this.position.x - position.x,
                y: _this.position.y - position.y
              };
              var combinedDelta = Math.abs(delta.x) + Math.abs(delta.y);
              _this.delta = delta;

              if (!distance && (!pressThreshold || combinedDelta >= pressThreshold)) {
                clearTimeout(_this.cancelTimer);
                _this.cancelTimer = setTimeout(_this.cancel, 0);
              } else if (distance && combinedDelta >= distance && _this.manager.isActive()) {
                _this.handlePress(event);
              }
            }
          });

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "handleEnd", function () {
            _this.touched = false;

            _this.cancel();
          });

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "cancel", function () {
            var distance = _this.props.distance;
            var sorting = _this.state.sorting;

            if (!sorting) {
              if (!distance) {
                clearTimeout(_this.pressTimer);
              }

              _this.manager.active = null;
            }
          });

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "handlePress", function (event) {
            try {
              var active = _this.manager.getActive();

              var _temp6 = function () {
                if (active) {
                  var _temp7 = function _temp7() {
                    var index = _node.sortableInfo.index;
                    var margin = getElementMargin(_node);
                    var gridGap = getContainerGridGap(_this.container);

                    var containerBoundingRect = _this.scrollContainer.getBoundingClientRect();

                    var dimensions = _getHelperDimensions({
                      index: index,
                      node: _node,
                      collection: _collection
                    });

                    _this.node = _node;
                    _this.margin = margin;
                    _this.gridGap = gridGap;
                    _this.width = dimensions.width;
                    _this.height = dimensions.height;
                    _this.marginOffset = {
                      x: _this.margin.left + _this.margin.right + _this.gridGap.x,
                      y: Math.max(_this.margin.top, _this.margin.bottom, _this.gridGap.y)
                    };
                    _this.boundingClientRect = _node.getBoundingClientRect();
                    _this.containerBoundingRect = containerBoundingRect;
                    _this.index = index;
                    _this.newIndex = index;
                    _this.axis = {
                      x: _axis.indexOf('x') >= 0,
                      y: _axis.indexOf('y') >= 0
                    };
                    _this.offsetEdge = getEdgeOffset(_node, _this.container);

                    if (_isKeySorting) {
                      _this.initialOffset = getPosition(_objectSpread({}, event, {
                        pageX: _this.boundingClientRect.left,
                        pageY: _this.boundingClientRect.top
                      }));
                    } else {
                      _this.initialOffset = getPosition(event);
                    }

                    _this.initialScroll = {
                      left: _this.scrollContainer.scrollLeft,
                      top: _this.scrollContainer.scrollTop
                    };
                    _this.initialWindowScroll = {
                      left: window.pageXOffset,
                      top: window.pageYOffset
                    };
                    _this.helper = _this.helperContainer.appendChild(cloneNode(_node));
                    setInlineStyles(_this.helper, {
                      boxSizing: 'border-box',
                      height: "".concat(_this.height, "px"),
                      left: "".concat(_this.boundingClientRect.left - margin.left, "px"),
                      pointerEvents: 'none',
                      position: 'fixed',
                      top: "".concat(_this.boundingClientRect.top - margin.top, "px"),
                      width: "".concat(_this.width, "px")
                    });

                    if (_isKeySorting) {
                      _this.helper.focus();
                    }

                    if (_hideSortableGhost) {
                      _this.sortableGhost = _node;
                      setInlineStyles(_node, {
                        opacity: 0,
                        visibility: 'hidden'
                      });
                    }

                    _this.minTranslate = {};
                    _this.maxTranslate = {};

                    if (_isKeySorting) {
                      var _ref = _useWindowAsScrollContainer ? {
                        top: 0,
                        left: 0,
                        width: _this.contentWindow.innerWidth,
                        height: _this.contentWindow.innerHeight
                      } : _this.containerBoundingRect,
                          containerTop = _ref.top,
                          containerLeft = _ref.left,
                          containerWidth = _ref.width,
                          containerHeight = _ref.height;

                      var containerBottom = containerTop + containerHeight;
                      var containerRight = containerLeft + containerWidth;

                      if (_this.axis.x) {
                        _this.minTranslate.x = containerLeft - _this.boundingClientRect.left;
                        _this.maxTranslate.x = containerRight - (_this.boundingClientRect.left + _this.width);
                      }

                      if (_this.axis.y) {
                        _this.minTranslate.y = containerTop - _this.boundingClientRect.top;
                        _this.maxTranslate.y = containerBottom - (_this.boundingClientRect.top + _this.height);
                      }
                    } else {
                      if (_this.axis.x) {
                        _this.minTranslate.x = (_useWindowAsScrollContainer ? 0 : containerBoundingRect.left) - _this.boundingClientRect.left - _this.width / 2;
                        _this.maxTranslate.x = (_useWindowAsScrollContainer ? _this.contentWindow.innerWidth : containerBoundingRect.left + containerBoundingRect.width) - _this.boundingClientRect.left - _this.width / 2;
                      }

                      if (_this.axis.y) {
                        _this.minTranslate.y = (_useWindowAsScrollContainer ? 0 : containerBoundingRect.top) - _this.boundingClientRect.top - _this.height / 2;
                        _this.maxTranslate.y = (_useWindowAsScrollContainer ? _this.contentWindow.innerHeight : containerBoundingRect.top + containerBoundingRect.height) - _this.boundingClientRect.top - _this.height / 2;
                      }
                    }

                    if (_helperClass) {
                      _helperClass.split(' ').forEach(function (className) {
                        return _this.helper.classList.add(className);
                      });
                    }

                    _this.listenerNode = event.touches ? event.target : _this.contentWindow;

                    if (_isKeySorting) {
                      _this.listenerNode.addEventListener('wheel', _this.handleKeyEnd, true);

                      _this.listenerNode.addEventListener('mousedown', _this.handleKeyEnd, true);

                      _this.listenerNode.addEventListener('keydown', _this.handleKeyDown);
                    } else {
                      events.move.forEach(function (eventName) {
                        return _this.listenerNode.addEventListener(eventName, _this.handleSortMove, false);
                      });
                      events.end.forEach(function (eventName) {
                        return _this.listenerNode.addEventListener(eventName, _this.handleSortEnd, false);
                      });
                    }

                    _this.setState({
                      sorting: true,
                      sortingIndex: index
                    });

                    if (_onSortStart) {
                      _onSortStart({
                        node: _node,
                        index: index,
                        collection: _collection,
                        isKeySorting: _isKeySorting,
                        nodes: _this.manager.getOrderedRefs(),
                        helper: _this.helper
                      }, event);
                    }

                    if (_isKeySorting) {
                      _this.keyMove(0);
                    }
                  };

                  var _this$props3 = _this.props,
                      _axis = _this$props3.axis,
                      _getHelperDimensions = _this$props3.getHelperDimensions,
                      _helperClass = _this$props3.helperClass,
                      _hideSortableGhost = _this$props3.hideSortableGhost,
                      updateBeforeSortStart = _this$props3.updateBeforeSortStart,
                      _onSortStart = _this$props3.onSortStart,
                      _useWindowAsScrollContainer = _this$props3.useWindowAsScrollContainer;
                  var _node = active.node,
                      _collection = active.collection;
                  var _isKeySorting = _this.manager.isKeySorting;

                  var _temp8 = function () {
                    if (typeof updateBeforeSortStart === 'function') {
                      _this._awaitingUpdateBeforeSortStart = true;

                      var _temp9 = _finallyRethrows(function () {
                        var index = _node.sortableInfo.index;
                        return Promise.resolve(updateBeforeSortStart({
                          collection: _collection,
                          index: index,
                          node: _node,
                          isKeySorting: _isKeySorting
                        }, event)).then(function () {});
                      }, function (_wasThrown, _result) {
                        _this._awaitingUpdateBeforeSortStart = false;
                        if (_wasThrown) throw _result;
                        return _result;
                      });

                      if (_temp9 && _temp9.then) return _temp9.then(function () {});
                    }
                  }();

                  return _temp8 && _temp8.then ? _temp8.then(_temp7) : _temp7(_temp8);
                }
              }();

              return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(function () {}) : void 0);
            } catch (e) {
              return Promise.reject(e);
            }
          });

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "handleSortMove", function (event) {
            var onSortMove = _this.props.onSortMove;

            if (typeof event.preventDefault === 'function' && event.cancelable) {
              event.preventDefault();
            }

            _this.updateHelperPosition(event);

            _this.animateNodes();

            _this.autoscroll();

            if (onSortMove) {
              onSortMove(event);
            }
          });

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "handleSortEnd", function (event) {
            var _this$props4 = _this.props,
                hideSortableGhost = _this$props4.hideSortableGhost,
                onSortEnd = _this$props4.onSortEnd;
            var _this$manager = _this.manager,
                collection = _this$manager.active.collection,
                isKeySorting = _this$manager.isKeySorting;

            var nodes = _this.manager.getOrderedRefs();

            if (_this.listenerNode) {
              if (isKeySorting) {
                _this.listenerNode.removeEventListener('wheel', _this.handleKeyEnd, true);

                _this.listenerNode.removeEventListener('mousedown', _this.handleKeyEnd, true);

                _this.listenerNode.removeEventListener('keydown', _this.handleKeyDown);
              } else {
                events.move.forEach(function (eventName) {
                  return _this.listenerNode.removeEventListener(eventName, _this.handleSortMove);
                });
                events.end.forEach(function (eventName) {
                  return _this.listenerNode.removeEventListener(eventName, _this.handleSortEnd);
                });
              }
            }

            _this.helper.parentNode.removeChild(_this.helper);

            if (hideSortableGhost && _this.sortableGhost) {
              setInlineStyles(_this.sortableGhost, {
                opacity: '',
                visibility: ''
              });
            }

            for (var i = 0, len = nodes.length; i < len; i++) {
              var _node2 = nodes[i];
              var el = _node2.node;
              _node2.edgeOffset = null;
              _node2.boundingClientRect = null;
              setTranslate3d(el, null);
              setTransitionDuration(el, null);
              _node2.translate = null;
            }

            _this.autoScroller.clear();

            _this.manager.active = null;
            _this.manager.isKeySorting = false;

            _this.setState({
              sorting: false,
              sortingIndex: null
            });

            if (typeof onSortEnd === 'function') {
              onSortEnd({
                collection: collection,
                newIndex: _this.newIndex,
                oldIndex: _this.index,
                isKeySorting: isKeySorting,
                nodes: nodes
              }, event);
            }

            _this.touched = false;
          });

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "autoscroll", function () {
            var disableAutoscroll = _this.props.disableAutoscroll;
            var isKeySorting = _this.manager.isKeySorting;

            if (disableAutoscroll) {
              _this.autoScroller.clear();

              return;
            }

            if (isKeySorting) {
              var translate = _objectSpread({}, _this.translate);

              var scrollX = 0;
              var scrollY = 0;

              if (_this.axis.x) {
                translate.x = Math.min(_this.maxTranslate.x, Math.max(_this.minTranslate.x, _this.translate.x));
                scrollX = _this.translate.x - translate.x;
              }

              if (_this.axis.y) {
                translate.y = Math.min(_this.maxTranslate.y, Math.max(_this.minTranslate.y, _this.translate.y));
                scrollY = _this.translate.y - translate.y;
              }

              _this.translate = translate;
              setTranslate3d(_this.helper, _this.translate);
              _this.scrollContainer.scrollLeft += scrollX;
              _this.scrollContainer.scrollTop += scrollY;
              return;
            }

            _this.autoScroller.update({
              height: _this.height,
              maxTranslate: _this.maxTranslate,
              minTranslate: _this.minTranslate,
              translate: _this.translate,
              width: _this.width
            });
          });

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onAutoScroll", function (offset) {
            _this.translate.x += offset.left;
            _this.translate.y += offset.top;

            _this.animateNodes();
          });

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "handleKeyDown", function (event) {
            var keyCode = event.keyCode;
            var _this$props5 = _this.props,
                shouldCancelStart = _this$props5.shouldCancelStart,
                _this$props5$keyCodes = _this$props5.keyCodes,
                customKeyCodes = _this$props5$keyCodes === void 0 ? {} : _this$props5$keyCodes;

            var keyCodes = _objectSpread({}, defaultKeyCodes, customKeyCodes);

            if (_this.manager.active && !_this.manager.isKeySorting || !_this.manager.active && (!keyCodes.lift.includes(keyCode) || shouldCancelStart(event) || !_this.isValidSortingTarget(event))) {
              return;
            }

            event.stopPropagation();
            event.preventDefault();

            if (keyCodes.lift.includes(keyCode) && !_this.manager.active) {
              _this.keyLift(event);
            } else if (keyCodes.drop.includes(keyCode) && _this.manager.active) {
              _this.keyDrop(event);
            } else if (keyCodes.cancel.includes(keyCode)) {
              _this.newIndex = _this.manager.active.index;

              _this.keyDrop(event);
            } else if (keyCodes.up.includes(keyCode)) {
              _this.keyMove(-1);
            } else if (keyCodes.down.includes(keyCode)) {
              _this.keyMove(1);
            }
          });

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "keyLift", function (event) {
            var target = event.target;
            var node = closest(target, function (el) {
              return el.sortableInfo != null;
            });
            var _node$sortableInfo2 = node.sortableInfo,
                index = _node$sortableInfo2.index,
                collection = _node$sortableInfo2.collection;
            _this.initialFocusedNode = target;
            _this.manager.isKeySorting = true;
            _this.manager.active = {
              index: index,
              collection: collection
            };

            _this.handlePress(event);
          });

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "keyMove", function (shift) {
            var nodes = _this.manager.getOrderedRefs();

            var lastIndex = nodes[nodes.length - 1].node.sortableInfo.index;
            var newIndex = _this.newIndex + shift;
            var prevIndex = _this.newIndex;

            if (newIndex < 0 || newIndex > lastIndex) {
              return;
            }

            _this.prevIndex = prevIndex;
            _this.newIndex = newIndex;
            var targetIndex = getTargetIndex(_this.newIndex, _this.prevIndex, _this.index);
            var target = nodes.find(function (_ref2) {
              var node = _ref2.node;
              return node.sortableInfo.index === targetIndex;
            });
            var targetNode = target.node;
            var scrollDelta = _this.containerScrollDelta;
            var targetBoundingClientRect = target.boundingClientRect || getScrollAdjustedBoundingClientRect(targetNode, scrollDelta);
            var targetTranslate = target.translate || {
              x: 0,
              y: 0
            };
            var targetPosition = {
              top: targetBoundingClientRect.top + targetTranslate.y - scrollDelta.top,
              left: targetBoundingClientRect.left + targetTranslate.x - scrollDelta.left
            };
            var shouldAdjustForSize = prevIndex < newIndex;
            var sizeAdjustment = {
              x: shouldAdjustForSize && _this.axis.x ? targetNode.offsetWidth - _this.width : 0,
              y: shouldAdjustForSize && _this.axis.y ? targetNode.offsetHeight - _this.height : 0
            };

            _this.handleSortMove({
              pageX: targetPosition.left + sizeAdjustment.x,
              pageY: targetPosition.top + sizeAdjustment.y,
              ignoreTransition: shift === 0
            });
          });

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "keyDrop", function (event) {
            _this.handleSortEnd(event);

            if (_this.initialFocusedNode) {
              _this.initialFocusedNode.focus();
            }
          });

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "handleKeyEnd", function (event) {
            if (_this.manager.active) {
              _this.keyDrop(event);
            }
          });

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "isValidSortingTarget", function (event) {
            var useDragHandle = _this.props.useDragHandle;
            var target = event.target;
            var node = closest(target, function (el) {
              return el.sortableInfo != null;
            });
            return node && node.sortableInfo && !node.sortableInfo.disabled && (useDragHandle ? isSortableHandle(target) : target.sortableInfo);
          });

          var manager = new Manager();
          validateProps(props);
          _this.manager = manager;
          _this.wrappedInstance = React.createRef();
          _this.sortableContextValue = {
            manager: manager
          };
          _this.events = {
            end: _this.handleEnd,
            move: _this.handleMove,
            start: _this.handleStart
          };
          return _this;
        }

        _createClass(WithSortableContainer, [{
          key: "componentDidMount",
          value: function componentDidMount() {
            var _this2 = this;

            var useWindowAsScrollContainer = this.props.useWindowAsScrollContainer;
            var container = this.getContainer();
            Promise.resolve(container).then(function (containerNode) {
              _this2.container = containerNode;
              _this2.document = _this2.container.ownerDocument || document;
              var contentWindow = _this2.props.contentWindow || _this2.document.defaultView || window;
              _this2.contentWindow = typeof contentWindow === 'function' ? contentWindow() : contentWindow;
              _this2.scrollContainer = useWindowAsScrollContainer ? _this2.document.scrollingElement || _this2.document.documentElement : getScrollingParent(_this2.container) || _this2.container;
              _this2.autoScroller = new AutoScroller(_this2.scrollContainer, _this2.onAutoScroll);
              Object.keys(_this2.events).forEach(function (key) {
                return events[key].forEach(function (eventName) {
                  return _this2.container.addEventListener(eventName, _this2.events[key], false);
                });
              });

              _this2.container.addEventListener('keydown', _this2.handleKeyDown);
            });
          }
        }, {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            var _this3 = this;

            if (this.helper && this.helper.parentNode) {
              this.helper.parentNode.removeChild(this.helper);
            }

            if (!this.container) {
              return;
            }

            Object.keys(this.events).forEach(function (key) {
              return events[key].forEach(function (eventName) {
                return _this3.container.removeEventListener(eventName, _this3.events[key]);
              });
            });
            this.container.removeEventListener('keydown', this.handleKeyDown);
          }
        }, {
          key: "updateHelperPosition",
          value: function updateHelperPosition(event) {
            var _this$props6 = this.props,
                lockAxis = _this$props6.lockAxis,
                lockOffset = _this$props6.lockOffset,
                lockToContainerEdges = _this$props6.lockToContainerEdges,
                transitionDuration = _this$props6.transitionDuration,
                _this$props6$keyboard = _this$props6.keyboardSortingTransitionDuration,
                keyboardSortingTransitionDuration = _this$props6$keyboard === void 0 ? transitionDuration : _this$props6$keyboard;
            var isKeySorting = this.manager.isKeySorting;
            var ignoreTransition = event.ignoreTransition;
            var offset = getPosition(event);
            var translate = {
              x: offset.x - this.initialOffset.x,
              y: offset.y - this.initialOffset.y
            };
            translate.y -= window.pageYOffset - this.initialWindowScroll.top;
            translate.x -= window.pageXOffset - this.initialWindowScroll.left;
            this.translate = translate;

            if (lockToContainerEdges) {
              var _getLockPixelOffsets = getLockPixelOffsets({
                height: this.height,
                lockOffset: lockOffset,
                width: this.width
              }),
                  _getLockPixelOffsets2 = _slicedToArray(_getLockPixelOffsets, 2),
                  minLockOffset = _getLockPixelOffsets2[0],
                  maxLockOffset = _getLockPixelOffsets2[1];

              var minOffset = {
                x: this.width / 2 - minLockOffset.x,
                y: this.height / 2 - minLockOffset.y
              };
              var maxOffset = {
                x: this.width / 2 - maxLockOffset.x,
                y: this.height / 2 - maxLockOffset.y
              };
              translate.x = limit(this.minTranslate.x + minOffset.x, this.maxTranslate.x - maxOffset.x, translate.x);
              translate.y = limit(this.minTranslate.y + minOffset.y, this.maxTranslate.y - maxOffset.y, translate.y);
            }

            if (lockAxis === 'x') {
              translate.y = 0;
            } else if (lockAxis === 'y') {
              translate.x = 0;
            }

            if (isKeySorting && keyboardSortingTransitionDuration && !ignoreTransition) {
              setTransitionDuration(this.helper, keyboardSortingTransitionDuration);
            }

            setTranslate3d(this.helper, translate);
          }
        }, {
          key: "animateNodes",
          value: function animateNodes() {
            var _this$props7 = this.props,
                transitionDuration = _this$props7.transitionDuration,
                hideSortableGhost = _this$props7.hideSortableGhost,
                onSortOver = _this$props7.onSortOver;
            var containerScrollDelta = this.containerScrollDelta,
                windowScrollDelta = this.windowScrollDelta;
            var nodes = this.manager.getOrderedRefs();
            var sortingOffset = {
              left: this.offsetEdge.left + this.translate.x + containerScrollDelta.left,
              top: this.offsetEdge.top + this.translate.y + containerScrollDelta.top
            };
            var isKeySorting = this.manager.isKeySorting;
            var prevIndex = this.newIndex;
            this.newIndex = null;

            for (var i = 0, len = nodes.length; i < len; i++) {
              var _node3 = nodes[i].node;
              var index = _node3.sortableInfo.index;
              var width = _node3.offsetWidth;
              var height = _node3.offsetHeight;
              var offset = {
                height: this.height > height ? height / 2 : this.height / 2,
                width: this.width > width ? width / 2 : this.width / 2
              };
              var mustShiftBackward = isKeySorting && index > this.index && index <= prevIndex;
              var mustShiftForward = isKeySorting && index < this.index && index >= prevIndex;
              var translate = {
                x: 0,
                y: 0
              };
              var edgeOffset = nodes[i].edgeOffset;

              if (!edgeOffset) {
                edgeOffset = getEdgeOffset(_node3, this.container);
                nodes[i].edgeOffset = edgeOffset;

                if (isKeySorting) {
                  nodes[i].boundingClientRect = getScrollAdjustedBoundingClientRect(_node3, containerScrollDelta);
                }
              }

              var nextNode = i < nodes.length - 1 && nodes[i + 1];
              var prevNode = i > 0 && nodes[i - 1];

              if (nextNode && !nextNode.edgeOffset) {
                nextNode.edgeOffset = getEdgeOffset(nextNode.node, this.container);

                if (isKeySorting) {
                  nextNode.boundingClientRect = getScrollAdjustedBoundingClientRect(nextNode.node, containerScrollDelta);
                }
              }

              if (index === this.index) {
                if (hideSortableGhost) {
                  this.sortableGhost = _node3;
                  setInlineStyles(_node3, {
                    opacity: 0,
                    visibility: 'hidden'
                  });
                }

                continue;
              }

              if (transitionDuration) {
                setTransitionDuration(_node3, transitionDuration);
              }

              if (this.axis.x) {
                if (this.axis.y) {
                  if (mustShiftForward || index < this.index && (sortingOffset.left + windowScrollDelta.left - offset.width <= edgeOffset.left && sortingOffset.top + windowScrollDelta.top <= edgeOffset.top + offset.height || sortingOffset.top + windowScrollDelta.top + offset.height <= edgeOffset.top)) {
                    translate.x = this.width + this.marginOffset.x;

                    if (edgeOffset.left + translate.x > this.containerBoundingRect.width - offset.width) {
                      if (nextNode) {
                        translate.x = nextNode.edgeOffset.left - edgeOffset.left;
                        translate.y = nextNode.edgeOffset.top - edgeOffset.top;
                      }
                    }

                    if (this.newIndex === null) {
                      this.newIndex = index;
                    }
                  } else if (mustShiftBackward || index > this.index && (sortingOffset.left + windowScrollDelta.left + offset.width >= edgeOffset.left && sortingOffset.top + windowScrollDelta.top + offset.height >= edgeOffset.top || sortingOffset.top + windowScrollDelta.top + offset.height >= edgeOffset.top + height)) {
                    translate.x = -(this.width + this.marginOffset.x);

                    if (edgeOffset.left + translate.x < this.containerBoundingRect.left + offset.width) {
                      if (prevNode) {
                        translate.x = prevNode.edgeOffset.left - edgeOffset.left;
                        translate.y = prevNode.edgeOffset.top - edgeOffset.top;
                      }
                    }

                    this.newIndex = index;
                  }
                } else {
                  if (mustShiftBackward || index > this.index && sortingOffset.left + windowScrollDelta.left + offset.width >= edgeOffset.left) {
                    translate.x = -(this.width + this.marginOffset.x);
                    this.newIndex = index;
                  } else if (mustShiftForward || index < this.index && sortingOffset.left + windowScrollDelta.left <= edgeOffset.left + offset.width) {
                    translate.x = this.width + this.marginOffset.x;

                    if (this.newIndex == null) {
                      this.newIndex = index;
                    }
                  }
                }
              } else if (this.axis.y) {
                if (mustShiftBackward || index > this.index && sortingOffset.top + windowScrollDelta.top + offset.height >= edgeOffset.top) {
                  translate.y = -(this.height + this.marginOffset.y);
                  this.newIndex = index;
                } else if (mustShiftForward || index < this.index && sortingOffset.top + windowScrollDelta.top <= edgeOffset.top + offset.height) {
                  translate.y = this.height + this.marginOffset.y;

                  if (this.newIndex == null) {
                    this.newIndex = index;
                  }
                }
              }

              setTranslate3d(_node3, translate);
              nodes[i].translate = translate;
            }

            if (this.newIndex == null) {
              this.newIndex = this.index;
            }

            if (isKeySorting) {
              this.newIndex = prevIndex;
            }

            var oldIndex = isKeySorting ? this.prevIndex : prevIndex;

            if (onSortOver && this.newIndex !== oldIndex) {
              onSortOver({
                collection: this.manager.active.collection,
                index: this.index,
                newIndex: this.newIndex,
                oldIndex: oldIndex,
                isKeySorting: isKeySorting,
                nodes: nodes,
                helper: this.helper
              });
            }
          }
        }, {
          key: "getWrappedInstance",
          value: function getWrappedInstance() {
            invariant_1(config.withRef, 'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableContainer() call');
            return this.wrappedInstance.current;
          }
        }, {
          key: "getContainer",
          value: function getContainer() {
            var getContainer = this.props.getContainer;

            if (typeof getContainer !== 'function') {
              return ReactDOM.findDOMNode(this);
            }

            return getContainer(config.withRef ? this.getWrappedInstance() : undefined);
          }
        }, {
          key: "render",
          value: function render() {
            var ref = config.withRef ? this.wrappedInstance : null;
            return React.createElement(SortableContext.Provider, {
              value: this.sortableContextValue
            }, React.createElement(WrappedComponent, _extends$1({
              ref: ref
            }, omit(this.props, omittedProps))));
          }
        }, {
          key: "helperContainer",
          get: function get() {
            var helperContainer = this.props.helperContainer;

            if (typeof helperContainer === 'function') {
              return helperContainer();
            }

            return this.props.helperContainer || this.document.body;
          }
        }, {
          key: "containerScrollDelta",
          get: function get() {
            var useWindowAsScrollContainer = this.props.useWindowAsScrollContainer;

            if (useWindowAsScrollContainer) {
              return {
                left: 0,
                top: 0
              };
            }

            return {
              left: this.scrollContainer.scrollLeft - this.initialScroll.left,
              top: this.scrollContainer.scrollTop - this.initialScroll.top
            };
          }
        }, {
          key: "windowScrollDelta",
          get: function get() {
            return {
              left: this.contentWindow.pageXOffset - this.initialWindowScroll.left,
              top: this.contentWindow.pageYOffset - this.initialWindowScroll.top
            };
          }
        }]);

        return WithSortableContainer;
      }(React.Component), _defineProperty(_class, "displayName", provideDisplayName('sortableList', WrappedComponent)), _defineProperty(_class, "defaultProps", defaultProps), _defineProperty(_class, "propTypes", propTypes), _temp;
    }

    var propTypes$1 = {
      index: PropTypes.number.isRequired,
      collection: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
      disabled: PropTypes.bool
    };
    var omittedProps$1 = Object.keys(propTypes$1);
    function sortableElement(WrappedComponent) {
      var _class, _temp;

      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        withRef: false
      };
      return _temp = _class = function (_React$Component) {
        _inherits(WithSortableElement, _React$Component);

        function WithSortableElement() {
          var _getPrototypeOf2;

          var _this;

          _classCallCheck(this, WithSortableElement);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WithSortableElement)).call.apply(_getPrototypeOf2, [this].concat(args)));

          _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "wrappedInstance", React.createRef());

          return _this;
        }

        _createClass(WithSortableElement, [{
          key: "componentDidMount",
          value: function componentDidMount() {
            this.register();
          }
        }, {
          key: "componentDidUpdate",
          value: function componentDidUpdate(prevProps) {
            if (this.node) {
              if (prevProps.index !== this.props.index) {
                this.node.sortableInfo.index = this.props.index;
              }

              if (prevProps.disabled !== this.props.disabled) {
                this.node.sortableInfo.disabled = this.props.disabled;
              }
            }

            if (prevProps.collection !== this.props.collection) {
              this.unregister(prevProps.collection);
              this.register();
            }
          }
        }, {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            this.unregister();
          }
        }, {
          key: "register",
          value: function register() {
            var _this$props = this.props,
                collection = _this$props.collection,
                disabled = _this$props.disabled,
                index = _this$props.index;
            var node = ReactDOM.findDOMNode(this);
            node.sortableInfo = {
              collection: collection,
              disabled: disabled,
              index: index,
              manager: this.context.manager
            };
            this.node = node;
            this.ref = {
              node: node
            };
            this.context.manager.add(collection, this.ref);
          }
        }, {
          key: "unregister",
          value: function unregister() {
            var collection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.collection;
            this.context.manager.remove(collection, this.ref);
          }
        }, {
          key: "getWrappedInstance",
          value: function getWrappedInstance() {
            invariant_1(config.withRef, 'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableElement() call');
            return this.wrappedInstance.current;
          }
        }, {
          key: "render",
          value: function render() {
            var ref = config.withRef ? this.wrappedInstance : null;
            return React.createElement(WrappedComponent, _extends$1({
              ref: ref
            }, omit(this.props, omittedProps$1)));
          }
        }]);

        return WithSortableElement;
      }(React.Component), _defineProperty(_class, "displayName", provideDisplayName('sortableElement', WrappedComponent)), _defineProperty(_class, "contextType", SortableContext), _defineProperty(_class, "propTypes", propTypes$1), _defineProperty(_class, "defaultProps", {
        collection: 0
      }), _temp;
    }

    var classnames = createCommonjsModule(function (module) {
    /* global define */

    (function () {

    	var hasOwn = {}.hasOwnProperty;

    	function classNames() {
    		var classes = [];

    		for (var i = 0; i < arguments.length; i++) {
    			var arg = arguments[i];
    			if (!arg) continue;

    			var argType = typeof arg;

    			if (argType === 'string' || argType === 'number') {
    				classes.push(arg);
    			} else if (Array.isArray(arg)) {
    				if (arg.length) {
    					var inner = classNames.apply(null, arg);
    					if (inner) {
    						classes.push(inner);
    					}
    				}
    			} else if (argType === 'object') {
    				if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
    					classes.push(arg.toString());
    					continue;
    				}

    				for (var key in arg) {
    					if (hasOwn.call(arg, key) && arg[key]) {
    						classes.push(key);
    					}
    				}
    			}
    		}

    		return classes.join(' ');
    	}

    	if (module.exports) {
    		classNames.default = classNames;
    		module.exports = classNames;
    	} else {
    		window.classNames = classNames;
    	}
    }());
    });

    var usePrefixCls = function (tag, props) {
        var _a;
        return (_a = props === null || props === void 0 ? void 0 : props.prefixCls) !== null && _a !== void 0 ? _a : "formily-arco".concat(tag ? "-".concat(tag) : '');
    };

    var formatMomentValue = function (value, format, placeholder) {
        var formatDate = function (date, format, i) {
            if (i === void 0) { i = 0; }
            if (!date)
                return placeholder;
            if (Formily.Shared.isArr(format)) {
                var _format = format[i];
                if (Formily.Shared.isFn(_format)) {
                    return _format(date);
                }
                return (date === null || date === void 0 ? void 0 : date.format) ? date.format(_format) : date;
            }
            else {
                if (Formily.Shared.isFn(format)) {
                    return format(date);
                }
                return (date === null || date === void 0 ? void 0 : date.format) ? date.format(format) : date;
            }
        };
        if (Formily.Shared.isArr(value)) {
            return value.map(function (val, index) {
                return formatDate(val, format, index);
            });
        }
        else {
            return value ? formatDate(value, format) : value || placeholder;
        }
    };

    var pickDataProps = function (props) {
        if (props === void 0) { props = {}; }
        return Object.keys(props).reduce(function (buf, key) {
            if (key.includes('data-')) {
                buf[key] = props[key];
            }
            return buf;
        }, {});
    };

    var PortalMap = Formily.Reactive.observable(new Map());
    var createPortalProvider = function (id) {
        var Portal = function (props) {
            if (props.id && !PortalMap.has(props.id)) {
                PortalMap.set(props.id, null);
            }
            return (React.createElement(React.Fragment, null,
                props.children,
                React.createElement(Formily.React.Observer, null, function () {
                    if (!props.id)
                        return null;
                    var portal = PortalMap.get(props.id);
                    if (portal)
                        return ReactDOM.createPortal(portal, document.body);
                    return null;
                })));
        };
        Portal.defaultProps = {
            id: id,
        };
        return Portal;
    };
    function createPortalRoot(host, id) {
        function render(renderer) {
            if (PortalMap.has(id)) {
                PortalMap.set(id, renderer === null || renderer === void 0 ? void 0 : renderer());
            }
            else if (host) {
                ReactDOM.render(React.createElement(React.Fragment, null, renderer === null || renderer === void 0 ? void 0 : renderer()), host);
            }
        }
        function unmount() {
            var _a;
            if (PortalMap.has(id)) {
                PortalMap.set(id, null);
            }
            else if (host) {
                ReactDOM.unmountComponentAtNode(host);
                (_a = host.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(host);
            }
        }
        return {
            render: render,
            unmount: unmount,
        };
    }

    var loading = function (title, processor) {
        if (title === void 0) { title = 'Loading...'; }
        return __awaiter$7(void 0, void 0, void 0, function () {
            var hide, loading;
            return __generator$7(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        hide = null;
                        loading = setTimeout(function () {
                            hide = Message$1.info({
                                content: title,
                                icon: React.createElement(Spin$1, null),
                                duration: 300,
                            });
                        }, 100);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, processor()];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        hide === null || hide === void 0 ? void 0 : hide(hide);
                        clearTimeout(loading);
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };

    var ArrayBaseContext = React.createContext(null);
    var ItemContext = React.createContext(null);
    var useArray = function () { return React.useContext(ArrayBaseContext); };
    var useIndex = function (index) {
        var ctx = React.useContext(ItemContext);
        return ctx ? ctx.index : index !== null && index !== void 0 ? index : 0;
    };
    var useRecord = function (record) {
        var ctx = React.useContext(ItemContext);
        return ctx ? ctx.record : record;
    };
    var getDefaultValue = function (defaultValue, schema) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (Formily.Shared.isValid(defaultValue))
            return defaultValue;
        if (Array.isArray(schema === null || schema === void 0 ? void 0 : schema.items))
            return getDefaultValue(defaultValue, schema.items[0]);
        if (((_a = schema === null || schema === void 0 ? void 0 : schema.items) === null || _a === void 0 ? void 0 : _a.type) === 'array')
            return [];
        if (((_b = schema === null || schema === void 0 ? void 0 : schema.items) === null || _b === void 0 ? void 0 : _b.type) === 'boolean')
            return true;
        if (((_c = schema === null || schema === void 0 ? void 0 : schema.items) === null || _c === void 0 ? void 0 : _c.type) === 'date')
            return '';
        if (((_d = schema === null || schema === void 0 ? void 0 : schema.items) === null || _d === void 0 ? void 0 : _d.type) === 'datetime')
            return '';
        if (((_e = schema === null || schema === void 0 ? void 0 : schema.items) === null || _e === void 0 ? void 0 : _e.type) === 'number')
            return 0;
        if (((_f = schema === null || schema === void 0 ? void 0 : schema.items) === null || _f === void 0 ? void 0 : _f.type) === 'object')
            return {};
        if (((_g = schema === null || schema === void 0 ? void 0 : schema.items) === null || _g === void 0 ? void 0 : _g.type) === 'string')
            return '';
        return null;
    };
    var ArrayBase = function (props) {
        var field = Formily.React.useField();
        var schema = Formily.React.useFieldSchema();
        return (React.createElement(ArrayBaseContext.Provider, { value: { field: field, schema: schema, props: props } }, props.children));
    };
    ArrayBase.Item = function (_a) {
        var children = _a.children, props = __rest$17(_a, ["children"]);
        return (React.createElement(ItemContext.Provider, { value: props }, children));
    };
    var SortHandle = sortableHandle(function (props) {
        var prefixCls = usePrefixCls('array-base');
        return (React.createElement(IconMenu$1, __assign$2e({}, props, { className: classnames("".concat(prefixCls, "-sort-handle"), props.className), style: __assign$2e({}, props.style) })));
    });
    ArrayBase.SortHandle = function (props) {
        var _a;
        var array = useArray();
        if (!array)
            return null;
        if (((_a = array.field) === null || _a === void 0 ? void 0 : _a.pattern) !== 'editable')
            return null;
        return React.createElement(SortHandle, __assign$2e({}, props));
    };
    var Index = function (props) {
        var _a;
        var renderIndex = props.renderIndex;
        var index = useIndex();
        var prefixCls = usePrefixCls('array-base');
        return (React.createElement("span", __assign$2e({}, props, { className: "".concat(prefixCls, "-index") }), (_a = renderIndex === null || renderIndex === void 0 ? void 0 : renderIndex(index)) !== null && _a !== void 0 ? _a : "#".concat(index + 1, ".")));
    };
    ArrayBase.Index = Index;
    var Addition = function (props) {
        var _a, _b, _c;
        var self = Formily.React.useField();
        var array = useArray();
        var prefixCls = usePrefixCls('array-base');
        if (!array)
            return null;
        if (((_a = array === null || array === void 0 ? void 0 : array.field) === null || _a === void 0 ? void 0 : _a.pattern) !== 'editable' &&
            ((_b = array === null || array === void 0 ? void 0 : array.field) === null || _b === void 0 ? void 0 : _b.pattern) !== 'disabled') {
            return null;
        }
        return (React.createElement(Button$3, __assign$2e({ long: true }, props, { disabled: (_c = array === null || array === void 0 ? void 0 : array.field) === null || _c === void 0 ? void 0 : _c.disabled, className: classnames("".concat(prefixCls, "-addition"), props.className), onClick: function (e) {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
                if ((_a = array.props) === null || _a === void 0 ? void 0 : _a.disabled)
                    return;
                var defaultValue = getDefaultValue(props.defaultValue, array.schema);
                if (props.method === 'unshift') {
                    (_b = array === null || array === void 0 ? void 0 : array.field) === null || _b === void 0 ? void 0 : _b.unshift(defaultValue);
                    (_d = (_c = array.props) === null || _c === void 0 ? void 0 : _c.onAdd) === null || _d === void 0 ? void 0 : _d.call(_c, 0);
                }
                else {
                    (_f = (_e = array === null || array === void 0 ? void 0 : array.field) === null || _e === void 0 ? void 0 : _e.push) === null || _f === void 0 ? void 0 : _f.call(_e, defaultValue);
                    (_h = (_g = array.props) === null || _g === void 0 ? void 0 : _g.onAdd) === null || _h === void 0 ? void 0 : _h.call(_g, ((_k = (_j = array === null || array === void 0 ? void 0 : array.field) === null || _j === void 0 ? void 0 : _j.value) === null || _k === void 0 ? void 0 : _k.length) - 1);
                }
                (_l = props.onClick) === null || _l === void 0 ? void 0 : _l.call(props, e);
            }, icon: React.createElement(IconPlus$1, null) }), self.title || props.title));
    };
    ArrayBase.Addition = Addition;
    ArrayBase.Remove = React.forwardRef(function (props, ref) {
        var _a;
        var index = useIndex();
        var array = useArray();
        var prefixCls = usePrefixCls('array-base');
        if (!array)
            return null;
        if (((_a = array === null || array === void 0 ? void 0 : array.field) === null || _a === void 0 ? void 0 : _a.pattern) !== 'editable')
            return null;
        return (React.createElement(IconDelete$1, __assign$2e({}, props, { className: classnames("".concat(prefixCls, "-remove"), props.className), ref: ref, onClick: function (e) {
                var _a, _b, _c, _d, _e;
                if ((_a = array.props) === null || _a === void 0 ? void 0 : _a.disabled)
                    return;
                e.stopPropagation();
                (_c = (_b = array.field) === null || _b === void 0 ? void 0 : _b.remove) === null || _c === void 0 ? void 0 : _c.call(_b, index);
                (_e = (_d = array.props) === null || _d === void 0 ? void 0 : _d.onRemove) === null || _e === void 0 ? void 0 : _e.call(_d, index);
                if (props.onClick) {
                    props.onClick(e);
                }
            } })));
    });
    ArrayBase.MoveDown = React.forwardRef(function (props, ref) {
        var _a;
        var index = useIndex(props.index);
        var array = useArray();
        var prefixCls = usePrefixCls('array-base-move-down');
        if (((_a = array === null || array === void 0 ? void 0 : array.field) === null || _a === void 0 ? void 0 : _a.pattern) !== 'editable')
            return null;
        return (React.createElement(IconCaretDown$1, __assign$2e({}, props, { className: classnames(prefixCls, props.className), ref: ref, onClick: function (e) {
                var _a, _b, _c, _d, _e;
                if ((_a = array.props) === null || _a === void 0 ? void 0 : _a.disabled)
                    return;
                e.stopPropagation();
                (_c = (_b = array.field) === null || _b === void 0 ? void 0 : _b.moveDown) === null || _c === void 0 ? void 0 : _c.call(_b, index);
                (_e = (_d = array.props) === null || _d === void 0 ? void 0 : _d.onMoveDown) === null || _e === void 0 ? void 0 : _e.call(_d, index);
                if (props.onClick) {
                    props.onClick(e);
                }
            } })));
    });
    ArrayBase.MoveUp = React.forwardRef(function (props, ref) {
        var _a;
        var index = useIndex(props.index);
        var array = useArray();
        var prefixCls = usePrefixCls('array-base-move-up');
        if (((_a = array === null || array === void 0 ? void 0 : array.field) === null || _a === void 0 ? void 0 : _a.pattern) !== 'editable')
            return null;
        return (React.createElement(IconCaretUp$1, __assign$2e({}, props, { className: classnames(prefixCls, props.className), ref: ref, onClick: function (e) {
                var _a, _b, _c, _d;
                if ((_a = array.props) === null || _a === void 0 ? void 0 : _a.disabled)
                    return;
                e.stopPropagation();
                (_b = array === null || array === void 0 ? void 0 : array.field) === null || _b === void 0 ? void 0 : _b.moveUp(index);
                (_d = (_c = array === null || array === void 0 ? void 0 : array.props) === null || _c === void 0 ? void 0 : _c.onMoveUp) === null || _d === void 0 ? void 0 : _d.call(_c, index);
                if (props.onClick) {
                    props.onClick(e);
                }
            } })));
    });
    ArrayBase.useArray = useArray;
    ArrayBase.useIndex = useIndex;
    ArrayBase.useRecord = useRecord;
    ArrayBase.mixin = function (target) {
        target.Index = ArrayBase.Index;
        target.SortHandle = ArrayBase.SortHandle;
        target.Addition = ArrayBase.Addition;
        target.Remove = ArrayBase.Remove;
        target.MoveDown = ArrayBase.MoveDown;
        target.MoveUp = ArrayBase.MoveUp;
        target.useArray = ArrayBase.useArray;
        target.useIndex = ArrayBase.useIndex;
        target.useRecord = ArrayBase.useRecord;
        return target;
    };

    var isAdditionComponent$2 = function (schema) {
        var _a;
        return ((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('Addition')) > -1;
    };
    var isIndexComponent = function (schema) {
        var _a;
        return ((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('Index')) > -1;
    };
    var isRemoveComponent = function (schema) {
        var _a;
        return ((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('Remove')) > -1;
    };
    var isMoveUpComponent = function (schema) {
        var _a;
        return ((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('MoveUp')) > -1;
    };
    var isMoveDownComponent = function (schema) {
        var _a;
        return ((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('MoveDown')) > -1;
    };
    var isOperationComponent = function (schema) {
        return (isAdditionComponent$2(schema) ||
            isRemoveComponent(schema) ||
            isMoveDownComponent(schema) ||
            isMoveUpComponent(schema));
    };
    var range = function (count) { return Array.from({ length: count }).map(function (_, i) { return i; }); };
    var takeDefaultActiveKeys = function (dataSourceLength, defaultOpenPanelCount) {
        if (defaultOpenPanelCount === void 0) { defaultOpenPanelCount = Infinity; }
        if (dataSourceLength < defaultOpenPanelCount)
            return range(dataSourceLength);
        return range(defaultOpenPanelCount);
    };
    var insertActiveKeys = function (activeKeys, index) {
        if (activeKeys.length <= index)
            return activeKeys.concat(index);
        return activeKeys.reduce(function (buf, key) {
            if (key < index)
                return buf.concat(key);
            if (key === index)
                return buf.concat([key, key + 1]);
            return buf.concat(key + 1);
        }, []);
    };
    var ArrayCollapse = Formily.React.observer(function (props) {
        var arrayBaseProps = props.arrayBaseProps, respProps = __rest$17(props, ["arrayBaseProps"]);
        var field = Formily.React.useField();
        var dataSource = Array.isArray(field.value) ? field.value : [];
        var _a = __read$1x(React.useState(takeDefaultActiveKeys(dataSource.length, respProps.defaultOpenPanelCount)), 2), activeKeys = _a[0], setActiveKeys = _a[1];
        var schema = Formily.React.useFieldSchema();
        var prefixCls = usePrefixCls('array-collapse', respProps);
        React.useEffect(function () {
            if (!field.modified && dataSource.length) {
                setActiveKeys(takeDefaultActiveKeys(dataSource.length, respProps.defaultOpenPanelCount));
            }
        }, [dataSource.length, field]);
        if (!schema)
            throw new Error('can not found schema object');
        var renderAddition = function () {
            return schema.reduceProperties(function (addition, schema, key) {
                if (isAdditionComponent$2(schema)) {
                    return React.createElement(Formily.React.RecursionField, { schema: schema, name: key });
                }
                return addition;
            }, null);
        };
        var renderEmpty = function () {
            if (dataSource.length)
                return;
            return (React.createElement(Card$1, { className: classnames("".concat(prefixCls, "-item"), respProps.className) },
                React.createElement(Empty$1, null)));
        };
        var renderItems = function () {
            return (React.createElement(Collapse$1, __assign$2e({}, respProps, { activeKey: activeKeys.map(function (z) { return "".concat(z); }), onChange: function (_key, keys) { return setActiveKeys(keys.map(Number)); }, className: classnames("".concat(prefixCls, "-item"), respProps.className) }), dataSource.map(function (item, index) {
                var items = Array.isArray(schema.items)
                    ? schema.items[index] || schema.items[0]
                    : schema.items;
                var panelProps = field
                    .query("".concat(field.address, ".").concat(index))
                    .get('componentProps');
                var props = items === null || items === void 0 ? void 0 : items['x-component-props'];
                var extra = (React.createElement(ArrayBase.Item, { index: index, record: item },
                    React.createElement(Formily.React.RecursionField, { schema: items, name: index, filterProperties: function (schema) {
                            if (!isOperationComponent(schema))
                                return false;
                            return true;
                        }, onlyRenderProperties: true }), props === null || props === void 0 ? void 0 :
                    props.extra));
                var content = (React.createElement(Formily.React.RecursionField, { schema: items, name: index, filterProperties: function (schema) {
                        if (isIndexComponent(schema))
                            return false;
                        if (isOperationComponent(schema))
                            return false;
                        return true;
                    } }));
                return (React.createElement(Collapse$1.Item, __assign$2e({}, props, panelProps, { key: index, name: index + '', 
                    //  header={header()}
                    // header 仅为 string 时，extra 才可用
                    extra: extra }),
                    React.createElement(ArrayBase.Item, { index: index, key: index, record: item }, content)));
            })));
        };
        return (React.createElement(ArrayBase, __assign$2e({}, arrayBaseProps, { onAdd: function (index) {
                var _a;
                setActiveKeys(insertActiveKeys(activeKeys, index));
                (_a = arrayBaseProps === null || arrayBaseProps === void 0 ? void 0 : arrayBaseProps.onAdd) === null || _a === void 0 ? void 0 : _a.call(arrayBaseProps, index);
            } }),
            renderEmpty(),
            renderItems(),
            renderAddition()));
    });
    var CollapsePanel$1 = function (_a) {
        var children = _a.children;
        return React.createElement(React.Fragment, null, children);
    };
    CollapsePanel$1.displayName = 'CollapsePanel';
    ArrayCollapse.defaultProps = {
        defaultOpenPanelCount: 5,
    };
    ArrayCollapse.displayName = 'ArrayCollapse';
    ArrayCollapse.CollapsePanel = CollapsePanel$1;
    ArrayBase.mixin(ArrayCollapse);

    var SortableItem = sortableElement(function (props) {
        var prefixCls = usePrefixCls('formily-array-items');
        return (React.createElement("div", __assign$2e({}, props, { className: classnames("".concat(prefixCls, "-item"), props.className) }), props.children));
    });
    var SortableList = sortableContainer(function (props) {
        var prefixCls = usePrefixCls('formily-array-items');
        return (React.createElement("div", __assign$2e({}, props, { className: classnames("".concat(prefixCls, "-list"), props.className) }), props.children));
    });
    var isAdditionComponent$1 = function (schema) {
        var _a;
        return ((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('Addition')) > -1;
    };
    var useAddition$1 = function () {
        var schema = Formily.React.useFieldSchema();
        return schema.reduceProperties(function (addition, schema, key) {
            if (isAdditionComponent$1(schema)) {
                return React.createElement(Formily.React.RecursionField, { schema: schema, name: key });
            }
            return addition;
        }, null);
    };
    var ArrayItems = Formily.React.observer(function (props) {
        var field = Formily.React.useField();
        var prefixCls = usePrefixCls('formily-array-items');
        var schema = Formily.React.useFieldSchema();
        var addition = useAddition$1();
        var dataSource = Array.isArray(field.value) ? field.value : [];
        if (!schema)
            throw new Error('can not found schema object');
        return (React.createElement(ArrayBase, null,
            React.createElement("div", __assign$2e({}, props, { onChange: function () { }, className: classnames(prefixCls, props.className) }),
                React.createElement(SortableList, { useDragHandle: true, lockAxis: "y", helperClass: "".concat(prefixCls, "-sort-helper"), onSortEnd: function (_a) {
                        var oldIndex = _a.oldIndex, newIndex = _a.newIndex;
                        field.move(oldIndex, newIndex);
                    } }, dataSource === null || dataSource === void 0 ? void 0 : dataSource.map(function (item, index) {
                    var items = Array.isArray(schema.items)
                        ? schema.items[index] || schema.items[0]
                        : schema.items;
                    return (React.createElement(ArrayBase.Item, { key: index, index: index, record: item },
                        React.createElement(SortableItem, { key: "item-".concat(index), index: index },
                            React.createElement("div", { className: "".concat(prefixCls, "-item-inner") },
                                React.createElement(Formily.React.RecursionField, { schema: items, name: index })))));
                })),
                addition)));
    });
    ArrayItems.displayName = 'ArrayItems';
    ArrayItems.Item = function (props) {
        var prefixCls = usePrefixCls('formily-array-items');
        return (React.createElement("div", __assign$2e({}, props, { onChange: function () { }, className: classnames("".concat(prefixCls, "-").concat(props.type || 'card'), props.className) }), props.children));
    };
    ArrayBase.mixin(ArrayItems);

    var SortableRow = sortableElement(function (props) { return React.createElement("tr", __assign$2e({}, props)); });
    var SortableBody = sortableContainer(function (props) { return React.createElement("tbody", __assign$2e({}, props)); });
    var isColumnComponent = function (schema) {
        var _a;
        return ((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('Column')) > -1;
    };
    var isOperationsComponent = function (schema) {
        var _a;
        return ((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('Operations')) > -1;
    };
    var isAdditionComponent = function (schema) {
        var _a;
        return ((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('Addition')) > -1;
    };
    var useArrayTableSources = function () {
        var arrayField = Formily.React.useField();
        var schema = Formily.React.useFieldSchema();
        var parseSources = function (schema) {
            var _a, _b, _c;
            if (isColumnComponent(schema) ||
                isOperationsComponent(schema) ||
                isAdditionComponent(schema)) {
                if (!((_a = schema['x-component-props']) === null || _a === void 0 ? void 0 : _a['dataIndex']) && !schema['name'])
                    return [];
                var name_1 = ((_b = schema['x-component-props']) === null || _b === void 0 ? void 0 : _b['dataIndex']) || schema['name'];
                var field = arrayField.query(arrayField.address.concat(name_1)).take();
                var columnProps = ((_c = field === null || field === void 0 ? void 0 : field.component) === null || _c === void 0 ? void 0 : _c[1]) || schema['x-component-props'] || {};
                var display = (field === null || field === void 0 ? void 0 : field.display) || schema['x-display'];
                return [
                    {
                        name: name_1,
                        display: display,
                        field: field,
                        schema: schema,
                        columnProps: columnProps,
                    },
                ];
            }
            else if (schema.properties) {
                return schema.reduceProperties(function (buf, schema) {
                    return buf.concat(parseSources(schema));
                }, []);
            }
            return [];
        };
        var parseArrayItems = function (schema) {
            var sources = [];
            var items = Formily.Shared.isArr(schema) ? schema : [schema];
            return items.reduce(function (columns, schema) {
                var item = parseSources(schema);
                if (item) {
                    return columns.concat(item);
                }
                return columns;
            }, sources);
        };
        if (!schema)
            throw new Error('can not found schema object');
        return parseArrayItems(schema.items);
    };
    var getTableColumns = function (sources) {
        return sources.reduce(function (buf, _a, key) {
            var name = _a.name, columnProps = _a.columnProps, schema = _a.schema, display = _a.display;
            if (display !== 'visible')
                return buf;
            if (!isColumnComponent(schema))
                return buf;
            return buf.concat(__assign$2e(__assign$2e({}, columnProps), { key: key, dataIndex: name, render: function (value, record, index) {
                    var children = (React.createElement(ArrayBase.Item, { index: index, record: record },
                        React.createElement(Formily.React.RecursionField, { schema: schema, name: index, onlyRenderProperties: true })));
                    return index > -1 ? children : null;
                } }));
        }, []);
    };
    var useAddition = function () {
        var schema = Formily.React.useFieldSchema();
        return schema.reduceProperties(function (addition, schema, key) {
            if (isAdditionComponent(schema)) {
                return React.createElement(Formily.React.RecursionField, { schema: schema, name: key });
            }
            return addition;
        }, null);
    };
    var schedulerRequest = {
        request: null,
    };
    var StatusSelect = Formily.React.observer(function (props) {
        var _a;
        var field = Formily.React.useField();
        var prefixCls = usePrefixCls('array-table');
        var errors = field.errors;
        var parseIndex = function (address) {
            var _a;
            return Number((_a = address
                .slice(address.indexOf(field.address.toString()) + 1)
                .match(/(\d+)/)) === null || _a === void 0 ? void 0 : _a[1]);
        };
        var options = (_a = props.options) === null || _a === void 0 ? void 0 : _a.map(function (_a) {
            var label = _a.label, value = _a.value;
            var hasError = errors.some(function (_a) {
                var address = _a.address;
                var currentIndex = parseIndex(address);
                var startIndex = (value - 1) * props.pageSize;
                var endIndex = value * props.pageSize;
                return currentIndex >= startIndex && currentIndex <= endIndex;
            });
            return {
                label: hasError ? React.createElement(Badge$1, { dot: true }, label) : label,
                value: value,
            };
        });
        var width = String(options === null || options === void 0 ? void 0 : options.length).length * 15;
        return (React.createElement(Select$3, { value: props.value, onChange: props.onChange, options: options, style: {
                width: width < 60 ? 60 : width,
            }, className: classnames("".concat(prefixCls, "-status-select"), {
                'has-error': errors === null || errors === void 0 ? void 0 : errors.length,
            }) }));
    }, {
        scheduler: function (update) {
            clearTimeout(schedulerRequest.request);
            schedulerRequest.request = setTimeout(function () {
                update();
            }, 100);
        },
    });
    var ArrayTablePagination = function (props) {
        var _a;
        var _b = __read$1x(React.useState(1), 2), current = _b[0], setCurrent = _b[1];
        var prefixCls = usePrefixCls('array-table');
        var pageSize = props.pageSize || 10;
        var size = props.size || 'default';
        var dataSource = props.dataSource || [];
        var startIndex = (current - 1) * pageSize;
        var endIndex = startIndex + pageSize - 1;
        var total = (dataSource === null || dataSource === void 0 ? void 0 : dataSource.length) || 0;
        var totalPage = Math.ceil(total / pageSize);
        var pages = Array.from(new Array(totalPage)).map(function (_, index) {
            var page = index + 1;
            return {
                label: page,
                value: page,
            };
        });
        var handleChange = function (current) {
            setCurrent(current);
        };
        var renderPagination = function () {
            if (totalPage <= 1)
                return;
            return (React.createElement("div", { className: "".concat(prefixCls, "-pagination") },
                React.createElement(ArcoSpace, null,
                    React.createElement(StatusSelect, { value: current, pageSize: pageSize, onChange: handleChange, options: pages }),
                    React.createElement(Pagination$1, __assign$2e({}, props, { pageSize: pageSize, current: current, total: dataSource.length, size: size, showJumper: true, showMore: false, onChange: handleChange })))));
        };
        return (React.createElement(React.Fragment, null, (_a = props.children) === null || _a === void 0 ? void 0 : _a.call(props, dataSource === null || dataSource === void 0 ? void 0 : dataSource.slice(startIndex, endIndex + 1), renderPagination())));
    };
    // components.wrapper所需要参数
    var ArrayTableComponentsContext = React.createContext({});
    var ArrayTableWrapper = function (props) {
        var _a = React.useContext(ArrayTableComponentsContext), ref = _a.ref, field = _a.field;
        var prefixCls = usePrefixCls('formily-array-table');
        var addTdStyles = function (node) {
            var helper = document.body.querySelector(".".concat(prefixCls, "-sort-helper"));
            if (helper) {
                var tds_1 = node.querySelectorAll('td');
                requestAnimationFrame(function () {
                    helper.querySelectorAll('td').forEach(function (td, index) {
                        if (tds_1[index]) {
                            td.style.width = getComputedStyle(tds_1[index]).width;
                        }
                    });
                });
            }
        };
        return (React.createElement(SortableBody, __assign$2e({ useDragHandle: true, lockAxis: "y", helperClass: "".concat(prefixCls, "-sort-helper"), helperContainer: function () {
                var _a;
                return (_a = ref === null || ref === void 0 ? void 0 : ref.current) === null || _a === void 0 ? void 0 : _a.querySelector('tbody');
            }, onSortStart: function (_a) {
                var node = _a.node;
                addTdStyles(node);
            }, onSortEnd: function (_a) {
                var oldIndex = _a.oldIndex, newIndex = _a.newIndex;
                field === null || field === void 0 ? void 0 : field.move(oldIndex, newIndex);
            } }, props)));
    };
    /**
     * 这里将Table.components写在函数外，使得components避免不必要的更新
     *
     * 原因：如果每次render时Table每次都拿到一个新的对象。Table内部是lodash.merge深拷贝了一份这个对象，导致components.body.row & wrapper每次都会变。
     * 当在array-table中用如文件上传组件时，会将原先的input销毁，导致没法监听到组件的onChange事件
     */
    var arrayTableComponents = {
        body: {
            tbody: ArrayTableWrapper,
            row: React.forwardRef(function (props, ref) {
                return React.createElement(SortableRow, __assign$2e({ ref: ref, index: props.index || 0 }, props));
            }),
        },
    };
    var ArrayTable = Formily.React.observer(function (props) {
        var ref = React.useRef();
        var field = Formily.React.useField();
        var prefixCls = usePrefixCls('array-table');
        var dataSource = Array.isArray(field.value) ? field.value.slice() : [];
        var sources = useArrayTableSources();
        var columns = getTableColumns(sources);
        var pagination = Formily.Shared.isBool(props.pagination) ? {} : props.pagination;
        var addition = useAddition();
        var defaultRowKey = function (record) {
            return dataSource.indexOf(record).toString();
        };
        return (React.createElement(ArrayTablePagination, __assign$2e({}, pagination, { dataSource: dataSource }), function (dataSource, pager) { return (React.createElement("div", { ref: ref, className: prefixCls },
            React.createElement(ArrayBase, __assign$2e({}, props === null || props === void 0 ? void 0 : props.arrayBaseProps),
                React.createElement(ArrayTableComponentsContext.Provider, { value: { ref: ref, field: field } },
                    React.createElement(Table, __assign$2e({ size: "small", border: true, rowKey: defaultRowKey }, props, { onChange: function () { }, pagination: false, columns: columns, data: dataSource, components: arrayTableComponents, onRow: function (_, index) { return ({
                            index: index,
                        }); } }))),
                React.createElement("div", { style: { marginTop: 5, marginBottom: 5 } }, pager),
                sources.map(function (column, key) {
                    // 承接对Column的状态管理
                    if (!isColumnComponent(column.schema))
                        return;
                    return React.createElement(Formily.React.RecursionField, {
                        name: column.name,
                        schema: column.schema,
                        onlyRenderSelf: true,
                        key: key,
                    });
                }),
                addition))); }));
    });
    ArrayTable.displayName = 'ArrayTable';
    ArrayTable.Column = function () {
        return React.createElement(React.Fragment, null);
    };
    ArrayBase.mixin(ArrayTable);

    var TabPane$1 = Tabs$1.TabPane;
    var FeedbackBadge = Formily.React.observer(function (props) {
        var field = Formily.React.useField();
        var tab = "".concat(field.title || 'Untitled', " ").concat(props.index + 1);
        var errors = field.errors.filter(function (error) {
            return error.address.includes("".concat(field.address, ".").concat(props.index));
        });
        if (errors.length) {
            return (React.createElement(Badge$1, { className: "errors-badge", count: errors.length, color: "danger" }, tab));
        }
        return React.createElement(React.Fragment, null, tab);
    });
    var ArrayTabs = Formily.React.observer(function (props) {
        var field = Formily.React.useField();
        var schema = Formily.React.useFieldSchema();
        var prefix = usePrefixCls('tabs');
        var _a = __read$1x(React.useState('tab-0'), 2), activeKey = _a[0], setActiveKey = _a[1];
        var value = Array.isArray(field.value) ? field.value : [];
        var dataSource = (value === null || value === void 0 ? void 0 : value.length) ? value : [{}];
        var onEdit = function (targetKey, type) {
            var _a, _b;
            if (type == 'add') {
                var id = dataSource.length;
                if ((_a = field === null || field === void 0 ? void 0 : field.value) === null || _a === void 0 ? void 0 : _a.length) {
                    field.push(null);
                }
                else {
                    field.push(null, null);
                }
                setActiveKey("tab-".concat(id));
            }
            else if (type == 'remove') {
                var index = Number((_b = targetKey.match(/-(\d+)/)) === null || _b === void 0 ? void 0 : _b[1]);
                if (index - 1 > -1) {
                    setActiveKey("tab-".concat(index - 1));
                }
                field.remove(index);
            }
        };
        return (React.createElement(Tabs$1, __assign$2e({}, props, { className: classnames(prefix, props.className), activeTab: activeKey, onChange: function (key) {
                var _a;
                // 获取当前tab的index eg:tab-1=>1
                var index = Number((_a = key.match(/-(\d+)/)) === null || _a === void 0 ? void 0 : _a[1]);
                if (dataSource.length !== index) {
                    setActiveKey(key);
                }
            }, type: "card", onAddTab: onEdit.bind(null, null, 'add'), 
            /*   extra={
              <Button
                icon={<IconPlus />}
                className={cls(`${prefix}-addition`)}
                onClick={onEdit.bind(null, null, 'add')}
              />
            } */
            editable: true, onDeleteTab: function (key) { return onEdit(key, 'remove'); } }), dataSource === null || dataSource === void 0 ? void 0 : dataSource.map(function (_, index) {
            var items = Array.isArray(schema.items)
                ? schema.items[index]
                : schema.items;
            var key = "tab-".concat(index);
            return (React.createElement(TabPane$1, { key: key, closable: index !== 0, title: React.createElement(FeedbackBadge, { index: index }) },
                React.createElement(Formily.React.RecursionField, { schema: items, name: index })));
        })));
    });

    var FormLayoutContext = React.createContext({});
    var FormLayoutShallowContext = React.createContext({});
    var useFormLayout = function () { return React.useContext(FormLayoutContext); };
    var useFormShallowLayout = function () { return React.useContext(FormLayoutShallowContext); };
    var FormLayout = function (_a) {
        var _b;
        var shallow = _a.shallow, children = _a.children, prefixCls = _a.prefixCls, className = _a.className, style = _a.style, props = __rest$17(_a, ["shallow", "children", "prefixCls", "className", "style"]);
        var formPrefixCls = usePrefixCls('form');
        var semiRtlPrefixCls = usePrefixCls('', { prefixCls: 'semi-rtl' });
        var layoutPrefixCls = usePrefixCls('layout', { prefixCls: prefixCls });
        var layoutClassName = classnames(layoutPrefixCls, (_b = {},
            _b["".concat(formPrefixCls, "-").concat(props.layout)] = props.layout,
            _b["".concat(semiRtlPrefixCls)] = props.direction === 'rtl',
            _b["".concat(formPrefixCls, "-").concat(props.size)] = props.size,
            _b), className);
        var renderChildren = function () {
            if (shallow) {
                return (React.createElement(FormLayoutShallowContext.Provider, { value: props }, children));
            }
            else {
                return (React.createElement(FormLayoutContext.Provider, { value: props }, children));
            }
        };
        return (React.createElement("div", { className: layoutClassName, style: style }, renderChildren()));
    };
    FormLayout.defaultProps = {
        shallow: true,
    };
    FormLayout.useFormLayout = useFormLayout;
    FormLayout.useFormShallowLayout = useFormShallowLayout;

    var PlaceholderContext = React.createContext('N/A');
    var Placeholder = PlaceholderContext.Provider;
    var usePlaceholder = function (value) {
        var placeholder = React.useContext(PlaceholderContext) || 'N/A';
        return Formily.Shared.isValid(value) && value !== '' ? value : placeholder;
    };
    var Input$1 = function (props) {
        var prefixCls = usePrefixCls('text');
        return (React.createElement(ArcoSpace, { className: classnames(prefixCls, props.className), style: props.style },
            props.addBefore,
            props.prefix,
            usePlaceholder(props.value),
            props.suffix,
            props.addAfter));
    };
    var Select$1 = Formily.React.observer(function (props) {
        var _a;
        var field = Formily.React.useField();
        var prefixCls = usePrefixCls('text');
        var dataSource = ((_a = field === null || field === void 0 ? void 0 : field.dataSource) === null || _a === void 0 ? void 0 : _a.length) ? field.dataSource : [];
        var placeholder = usePlaceholder();
        var getSelected = function () {
            var value = props.value, labelInValue = props.labelInValue;
            if (props.mode == 'multiple') {
                return Formily.Shared.isArr(value)
                    ? value.map(function (val) { return (labelInValue ? val : { label: val, value: val }); })
                    : [];
            }
            else {
                return labelInValue && Formily.Shared.isPlainObj(value)
                    ? [value]
                    : // 保护value可能为0的情况
                        value !== undefined && value !== null
                            ? [{ label: value, value: value }]
                            : [];
            }
        };
        var getLabels = function () {
            var selected = getSelected();
            if (!selected.length)
                return React.createElement(Tag$1, null, placeholder);
            return selected.map(function (_a, key) {
                var _b;
                var value = _a.value, label = _a.label;
                var text = ((_b = dataSource === null || dataSource === void 0 ? void 0 : dataSource.find(function (item) { return item.value === value; })) === null || _b === void 0 ? void 0 : _b.label) || label;
                return React.createElement(Tag$1, { key: key }, text || placeholder);
            });
        };
        return (React.createElement("div", { className: classnames(prefixCls, props.className), style: props.style },
            React.createElement(ArcoSpace, null, getLabels())));
    });
    var TreeSelect$1 = Formily.React.observer(function (props) {
        var _a;
        var field = Formily.React.useField();
        var placeholder = usePlaceholder();
        var prefixCls = usePrefixCls('text');
        var dataSource = ((_a = field === null || field === void 0 ? void 0 : field.dataSource) === null || _a === void 0 ? void 0 : _a.length) ? field.dataSource : [];
        var getSelected = function () {
            var value = props.value;
            if (props.multiple) {
                return Formily.Shared.isArr(value)
                    ? value.map(function (val) { return ({ label: val, value: val }); })
                    : [];
            }
            else {
                return value ? [{ label: value, value: value }] : [];
            }
        };
        var findLabel = function (value, dataSource) {
            for (var i = 0; i < (dataSource === null || dataSource === void 0 ? void 0 : dataSource.length); i++) {
                var item = dataSource[i];
                if ((item === null || item === void 0 ? void 0 : item.value) === value) {
                    return item === null || item === void 0 ? void 0 : item.label;
                }
                else {
                    var childLabel = findLabel(value, item === null || item === void 0 ? void 0 : item.children);
                    if (childLabel)
                        return childLabel;
                }
            }
        };
        var getLabels = function () {
            var selected = getSelected();
            if (!(selected === null || selected === void 0 ? void 0 : selected.length))
                return React.createElement(Tag$1, null, placeholder);
            return selected.map(function (_a, key) {
                var value = _a.value, label = _a.label;
                return (React.createElement(Tag$1, { key: key }, findLabel(value, dataSource) || label || placeholder));
            });
        };
        return (React.createElement("div", { className: classnames(prefixCls, props.className), style: props.style }, getLabels()));
    });
    var Cascader$1 = Formily.React.observer(function (props) {
        var _a;
        var field = Formily.React.useField();
        var placeholder = usePlaceholder();
        var prefixCls = usePrefixCls('text');
        var dataSource = ((_a = field === null || field === void 0 ? void 0 : field.dataSource) === null || _a === void 0 ? void 0 : _a.length) ? field.dataSource : [];
        var getSelected = function () {
            return Formily.Shared.isArr(props.value) ? props.value : [];
        };
        var findLabel = function (value, dataSource) {
            for (var i = 0; i < (dataSource === null || dataSource === void 0 ? void 0 : dataSource.length); i++) {
                var item = dataSource[i];
                if ((item === null || item === void 0 ? void 0 : item.value) === value) {
                    return item === null || item === void 0 ? void 0 : item.label;
                }
                else {
                    var childLabel = findLabel(value, item === null || item === void 0 ? void 0 : item.children);
                    if (childLabel)
                        return childLabel;
                }
            }
        };
        var getLabels = function () {
            var selected = getSelected();
            if (!(selected === null || selected === void 0 ? void 0 : selected.length)) {
                return placeholder;
            }
            return selected
                .map(function (value) {
                return findLabel(value, dataSource) || placeholder;
            })
                .join('/');
        };
        return (React.createElement("div", { className: classnames(prefixCls, props.className), style: props.style }, getLabels()));
    });
    var DatePicker$1 = function (props) {
        var placeholder = usePlaceholder();
        var prefixCls = usePrefixCls('text');
        var getLabels = function () {
            var labels = formatMomentValue(props.value, props.format, placeholder);
            return Formily.Shared.isArr(labels) ? labels.join('~') : labels;
        };
        return React.createElement("div", { className: classnames(prefixCls, props.className) }, getLabels());
    };
    var DateRangePicker = function (props) {
        var placeholder = usePlaceholder();
        var prefixCls = usePrefixCls('text');
        var getLabels = function () {
            var labels = formatMomentValue(props.value, props.format, placeholder);
            return Formily.Shared.isArr(labels) ? labels.join('~') : labels;
        };
        return (React.createElement("div", { className: classnames(prefixCls, props.className), style: props.style }, getLabels()));
    };
    var TimePicker$1 = function (props) {
        var placeholder = usePlaceholder();
        var prefixCls = usePrefixCls('text');
        var getLabels = function () {
            var labels = formatMomentValue(props.value, props.format, placeholder);
            return Formily.Shared.isArr(labels) ? labels.join('~') : labels;
        };
        return (React.createElement("div", { className: classnames(prefixCls, props.className), style: props.style }, getLabels()));
    };
    var TimeRangePicker = function (props) {
        var placeholder = usePlaceholder();
        var prefixCls = usePrefixCls('text');
        var getLabels = function () {
            var labels = formatMomentValue(props.value, props.format, placeholder);
            return Formily.Shared.isArr(labels) ? labels.join('~') : labels;
        };
        return (React.createElement("div", { className: classnames(prefixCls, props.className), style: props.style }, getLabels()));
    };
    var Text = function (props) {
        var prefixCls = usePrefixCls('text');
        return (React.createElement("div", { className: classnames(prefixCls, props.className), style: props.style }, usePlaceholder(props.value)));
    };
    Text.Input = Input$1;
    Text.Select = Select$1;
    Text.TreeSelect = TreeSelect$1;
    Text.Cascader = Cascader$1;
    Text.DatePicker = DatePicker$1;
    Text.DateRangePicker = DateRangePicker;
    Text.TimePicker = TimePicker$1;
    Text.TimeRangePicker = TimeRangePicker;
    Text.Placeholder = Placeholder;
    Text.usePlaceholder = usePlaceholder;
    var PreviewText = Text;

    var Form = function (_a) {
        var form = _a.form, component = _a.component, onAutoSubmit = _a.onAutoSubmit, onAutoSubmitFailed = _a.onAutoSubmitFailed, previewTextPlaceholder = _a.previewTextPlaceholder, props = __rest$17(_a, ["form", "component", "onAutoSubmit", "onAutoSubmitFailed", "previewTextPlaceholder"]);
        var top = Formily.React.useParentForm();
        var renderContent = function (form) { return (React.createElement(Formily.React.RecordScope, { getRecord: function () { return (Formily.Core.isForm(form) ? form.values : form.value); } },
            React.createElement(PreviewText.Placeholder, { value: previewTextPlaceholder },
                React.createElement(FormLayout, __assign$2e({}, props), React.createElement(component, {
                    onSubmit: function (e) {
                        var _a, _b;
                        (_a = e === null || e === void 0 ? void 0 : e.stopPropagation) === null || _a === void 0 ? void 0 : _a.call(e);
                        (_b = e === null || e === void 0 ? void 0 : e.preventDefault) === null || _b === void 0 ? void 0 : _b.call(e);
                        form.submit(onAutoSubmit).catch(onAutoSubmitFailed);
                    },
                }, props.children))))); };
        if (form)
            return React.createElement(Formily.React.FormProvider, { form: form }, renderContent(form));
        if (!top)
            throw new Error('must pass form instance by createForm');
        return renderContent(top);
    };
    Form.defaultProps = {
        component: 'form',
    };

    var FormGridContext = React.createContext({});

    var S = 720;
    var MD = 1280;
    var LG = 1920;
    var useLayout = function (props) {
        var intervals = props.intervals, minColumns = props.minColumns, maxColumns = props.maxColumns, minWidth = props.minWidth, maxWidth = props.maxWidth, colWrap = props.colWrap, columnGap = props.columnGap, rowGap = props.rowGap;
        var ref = React.useRef(null);
        var formGridPrefixCls = usePrefixCls('grid');
        var _a = __read$1x(React.useState({}), 2), layoutParams = _a[0], setLayout = _a[1];
        var _b = __read$1x(React.useState({}), 2), styles = _b[0], setStyles = _b[1];
        var calculateSmartColumns = function (target) {
            var _a;
            var clientWidth = target.clientWidth;
            var index = intervals.findIndex(function (interval) {
                var _a = __read$1x(interval, 2), min = _a[0], max = _a[1];
                if (clientWidth >= min && max > clientWidth) {
                    return true;
                }
                return false;
            });
            var takeMaxColumns = function () {
                return (maxColumns === null || maxColumns === void 0 ? void 0 : maxColumns[index]) || maxColumns;
            };
            var takeMinColumns = function () {
                return (minColumns === null || minColumns === void 0 ? void 0 : minColumns[index]) || minColumns || 1;
            };
            var takeColwrap = function () {
                return (colWrap === null || colWrap === void 0 ? void 0 : colWrap[index]) || colWrap || true;
            };
            var takeMinWidth = function () {
                var rMaxColumns = takeMaxColumns();
                if (Formily.Shared.isValid(minWidth)) {
                    return minWidth[index] || 0;
                }
                else {
                    if (Formily.Shared.isValid(rMaxColumns)) {
                        return Math.floor((clientWidth - (rMaxColumns - 1) * props.columnGap) / rMaxColumns);
                    }
                    else {
                        return 0;
                    }
                }
            };
            var takeMaxWidth = function () {
                var rMinColumns = takeMinColumns();
                if (Formily.Shared.isValid(maxWidth)) {
                    return maxWidth[index] || 0;
                }
                else {
                    if (Formily.Shared.isValid(rMinColumns)) {
                        var calculated = Math.floor((clientWidth - (minColumns[index] - 1) * props.columnGap) /
                            minColumns[index]);
                        if (Infinity === calculated) {
                            return clientWidth;
                        }
                        return calculated;
                    }
                    else {
                        return Infinity;
                    }
                }
            };
            return {
                minWidth: takeMinWidth(),
                maxWidth: takeMaxWidth(),
                columns: (_a = target === null || target === void 0 ? void 0 : target.childNodes) === null || _a === void 0 ? void 0 : _a.length,
                colWrap: takeColwrap(),
                minColumns: takeMinColumns(),
                maxColumns: takeMaxColumns(),
                clientWidth: clientWidth,
            };
        };
        React.useLayoutEffect(function () {
            var observer = function () {
                if (!ref.current)
                    return;
                var params = calculateSmartColumns(ref.current);
                setLayout(params);
                var style = getStyle({ columnGap: columnGap, rowGap: rowGap, layoutParams: params, ref: ref });
                if (!Formily.Shared.isEqual(style, styles)) {
                    setStyles(style);
                }
            };
            var resizeObserver = new index(observer);
            var mutationObserver = new MutationObserver(observer);
            if (ref.current) {
                resizeObserver.observe(ref.current);
                mutationObserver.observe(ref.current, {
                    childList: true,
                });
            }
            return function () {
                if (!ref.current)
                    return;
                resizeObserver.unobserve(ref.current);
                mutationObserver.disconnect();
            };
        }, []);
        return {
            ref: ref,
            formGridPrefixCls: formGridPrefixCls,
            layoutParams: layoutParams,
            styles: styles,
        };
    };
    var getStyle = function (props) {
        var _a;
        var columnGap = props.columnGap, rowGap = props.rowGap, layoutParams = props.layoutParams, ref = props.ref;
        // const max = layoutParams.maxWidth ? `${layoutParams.maxWidth}px` : '1fr';
        var _b = layoutParams, clientWidth = _b.clientWidth, minWidth = _b.minWidth, maxColumns = _b.maxColumns, minColumns = _b.minColumns;
        var getMinMax = function (minWidth, maxWidth) {
            if (!minWidth || !maxWidth)
                return;
            var minmax;
            if (minWidth === Infinity) {
                if (!Formily.Shared.isValid(maxWidth)) {
                    minmax = '1fr';
                }
                else {
                    minmax = "minmax(0px,".concat(maxWidth, "px)");
                }
            }
            else {
                minmax = "minmax(".concat(minWidth, "px,").concat(Formily.Shared.isValid(maxWidth) ? "".concat(maxWidth, "px") : '1fr', ")");
            }
            return minmax;
        };
        var spans = Array.from(((_a = ref.current) === null || _a === void 0 ? void 0 : _a.childNodes) || []).reduce(function (buf, cur) {
            var span = Formily.Shared.isValid(maxColumns)
                ? Math.min((Number(cur.getAttribute('data-span')) || 1), maxColumns)
                : Number(cur.getAttribute('data-span')) || 1;
            return buf + Number(span);
        }, 0);
        var calc = Math.floor((clientWidth + columnGap) / (minWidth + columnGap));
        var finalColumns;
        finalColumns = Math.min(spans, calc);
        if (Formily.Shared.isValid(maxColumns)) {
            finalColumns = Math.min(spans, calc, maxColumns);
        }
        else {
            finalColumns = Math.min(spans, calc);
        }
        if (Formily.Shared.isValid(minColumns)) {
            if (finalColumns < minColumns) {
                finalColumns = minColumns;
            }
        }
        var style = {
            gridTemplateColumns: "repeat(".concat(finalColumns, ", ").concat(getMinMax(layoutParams === null || layoutParams === void 0 ? void 0 : layoutParams.minWidth, layoutParams === null || layoutParams === void 0 ? void 0 : layoutParams.maxWidth), ")"),
            gridGap: "".concat(rowGap, "px ").concat(columnGap, "px"),
        };
        return style;
    };
    var useGridSpan = function (gridSpan) {
        if (gridSpan === void 0) { gridSpan = 1; }
        var params = React.useContext(FormGridContext);
        if (!Formily.Shared.isValid(params)) {
            return gridSpan;
        }
        var colWrap = params.colWrap, _a = params.columns, columns = _a === void 0 ? Infinity : _a, clientWidth = params.clientWidth, minWidth = params.minWidth, columnGap = params.columnGap, _b = params.maxColumns, maxColumns = _b === void 0 ? Infinity : _b;
        var calc = Math.floor((clientWidth + columnGap) / (minWidth + columnGap)); // 算出实际一行最多能塞进的格子数
        if (colWrap === true) {
            if (Math.min(calc, columns) >= gridSpan) {
                if (Formily.Shared.isValid(maxColumns)) {
                    return Math.min(gridSpan, maxColumns);
                }
                return gridSpan;
            }
            else {
                if (Formily.Shared.isValid(maxColumns)) {
                    return Math.min(calc, columns, maxColumns);
                }
                return Math.min(calc, columns);
            }
        }
        else {
            if (Math.min(calc, columns) >= gridSpan) {
                if (Formily.Shared.isValid(maxColumns)) {
                    return Math.min(gridSpan, maxColumns);
                }
                return gridSpan;
            }
            else {
                if (Formily.Shared.isValid(maxColumns)) {
                    return Math.min(calc, columns, maxColumns);
                }
                return Math.min(calc, columns);
            }
        }
    };
    var FormGrid = function (props) {
        var normalizeProps = function (props) {
            var breakpoints = props.breakpoints;
            var intervals = breakpoints ? breakpoints.reduce(function (buf, cur, index, array) {
                if (index === array.length - 1) {
                    return __spreadArray$C(__spreadArray$C([], __read$1x(buf), false), [[array[index], Infinity]]);
                }
                if (index === 0) {
                    return __spreadArray$C(__spreadArray$C([], __read$1x(buf), false), [[0, cur], [cur, array[index + 1]]]);
                }
                return __spreadArray$C(__spreadArray$C([], __read$1x(buf), false), [[cur, array[index + 1]]]);
            }, []) : [];
            var normalize = function (prop) {
                if (Formily.Shared.isNum(prop) || Formily.Shared.isBool(prop)) {
                    return intervals.map(function () { return prop; });
                }
                else if (Array.isArray(prop)) {
                    var lastVal_1;
                    return intervals.map(function (it, idx) {
                        var res = Formily.Shared.isValid(prop[idx]) ? prop[idx] : lastVal_1;
                        lastVal_1 = Formily.Shared.isValid(prop[idx]) ? prop[idx] : lastVal_1;
                        return res;
                    });
                }
                else {
                    return undefined;
                }
            };
            return __assign$2e(__assign$2e({}, props), { intervals: intervals, colWrap: normalize(props.colWrap), minWidth: normalize(props.minWidth), maxWidth: normalize(props.maxWidth), minColumns: normalize(props.minColumns), maxColumns: normalize(props.maxColumns) });
        };
        var children = props.children;
        var normalizedProps = normalizeProps(props);
        var _a = useLayout(normalizedProps), ref = _a.ref, formGridPrefixCls = _a.formGridPrefixCls, layoutParams = _a.layoutParams, styles = _a.styles;
        return (React.createElement(FormGridContext.Provider, { value: __assign$2e({ columnGap: props.columnGap }, layoutParams) },
            React.createElement("div", __assign$2e({}, pickDataProps(props), { className: classnames("".concat(formGridPrefixCls, "-layout")), style: styles, ref: ref }), children)));
    };
    var GridColumn = function (_a) {
        var gridSpan = _a.gridSpan, children = _a.children;
        var span = FormGrid.useGridSpan(gridSpan);
        return (React.createElement("div", { style: { gridColumnStart: "span ".concat(span) }, "data-span": span || 1 }, children));
    };
    GridColumn.defaultProps = {
        gridSpan: 1,
    };
    FormGrid.useGridSpan = useGridSpan;
    FormGrid.GridColumn = GridColumn;
    FormGrid.defaultProps = {
        columnGap: 10,
        rowGap: 5,
        minColumns: 0,
        minWidth: 100,
        breakpoints: [S, MD, LG],
        colWrap: true,
    };

    var useFormItemLayout = function (props) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
        var shallowFormLayout = useFormShallowLayout();
        var formLayout = useFormLayout();
        var layout = __assign$2e(__assign$2e({}, shallowFormLayout), formLayout);
        return __assign$2e(__assign$2e({}, props), { layout: (_b = (_a = props.layout) !== null && _a !== void 0 ? _a : layout.layout) !== null && _b !== void 0 ? _b : 'horizontal', colon: (_c = props.colon) !== null && _c !== void 0 ? _c : layout.colon, labelAlign: layout.layout === 'vertical'
                ? (_e = (_d = props.labelAlign) !== null && _d !== void 0 ? _d : layout.labelAlign) !== null && _e !== void 0 ? _e : 'left'
                : (_g = (_f = props.labelAlign) !== null && _f !== void 0 ? _f : layout.labelAlign) !== null && _g !== void 0 ? _g : 'right', labelWrap: (_h = props.labelWrap) !== null && _h !== void 0 ? _h : layout.labelWrap, labelWidth: (_j = props.labelWidth) !== null && _j !== void 0 ? _j : layout.labelWidth, wrapperWidth: (_k = props.wrapperWidth) !== null && _k !== void 0 ? _k : layout.wrapperWidth, labelCol: (_l = props.labelCol) !== null && _l !== void 0 ? _l : layout.labelCol, wrapperCol: (_m = props.wrapperCol) !== null && _m !== void 0 ? _m : layout.wrapperCol, wrapperAlign: (_o = props.wrapperAlign) !== null && _o !== void 0 ? _o : layout.wrapperAlign, wrapperWrap: (_p = props.wrapperWrap) !== null && _p !== void 0 ? _p : layout.wrapperWrap, fullness: (_q = props.fullness) !== null && _q !== void 0 ? _q : layout.fullness, size: (_r = props.size) !== null && _r !== void 0 ? _r : layout.size, inset: (_s = props.inset) !== null && _s !== void 0 ? _s : layout.inset, asterisk: props.asterisk, bordered: (_t = props.bordered) !== null && _t !== void 0 ? _t : layout.bordered, feedbackIcon: props.feedbackIcon, feedbackLayout: (_v = (_u = props.feedbackLayout) !== null && _u !== void 0 ? _u : layout.feedbackLayout) !== null && _v !== void 0 ? _v : 'loose', tooltipLayout: (_x = (_w = props.tooltipLayout) !== null && _w !== void 0 ? _w : layout.tooltipLayout) !== null && _x !== void 0 ? _x : 'icon', direction: props.direction === 'rtl' && layout.direction !== 'rtl' ? 'rtl' : 'ltr' });
    };
    var ICON_MAP = {
        error: React.createElement(IconDelete$1, null),
        success: React.createElement(IconRightCircle$1, null),
        warning: React.createElement(IconInfoCircle$1, null),
    };
    var BaseItem = function (props) {
        var _a, _b, _c, _d, _e, _f;
        var _g;
        var children = props.children, others = __rest$17(props, ["children"]);
        var _h = __read$1x(React.useState(false), 2), active = _h[0], setActice = _h[1];
        var popoverContainerRef = React.useRef();
        var formLayout = useFormItemLayout(others);
        var shallowFormLayout = useFormShallowLayout();
        var label = formLayout.label, style = formLayout.style, layout = formLayout.layout, _j = formLayout.colon, colon = _j === void 0 ? false : _j, addonBefore = formLayout.addonBefore, addonAfter = formLayout.addonAfter, asterisk = formLayout.asterisk, _k = formLayout.feedbackStatus, feedbackStatus = _k === void 0 ? 'success' : _k, extra = formLayout.extra, feedbackText = formLayout.feedbackText, fullness = formLayout.fullness, feedbackLayout = formLayout.feedbackLayout, feedbackIcon = formLayout.feedbackIcon, inset = formLayout.inset, _l = formLayout.bordered, bordered = _l === void 0 ? true : _l, labelWidth = formLayout.labelWidth, wrapperWidth = formLayout.wrapperWidth, labelCol = formLayout.labelCol, wrapperCol = formLayout.wrapperCol, labelAlign = formLayout.labelAlign, _m = formLayout.wrapperAlign, wrapperAlign = _m === void 0 ? 'left' : _m, size = formLayout.size, labelWrap = formLayout.labelWrap, wrapperWrap = formLayout.wrapperWrap, tooltip = formLayout.tooltip, _o = formLayout.tooltipProps, tooltipProps = _o === void 0 ? {} : _o, tooltipLayout = formLayout.tooltipLayout, direction = formLayout.direction;
        var labelStyle = __assign$2e({}, formLayout.labelStyle);
        var wrapperStyle = __assign$2e({}, formLayout.wrapperStyle);
        // 固定宽度
        var enableCol = false;
        if (labelWidth || wrapperWidth) {
            if (labelWidth) {
                labelStyle.width = labelWidth;
                labelStyle.maxWidth = labelWidth;
            }
            if (wrapperWidth) {
                wrapperStyle.width = wrapperWidth;
                wrapperStyle.maxWidth = wrapperWidth;
            }
            // 栅格模式
        }
        else if (labelCol || wrapperCol) {
            enableCol = true;
        }
        var prefixCls = usePrefixCls('item', props);
        var semiRtlPrefixCls = usePrefixCls('', { prefixCls: 'semi-rtl' });
        var formatChildren = feedbackLayout === 'popover' ? (React.createElement(Popover$1, { position: "top", getPopupContainer: function () { return popoverContainerRef.current; }, content: React.createElement("div", { className: classnames((_a = {},
                    _a["".concat(prefixCls, "-").concat(feedbackStatus, "-help")] = !!feedbackStatus,
                    _a["".concat(prefixCls, "-help")] = true,
                    _a)) },
                ICON_MAP[feedbackStatus],
                " ",
                feedbackText), popupVisible: !!feedbackText }, children)) : (children);
        var labelChildren = (React.createElement("div", { className: classnames("".concat(prefixCls, "-label-content")) },
            React.createElement("label", null, label),
            asterisk && React.createElement("span", { className: classnames("".concat(prefixCls, "-asterisk")) }, '*')));
        return (React.createElement("div", __assign$2e({}, pickDataProps(props), { ref: popoverContainerRef, style: __assign$2e(__assign$2e({}, style), { gridColumnStart: "span ".concat(useGridSpan(props.gridSpan)) }), className: classnames((_b = {},
                _b["".concat(prefixCls)] = true,
                // FormLayout有direction属性则不根据FormItem的direction属性, FormLayout已经对children做了一层
                _b["".concat(semiRtlPrefixCls)] = direction === 'rtl',
                _b["".concat(prefixCls, "-layout-").concat(layout)] = true,
                _b["".concat(prefixCls, "-").concat(feedbackStatus)] = !!feedbackStatus,
                _b["".concat(prefixCls, "-feedback-has-text")] = !!feedbackText,
                _b["".concat(prefixCls, "-size-").concat(size)] = !!size,
                _b["".concat(prefixCls, "-feedback-layout-").concat(feedbackLayout)] = !!feedbackLayout,
                _b["".concat(prefixCls, "-fullness")] = !!fullness || !!inset || !!feedbackIcon,
                _b["".concat(prefixCls, "-inset")] = !!inset,
                _b["".concat(prefixCls, "-active")] = active,
                _b["".concat(prefixCls, "-inset-active")] = !!inset && active,
                _b["".concat(prefixCls, "-label-align-").concat(labelAlign)] = true,
                _b["".concat(prefixCls, "-control-align-").concat(wrapperAlign)] = true,
                _b["".concat(prefixCls, "-label-wrap")] = !!labelWrap,
                _b["".concat(prefixCls, "-control-wrap")] = !!wrapperWrap,
                _b["".concat(prefixCls, "-bordered-none")] = bordered === false || !!inset || !!feedbackIcon,
                _b[(_g = props.className) !== null && _g !== void 0 ? _g : ''] = !!props.className,
                _b)), onFocus: function () {
                if (feedbackIcon || inset) {
                    setActice(true);
                }
            }, onBlur: function () {
                if (feedbackIcon || inset) {
                    setActice(false);
                }
            } }),
            label !== undefined && (React.createElement("div", { className: classnames((_c = {},
                    _c["".concat(prefixCls, "-label")] = true,
                    _c["".concat(prefixCls, "-label-tooltip")] = tooltip && tooltipLayout === 'text',
                    _c["".concat(prefixCls, "-item-col-").concat(labelCol)] = enableCol && !!labelCol,
                    _c)), style: labelStyle },
                tooltipLayout === 'text' ? (React.createElement(Tooltip$1, __assign$2e({ position: "top", content: tooltip, getPopupContainer: function () { return popoverContainerRef.current; } }, tooltipProps), labelChildren)) : (labelChildren),
                tooltip && tooltipLayout === 'icon' && (React.createElement("span", { className: classnames("".concat(prefixCls, "-label-tooltip")) },
                    React.createElement(Tooltip$1, __assign$2e({ position: "top", content: tooltip, getPopupContainer: function () { return popoverContainerRef.current; } }, tooltipProps),
                        React.createElement(IconQuestionCircle$1, null)))),
                label && (React.createElement("span", { className: classnames("".concat(prefixCls, "-colon")) }, colon ? ':' : '')))),
            React.createElement("div", { className: classnames((_d = {},
                    _d["".concat(prefixCls, "-control")] = true,
                    _d["".concat(prefixCls, "-item-col-").concat(wrapperCol)] = enableCol && !!wrapperCol && label,
                    _d)) },
                React.createElement("div", { className: classnames("".concat(prefixCls, "-control-content")) },
                    addonBefore && (React.createElement("div", { className: classnames("".concat(prefixCls, "-addon-before")) }, addonBefore)),
                    React.createElement("div", { style: wrapperStyle, className: classnames((_e = {},
                            _e["".concat(prefixCls, "-control-content-component")] = true,
                            _e["".concat(prefixCls, "-control-content-component-has-feedback-icon")] = !!feedbackIcon,
                            _e)) },
                        React.createElement(FormLayoutShallowContext.Provider, { value: Formily.Shared.reduce(shallowFormLayout, function (buf, _, key) {
                                if (key === 'size') {
                                    buf.size = size;
                                }
                                else {
                                    buf[key] = undefined;
                                }
                                return buf;
                            }, {
                                size: size,
                            }) }, formatChildren),
                        feedbackIcon && (React.createElement("div", { className: classnames("".concat(prefixCls, "-feedback-icon")) }, feedbackIcon))),
                    addonAfter && (React.createElement("div", { className: classnames("".concat(prefixCls, "-addon-after")) }, addonAfter))),
                !!feedbackText &&
                    feedbackLayout !== 'popover' &&
                    feedbackLayout !== 'none' && (React.createElement("div", { className: classnames((_f = {},
                        _f["".concat(prefixCls, "-").concat(feedbackStatus, "-help")] = !!feedbackStatus,
                        _f["".concat(prefixCls, "-help")] = true,
                        _f["".concat(prefixCls, "-help-enter")] = true,
                        _f["".concat(prefixCls, "-help-enter-active")] = true,
                        _f)) }, feedbackText)),
                extra && React.createElement("div", { className: classnames("".concat(prefixCls, "-extra")) }, extra))));
    };
    var FormItem = Object.assign(Formily.React.connect(BaseItem, Formily.React.mapProps(function (props, field) {
        if (Formily.Core.isVoidField(field))
            return {
                label: field.title || props.label,
                asterisk: props.asterisk,
                extra: props.extra || field.description,
            };
        if (!field)
            return props;
        var takeFeedbackStatus = function () {
            if (field.validating)
                return 'pending';
            return field.decoratorProps.feedbackStatus || field.validateStatus;
        };
        var takeMessage = function () {
            var split = function (messages) {
                return messages.reduce(function (buf, text, index) {
                    if (!text)
                        return buf;
                    return index < messages.length - 1
                        ? buf.concat([text, ', '])
                        : buf.concat([text]);
                }, []);
            };
            if (field.validating)
                return;
            if (props.feedbackText)
                return props.feedbackText;
            if (field.selfErrors.length)
                return split(field.selfErrors);
            if (field.selfWarnings.length)
                return split(field.selfWarnings);
            if (field.selfSuccesses.length)
                return split(field.selfSuccesses);
        };
        var takeAsterisk = function () {
            if (field.required && field.pattern !== 'readPretty') {
                return true;
            }
            if ('asterisk' in props) {
                return props.asterisk;
            }
            return false;
        };
        return {
            label: props.label || field.title,
            feedbackStatus: takeFeedbackStatus(),
            feedbackText: takeMessage(),
            asterisk: takeAsterisk(),
            extra: props.extra || field.description,
        };
    })), {
        BaseItem: BaseItem,
    });

    var TabPaneArco = Tabs$1.TabPane;
    var useTabs = function () {
        var tabsField = Formily.React.useField();
        var schema = Formily.React.useFieldSchema();
        var tabs = [];
        schema.mapProperties(function (schema, name) {
            var _a, _b;
            var field = tabsField.query(tabsField.address.concat(name)).take();
            if ((field === null || field === void 0 ? void 0 : field.display) === 'none' || (field === null || field === void 0 ? void 0 : field.display) === 'hidden')
                return;
            if (((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('TabPane')) > -1) {
                tabs.push({
                    name: name,
                    props: __assign$2e({ itemKey: ((_b = schema === null || schema === void 0 ? void 0 : schema['x-component-props']) === null || _b === void 0 ? void 0 : _b.itemKey) || name }, schema === null || schema === void 0 ? void 0 : schema['x-component-props']),
                    schema: schema,
                });
            }
        });
        return tabs;
    };
    var createFormTab = function (defaultActiveKey, activeKey) {
        var formTab = Formily.Reactive.model({
            defaultActiveKey: defaultActiveKey,
            activeKey: activeKey,
            setActiveKey: function (key) {
                formTab.activeKey = key;
            },
        });
        return formTab;
    };
    var FormTab = Formily.React.observer(function (_a) {
        var _b;
        var formTab = _a.formTab, props = __rest$17(_a, ["formTab"]);
        var field = Formily.React.useField();
        var tabs = useTabs();
        var tabsRef = React.useRef(tabs);
        var propsRef = React.useRef(props);
        var _formTab = React.useMemo(function () {
            var _a, _b, _c, _d;
            return (formTab !== null && formTab !== void 0 ? formTab : createFormTab((_a = propsRef.current.defaultActiveTab) !== null && _a !== void 0 ? _a : (_d = (_c = (_b = tabsRef.current) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.props) === null || _d === void 0 ? void 0 : _d.itemKey, propsRef.current.activeTab));
        }, [formTab]);
        var prefixCls = usePrefixCls('formily-tab');
        var badgedTab = function (key, props) {
            var _a, _b;
            var errors = field.form.queryFeedbacks({
                type: 'error',
                address: "".concat(field.address.concat(key), ".*"),
            });
            if (errors.length) {
                return (React.createElement(Badge$1, { className: "errors-badge", count: errors.length }, (_a = props.tab) !== null && _a !== void 0 ? _a : props.title));
            }
            return (_b = props.tab) !== null && _b !== void 0 ? _b : props.title;
        };
        return (React.createElement(Tabs$1, __assign$2e({}, props, { type: "card-gutter", className: classnames(prefixCls, props.className), defaultActiveTab: _formTab === null || _formTab === void 0 ? void 0 : _formTab.defaultActiveKey, activeTab: (_b = _formTab === null || _formTab === void 0 ? void 0 : _formTab.activeKey) !== null && _b !== void 0 ? _b : _formTab === null || _formTab === void 0 ? void 0 : _formTab.defaultActiveKey, onChange: function (key) {
                var _a, _b;
                (_a = props.onChange) === null || _a === void 0 ? void 0 : _a.call(props, key);
                (_b = _formTab === null || _formTab === void 0 ? void 0 : _formTab.setActiveKey) === null || _b === void 0 ? void 0 : _b.call(_formTab, key);
            } }), tabs.map(function (_a, key) {
            var props = _a.props, schema = _a.schema, name = _a.name;
            var itemKey = props.itemKey, reset = __rest$17(props, ["itemKey"]);
            return (React.createElement(TabPaneArco, __assign$2e({ key: "".concat(itemKey !== null && itemKey !== void 0 ? itemKey : key) }, reset, { title: badgedTab(name, props) }),
                React.createElement(Formily.React.RecursionField, { schema: schema, name: name })));
        })));
    });
    var TabPane = function (_a) {
        var children = _a.children;
        return React.createElement(React.Fragment, null, children);
    };
    FormTab.TabPane = TabPane;
    FormTab.createFormTab = createFormTab;

    const _global_React = React;

    var reactJsxRuntime_production_min = createCommonjsModule(function (module, exports) {
    var g=60103;exports.Fragment=60107;if("function"===typeof Symbol&&Symbol.for){var h=Symbol.for;g=h("react.element");exports.Fragment=h("react.fragment");}var m=_global_React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,n=Object.prototype.hasOwnProperty,p={key:!0,ref:!0,__self:!0,__source:!0};
    function q(c,a,k){var b,d={},e=null,l=null;void 0!==k&&(e=""+k);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(l=a.ref);for(b in a)n.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return {$$typeof:g,type:c,key:e,ref:l,props:d,_owner:m.current}}exports.jsx=q;exports.jsxs=q;
    });

    var reactJsxRuntime_development = createCommonjsModule(function (module, exports) {

    if (process.env.NODE_ENV !== "production") {
      (function() {

    var React = _global_React;
    var _assign = objectAssign;

    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var REACT_ELEMENT_TYPE = 0xeac7;
    var REACT_PORTAL_TYPE = 0xeaca;
    exports.Fragment = 0xeacb;
    var REACT_STRICT_MODE_TYPE = 0xeacc;
    var REACT_PROFILER_TYPE = 0xead2;
    var REACT_PROVIDER_TYPE = 0xeacd;
    var REACT_CONTEXT_TYPE = 0xeace;
    var REACT_FORWARD_REF_TYPE = 0xead0;
    var REACT_SUSPENSE_TYPE = 0xead1;
    var REACT_SUSPENSE_LIST_TYPE = 0xead8;
    var REACT_MEMO_TYPE = 0xead3;
    var REACT_LAZY_TYPE = 0xead4;
    var REACT_BLOCK_TYPE = 0xead9;
    var REACT_SERVER_BLOCK_TYPE = 0xeada;
    var REACT_FUNDAMENTAL_TYPE = 0xead5;
    var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
    var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

    if (typeof Symbol === 'function' && Symbol.for) {
      var symbolFor = Symbol.for;
      REACT_ELEMENT_TYPE = symbolFor('react.element');
      REACT_PORTAL_TYPE = symbolFor('react.portal');
      exports.Fragment = symbolFor('react.fragment');
      REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
      REACT_PROFILER_TYPE = symbolFor('react.profiler');
      REACT_PROVIDER_TYPE = symbolFor('react.provider');
      REACT_CONTEXT_TYPE = symbolFor('react.context');
      REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
      REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
      REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
      REACT_MEMO_TYPE = symbolFor('react.memo');
      REACT_LAZY_TYPE = symbolFor('react.lazy');
      REACT_BLOCK_TYPE = symbolFor('react.block');
      REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
      REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
      symbolFor('react.scope');
      symbolFor('react.opaque.id');
      REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
      symbolFor('react.offscreen');
      REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
    }

    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';
    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable !== 'object') {
        return null;
      }

      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

      if (typeof maybeIterator === 'function') {
        return maybeIterator;
      }

      return null;
    }

    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

    function error(format) {
      {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        printWarning('error', format, args);
      }
    }

    function printWarning(level, format, args) {
      // When changing this logic, you might want to also
      // update consoleWithStackDev.www.js as well.
      {
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();

        if (stack !== '') {
          format += '%s';
          args = args.concat([stack]);
        }

        var argsWithFormat = args.map(function (item) {
          return '' + item;
        }); // Careful: RN currently depends on this prefix

        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
        // breaks IE9: https://github.com/facebook/react/issues/13610
        // eslint-disable-next-line react-internal/no-production-logging

        Function.prototype.apply.call(console[level], console, argsWithFormat);
      }
    }

    // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

    var enableScopeAPI = false; // Experimental Create Event Handle API.

    function isValidElementType(type) {
      if (typeof type === 'string' || typeof type === 'function') {
        return true;
      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


      if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
        return true;
      }

      if (typeof type === 'object' && type !== null) {
        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
          return true;
        }
      }

      return false;
    }

    function getWrappedName(outerType, innerType, wrapperName) {
      var functionName = innerType.displayName || innerType.name || '';
      return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
    }

    function getContextName(type) {
      return type.displayName || 'Context';
    }

    function getComponentName(type) {
      if (type == null) {
        // Host root, text node or just invalid type.
        return null;
      }

      {
        if (typeof type.tag === 'number') {
          error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
        }
      }

      if (typeof type === 'function') {
        return type.displayName || type.name || null;
      }

      if (typeof type === 'string') {
        return type;
      }

      switch (type) {
        case exports.Fragment:
          return 'Fragment';

        case REACT_PORTAL_TYPE:
          return 'Portal';

        case REACT_PROFILER_TYPE:
          return 'Profiler';

        case REACT_STRICT_MODE_TYPE:
          return 'StrictMode';

        case REACT_SUSPENSE_TYPE:
          return 'Suspense';

        case REACT_SUSPENSE_LIST_TYPE:
          return 'SuspenseList';
      }

      if (typeof type === 'object') {
        switch (type.$$typeof) {
          case REACT_CONTEXT_TYPE:
            var context = type;
            return getContextName(context) + '.Consumer';

          case REACT_PROVIDER_TYPE:
            var provider = type;
            return getContextName(provider._context) + '.Provider';

          case REACT_FORWARD_REF_TYPE:
            return getWrappedName(type, type.render, 'ForwardRef');

          case REACT_MEMO_TYPE:
            return getComponentName(type.type);

          case REACT_BLOCK_TYPE:
            return getComponentName(type._render);

          case REACT_LAZY_TYPE:
            {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;

              try {
                return getComponentName(init(payload));
              } catch (x) {
                return null;
              }
            }
        }
      }

      return null;
    }

    // Helpers to patch console.logs to avoid logging during side-effect free
    // replaying on render function. This currently only patches the object
    // lazily which won't cover if the log function was extracted eagerly.
    // We could also eagerly patch the method.
    var disabledDepth = 0;
    var prevLog;
    var prevInfo;
    var prevWarn;
    var prevError;
    var prevGroup;
    var prevGroupCollapsed;
    var prevGroupEnd;

    function disabledLog() {}

    disabledLog.__reactDisabledLog = true;
    function disableLogs() {
      {
        if (disabledDepth === 0) {
          /* eslint-disable react-internal/no-production-logging */
          prevLog = console.log;
          prevInfo = console.info;
          prevWarn = console.warn;
          prevError = console.error;
          prevGroup = console.group;
          prevGroupCollapsed = console.groupCollapsed;
          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

          var props = {
            configurable: true,
            enumerable: true,
            value: disabledLog,
            writable: true
          }; // $FlowFixMe Flow thinks console is immutable.

          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
          /* eslint-enable react-internal/no-production-logging */
        }

        disabledDepth++;
      }
    }
    function reenableLogs() {
      {
        disabledDepth--;

        if (disabledDepth === 0) {
          /* eslint-disable react-internal/no-production-logging */
          var props = {
            configurable: true,
            enumerable: true,
            writable: true
          }; // $FlowFixMe Flow thinks console is immutable.

          Object.defineProperties(console, {
            log: _assign({}, props, {
              value: prevLog
            }),
            info: _assign({}, props, {
              value: prevInfo
            }),
            warn: _assign({}, props, {
              value: prevWarn
            }),
            error: _assign({}, props, {
              value: prevError
            }),
            group: _assign({}, props, {
              value: prevGroup
            }),
            groupCollapsed: _assign({}, props, {
              value: prevGroupCollapsed
            }),
            groupEnd: _assign({}, props, {
              value: prevGroupEnd
            })
          });
          /* eslint-enable react-internal/no-production-logging */
        }

        if (disabledDepth < 0) {
          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
        }
      }
    }

    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
    var prefix;
    function describeBuiltInComponentFrame(name, source, ownerFn) {
      {
        if (prefix === undefined) {
          // Extract the VM specific prefix used by each line.
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || '';
          }
        } // We use the prefix to ensure our stacks line up with native stack frames.


        return '\n' + prefix + name;
      }
    }
    var reentry = false;
    var componentFrameCache;

    {
      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
      componentFrameCache = new PossiblyWeakMap();
    }

    function describeNativeComponentFrame(fn, construct) {
      // If something asked for a stack inside a fake render, it should get ignored.
      if (!fn || reentry) {
        return '';
      }

      {
        var frame = componentFrameCache.get(fn);

        if (frame !== undefined) {
          return frame;
        }
      }

      var control;
      reentry = true;
      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

      Error.prepareStackTrace = undefined;
      var previousDispatcher;

      {
        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
        // for warnings.

        ReactCurrentDispatcher.current = null;
        disableLogs();
      }

      try {
        // This should throw.
        if (construct) {
          // Something should be setting the props in the constructor.
          var Fake = function () {
            throw Error();
          }; // $FlowFixMe


          Object.defineProperty(Fake.prototype, 'props', {
            set: function () {
              // We use a throwing setter instead of frozen or non-writable props
              // because that won't throw in a non-strict mode function.
              throw Error();
            }
          });

          if (typeof Reflect === 'object' && Reflect.construct) {
            // We construct a different control for this case to include any extra
            // frames added by the construct call.
            try {
              Reflect.construct(Fake, []);
            } catch (x) {
              control = x;
            }

            Reflect.construct(fn, [], Fake);
          } else {
            try {
              Fake.call();
            } catch (x) {
              control = x;
            }

            fn.call(Fake.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (x) {
            control = x;
          }

          fn();
        }
      } catch (sample) {
        // This is inlined manually because closure doesn't do it for us.
        if (sample && control && typeof sample.stack === 'string') {
          // This extracts the first frame from the sample that isn't also in the control.
          // Skipping one frame that we assume is the frame that calls the two.
          var sampleLines = sample.stack.split('\n');
          var controlLines = control.stack.split('\n');
          var s = sampleLines.length - 1;
          var c = controlLines.length - 1;

          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
            // We expect at least one stack frame to be shared.
            // Typically this will be the root most one. However, stack frames may be
            // cut off due to maximum stack limits. In this case, one maybe cut off
            // earlier than the other. We assume that the sample is longer or the same
            // and there for cut off earlier. So we should find the root most frame in
            // the sample somewhere in the control.
            c--;
          }

          for (; s >= 1 && c >= 0; s--, c--) {
            // Next we find the first one that isn't the same which should be the
            // frame that called our sample function and the control.
            if (sampleLines[s] !== controlLines[c]) {
              // In V8, the first line is describing the message but other VMs don't.
              // If we're about to return the first line, and the control is also on the same
              // line, that's a pretty good indicator that our sample threw at same line as
              // the control. I.e. before we entered the sample frame. So we ignore this result.
              // This can happen if you passed a class to function component, or non-function.
              if (s !== 1 || c !== 1) {
                do {
                  s--;
                  c--; // We may still have similar intermediate frames from the construct call.
                  // The next one that isn't the same should be our match though.

                  if (c < 0 || sampleLines[s] !== controlLines[c]) {
                    // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                    var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                    {
                      if (typeof fn === 'function') {
                        componentFrameCache.set(fn, _frame);
                      }
                    } // Return the line we found.


                    return _frame;
                  }
                } while (s >= 1 && c >= 0);
              }

              break;
            }
          }
        }
      } finally {
        reentry = false;

        {
          ReactCurrentDispatcher.current = previousDispatcher;
          reenableLogs();
        }

        Error.prepareStackTrace = previousPrepareStackTrace;
      } // Fallback to just using the name if we couldn't make it throw.


      var name = fn ? fn.displayName || fn.name : '';
      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

      {
        if (typeof fn === 'function') {
          componentFrameCache.set(fn, syntheticFrame);
        }
      }

      return syntheticFrame;
    }
    function describeFunctionComponentFrame(fn, source, ownerFn) {
      {
        return describeNativeComponentFrame(fn, false);
      }
    }

    function shouldConstruct(Component) {
      var prototype = Component.prototype;
      return !!(prototype && prototype.isReactComponent);
    }

    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

      if (type == null) {
        return '';
      }

      if (typeof type === 'function') {
        {
          return describeNativeComponentFrame(type, shouldConstruct(type));
        }
      }

      if (typeof type === 'string') {
        return describeBuiltInComponentFrame(type);
      }

      switch (type) {
        case REACT_SUSPENSE_TYPE:
          return describeBuiltInComponentFrame('Suspense');

        case REACT_SUSPENSE_LIST_TYPE:
          return describeBuiltInComponentFrame('SuspenseList');
      }

      if (typeof type === 'object') {
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            return describeFunctionComponentFrame(type.render);

          case REACT_MEMO_TYPE:
            // Memo may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

          case REACT_BLOCK_TYPE:
            return describeFunctionComponentFrame(type._render);

          case REACT_LAZY_TYPE:
            {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;

              try {
                // Lazy may contain any component type so we recursively resolve it.
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {}
            }
        }
      }

      return '';
    }

    var loggedTypeFailures = {};
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

    function setCurrentlyValidatingElement(element) {
      {
        if (element) {
          var owner = element._owner;
          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame.setExtraStackFrame(stack);
        } else {
          ReactDebugCurrentFrame.setExtraStackFrame(null);
        }
      }
    }

    function checkPropTypes(typeSpecs, values, location, componentName, element) {
      {
        // $FlowFixMe This is okay but Flow doesn't know it.
        var has = Function.call.bind(Object.prototype.hasOwnProperty);

        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
            // fail the render phase where it didn't fail before. So we log it.
            // After these have been cleaned up, we'll let them throw.

            try {
              // This is intentionally an invariant that gets caught. It's the same
              // behavior as without this statement except with a better message.
              if (typeof typeSpecs[typeSpecName] !== 'function') {
                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                err.name = 'Invariant Violation';
                throw err;
              }

              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
            } catch (ex) {
              error$1 = ex;
            }

            if (error$1 && !(error$1 instanceof Error)) {
              setCurrentlyValidatingElement(element);

              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

              setCurrentlyValidatingElement(null);
            }

            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
              // Only monitor this failure once because there tends to be a lot of the
              // same error.
              loggedTypeFailures[error$1.message] = true;
              setCurrentlyValidatingElement(element);

              error('Failed %s type: %s', location, error$1.message);

              setCurrentlyValidatingElement(null);
            }
          }
        }
      }
    }

    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };
    var specialPropKeyWarningShown;
    var specialPropRefWarningShown;
    var didWarnAboutStringRefs;

    {
      didWarnAboutStringRefs = {};
    }

    function hasValidRef(config) {
      {
        if (hasOwnProperty.call(config, 'ref')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }

      return config.ref !== undefined;
    }

    function hasValidKey(config) {
      {
        if (hasOwnProperty.call(config, 'key')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }

      return config.key !== undefined;
    }

    function warnIfStringRefCannotBeAutoConverted(config, self) {
      {
        if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
          var componentName = getComponentName(ReactCurrentOwner.current.type);

          if (!didWarnAboutStringRefs[componentName]) {
            error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);

            didWarnAboutStringRefs[componentName] = true;
          }
        }
      }
    }

    function defineKeyPropWarningGetter(props, displayName) {
      {
        var warnAboutAccessingKey = function () {
          if (!specialPropKeyWarningShown) {
            specialPropKeyWarningShown = true;

            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
          }
        };

        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, 'key', {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
    }

    function defineRefPropWarningGetter(props, displayName) {
      {
        var warnAboutAccessingRef = function () {
          if (!specialPropRefWarningShown) {
            specialPropRefWarningShown = true;

            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
          }
        };

        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, 'ref', {
          get: warnAboutAccessingRef,
          configurable: true
        });
      }
    }
    /**
     * Factory method to create a new React element. This no longer adheres to
     * the class pattern, so do not use new to call it. Also, instanceof check
     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
     * if something is a React Element.
     *
     * @param {*} type
     * @param {*} props
     * @param {*} key
     * @param {string|object} ref
     * @param {*} owner
     * @param {*} self A *temporary* helper to detect places where `this` is
     * different from the `owner` when React.createElement is called, so that we
     * can warn. We want to get rid of owner and replace string `ref`s with arrow
     * functions, and as long as `this` and owner are the same, there will be no
     * change in behavior.
     * @param {*} source An annotation object (added by a transpiler or otherwise)
     * indicating filename, line number, and/or other information.
     * @internal
     */


    var ReactElement = function (type, key, ref, self, source, owner, props) {
      var element = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: REACT_ELEMENT_TYPE,
        // Built-in properties that belong on the element
        type: type,
        key: key,
        ref: ref,
        props: props,
        // Record the component responsible for creating this element.
        _owner: owner
      };

      {
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.

        Object.defineProperty(element._store, 'validated', {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        }); // self and source are DEV only properties.

        Object.defineProperty(element, '_self', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        }); // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.

        Object.defineProperty(element, '_source', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });

        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }

      return element;
    };
    /**
     * https://github.com/reactjs/rfcs/pull/107
     * @param {*} type
     * @param {object} props
     * @param {string} key
     */

    function jsxDEV(type, config, maybeKey, source, self) {
      {
        var propName; // Reserved names are extracted

        var props = {};
        var key = null;
        var ref = null; // Currently, key can be spread in as a prop. This causes a potential
        // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
        // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
        // but as an intermediary step, we will use jsxDEV for everything except
        // <div {...props} key="Hi" />, because we aren't currently able to tell if
        // key is explicitly declared to be undefined or not.

        if (maybeKey !== undefined) {
          key = '' + maybeKey;
        }

        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        if (hasValidRef(config)) {
          ref = config.ref;
          warnIfStringRefCannotBeAutoConverted(config, self);
        } // Remaining properties are added to a new props object


        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        } // Resolve default props


        if (type && type.defaultProps) {
          var defaultProps = type.defaultProps;

          for (propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
        }

        if (key || ref) {
          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

          if (key) {
            defineKeyPropWarningGetter(props, displayName);
          }

          if (ref) {
            defineRefPropWarningGetter(props, displayName);
          }
        }

        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
      }
    }

    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

    function setCurrentlyValidatingElement$1(element) {
      {
        if (element) {
          var owner = element._owner;
          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else {
          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
        }
      }
    }

    var propTypesMisspellWarningShown;

    {
      propTypesMisspellWarningShown = false;
    }
    /**
     * Verifies the object is a ReactElement.
     * See https://reactjs.org/docs/react-api.html#isvalidelement
     * @param {?object} object
     * @return {boolean} True if `object` is a ReactElement.
     * @final
     */

    function isValidElement(object) {
      {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
    }

    function getDeclarationErrorAddendum() {
      {
        if (ReactCurrentOwner$1.current) {
          var name = getComponentName(ReactCurrentOwner$1.current.type);

          if (name) {
            return '\n\nCheck the render method of `' + name + '`.';
          }
        }

        return '';
      }
    }

    function getSourceInfoErrorAddendum(source) {
      {
        if (source !== undefined) {
          var fileName = source.fileName.replace(/^.*[\\\/]/, '');
          var lineNumber = source.lineNumber;
          return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
        }

        return '';
      }
    }
    /**
     * Warn if there's no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */


    var ownerHasKeyUseWarning = {};

    function getCurrentComponentErrorInfo(parentType) {
      {
        var info = getDeclarationErrorAddendum();

        if (!info) {
          var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

          if (parentName) {
            info = "\n\nCheck the top-level render call using <" + parentName + ">.";
          }
        }

        return info;
      }
    }
    /**
     * Warn if the element doesn't have an explicit key assigned to it.
     * This element is in an array. The array could grow and shrink or be
     * reordered. All children that haven't already been validated are required to
     * have a "key" property assigned to it. Error statuses are cached so a warning
     * will only be shown once.
     *
     * @internal
     * @param {ReactElement} element Element that requires a key.
     * @param {*} parentType element's parent's type.
     */


    function validateExplicitKey(element, parentType) {
      {
        if (!element._store || element._store.validated || element.key != null) {
          return;
        }

        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
          return;
        }

        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
        // property, it may be the creator of the child that's responsible for
        // assigning it a key.

        var childOwner = '';

        if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
          // Give the component that originally created this child.
          childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
        }

        setCurrentlyValidatingElement$1(element);

        error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

        setCurrentlyValidatingElement$1(null);
      }
    }
    /**
     * Ensure that every element either is passed in a static location, in an
     * array with an explicit keys property defined, or in an object literal
     * with valid key property.
     *
     * @internal
     * @param {ReactNode} node Statically passed child of any type.
     * @param {*} parentType node's parent's type.
     */


    function validateChildKeys(node, parentType) {
      {
        if (typeof node !== 'object') {
          return;
        }

        if (Array.isArray(node)) {
          for (var i = 0; i < node.length; i++) {
            var child = node[i];

            if (isValidElement(child)) {
              validateExplicitKey(child, parentType);
            }
          }
        } else if (isValidElement(node)) {
          // This element was passed in a valid location.
          if (node._store) {
            node._store.validated = true;
          }
        } else if (node) {
          var iteratorFn = getIteratorFn(node);

          if (typeof iteratorFn === 'function') {
            // Entry iterators used to provide implicit keys,
            // but now we print a separate warning for them later.
            if (iteratorFn !== node.entries) {
              var iterator = iteratorFn.call(node);
              var step;

              while (!(step = iterator.next()).done) {
                if (isValidElement(step.value)) {
                  validateExplicitKey(step.value, parentType);
                }
              }
            }
          }
        }
      }
    }
    /**
     * Given an element, validate that its props follow the propTypes definition,
     * provided by the type.
     *
     * @param {ReactElement} element
     */


    function validatePropTypes(element) {
      {
        var type = element.type;

        if (type === null || type === undefined || typeof type === 'string') {
          return;
        }

        var propTypes;

        if (typeof type === 'function') {
          propTypes = type.propTypes;
        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        type.$$typeof === REACT_MEMO_TYPE)) {
          propTypes = type.propTypes;
        } else {
          return;
        }

        if (propTypes) {
          // Intentionally inside to avoid triggering lazy initializers:
          var name = getComponentName(type);
          checkPropTypes(propTypes, element.props, 'prop', name, element);
        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

          var _name = getComponentName(type);

          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
        }

        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
        }
      }
    }
    /**
     * Given a fragment, validate that it can only be provided with fragment props
     * @param {ReactElement} fragment
     */


    function validateFragmentProps(fragment) {
      {
        var keys = Object.keys(fragment.props);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];

          if (key !== 'children' && key !== 'key') {
            setCurrentlyValidatingElement$1(fragment);

            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

            setCurrentlyValidatingElement$1(null);
            break;
          }
        }

        if (fragment.ref !== null) {
          setCurrentlyValidatingElement$1(fragment);

          error('Invalid attribute `ref` supplied to `React.Fragment`.');

          setCurrentlyValidatingElement$1(null);
        }
      }
    }

    function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
      {
        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
        // succeed and there will likely be errors in render.

        if (!validType) {
          var info = '';

          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
            info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
          }

          var sourceInfo = getSourceInfoErrorAddendum(source);

          if (sourceInfo) {
            info += sourceInfo;
          } else {
            info += getDeclarationErrorAddendum();
          }

          var typeString;

          if (type === null) {
            typeString = 'null';
          } else if (Array.isArray(type)) {
            typeString = 'array';
          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
            typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
            info = ' Did you accidentally export a JSX literal instead of a component?';
          } else {
            typeString = typeof type;
          }

          error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
        }

        var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
        // TODO: Drop this when these are no longer allowed as the type argument.

        if (element == null) {
          return element;
        } // Skip key warning if the type isn't valid since our key validation logic
        // doesn't expect a non-string/function type and can throw confusing errors.
        // We don't want exception behavior to differ between dev and prod.
        // (Rendering will throw with a helpful message and as soon as the type is
        // fixed, the key warnings will appear.)


        if (validType) {
          var children = props.children;

          if (children !== undefined) {
            if (isStaticChildren) {
              if (Array.isArray(children)) {
                for (var i = 0; i < children.length; i++) {
                  validateChildKeys(children[i], type);
                }

                if (Object.freeze) {
                  Object.freeze(children);
                }
              } else {
                error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
              }
            } else {
              validateChildKeys(children, type);
            }
          }
        }

        if (type === exports.Fragment) {
          validateFragmentProps(element);
        } else {
          validatePropTypes(element);
        }

        return element;
      }
    } // These two functions exist to still get child warnings in dev
    // even with the prod transform. This means that jsxDEV is purely
    // opt-in behavior for better messages but that we won't stop
    // giving you warnings if you use production apis.

    function jsxWithValidationStatic(type, props, key) {
      {
        return jsxWithValidation(type, props, key, true);
      }
    }
    function jsxWithValidationDynamic(type, props, key) {
      {
        return jsxWithValidation(type, props, key, false);
      }
    }

    var jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.
    // for now we can ship identical prod functions

    var jsxs =  jsxWithValidationStatic ;

    exports.jsx = jsx;
    exports.jsxs = jsxs;
      })();
    }
    });

    var jsxRuntime = createCommonjsModule(function (module) {

    if (process.env.NODE_ENV === 'production') {
      module.exports = reactJsxRuntime_production_min;
    } else {
      module.exports = reactJsxRuntime_development;
    }
    });

    var getScrollParent = (node) => {
      let parent = node;
      while (parent = parent.parentElement) {
        const overflowYVal = getComputedStyle(parent, null).getPropertyValue("overflow-y");
        if (parent === document.body)
          return window;
        if (overflowYVal === "auto" || overflowYVal === "scroll")
          return parent;
      }
      return window;
    };
    var isOffsetElement = (el) => el.firstChild ? el.firstChild.offsetParent === el : true;
    var offsetTill = (node, target) => {
      let current = node;
      let offset = 0;
      if (!isOffsetElement(target)) {
        offset += node.offsetTop - target.offsetTop;
        target = node.offsetParent;
        offset += -node.offsetTop;
      }
      do {
        offset += current.offsetTop;
        current = current.offsetParent;
      } while (current && current !== target);
      return offset;
    };
    var getParentNode = (node) => {
      let currentParent = node.parentElement;
      while (currentParent) {
        const style = getComputedStyle(currentParent, null);
        if (style.getPropertyValue("display") !== "contents")
          break;
        currentParent = currentParent.parentElement;
      }
      return currentParent || window;
    };
    var stickyProp = null;
    if (typeof CSS !== "undefined" && CSS.supports) {
      if (CSS.supports("position", "sticky"))
        stickyProp = "sticky";
      else if (CSS.supports("position", "-webkit-sticky"))
        stickyProp = "-webkit-sticky";
    }
    var passiveArg = false;
    try {
      const opts = Object.defineProperty({}, "passive", {
        get() {
          passiveArg = { passive: true };
        }
      });
      const emptyHandler = () => {
      };
      window.addEventListener("testPassive", emptyHandler, opts);
      window.removeEventListener("testPassive", emptyHandler, opts);
    } catch (e) {
    }
    var getDimensions = (opts) => {
      const { el, onChange, unsubs, measure } = opts;
      if (el === window) {
        const getRect = () => ({ top: 0, left: 0, height: window.innerHeight, width: window.innerWidth });
        const mResult = measure(getRect());
        const handler = () => {
          Object.assign(mResult, measure(getRect()));
          onChange();
        };
        window.addEventListener("resize", handler, passiveArg);
        unsubs.push(() => window.addEventListener("resize", handler, passiveArg));
        return mResult;
      } else {
        const mResult = measure(el.getBoundingClientRect());
        const handler = () => {
          Object.assign(mResult, measure(el.getBoundingClientRect()));
          onChange();
        };
        const ro = new ResizeObserver(handler);
        ro.observe(el);
        unsubs.push(() => ro.disconnect());
        return mResult;
      }
    };
    var getVerticalPadding = (node) => {
      const computedParentStyle = getComputedStyle(node, null);
      const parentPaddingTop = parseInt(computedParentStyle.getPropertyValue("padding-top"), 10);
      const parentPaddingBottom = parseInt(computedParentStyle.getPropertyValue("padding-bottom"), 10);
      return { top: parentPaddingTop, bottom: parentPaddingBottom };
    };
    var setup = (node, unsubs, opts) => {
      const { bottom, offsetBottom, offsetTop } = opts;
      const scrollPane = getScrollParent(node);
      let isScheduled = false;
      const scheduleOnLayout = () => {
        if (!isScheduled) {
          requestAnimationFrame(() => {
            const nextMode = onLayout();
            if (nextMode !== mode)
              changeMode(nextMode);
            isScheduled = false;
          });
        }
        isScheduled = true;
      };
      let latestScrollY = scrollPane === window ? window.scrollY : scrollPane.scrollTop;
      const isBoxTooLow = (scrollY) => {
        const { offsetTop: scrollPaneOffset, height: viewPortHeight } = scrollPaneDims;
        const { naturalTop } = parentDims;
        const { height: nodeHeight } = nodeDims;
        if (scrollY + scrollPaneOffset + viewPortHeight >= naturalTop + nodeHeight + relativeOffset + offsetBottom) {
          return true;
        }
        return false;
      };
      const onLayout = () => {
        const { height: viewPortHeight } = scrollPaneDims;
        const { height: nodeHeight } = nodeDims;
        if (nodeHeight + offsetTop + offsetBottom <= viewPortHeight) {
          return 3 /* small */;
        } else {
          if (isBoxTooLow(latestScrollY)) {
            return 1 /* stickyBottom */;
          } else {
            return 2 /* relative */;
          }
        }
      };
      const scrollPaneIsOffsetEl = scrollPane !== window && isOffsetElement(scrollPane);
      const scrollPaneDims = getDimensions({
        el: scrollPane,
        onChange: scheduleOnLayout,
        unsubs,
        measure: ({ height, top }) => ({
          height,
          offsetTop: scrollPaneIsOffsetEl ? top : 0
        })
      });
      const parentNode = getParentNode(node);
      const parentPaddings = parentNode === window ? { top: 0, bottom: 0 } : getVerticalPadding(parentNode);
      const parentDims = getDimensions({
        el: parentNode,
        onChange: scheduleOnLayout,
        unsubs,
        measure: ({ height }) => ({
          height: height - parentPaddings.top - parentPaddings.bottom,
          naturalTop: parentNode === window ? 0 : offsetTill(parentNode, scrollPane) + parentPaddings.top + scrollPaneDims.offsetTop
        })
      });
      const nodeDims = getDimensions({
        el: node,
        onChange: scheduleOnLayout,
        unsubs,
        measure: ({ height }) => ({ height })
      });
      let relativeOffset = 0;
      let mode = onLayout();
      const changeMode = (newMode) => {
        const prevMode = mode;
        mode = newMode;
        if (prevMode === 2 /* relative */)
          relativeOffset = -1;
        if (newMode === 3 /* small */) {
          node.style.position = stickyProp;
          if (bottom) {
            node.style.bottom = `${offsetBottom}px`;
          } else {
            node.style.top = `${offsetTop}px`;
          }
          return;
        }
        const { height: viewPortHeight, offsetTop: scrollPaneOffset } = scrollPaneDims;
        const { height: parentHeight, naturalTop } = parentDims;
        const { height: nodeHeight } = nodeDims;
        if (newMode === 2 /* relative */) {
          node.style.position = "relative";
          relativeOffset = prevMode === 0 /* stickyTop */ ? Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop) : Math.max(
            0,
            scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom)
          );
          if (bottom) {
            const nextBottom = Math.max(0, parentHeight - nodeHeight - relativeOffset);
            node.style.bottom = `${nextBottom}px`;
          } else {
            node.style.top = `${relativeOffset}px`;
          }
        } else {
          node.style.position = stickyProp;
          if (newMode === 1 /* stickyBottom */) {
            if (bottom) {
              node.style.bottom = `${offsetBottom}px`;
            } else {
              node.style.top = `${viewPortHeight - nodeHeight - offsetBottom}px`;
            }
          } else {
            if (bottom) {
              node.style.bottom = `${viewPortHeight - nodeHeight - offsetBottom}px`;
            } else {
              node.style.top = `${offsetTop}px`;
            }
          }
        }
      };
      changeMode(mode);
      const onScroll = (scrollY) => {
        if (scrollY === latestScrollY)
          return;
        const scrollDelta = scrollY - latestScrollY;
        latestScrollY = scrollY;
        if (mode === 3 /* small */)
          return;
        const { offsetTop: scrollPaneOffset, height: viewPortHeight } = scrollPaneDims;
        const { naturalTop, height: parentHeight } = parentDims;
        const { height: nodeHeight } = nodeDims;
        if (scrollDelta > 0) {
          if (mode === 0 /* stickyTop */) {
            if (scrollY + scrollPaneOffset + offsetTop > naturalTop) {
              const topOffset = Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop);
              if (scrollY + scrollPaneOffset + viewPortHeight <= naturalTop + nodeHeight + topOffset + offsetBottom) {
                changeMode(2 /* relative */);
              } else {
                changeMode(1 /* stickyBottom */);
              }
            }
          } else if (mode === 2 /* relative */) {
            if (isBoxTooLow(scrollY))
              changeMode(1 /* stickyBottom */);
          }
        } else {
          if (mode === 1 /* stickyBottom */) {
            if (scrollPaneOffset + scrollY + viewPortHeight < naturalTop + parentHeight + offsetBottom) {
              const bottomOffset = Math.max(
                0,
                scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom)
              );
              if (scrollPaneOffset + scrollY + offsetTop >= naturalTop + bottomOffset) {
                changeMode(2 /* relative */);
              } else {
                changeMode(0 /* stickyTop */);
              }
            }
          } else if (mode === 2 /* relative */) {
            if (scrollPaneOffset + scrollY + offsetTop < naturalTop + relativeOffset) {
              changeMode(0 /* stickyTop */);
            }
          }
        }
      };
      const handleScroll = scrollPane === window ? () => onScroll(window.scrollY) : () => onScroll(scrollPane.scrollTop);
      scrollPane.addEventListener("scroll", handleScroll, passiveArg);
      scrollPane.addEventListener("mousewheel", handleScroll, passiveArg);
      unsubs.push(
        () => scrollPane.removeEventListener("scroll", handleScroll),
        () => scrollPane.removeEventListener("mousewheel", handleScroll)
      );
    };
    var useStickyBox = ({
      offsetTop = 0,
      offsetBottom = 0,
      bottom = false
    } = {}) => {
      const [node, setNode] = React.useState(null);
      React.useEffect(() => {
        if (!node || !stickyProp)
          return;
        const unsubs = [];
        setup(node, unsubs, { offsetBottom, offsetTop, bottom });
        return () => {
          unsubs.forEach((fn) => fn());
        };
      }, [node, offsetBottom, offsetTop, bottom]);
      return setNode;
    };
    var StickyBox = (props) => {
      const { offsetTop, offsetBottom, bottom, children, className, style } = props;
      const ref = useStickyBox({ offsetTop, offsetBottom, bottom });
      return /* @__PURE__ */ jsxRuntime.jsx("div", {
        className,
        style,
        ref,
        children
      });
    };
    var src_default = StickyBox;

    function getInheritedBackgroundColor(el) {
        // get default style for current browser
        var defaultStyle = getDefaultBackground(); // typically "rgba(0, 0, 0, 0)"
        // get computed color for el
        var backgroundColor = window.getComputedStyle(el).backgroundColor;
        // if we got a real value, return it
        if (backgroundColor != defaultStyle)
            return backgroundColor;
        // if we've reached the top parent el without getting an explicit color, return default
        if (!el.parentElement)
            return defaultStyle;
        // otherwise, recurse and try again on parent element
        return getInheritedBackgroundColor(el.parentElement);
    }
    function getDefaultBackground() {
        // have to add to the document in order to use getComputedStyle
        var div = document.createElement('div');
        document.head.appendChild(div);
        var bg = window.getComputedStyle(div).backgroundColor;
        document.head.removeChild(div);
        return bg;
    }
    var FormButtonGroup = function (_a) {
        var align = _a.align, size = _a.size, props = __rest$17(_a, ["align", "size"]);
        var prefixCls = usePrefixCls('button-group');
        return (React.createElement(ArcoSpace, __assign$2e({}, props, { size: size, className: classnames(prefixCls, props.className), style: __assign$2e(__assign$2e({}, props.style), { justifyContent: align === 'left'
                    ? 'flex-start'
                    : align === 'right'
                        ? 'flex-end'
                        : 'center', display: 'flex' }) }), props.children));
    };
    FormButtonGroup.defaultProps = {
        align: 'left',
    };
    FormButtonGroup.FormItem = function (_a) {
        var _b;
        var spacing = _a.size, props = __rest$17(_a, ["size"]);
        return (React.createElement(BaseItem, __assign$2e({}, props, { label: " ", style: __assign$2e(__assign$2e({ margin: 0, padding: 0 }, props.style), { width: '100%' }), colon: false }), ((_b = props.children) === null || _b === void 0 ? void 0 : _b['length']) ? (React.createElement(ArcoSpace, { size: spacing }, props.children)) : (props.children)));
    };
    FormButtonGroup.Sticky = function (_a) {
        var align = _a.align, props = __rest$17(_a, ["align"]);
        var ref = React.useRef();
        var _b = __read$1x(React.useState('transparent'), 2), color = _b[0], setColor = _b[1];
        var prefixCls = usePrefixCls('button-group');
        React.useLayoutEffect(function () {
            if (ref.current) {
                var computed = getInheritedBackgroundColor(ref.current);
                if (computed !== color) {
                    setColor(computed);
                }
            }
        });
        return (React.createElement(src_default, __assign$2e({}, props, { className: classnames("".concat(prefixCls, "-sticky"), props.className), style: __assign$2e({ backgroundColor: color }, props.style), bottom: true }),
            React.createElement("div", { ref: ref, className: "".concat(prefixCls, "-sticky-inner"), style: __assign$2e(__assign$2e({}, props.style), { justifyContent: align === 'left'
                        ? 'flex-start'
                        : align === 'right'
                            ? 'flex-end'
                            : 'center' }) }, props.children)));
    };
    FormButtonGroup.Sticky.defaultProps = {
        align: 'left',
    };

    var isModalTitle = function (props) {
        return Formily.Shared.isNum(props) || Formily.Shared.isStr(props) || Formily.Shared.isBool(props) || React.isValidElement(props);
    };
    var getModelProps = function (props) {
        if (isModalTitle(props)) {
            return {
                title: props,
            };
        }
        else {
            return props;
        }
    };
    function FormDialog(title, id, renderer) {
        var _this = this;
        if (Formily.Shared.isFn(id) || React.isValidElement(id)) {
            renderer = id;
            id = "form-dialog";
        }
        var env = {
            host: document.createElement("div"),
            form: null,
            promise: null,
            openMiddlewares: [],
            confirmMiddlewares: [],
            cancelMiddlewares: [],
        };
        var root = createPortalRoot(env.host, id);
        var props = getModelProps(title);
        var modal = __assign$2e(__assign$2e({}, props), { afterClose: function () {
                var _a;
                (_a = props === null || props === void 0 ? void 0 : props.afterClose) === null || _a === void 0 ? void 0 : _a.call(props);
                root.unmount();
            } });
        var DialogContent = Formily.React.observer(function () { return (React.createElement(React.Fragment, null, Formily.Shared.isFn(renderer) ? renderer(env.form) : renderer)); });
        var renderDialog = function (visible, resolve, reject) {
            if (visible === void 0) { visible = true; }
            return (React.createElement(Formily.React.Observer, null, function () {
                var _a, _b;
                return (React.createElement(Modal$1, __assign$2e({}, modal, (((_a = modal === null || modal === void 0 ? void 0 : modal.getModalProps) === null || _a === void 0 ? void 0 : _a.call(modal, __assign$2e(__assign$2e({}, modal), { triggerConfirm: resolve, triggerCancel: reject }))) || {}), { visible: visible, confirmLoading: (_b = env === null || env === void 0 ? void 0 : env.form) === null || _b === void 0 ? void 0 : _b.submitting, onCancel: function () {
                        var _a;
                        if (((_a = modal === null || modal === void 0 ? void 0 : modal.onCancel) === null || _a === void 0 ? void 0 : _a.call(modal)) !== false) {
                            reject === null || reject === void 0 ? void 0 : reject();
                        }
                    }, onOk: function (e) { return __awaiter$7(_this, void 0, void 0, function () {
                        var _a;
                        return __generator$7(this, function (_b) {
                            if (((_a = modal === null || modal === void 0 ? void 0 : modal.onOk) === null || _a === void 0 ? void 0 : _a.call(modal, e)) !== false) {
                                resolve === null || resolve === void 0 ? void 0 : resolve();
                            }
                            return [2 /*return*/];
                        });
                    }); }, onConfirm: function (e) { return __awaiter$7(_this, void 0, void 0, function () {
                        var _a;
                        return __generator$7(this, function (_b) {
                            if (((_a = modal === null || modal === void 0 ? void 0 : modal.onOk) === null || _a === void 0 ? void 0 : _a.call(modal, e)) !== false) {
                                resolve === null || resolve === void 0 ? void 0 : resolve();
                            }
                            return [2 /*return*/];
                        });
                    }); } }), env.form ? (React.createElement(Formily.React.FormProvider, { form: env.form },
                    React.createElement(DialogContent, null))) : null));
            }));
        };
        document.body.appendChild(env.host);
        var formDialog = {
            forOpen: function (middleware) {
                if (Formily.Shared.isFn(middleware)) {
                    env.openMiddlewares.push(middleware);
                }
                return formDialog;
            },
            forConfirm: function (middleware) {
                if (Formily.Shared.isFn(middleware)) {
                    env.confirmMiddlewares.push(middleware);
                }
                return formDialog;
            },
            forCancel: function (middleware) {
                if (Formily.Shared.isFn(middleware)) {
                    env.cancelMiddlewares.push(middleware);
                }
                return formDialog;
            },
            open: function (formProps) { return __awaiter$7(_this, void 0, void 0, function () {
                var _this = this;
                return __generator$7(this, function (_a) {
                    if (env.promise) {
                        return [2 /*return*/, env.promise];
                    }
                    env.promise = new Promise(function (resolve, reject) { return __awaiter$7(_this, void 0, void 0, function () {
                        var e_1;
                        var _this = this;
                        return __generator$7(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    _a.trys.push([0, 2, , 3]);
                                    return [4 /*yield*/, loading(modal.loadingText, function () {
                                            return Formily.Shared.applyMiddleware(formProps, env.openMiddlewares);
                                        })];
                                case 1:
                                    formProps = _a.sent();
                                    env.form = env.form || Formily.Core.createForm(formProps);
                                    return [3 /*break*/, 3];
                                case 2:
                                    e_1 = _a.sent();
                                    reject(e_1);
                                    return [3 /*break*/, 3];
                                case 3:
                                    root.render(function () {
                                        return renderDialog(true, function () {
                                            var _a;
                                            (_a = env.form) === null || _a === void 0 ? void 0 : _a.submit(function () { return __awaiter$7(_this, void 0, void 0, function () {
                                                var _a;
                                                return __generator$7(this, function (_b) {
                                                    switch (_b.label) {
                                                        case 0: return [4 /*yield*/, Formily.Shared.applyMiddleware(env.form, env.confirmMiddlewares)];
                                                        case 1:
                                                            _b.sent();
                                                            resolve(Formily.Reactive.toJS((_a = env.form) === null || _a === void 0 ? void 0 : _a.values));
                                                            formDialog.close();
                                                            return [2 /*return*/];
                                                    }
                                                });
                                            }); }).catch(function () {
                                                /** do nothing */
                                            });
                                        }, function () { return __awaiter$7(_this, void 0, void 0, function () {
                                            return __generator$7(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0: return [4 /*yield*/, loading(modal.loadingText, function () {
                                                            return Formily.Shared.applyMiddleware(env.form, env.cancelMiddlewares);
                                                        })];
                                                    case 1:
                                                        _a.sent();
                                                        formDialog.close();
                                                        return [2 /*return*/];
                                                }
                                            });
                                        }); });
                                    });
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                    return [2 /*return*/, env.promise];
                });
            }); },
            close: function () {
                if (!env.host) {
                    return;
                }
                root.render(function () { return renderDialog(false); });
            },
        };
        return formDialog;
    }
    var DialogFooter = function (props) {
        var ref = React.useRef(null);
        var _a = __read$1x(React.useState(), 2), footer = _a[0], setFooter = _a[1];
        var footerRef = React.useRef();
        var prefixCls = usePrefixCls("", {
            prefixCls: "semi-modal",
        });
        React.useLayoutEffect(function () {
            var _a;
            var content = (_a = ref.current) === null || _a === void 0 ? void 0 : _a.closest(".".concat(prefixCls, "-content"));
            if (content) {
                if (!footerRef.current) {
                    footerRef.current = content.querySelector(".".concat(prefixCls, "-footer"));
                    if (!footerRef.current) {
                        footerRef.current = document.createElement("div");
                        footerRef.current.classList.add("".concat(prefixCls, "-footer"));
                        content.appendChild(footerRef.current);
                    }
                }
                setFooter(footerRef.current);
            }
        });
        footerRef.current = footer;
        return (React.createElement("div", { ref: ref, style: { display: "none" } }, footer && ReactDOM.createPortal(props.children, footer)));
    };
    FormDialog.Footer = DialogFooter;
    FormDialog.Portal = createPortalProvider("form-dialog");

    var isTitleComp = function (props) {
        return Formily.Shared.isNum(props) || Formily.Shared.isStr(props) || Formily.Shared.isBool(props) || React.isValidElement(props);
    };
    var getDrawerProps = function (props) {
        if (isTitleComp(props)) {
            return {
                title: props,
            };
        }
        else {
            return props;
        }
    };
    /**
     * 渲染一个弹窗
     * @param title
     * @param id
     * @param renderer
     * @returns
     */
    function FormDrawer(title, id, renderer) {
        var _this = this;
        if (Formily.Shared.isFn(id) || React.isValidElement(id)) {
            renderer = id;
            id = 'form-drawer';
        }
        var env = {
            host: document.createElement('div'),
            form: null,
            promise: null,
            openMiddlewares: [],
        };
        var root = createPortalRoot(env.host, id);
        var props = getDrawerProps(title);
        var drawer = __assign$2e(__assign$2e({ width: '40%' }, props), { onCancel: function (e) {
                var _a;
                if (((_a = props === null || props === void 0 ? void 0 : props.onCancel) === null || _a === void 0 ? void 0 : _a.call(props, e)) !== false) {
                    formDrawer.close();
                }
            }, afterClose: function () {
                var _a;
                (_a = props === null || props === void 0 ? void 0 : props.afterClose) === null || _a === void 0 ? void 0 : _a.call(props);
                root.unmount();
            } });
        var DrawerContent = Formily.React.observer(function () { return (React.createElement(React.Fragment, null, Formily.Shared.isFn(renderer) ? renderer(env.form) : renderer)); });
        var renderDrawer = function (visible) {
            if (visible === void 0) { visible = true; }
            return (React.createElement(Drawer$1, __assign$2e({ footer: null }, drawer, { visible: visible }), env.form ? (React.createElement(Formily.React.FormProvider, { form: env.form },
                React.createElement(DrawerContent, null))) : null));
        };
        document.body.appendChild(env.host);
        var formDrawer = {
            forOpen: function (middleware) {
                if (Formily.Shared.isFn(middleware)) {
                    env.openMiddlewares.push(middleware);
                }
                return formDrawer;
            },
            open: function (drawerProps) { return __awaiter$7(_this, void 0, void 0, function () {
                var _this = this;
                return __generator$7(this, function (_a) {
                    if (env.promise) {
                        return [2 /*return*/, env.promise];
                    }
                    env.promise = new Promise(function (resolve, reject) { return __awaiter$7(_this, void 0, void 0, function () {
                        return __generator$7(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, loading(drawer.loadingText, function () {
                                        return Formily.Shared.applyMiddleware(drawerProps, env.openMiddlewares);
                                    })];
                                case 1:
                                    drawerProps = _a.sent();
                                    try {
                                        env.form =
                                            env.form ||
                                                Formily.Core.createForm(__assign$2e(__assign$2e({}, drawerProps), { effects: function (form) {
                                                        var _a;
                                                        Formily.Core.onFormSubmitSuccess(function () {
                                                            resolve(Formily.Reactive.toJS(form.values));
                                                            formDrawer.close();
                                                        });
                                                        (_a = drawerProps === null || drawerProps === void 0 ? void 0 : drawerProps.effects) === null || _a === void 0 ? void 0 : _a.call(drawerProps, form);
                                                    } }));
                                    }
                                    catch (e) {
                                        reject(e);
                                    }
                                    root.render(function () { return renderDrawer(false); });
                                    setTimeout(function () {
                                        root.render(function () { return renderDrawer(true); });
                                    }, 16);
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                    return [2 /*return*/, env.promise];
                });
            }); },
            close: function () {
                if (!env.host) {
                    return;
                }
                root.render(function () { return renderDrawer(false); });
            },
        };
        return formDrawer;
    }
    var DrawerFooter = function (props) {
        var ref = React.useRef(null);
        var _a = __read$1x(React.useState(), 2), footer = _a[0], setFooter = _a[1];
        var footerRef = React.useRef();
        var prefixCls = 'arco-drawer';
        React.useLayoutEffect(function () {
            var _a;
            var content = (_a = ref.current) === null || _a === void 0 ? void 0 : _a.closest(".".concat(prefixCls, "-scroll"));
            if (content) {
                if (!footerRef.current) {
                    footerRef.current = content.querySelector(".".concat(prefixCls, "-footer"));
                    if (!footerRef.current) {
                        footerRef.current = document.createElement('div');
                        footerRef.current.classList.add("".concat(prefixCls, "-footer"));
                        content.appendChild(footerRef.current);
                    }
                }
                setFooter(footerRef.current);
            }
        });
        footerRef.current = footer;
        return (React.createElement("div", { ref: ref, style: { display: 'none' } }, footer && ReactDOM.createPortal(props.children, footer)));
    };
    FormDrawer.Footer = DrawerFooter;
    FormDrawer.Portal = createPortalProvider('form-drawer');

    var parseSteps = function (schema) {
        var steps = [];
        schema.mapProperties(function (propertySchema, name) {
            var _a;
            if (((_a = propertySchema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('StepPane')) > -1) {
                steps.push({
                    name: name,
                    props: propertySchema['x-component-props'],
                    schema: propertySchema,
                });
            }
        });
        return steps;
    };
    var createFormStep = function (defaultCurrent) {
        var _a, _b, _c;
        if (defaultCurrent === void 0) { defaultCurrent = 0; }
        var env = {
            form: null,
            field: null,
            steps: [],
        };
        var setDisplay = (_a = Formily.Reactive.action.bound) === null || _a === void 0 ? void 0 : _a.call(Formily.Reactive.action, function (target) {
            var currentStep = env.steps[target];
            env.steps.forEach(function (_a) {
                var _b, _c;
                var name = _a.name;
                (_b = env.form) === null || _b === void 0 ? void 0 : _b.query("".concat((_c = env.field) === null || _c === void 0 ? void 0 : _c.address, ".").concat(name)).take(function (field) {
                    if (name === currentStep.name) {
                        field.setDisplay('visible');
                    }
                    else {
                        field.setDisplay('hidden');
                    }
                });
            });
        });
        var next = (_b = Formily.Reactive.action.bound) === null || _b === void 0 ? void 0 : _b.call(Formily.Reactive.action, function () {
            if (formStep.allowNext) {
                setDisplay === null || setDisplay === void 0 ? void 0 : setDisplay(formStep.current + 1);
                formStep.setCurrent(formStep.current + 1);
            }
        });
        var back = (_c = Formily.Reactive.action.bound) === null || _c === void 0 ? void 0 : _c.call(Formily.Reactive.action, function () {
            if (formStep.allowBack) {
                setDisplay === null || setDisplay === void 0 ? void 0 : setDisplay(formStep.current - 1);
                formStep.setCurrent(formStep.current - 1);
            }
        });
        var formStep = Formily.Reactive.model({
            connect: function (steps, field) {
                env.steps = steps;
                env.form = field === null || field === void 0 ? void 0 : field.form;
                env.field = field;
            },
            current: defaultCurrent,
            setCurrent: function (key) {
                formStep.current = key;
            },
            get allowNext() {
                return formStep.current < env.steps.length - 1;
            },
            get allowBack() {
                return formStep.current > 0;
            },
            get steps() {
                return env.steps;
            },
            next: function () {
                var _a;
                return __awaiter$7(this, void 0, void 0, function () {
                    return __generator$7(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                _c.trys.push([0, 2, , 3]);
                                return [4 /*yield*/, ((_a = env.form) === null || _a === void 0 ? void 0 : _a.validate())];
                            case 1:
                                _c.sent();
                                next === null || next === void 0 ? void 0 : next();
                                return [3 /*break*/, 3];
                            case 2:
                                _c.sent();
                                return [3 /*break*/, 3];
                            case 3: return [2 /*return*/];
                        }
                    });
                });
            },
            back: function () {
                return __awaiter$7(this, void 0, void 0, function () {
                    return __generator$7(this, function (_a) {
                        back === null || back === void 0 ? void 0 : back();
                        return [2 /*return*/];
                    });
                });
            },
            submit: function (onSubmit) {
                var _a, _b;
                return __awaiter$7(this, void 0, void 0, function () {
                    return __generator$7(this, function (_c) {
                        return [2 /*return*/, (_b = (_a = env.form) === null || _a === void 0 ? void 0 : _a.submit) === null || _b === void 0 ? void 0 : _b.call(_a, onSubmit)];
                    });
                });
            },
        });
        return Formily.Reactive.markRaw(formStep);
    };
    var FormStep = Formily.React.connect(Formily.React.observer(function (_a) {
        var _b;
        var formStep = _a.formStep, className = _a.className, props = __rest$17(_a, ["formStep", "className"]);
        var field = Formily.React.useField();
        var prefixCls = usePrefixCls('formily-step', props);
        var schema = Formily.React.useFieldSchema();
        var steps = parseSteps(schema);
        var current = props.current || (formStep === null || formStep === void 0 ? void 0 : formStep.current) || 0;
        (_b = formStep === null || formStep === void 0 ? void 0 : formStep.connect) === null || _b === void 0 ? void 0 : _b.call(formStep, steps, field);
        return (React.createElement("div", { className: classnames(prefixCls, className) },
            React.createElement(Steps$1, __assign$2e({}, props, { style: __assign$2e({ marginBottom: 10 }, props.style), current: current }), steps.map(function (_a, key) {
                var stepProps = _a.props;
                return (React.createElement(Steps$1.Step, __assign$2e({}, stepProps, { key: key })));
            })),
            steps.map(function (_a, key) {
                var name = _a.name, stepSchema = _a.schema;
                if (key !== current) {
                    return;
                }
                return React.createElement(Formily.React.RecursionField, { key: key, name: name, schema: stepSchema });
            })));
    }));
    var StepPane$1 = function (_a) {
        var children = _a.children;
        return (React.createElement(React.Fragment, null, children));
    };
    FormStep.StepPane = StepPane$1;
    FormStep.createFormStep = createFormStep;

    var FormStepProContext = React.createContext(null);
    var useFormStepPro = function () { return React.useContext(FormStepProContext); };
    var parseSchema = function (schema) {
        var schemaStep = { steps: [] };
        schema.mapProperties(function (propertySchema, name) {
            var _a, _b;
            if (((_a = propertySchema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('StepPane')) > -1) {
                schemaStep.steps.push({
                    name: name,
                    props: propertySchema['x-component-props'],
                    schema: propertySchema,
                });
            }
            if (((_b = propertySchema['x-component']) === null || _b === void 0 ? void 0 : _b.indexOf('Previous')) > -1) {
                schemaStep.previous = {
                    name: name,
                    props: propertySchema['x-component-props'],
                    schema: propertySchema,
                };
            }
            if (/NextWithSubmit$/.test(propertySchema['x-component'])) {
                schemaStep.nextWithSubmit = {
                    name: name,
                    props: propertySchema['x-component-props'],
                    schema: propertySchema,
                };
            }
            if (/Next$/.test(propertySchema['x-component'])) {
                schemaStep.next = {
                    name: name,
                    props: propertySchema['x-component-props'],
                    schema: propertySchema,
                };
            }
            if (/\.Submit$/.test(propertySchema['x-component'])) {
                schemaStep.submit = {
                    name: name,
                    props: propertySchema['x-component-props'],
                    schema: propertySchema,
                };
            }
        });
        return schemaStep;
    };
    var Previous = function (props) {
        var _a;
        var text = props.text, restProps = __rest$17(props, ["text"]);
        var formStepCtx = useFormStepPro();
        return (React.createElement(Button$3, __assign$2e({}, restProps, { disabled: (formStepCtx === null || formStepCtx === void 0 ? void 0 : formStepCtx.field.disabled) || !((_a = formStepCtx === null || formStepCtx === void 0 ? void 0 : formStepCtx.props.formStep) === null || _a === void 0 ? void 0 : _a.allowBack), onClick: function () {
                var _a;
                (_a = formStepCtx === null || formStepCtx === void 0 ? void 0 : formStepCtx.props.formStep) === null || _a === void 0 ? void 0 : _a.back();
            } }), text));
    };
    var Next = function (props) {
        var _a;
        var text = props.text, restProps = __rest$17(props, ["text"]);
        var formStepCtx = useFormStepPro();
        return (React.createElement(Button$3, __assign$2e({}, restProps, { disabled: (formStepCtx === null || formStepCtx === void 0 ? void 0 : formStepCtx.field.disabled) || !((_a = formStepCtx === null || formStepCtx === void 0 ? void 0 : formStepCtx.props.formStep) === null || _a === void 0 ? void 0 : _a.allowNext), onClick: function () {
                var _a;
                (_a = formStepCtx === null || formStepCtx === void 0 ? void 0 : formStepCtx.props.formStep) === null || _a === void 0 ? void 0 : _a.next();
            } }), text));
    };
    var NextWithSubmit = function (props) {
        var _a, _b;
        var text = props.text, onSubmit = props.onSubmit, restProps = __rest$17(props, ["text", "onSubmit"]);
        var formStepCtx = useFormStepPro();
        var _c = ((_b = (_a = formStepCtx === null || formStepCtx === void 0 ? void 0 : formStepCtx.props) === null || _a === void 0 ? void 0 : _a.formStep) !== null && _b !== void 0 ? _b : {}).current, current = _c === void 0 ? 0 : _c;
        var form = Formily.React.useForm();
        var picks = Object.entries(form.getFormGraph())
            .filter(function (_a) {
            var _b = __read$1x(_a, 2), value = _b[1];
            return value.display === 'visible' && value.displayName === 'Field';
        })
            .map(function (_a) {
            var _b = __read$1x(_a, 2), value = _b[1];
            return value.path;
        });
        return (React.createElement(Button$3, __assign$2e({}, restProps, { onClick: function () {
                var _a, _b;
                (_a = formStepCtx === null || formStepCtx === void 0 ? void 0 : formStepCtx.props.formStep) === null || _a === void 0 ? void 0 : _a.submit(function (values) {
                    var _a, _b;
                    var target = {};
                    picks.forEach(function (pickPath) {
                        var parser = Formily.Shared.FormPath.parse(pickPath);
                        parser.setIn(target, parser.getIn(values));
                    });
                    if (onSubmit) {
                        onSubmit === null || onSubmit === void 0 ? void 0 : onSubmit(target, current);
                    }
                    else {
                        (_b = (_a = formStepCtx === null || formStepCtx === void 0 ? void 0 : formStepCtx.props) === null || _a === void 0 ? void 0 : _a.onSubmit) === null || _b === void 0 ? void 0 : _b.call(_a, target);
                    }
                });
                (_b = formStepCtx === null || formStepCtx === void 0 ? void 0 : formStepCtx.props.formStep) === null || _b === void 0 ? void 0 : _b.next();
            } }), text));
    };
    var Submit$1 = function (props) {
        var _a;
        var text = props.text, restProps = __rest$17(props, ["text"]);
        var formStepCtx = useFormStepPro();
        return (React.createElement(Button$3, __assign$2e({}, restProps, { disabled: (formStepCtx === null || formStepCtx === void 0 ? void 0 : formStepCtx.field.disabled) || ((_a = formStepCtx === null || formStepCtx === void 0 ? void 0 : formStepCtx.props.formStep) === null || _a === void 0 ? void 0 : _a.allowNext), onClick: function () {
                var _a, _b;
                (_a = formStepCtx === null || formStepCtx === void 0 ? void 0 : formStepCtx.props.formStep) === null || _a === void 0 ? void 0 : _a.submit((_b = formStepCtx === null || formStepCtx === void 0 ? void 0 : formStepCtx.props) === null || _b === void 0 ? void 0 : _b.onSubmit);
            } }), text));
    };
    var FormStepPro = Formily.React.connect(Formily.React.observer(function (_a) {
        var _b;
        var propsFormStep = _a.formStep, className = _a.className, onSubmit = _a.onSubmit, props = __rest$17(_a, ["formStep", "className", "onSubmit"]);
        var field = Formily.React.useField();
        var formStep = React.useMemo(function () { var _a; return propsFormStep || ((_a = FormStep.createFormStep) === null || _a === void 0 ? void 0 : _a.call(FormStep)); }, [propsFormStep]);
        var prefixCls = usePrefixCls(props.direction, {
            prefixCls: 'formily-step-pro',
        });
        var schema = Formily.React.useFieldSchema();
        var _c = parseSchema(schema), steps = _c.steps, previous = _c.previous, next = _c.next, nextWithSubmit = _c.nextWithSubmit, submit = _c.submit;
        var current = props.current || (formStep === null || formStep === void 0 ? void 0 : formStep.current) || 0;
        (_b = formStep === null || formStep === void 0 ? void 0 : formStep.connect) === null || _b === void 0 ? void 0 : _b.call(formStep, steps, field);
        return (React.createElement(FormStepProContext.Provider, { value: { props: { formStep: formStep, onSubmit: onSubmit }, field: field, schema: schema } },
            React.createElement("div", { className: classnames(prefixCls, className) },
                React.createElement(Steps$1, __assign$2e({}, props, { style: __assign$2e({ marginBottom: 10 }, props.style), current: current }), steps.map(function (_a, key) {
                    var stepProps = _a.props;
                    return (React.createElement(Steps$1.Step, __assign$2e({}, stepProps, { key: key })));
                })),
                steps.map(function (_a, key) {
                    var name = _a.name, stepSchema = _a.schema;
                    if (key !== current) {
                        return;
                    }
                    return (React.createElement(Formily.React.RecursionField, { key: key, name: name, schema: stepSchema }));
                }),
                React.createElement(ArcoSpace, null,
                    previous ? (React.createElement(Formily.React.RecursionField, { schema: previous.schema, name: previous.name, key: previous.name })) : null,
                    next ? (React.createElement(Formily.React.RecursionField, { schema: next.schema, name: next.name, key: next.name })) : null,
                    nextWithSubmit ? (React.createElement(Formily.React.RecursionField, { schema: nextWithSubmit.schema, name: nextWithSubmit.name, key: nextWithSubmit.name })) : null,
                    submit ? (React.createElement(Formily.React.RecursionField, { schema: submit.schema, name: submit.name, key: submit.name })) : null))));
    }));
    var StepPane = function (_a) {
        var children = _a.children;
        return (React.createElement(React.Fragment, null, children));
    };
    FormStepPro.StepPane = StepPane;
    FormStepPro.Previous = Previous;
    FormStepPro.Next = Next;
    FormStepPro.NextWithSubmit = NextWithSubmit;
    FormStepPro.Submit = Submit$1;

    var usePanels = function () {
        var collapseField = Formily.React.useField();
        var schema = Formily.React.useFieldSchema();
        var panels = [];
        schema.mapProperties(function (schema, name) {
            var _a, _b, _c;
            var field = collapseField.query(collapseField.address.concat(name)).take();
            if ((field === null || field === void 0 ? void 0 : field.display) === 'none' || (field === null || field === void 0 ? void 0 : field.display) === 'hidden') {
                return;
            }
            if (((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('CollapsePanel')) > -1) {
                panels.push({
                    name: name,
                    props: __assign$2e(__assign$2e({}, schema === null || schema === void 0 ? void 0 : schema['x-component-props']), { key: ((_b = schema === null || schema === void 0 ? void 0 : schema['x-component-props']) === null || _b === void 0 ? void 0 : _b.key) || name, name: ((_c = schema === null || schema === void 0 ? void 0 : schema['x-component-props']) === null || _c === void 0 ? void 0 : _c.name) || name }),
                    schema: schema,
                });
            }
        });
        return panels;
    };
    var createFormCollapse = function (defaultActiveKeys) {
        var formCollapse = Formily.Reactive.model({
            activeKeys: defaultActiveKeys || [],
            setActiveKeys: function (keys) {
                formCollapse.activeKeys = keys;
            },
            hasActiveKey: function (key) {
                if (Array.isArray(formCollapse.activeKeys)) {
                    if (formCollapse.activeKeys.includes(key)) {
                        return true;
                    }
                }
                else if (formCollapse.activeKeys == key) {
                    return true;
                }
                return false;
            },
            addActiveKey: function (key) {
                if (formCollapse.hasActiveKey(key)) {
                    return;
                }
                formCollapse.activeKeys = Formily.Shared.toArr(formCollapse.activeKeys).concat(key);
            },
            removeActiveKey: function (key) {
                if (Array.isArray(formCollapse.activeKeys)) {
                    formCollapse.activeKeys = formCollapse.activeKeys.filter(function (item) { return item != key; });
                }
                else {
                    formCollapse.activeKeys = '';
                }
            },
            toggleActiveKey: function (key) {
                if (formCollapse.hasActiveKey(key)) {
                    formCollapse.removeActiveKey(key);
                }
                else {
                    formCollapse.addActiveKey(key);
                }
            },
        });
        return formCollapse;
    };
    var FormCollapse = Formily.React.observer(function (_a) {
        var formCollapse = _a.formCollapse, props = __rest$17(_a, ["formCollapse"]);
        var field = Formily.React.useField();
        var panels = usePanels();
        var prefixCls = usePrefixCls('collapse');
        var _formCollapse = React.useMemo(function () { return formCollapse !== null && formCollapse !== void 0 ? formCollapse : createFormCollapse(props.defaultActiveKey); }, [formCollapse, props.defaultActiveKey]);
        var activeKey = props.activeKey || (_formCollapse === null || _formCollapse === void 0 ? void 0 : _formCollapse.activeKeys);
        var badgedHeader = function (key, props) {
            var errors = field.form.queryFeedbacks({
                type: 'error',
                address: "".concat(field.address.concat(key), ".*"),
            });
            if (errors.length) {
                return (React.createElement(Badge$1, { className: "errors-badge", count: errors.length }, props.header));
            }
            return props.header;
        };
        return (React.createElement("div", null,
            React.createElement("div", null, JSON.stringify(activeKey)),
            React.createElement(Collapse$1, __assign$2e({}, props, { className: classnames(prefixCls, props.className), activeKey: "".concat(activeKey), onChange: function (key, keys, e) {
                    var _a, _b;
                    (_a = props === null || props === void 0 ? void 0 : props.onChange) === null || _a === void 0 ? void 0 : _a.call(props, key, keys, e);
                    (_b = _formCollapse === null || _formCollapse === void 0 ? void 0 : _formCollapse.setActiveKeys) === null || _b === void 0 ? void 0 : _b.call(_formCollapse, key);
                } }), panels.map(function (_a, index) {
                var props = _a.props, schema = _a.schema, name = _a.name;
                return (React.createElement(Collapse$1.Item, __assign$2e({ key: index }, props, { header: badgedHeader(name, props), destroyOnHide: false }),
                    React.createElement(Formily.React.RecursionField, { schema: schema, name: name })));
            }))));
    });
    var CollapsePanel = function (_a) {
        var children = _a.children;
        return (React.createElement(React.Fragment, null, children));
    };
    FormCollapse.CollapsePanel = CollapsePanel;
    FormCollapse.createFormCollapse = createFormCollapse;

    // 递归过滤，只要是 就一直过滤
    function renderChildren(children) {
        if (!children) {
            return null;
        }
        if (Array.isArray(children)) {
            return children.map(renderChildren);
        }
        if (React.isValidElement(children) && ReactIs.isFragment(children)) {
            return renderChildren(children.props.children);
        }
        return children;
    }
    var Space = function (_a) {
        var children = _a.children, props = __rest$17(_a, ["children"]);
        return React.createElement(ArcoSpace, __assign$2e({}, props), renderChildren(children));
    };

    var Section = Formily.React.observer(function (props) {
        var fieldSchema = Formily.React.useFieldSchema();
        var items = [];
        // 获取 properties 里子元素配置，并在下面渲染
        fieldSchema.mapProperties(function (schema, name) {
            items.push({
                name: name,
                schema: schema,
            });
        });
        return (React.createElement(Card$1, __assign$2e({ bordered: false, bodyStyle: { padding: 0 }, size: "small" }, props), items.map(function (_a, index) {
            var schema = _a.schema, name = _a.name;
            return (React.createElement(Formily.React.RecursionField, { schema: schema, name: name, key: name.toString() + index }));
        })));
    });

    var ArcoInputTextArea = Input$4.TextArea;
    var InternalInput = Formily.React.connect(Input$4, Formily.React.mapProps({
        value: 'value',
    }, function (props, field) {
        return __assign$2e(__assign$2e({}, props), { suffix: (React.createElement("span", null, (field === null || field === void 0 ? void 0 : field['loading']) || (field === null || field === void 0 ? void 0 : field['validating']) ? (React.createElement(IconLoading$1, { spin: true })) : (props.suffix))) });
    }), Formily.React.mapReadPretty(PreviewText.Input));
    var TextArea = Formily.React.connect(ArcoInputTextArea, Formily.React.mapProps({
        value: 'value',
    }), Formily.React.mapReadPretty(PreviewText.Input));
    var Input = Object.assign(InternalInput, {
        TextArea: TextArea,
    });

    var InputNumber = Formily.React.connect(ArcoInputNumber, Formily.React.mapProps(function (props, field) {
        return __assign$2e(__assign$2e({}, props), { suffix: (React.createElement("span", null, (field === null || field === void 0 ? void 0 : field["loading"]) || (field === null || field === void 0 ? void 0 : field["validating"]) ? (React.createElement(IconLoading$1, null)) : (props.suffix))) });
    }), Formily.React.mapReadPretty(PreviewText.Input));
    var NumberPicker = InputNumber;

    var Select = Formily.React.connect(Select$3, Formily.React.mapProps({
        loading: true,
        dataSource: "options",
    }, function (props, field) {
        return __assign$2e(__assign$2e({}, props), { suffix: (field === null || field === void 0 ? void 0 : field["loading"]) || (field === null || field === void 0 ? void 0 : field["validating"]) ? (React.createElement(IconLoading$1, null)) : (props.suffix) });
    }), Formily.React.mapReadPretty(PreviewText.Select));

    var Cascader = Formily.React.connect(Cascader$3, Formily.React.mapProps({ dataSource: "options" }));

    var ArcoCheckboxGroup = Checkbox$2.Group;
    var CheckboxGroup = Formily.React.connect(ArcoCheckboxGroup, Formily.React.mapProps({
        dataSource: "options",
    }));

    var Checkbox = Formily.React.connect(Checkbox$2, Formily.React.mapProps({
        value: 'checked',
        onInput: 'onChange',
    }));
    Checkbox.Group = CheckboxGroup;

    var DatePicker = Formily.React.connect(ArcoDatePicker, Formily.React.mapProps(function (props) {
        var onChange = props.onChange;
        return __assign$2e(__assign$2e({}, props), { onChange: function (dateStr, date) {
                if (onChange) {
                    // 这种方式破坏了原有属性
                    onChange(dateStr, date);
                }
            } });
    }));

    var ArcoRadioGroup = Radio$1.Group;
    var RadioGroup = Formily.React.connect(ArcoRadioGroup, Formily.React.mapProps({
        dataSource: "options",
    }));

    var Radio = Formily.React.connect(Radio$1, Formily.React.mapProps({
        value: "checked",
        onInput: "onChange",
    }));
    Radio.Group = RadioGroup;

    var Reset = function (_a) {
        var forceClear = _a.forceClear, validate = _a.validate, props = __rest$17(_a, ["forceClear", "validate"]);
        var form = Formily.React.useForm();
        return (React.createElement(Button$3, __assign$2e({}, props, { onClick: function (e) {
                if (props.onClick) {
                    props.onClick(e);
                }
                form.reset("*", {
                    forceClear: forceClear,
                    validate: validate,
                });
            } })));
    };

    var TimePicker = Formily.React.connect(ArcoTimePicker, Formily.React.mapProps(function (props) {
        var onChange = props.onChange;
        return __assign$2e(__assign$2e({}, props), { onChange: function (time, timeStr) {
                if (onChange) {
                    onChange(timeStr, timeStr);
                }
            } });
    }));

    var Upload = Formily.React.connect(Upload$2, Formily.React.mapProps({
        value: "fileList"
    }, function (_a) {
        var reset = __rest$17(_a, []);
        return __assign$2e({}, reset);
    }));

    var isNum = function (c) {
        return c >= 48 && c <= 57;
    };
    var isLower = function (c) {
        return c >= 97 && c <= 122;
    };
    var isUpper = function (c) {
        return c >= 65 && c <= 90;
    };
    var isSymbol = function (c) {
        return !(isLower(c) || isUpper(c) || isNum(c));
    };
    var isLetter = function (c) {
        return isLower(c) || isUpper(c);
    };
    var getStrength = function (val) {
        if (!val) {
            return 0;
        }
        var num = 0;
        var lower = 0;
        var upper = 0;
        var symbol = 0;
        var MNS = 0;
        var rep = 0;
        var repC = 0;
        var consecutive = 0;
        var sequential = 0;
        var len = function () { return num + lower + upper + symbol; };
        var callme = function () {
            var re = num > 0 ? 1 : 0;
            re += lower > 0 ? 1 : 0;
            re += upper > 0 ? 1 : 0;
            re += symbol > 0 ? 1 : 0;
            if (re > 2 && len() >= 8) {
                return re + 1;
            }
            else {
                return 0;
            }
        };
        for (var i = 0; i < val.length; i++) {
            var c = val.charCodeAt(i);
            if (isNum(c)) {
                num++;
                if (i !== 0 && i !== val.length - 1) {
                    MNS++;
                }
                if (i > 0 && isNum(val.charCodeAt(i - 1))) {
                    consecutive++;
                }
            }
            else if (isLower(c)) {
                lower++;
                if (i > 0 && isLower(val.charCodeAt(i - 1))) {
                    consecutive++;
                }
            }
            else if (isUpper(c)) {
                upper++;
                if (i > 0 && isUpper(val.charCodeAt(i - 1))) {
                    consecutive++;
                }
            }
            else {
                symbol++;
                if (i !== 0 && i !== val.length - 1) {
                    MNS++;
                }
            }
            var exists = false;
            for (var j = 0; j < val.length; j++) {
                if (val[i] === val[j] && i !== j) {
                    exists = true;
                    repC += Math.abs(val.length / (j - i));
                }
            }
            if (exists) {
                rep++;
                var unique = val.length - rep;
                repC = unique ? Math.ceil(repC / unique) : Math.ceil(repC);
            }
            if (i > 1) {
                var last1 = val.charCodeAt(i - 1);
                var last2 = val.charCodeAt(i - 2);
                if (isLetter(c)) {
                    if (isLetter(last1) && isLetter(last2)) {
                        var v = val.toLowerCase();
                        var vi = v.charCodeAt(i);
                        var vi1 = v.charCodeAt(i - 1);
                        var vi2 = v.charCodeAt(i - 2);
                        if (vi - vi1 === vi1 - vi2 && Math.abs(vi - vi1) === 1) {
                            sequential++;
                        }
                    }
                }
                else if (isNum(c)) {
                    if (isNum(last1) && isNum(last2)) {
                        if (c - last1 === last1 - last2 && Math.abs(c - last1) === 1) {
                            sequential++;
                        }
                    }
                }
                else {
                    if (isSymbol(last1) && isSymbol(last2)) {
                        if (c - last1 === last1 - last2 && Math.abs(c - last1) === 1) {
                            sequential++;
                        }
                    }
                }
            }
        }
        var sum = 0;
        var length = len();
        sum += 4 * length;
        if (lower > 0) {
            sum += 2 * (length - lower);
        }
        if (upper > 0) {
            sum += 2 * (length - upper);
        }
        if (num !== length) {
            sum += 4 * num;
        }
        sum += 6 * symbol;
        sum += 2 * MNS;
        sum += 2 * callme();
        if (length === lower + upper) {
            sum -= length;
        }
        if (length === num) {
            sum -= num;
        }
        sum -= repC;
        sum -= 2 * consecutive;
        sum -= 3 * sequential;
        sum = sum < 0 ? 0 : sum;
        sum = sum > 100 ? 100 : sum;
        if (sum >= 80) {
            return 100;
        }
        else if (sum >= 60) {
            return 80;
        }
        else if (sum >= 40) {
            return 60;
        }
        else if (sum >= 20) {
            return 40;
        }
        else {
            return 20;
        }
    };
    var PasswordStrength = function (props) {
        if (Formily.Shared.isFn(props.children)) {
            return props.children(getStrength(String(props.value)));
        }
        else {
            return React.createElement(React.Fragment, null, props.children);
        }
    };

    var Password = Formily.React.connect(function (props) {
        var value = props.value, className = props.className, checkStrength = props.checkStrength, others = __rest$17(props, ["value", "className", "checkStrength"]);
        return (React.createElement("span", { className: className === null || className === void 0 ? void 0 : className[0] },
            React.createElement(Input$4.Password, __assign$2e({}, others, { value: value })),
            checkStrength && (React.createElement(PasswordStrength, { value: String(value) }, function (score) { return React.createElement(PasswordScore, { score: score }); }))));
    }, Formily.React.mapReadPretty(PreviewText.Input));
    var blockStyle = {
        position: 'absolute',
        zIndex: 1,
        height: 8,
        top: 0,
        background: '#fff',
        width: 1,
        transform: 'translate(-50%, 0)',
    };
    /**
     * 密码强度
     * @param param0
     * @returns
     */
    function PasswordScore(_a) {
        var score = _a.score;
        return (React.createElement("div", { style: {
                background: '#e0e0e0',
                marginBottom: 3,
                position: 'relative',
            } },
            React.createElement("div", { style: __assign$2e(__assign$2e({}, blockStyle), { left: '20%' }) }),
            React.createElement("div", { style: __assign$2e(__assign$2e({}, blockStyle), { left: '40%' }) }),
            React.createElement("div", { style: __assign$2e(__assign$2e({}, blockStyle), { left: '60%' }) }),
            React.createElement("div", { style: __assign$2e(__assign$2e({}, blockStyle), { left: '80%' }) }),
            React.createElement("div", { style: {
                    position: 'relative',
                    backgroundImage: '-webkit-linear-gradient(left, #ff5500, #ff9300)',
                    transition: 'all 0.35s ease-in-out',
                    height: 8,
                    width: '100%',
                    marginTop: 5,
                    clipPath: "polygon(0 0,".concat(score, "% 0,").concat(score, "% 100%,0 100%)"),
                } })));
    }

    var Switch = Formily.React.connect(ArcoSwitch, Formily.React.mapProps({
        value: "checked",
    }));

    var Transfer = Formily.React.connect(ArcoTransfer, Formily.React.mapProps({
        value: true,
        dataSource: true,
    }));

    function convertTreeData(list) {
        return list.map(function (z) {
            var _a;
            var result = __assign$2e(__assign$2e({}, z), { title: (_a = z.title) !== null && _a !== void 0 ? _a : z.label });
            if (Array.isArray(z.children)) {
                result.children = convertTreeData(z.children);
            }
            return result;
        });
    }
    //treeData  label
    var TreeSelect = Formily.React.connect(TreeSelect$3, Formily.React.mapProps(function (props, field) {
        var _a = field.dataSource, dataSource = _a === void 0 ? [] : _a;
        return __assign$2e(__assign$2e({}, props), { treeData: convertTreeData(dataSource), suffixIcon: (field === null || field === void 0 ? void 0 : field["loading"]) || (field === null || field === void 0 ? void 0 : field["validating"]) ? (React.createElement(IconLoading$1, null)) : (props === null || props === void 0 ? void 0 : props["arrowIcon"]) });
    }), Formily.React.mapReadPretty(PreviewText.TreeSelect));

    var TagInput = InputTag$1;

    var Submit = Formily.React.observer(function (_a) {
        var onSubmit = _a.onSubmit, onSubmitFailed = _a.onSubmitFailed, onSubmitSuccess = _a.onSubmitSuccess, props = __rest$17(_a, ["onSubmit", "onSubmitFailed", "onSubmitSuccess"]);
        var form = Formily.React.useParentForm();
        return (React.createElement(Button$3, __assign$2e({ htmlType: onSubmit ? 'button' : 'submit', type: "primary" }, props, { loading: props.loading !== undefined ? props.loading : form.submitting, onClick: function (e) {
                if (props.onClick) {
                    if (props.onClick(e) === false)
                        return;
                }
                if (onSubmit) {
                    form.submit(onSubmit).then(onSubmitSuccess).catch(onSubmitFailed);
                }
            } }), props.children));
    }, {
        forwardRef: true,
    });

    var components = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ArrayBase: ArrayBase,
        ArrayCollapse: ArrayCollapse,
        ArrayItems: ArrayItems,
        ArrayTable: ArrayTable,
        ArrayTabs: ArrayTabs,
        Form: Form,
        useGridSpan: useGridSpan,
        FormGrid: FormGrid,
        GridColumn: GridColumn,
        BaseItem: BaseItem,
        FormItem: FormItem,
        FormLayoutContext: FormLayoutContext,
        FormLayoutShallowContext: FormLayoutShallowContext,
        useFormLayout: useFormLayout,
        useFormShallowLayout: useFormShallowLayout,
        FormLayout: FormLayout,
        FormTab: FormTab,
        FormButtonGroup: FormButtonGroup,
        FormDialog: FormDialog,
        FormDrawer: FormDrawer,
        FormStep: FormStep,
        FormStepPro: FormStepPro,
        FormCollapse: FormCollapse,
        Button: Button$3,
        Space: Space,
        Card: Card$1,
        Section: Section,
        Input: Input,
        InputNumber: InputNumber,
        NumberPicker: NumberPicker,
        Select: Select,
        Cascader: Cascader,
        Checkbox: Checkbox,
        CheckboxGroup: CheckboxGroup,
        DatePicker: DatePicker,
        Radio: Radio,
        RadioGroup: RadioGroup,
        Reset: Reset,
        TimePicker: TimePicker,
        Upload: Upload,
        Password: Password,
        Switch: Switch,
        Transfer: Transfer,
        TreeSelect: TreeSelect,
        TagInput: TagInput,
        Submit: Submit,
        PreviewText: PreviewText
    });

    function checkExsitInFieldDataSource(field) {
        var _a;
        return (((_a = field.dataSource) === null || _a === void 0 ? void 0 : _a.findIndex(function (_a) {
            var _b;
            var value = _a.value;
            return field.value === value || ((_b = field.value) === null || _b === void 0 ? void 0 : _b.includes(value));
        })) === -1);
    }
    var useAsyncDataSource = function (service, checkExsit) {
        if (checkExsit === void 0) { checkExsit = true; }
        return function (field, form) {
            var _a;
            field.loading = true;
            service(field, form).then((_a = Formily.Reactive.action === null || Formily.Reactive.action === void 0 ? void 0 : Formily.Reactive.action.bound) === null || _a === void 0 ? void 0 : _a.call(Formily.Reactive.action, function (data) {
                field.dataSource = data;
                if (checkExsit && checkExsitInFieldDataSource(field)) {
                    field.setValue(undefined);
                }
                field.loading = false;
            }));
        };
    };

    var scopeBase = /*#__PURE__*/Object.freeze({
        __proto__: null,
        useAsyncDataSource: useAsyncDataSource
    });

    // setValidateLanguage('zh-CN');
    var SchemaForm = React.forwardRef(function (props, ref) {
        var schema = props.schema, _a = props.scope, scope = _a === void 0 ? {} : _a, _b = props.components, components$1 = _b === void 0 ? {} : _b, initialValues = props.initialValues, restProps = __rest$17(props, ["schema", "scope", "components", "initialValues"]);
        var contextForm = React.useContext(Formily.React.FormContext);
        var form = React.useMemo(function () {
            if (contextForm) {
                return contextForm;
            }
            else {
                return Formily.Core.createForm({
                    initialValues: Object.entries(initialValues !== null && initialValues !== void 0 ? initialValues : {})
                        .filter(function (_a) {
                        var _b = __read$1x(_a, 1), key = _b[0];
                        return initialValues[key] !== undefined;
                    })
                        .reduce(function (acc, _a) {
                        var _b;
                        var _c = __read$1x(_a, 2), key = _c[0], value = _c[1];
                        return (__assign$2e(__assign$2e({}, acc), (_b = {}, _b[key] = value, _b)));
                    }, {}),
                });
            }
        }, [initialValues, contextForm]);
        React.useImperativeHandle(ref, function () { return ({
            getForm: function () {
                return form;
            },
        }); }, [form]);
        return (React.createElement(Form, __assign$2e({ form: form }, restProps),
            React.createElement(SchemaRender, { schema: schema, scope: __assign$2e(__assign$2e({}, scopeBase), scope), components: __assign$2e({ componentsBase: components }, components$1) }), props === null || props === void 0 ? void 0 :
            props.children));
    });

    var SchemaField = Formily.React.createSchemaField({
        components: components,
    });
    // 为了解决 d.js 类型校验错误的问题
    var SchemaRender = function (args) { return React.createElement(SchemaField, __assign$2e({}, args)); };

    exports.ArrayBase = ArrayBase;
    exports.ArrayCollapse = ArrayCollapse;
    exports.ArrayItems = ArrayItems;
    exports.ArrayTable = ArrayTable;
    exports.ArrayTabs = ArrayTabs;
    exports.BaseItem = BaseItem;
    exports.Button = Button$3;
    exports.Card = Card$1;
    exports.Cascader = Cascader;
    exports.Checkbox = Checkbox;
    exports.CheckboxGroup = CheckboxGroup;
    exports.DatePicker = DatePicker;
    exports.Form = Form;
    exports.FormButtonGroup = FormButtonGroup;
    exports.FormCollapse = FormCollapse;
    exports.FormDialog = FormDialog;
    exports.FormDrawer = FormDrawer;
    exports.FormGrid = FormGrid;
    exports.FormItem = FormItem;
    exports.FormLayout = FormLayout;
    exports.FormLayoutContext = FormLayoutContext;
    exports.FormLayoutShallowContext = FormLayoutShallowContext;
    exports.FormStep = FormStep;
    exports.FormStepPro = FormStepPro;
    exports.FormTab = FormTab;
    exports.GridColumn = GridColumn;
    exports.Input = Input;
    exports.InputNumber = InputNumber;
    exports.NumberPicker = NumberPicker;
    exports.Password = Password;
    exports.PreviewText = PreviewText;
    exports.Radio = Radio;
    exports.RadioGroup = RadioGroup;
    exports.Reset = Reset;
    exports.SchemaField = SchemaField;
    exports.SchemaForm = SchemaForm;
    exports.SchemaRender = SchemaRender;
    exports.Section = Section;
    exports.Select = Select;
    exports.Space = Space;
    exports.Submit = Submit;
    exports.Switch = Switch;
    exports.TagInput = TagInput;
    exports.TimePicker = TimePicker;
    exports.Transfer = Transfer;
    exports.TreeSelect = TreeSelect;
    exports.Upload = Upload;
    exports.useFormLayout = useFormLayout;
    exports.useFormShallowLayout = useFormShallowLayout;
    exports.useGridSpan = useGridSpan;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=formily.arco.umd.development.js.map
